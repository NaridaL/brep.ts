"use strict";function _interopDefault(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var ts3dutils=require("ts3dutils"),tsgl=require("tsgl"),opentype=require("opentype.js"),svgPathdata=require("svg-pathdata"),javasetmap_ts=require("javasetmap.ts"),earcut=_interopDefault(require("earcut")),nerdamer=_interopDefault(require("nerdamer")),chroma=_interopDefault(require("chroma-js"));const{ceil:ceil,floor:floor,abs:abs$1}=Math;class Curve extends ts3dutils.Transformable{constructor(t,s){super(),this.tMin=t,this.tMax=s,ts3dutils.assertNumbers(t,s),ts3dutils.assert("number"==typeof t&&!isNaN(t)),ts3dutils.assert("number"==typeof s&&!isNaN(s)),ts3dutils.assert(t<s)}static integrate(t,s,e,i){const r=(e-s)/i;let n=0,a=t.at(s),o=0,l=s+r;for(;o<i;o++,l+=r){const s=t.at(l);n+=a.distanceTo(s),a=s}return n}static ispsRecursive(t,s,e,i,r,n){const a=[];return function s(e,r,n,o,l,u,c=0){const h=ts3dutils.NLA_PRECISION;if(l.fuzzyTouchesAABB(u)){const l=(e+r)/2,u=(n+o)/2;if(Math.abs(r-e)<h||Math.abs(o-n)<h)return function(s,e){if(!a.some(t=>ts3dutils.eq(t.tThis,s)&&ts3dutils.eq(t.tOther,e))){const r=(s,e)=>t.tangentAt(s).dot(t.at(s).minus(i.at(e))),n=(s,e)=>i.tangentAt(e).dot(t.at(s).minus(i.at(e))),o=(t,s,e,i)=>t.ddt(e).dot(t.at(e).minus(s.at(i)))+t.tangentAt(e).squared(),l=(t,s,e,i)=>-t.tangentAt(e).dot(s.tangentAt(i)),u=ts3dutils.newtonIterate2dWithDerivatives(r,n,s,e,16,o.bind(void 0,t,i),l.bind(void 0,t,i),(s,e)=>-l(i,t,e,s),(s,e)=>-o(i,t,e,s));ts3dutils.assert(isFinite(u.x)),ts3dutils.assert(isFinite(u.y)),void 0==u&&console.log(s,e,t.sce,i.sce),a.push({tThis:u.x,tOther:u.y,p:t.at(u.x)})}}(l,u),!0;{const a=t.getAABB(e,l),h=i.getAABB(n,u);let d,f;s(e,l,n,u,a,h,c+1)||s(e,l,u,o,a,f=i.getAABB(u,o),c+1)||s(l,r,n,u,d=t.getAABB(l,r),h,c+1)||s(l,r,u,o,d,f,c+1)}}return!1}(s,e,r,n,t.getAABB(s,e),i.getAABB(r,n)),ts3dutils.fuzzyUniquesF(a,t=>t.tThis)}static breakDownIC(t,{sMin:s,sMax:e,tMin:i,tMax:r},n,a,o,l,u){const c=(t,n)=>s<=t&&t<=e&&i<=n&&n<=r,h=r-i,d=ceil((e-s)/n),f=ceil(h/a),p=new Array(d*f).fill(0);ts3dutils.arrayFromFunction(f,t=>p.slice(d*t,d*(t+1)).map(t=>t?"X":"_").join("")).join("\n");const m=(t,s)=>p[s*d+t],g=(t,s)=>0<=t&&t<d&&0<=s&&s<f&&(p[s*d+t]=1),P=[],v=[];for(let e=0;e<d;e++)t:for(let r=0;r<f;r++){if(m(e,r))continue;g(e,r);let l=s+(e+.5)*n,u=i+(r+.5)*a;const h=l,d=u;for(let s=0;s<8;s++){const s=t(l,u),e=t.x(l,u),i=t.y(l,u);if(0==e*e+i*i)continue t;const r=s/(e*e+i*i);l-=r*e,u-=r*i}const f=floor((l-s)/n),p=floor((u-i)/a);if(v.push({i:e,j:r,li:f,lj:p,startS:h,startT:d,s:l,t:u,"bounds(s, t)":c(l,u),"ic(s,t)":t(l,u)}),(e==f&&r==p||!m(f,p))&&(g(f,p),c(l,u)&&ts3dutils.eq0(t(l,u)))){console.log(ts3dutils.V(l,u).sce);const e=mkcurves(t,l,u,o,t.x,t.y,c);for(const t of e){ts3dutils.assert(t.points.length>2);for(const{x:e,y:r}of t.points){const t=(e-s)/n,o=(r-i)/a;g(t-.5|0,o-.5|0),g(t-.5|0,o+.5|0),g(t+.5|0,o-.5|0),g(t+.5|0,o+.5|0)}}P.push(...e)}}for(const{points:t}of P)for(let s=0;s<t.length-1;s++)ts3dutils.assert(!t[s].equals(t[s+1]));return P}toString(){return this.toSource()}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}withBounds(t=this.tMin,s=this.tMax){return ts3dutils.assert(this.tMin<=t&&t<=this.tMax),ts3dutils.assert(this.tMin<=s&&s<=this.tMax),ts3dutils.assert(this.tMin<=s&&s<=this.tMax),new this.constructor(...this.getConstructorParameters().slice(0,-2),t,s)}closestPointToPoint(t){return this.at(this.closestTToPoint(t))}isValidT(t){return ts3dutils.le(this.tMin,t)&&ts3dutils.le(t,this.tMax)}diff(t,s){return this.at(t).to(this.at(t+s))}closestTToPoint(t,s){const e=void 0!==s?s:ts3dutils.arrayFromFunction(32,t=>this.tMin+(this.tMax-this.tMin)*t/32).withMax(s=>-this.at(s).distanceTo(t));return ts3dutils.newtonIterateWithDerivative(s=>this.at(s).minus(t).dot(this.tangentAt(s)),e,16,s=>this.tangentAt(s).squared()+this.at(s).minus(t).dot(this.ddt(s)))}calcSegmentPoints(t,s,e,i,r,n){ts3dutils.assert(this.tIncrement,"tIncrement not defined on "+this);const a=this.tIncrement,o=[];if(n&&o.push(e),ts3dutils.assert(r!=t<s),t<s){const e=Math.ceil((t+ts3dutils.NLA_PRECISION)/a),i=Math.floor((s-ts3dutils.NLA_PRECISION)/a);for(let t=e;t<=i;t++)o.push(this.at(t*a))}else{const e=Math.floor((t-ts3dutils.NLA_PRECISION)/a),i=Math.ceil((s+ts3dutils.NLA_PRECISION)/a);for(let t=e;t>=i;t--)o.push(this.at(t*a))}return o.push(i),o}distanceToPoint(t,s,e){const i=this.closestTToPoint(t,s,e);return this.at(i).distanceTo(t)}asSegmentDistanceToPoint(t,s,e){let i=this.closestTToPoint(t,s,e);return i=ts3dutils.clamp(i,s,e),this.at(i).distanceTo(t)}isInfosWithCurve(t){return Curve.ispsRecursive(this,this.tMin,this.tMax,t,t.tMin,t.tMax)}arcLength(t,s,e=1){return ts3dutils.assert(t<s,"startT < endT"),ts3dutils.glqInSteps(t=>this.tangentAt(t).length(),t,s,e)}getAABB(t=this.tMin,s=this.tMax){t=isFinite(t)?t:this.tMin,s=isFinite(s)?s:this.tMax;const e=this.at(t),i=this.at(s),r=this.roots(),n=new Array(3),a=new Array(3);for(let o=0;o<3;o++){const l=r[o];n[o]=Math.min(e.e(o),i.e(o)),a[o]=Math.max(e.e(o),i.e(o));for(const e of l)t<e&&e<s&&(n[o]=Math.min(n[o],this.at(e).e(o)),a[o]=Math.max(a[o],this.at(e).e(o)))}return new ts3dutils.AABB(ts3dutils.V3.fromArray(n),ts3dutils.V3.fromArray(a))}reversed(){throw new Error}clipPlane(t){const s=this.isTsWithPlane(t).filter(t=>this.tMin<=t&&t<=this.tMax);return ts3dutils.getIntervals(s,this.tMin,this.tMax).mapFilter(([s,e])=>{const i=(s+e)/2;return!ts3dutils.eq(s,e)&&t.distanceToPointSigned(this.at(i))<0&&this.withBounds(s,e)})}}function mkcurves(t,s,e,i,r,n,a){const o=ts3dutils.V(s,e),{points:l,tangents:u}=followAlgorithm2d(t,o,i,a);if(l[0].distanceTo(l.last)<i&&l.length>2){for(let t=0;t<l.length-1;t++)ts3dutils.assert(!l[t].equals(l[t+1]));const t=floor(l.length/2),s=l.slice(0,t),e=l.slice(t-1,l.length),i=u.slice(0,t),r=u.slice(t-1,u.length);r[r.length-1]=i[0],e[r.length-1]=s[0];for(let t=0;t<s.length-1;t++)ts3dutils.assert(!s[t].equals(s[t+1]));for(let t=0;t<e.length-1;t++)ts3dutils.assert(!e[t].equals(e[t+1]));return[{points:s,tangents:i},{points:e,tangents:r}]}{const{points:s,tangents:e}=followAlgorithm2d(t,o,-i,a),r=followAlgorithm2d(t,s.last,i,a,void 0,e.last.negated());return ts3dutils.assert(r.points.length>2),[r]}}function curvePoint(t,s,e,i){let r=s;for(let s=0;s<8;s++){const s=t(r.x,r.y),n=e(r.x,r.y),a=i(r.x,r.y),o=s/(n*n+a*a);r=r.minus(new ts3dutils.V3(o*n,o*a,0))}return r}function curvePointMF(t,s,e=8,i=1/(1<<30)){let r=s;for(let s=0;s<e;s++){const s=t(r.x,r.y),e=t.x(r.x,r.y),n=t.y(r.x,r.y),a=s/(e*e+n*n);if(r=r.minus(new ts3dutils.V3(a*e,a*n,0)),abs$1(s)<=i)break}return r}Curve.hlol=0;const{PI:PI}=Math;class XiEtaCurve extends Curve{constructor(t,s,e,i=-PI,r=PI){if(super(i,r),this.center=t,this.f1=s,this.f2=e,this.tMin=i,this.tMax=r,ts3dutils.assertVectors(t,s,e),this.normal=s.cross(e),this.normal.likeO()){this.matrix=ts3dutils.M4.forSys(s,e,s.unit(),t);const i=s.getPerpendicular();this.inverseMatrix=new ts3dutils.M4(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1).times(ts3dutils.M4.forSys(s,i,s.cross(i),t).inversed())}else this.normal=this.normal.unit(),this.matrix=ts3dutils.M4.forSys(s,e,this.normal,t),this.inverseMatrix=this.matrix.inversed()}static magic(t,s,e){throw new Error("abstract")}static forAB(t,s,e=ts3dutils.V3.O){return new this(e,ts3dutils.V(t,0,0),ts3dutils.V(0,s,0))}static XYLCValid(t){throw new Error("abstract")}static XYLCPointT(t){throw new Error("abstract")}static unitIsInfosWithLine(t,s,e,i){throw new Error("abstract")}addToMesh(t,s=4,e=0,i=1){const r=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/s)),n=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(e,ts3dutils.TAU*t/s)),a=this.tIncrement,o=Math.ceil((this.tMin+ts3dutils.NLA_PRECISION)/a),l=Math.floor((this.tMax-ts3dutils.NLA_PRECISION)/a);for(let e=o;e<=l;e+=i){const i=e*a,o=t.vertices.length;if(0!==e)for(let e=0;e<s;e++)tsgl.pushQuad(t.TRIANGLES,!0,o-s+e,o+e,o-s+(e+1)%s,o+(e+1)%s);const l=this.at(i),u=this.tangentAt(i),c=ts3dutils.M4.forSys(this.normal,u.cross(this.normal),u,l);t.normals.push(...c.transformedVectors(r)),t.vertices.push(...c.transformedPoints(n))}}getConstructorParameters(){return[this.center,this.f1,this.f2,this.tMin,this.tMax]}isInfosWithCurve(t){return t instanceof L3$1?this.isInfosWithLine(t.anchor,t.dir1,this.tMin,this.tMax,t.tMin,t.tMax):t instanceof BezierCurve?this.isInfosWithBezier(t):t instanceof XiEtaCurve&&!this.normal.isParallelTo(t.normal)?this.isTsWithPlane(t.getPlane()).mapFilter(s=>{const e=this.at(s);if(t.containsPoint(e))return{tThis:s,tOther:t.pointT(e),p:e}}):super.isInfosWithCurve(t)}transform(t){return new this.constructor(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),this.tMin,this.tMax)}equals(t){return this==t||t.constructor==this.constructor&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.center.hashCode())+this.f1.hashCode())+this.f2.hashCode())}likeCurve(t){return ts3dutils.hasConstructor(t,this.constructor)&&this.center.like(t.center)&&this.f1.like(t.f1)&&this.f2.like(t.f2)}normalP(t){return this.tangentAt(t).cross(this.normal)}getPlane(){return P3.normalOnAnchor(this.normal,this.center)}isTsWithPlane(t){if(ts3dutils.assertInst(P3,t),t.normal1.isParallelTo(this.normal))return[];const s=t.normal1,e=t.w,i=this.center,r=this.f1,n=this.f2,a=s.dot(r),o=s.dot(n),l=e-s.dot(i);return this.constructor.magic(a,o,l)}pointT(t){ts3dutils.assertVectors(t);const s=this.inverseMatrix.transformPoint(t);return this.constructor.XYLCPointT(s)}containsPoint(t){const s=this.inverseMatrix.transformPoint(t);return ts3dutils.eq0(s.z)&&this.constructor.XYLCValid(s)}isInfosWithLine(t,s,e,i,r=-1e5,n=1e5){const a=this.inverseMatrix.transformPoint(t),o=this.inverseMatrix.transformVector(s);if(ts3dutils.eq0(o.z)){if(ts3dutils.eq0(a.z))return this.constructor.unitIsInfosWithLine(a,o,t,s)}else{const e=a.z/o.z,i=o.times(e).plus(a);if(this.constructor.XYLCValid(i))return[{tThis:this.constructor.XYLCPointT(i),tOther:e,p:t.plus(s.times(e))}]}return[]}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof SemiEllipsoidSurface){const s=t.asEllipsoidSurface().isCurvesWithSurface(new PlaneSurface$1(this.getPlane()));return s.length<1?[]:this.isInfosWithCurve(s[0]).filter(s=>t.containsPoint(s.p)).map(t=>t.tThis)}if(t instanceof ProjectedCurveSurface||t instanceof EllipsoidSurface||t instanceof ConicSurface)return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).map(t=>t.tThis);throw new Error}isInfosWithBezier(t){const s=t.transform(this.inverseMatrix);if(new PlaneSurface$1(P3.XY).containsCurve(s))return this.isInfosWithBezier2D(t);return s.isTsWithPlane(P3.XY).mapFilter(e=>{const i=s.at(e);if(this.constructor.XYLCValid(i))return{tOther:e,p:t.at(e),tThis:this.constructor.XYLCPointT(i)}})}isInfosWithBezier2D(t,s,e){return s=isFinite(s)?s:t.tMin,e=isFinite(e)?e:t.tMax,ts3dutils.assertf(()=>0<Math.PI),ts3dutils.assertf(()=>s<e),Curve.ispsRecursive(this,this.tMin,this.tMax,t,s,e)}isOrthogonal(){return this.f1.isPerpendicularTo(this.f2)}at2(t,s){return ts3dutils.assertNumbers(t,s),this.center.plus(this.f1.times(t)).plus(this.f2.times(s))}debugToMesh(t,s){t[s]||t.addVertexBuffer(s,s);for(let e=0;e<Math.PI;e+=.1){const i=this.at(e);t[s].push(i,i.plus(this.tangentAt(e).toLength(1))),t[s].push(i,i.plus(this.normalP(e).toLength(1)))}t[s].push(this.center,this.center.plus(this.f1.times(1.2))),t[s].push(this.center,this.center.plus(this.f2)),t[s].push(this.center,this.center.plus(this.normal))}}const{ceil:ceil$1,floor:floor$1}=Math;class ImplicitCurve extends Curve{constructor(t,s,e=1,i,r=(1==e?0:-(t.length-1)),n=(1==e?t.length-1:0)){super(r,n),this.points=t,this.tangents=s,this.dir=e,this.generator=i,ts3dutils.assert(t.length>2),ts3dutils.assert(0<=r&&r<=t.length-1),ts3dutils.assert(0<=n&&n<=t.length-1)}likeCurve(t){throw new Error("Method not implemented.")}toSource(t=(t=>t)){return this.generator||super.toSource(t)}containsPoint(t){return ts3dutils.assertVectors(t),!isNaN(this.pointT(t))}equals(t){return this==t||Object.getPrototypeOf(t)==PICurve.prototype&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])}hashCode(){return[this.points[0],this.tangents[0]].hashCode()}tangentP(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t),"this.containsPoint(pWC)"+this.containsPoint(t));const s=this.pointT(t);return this.tangentAt(s)}tangentAt(t){return t=ts3dutils.clamp(t,this.tMin,this.tMax),ts3dutils.V3.lerp(this.tangents[floor$1(t)],this.tangents[ceil$1(t)],t%1)}at(t){return ts3dutils.assert(!isNaN(t)),ts3dutils.V3.lerp(this.points[floor$1(t)],this.points[ceil$1(t)],t%1)}getConstructorParameters(){return[]}transform(t){return new ImplicitCurve(t.transformedPoints(this.points),t.transformedVectors(this.tangents))}roots(){const t=ts3dutils.arrayRange(0,this.points.length);return[t,t,t]}addToMesh(t,s=4,e=0,i=1){const r=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/s)),n=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(e,ts3dutils.TAU*t/s));let a=ts3dutils.V3.Z,o=ts3dutils.M4.IDENTITY;for(let e=ceil$1(this.tMin);e<floor$1(this.tMax);e+=i){const i=t.vertices.length;if(ceil$1(this.tMin)!==e)for(let e=0;e<s;e++)tsgl.pushQuad(t.TRIANGLES,!0,i-s+e,i+e,i-s+(e+1)%s,i+(e+1)%s);const l=this.points[e],u=this.tangents[e],c=ts3dutils.M4.rotateAB(a,u).times(o);t.normals.push(...c.transformedVectors(r));const h=ts3dutils.M4.translate(l).times(c);t.vertices.push(...h.transformedPoints(n)),a=u,o=c}}}ImplicitCurve.prototype.tIncrement=1;const{PI:PI$1,abs:abs$2,sin:sin,cos:cos}=Math;class BezierCurve extends Curve{constructor(t,s,e,i,r=-.1,n=1.1){super(r,n),ts3dutils.assertVectors(t,s,e,i),ts3dutils.assert(isFinite(r)&&isFinite(n)),this.p0=t,this.p1=s,this.p2=e,this.p3=i}get points(){return[this.p0,this.p1,this.p2,this.p3]}static graphXY(t,s,e,i,r,n){const a=i,o=e/3+a,l=s/3-a+2*o,u=t+a-3*o+3*l;return new BezierCurve(ts3dutils.V(0,a),ts3dutils.V(1/3,o),ts3dutils.V(2/3,l),ts3dutils.V(1,u),r,n)}static quadratic(t,s,e,i=0,r=1){const n=L3$1.throughPoints(t,e);return n.containsPoint(s)?n:new BezierCurve(t,s.times(2).plus(t).div(3),s.times(2).plus(e).div(3),e,i,r)}static approximateUnitArc(t){const s=4/3*Math.tan(t/4);return new BezierCurve(ts3dutils.V3.X,new ts3dutils.V3(1,s,0),new ts3dutils.V3(cos(t)+s*sin(t),sin(t)-s*cos(t),0),ts3dutils.V3.sphere(t,0),0,1)}static testEdges(){const t=BezierCurve.graphXY(2,-3,-3,2,.6,2),s=t.magic().map(t=>Edge.forCurveAndTs(t).translate(3));return console.log(s.length),[Edge.forCurveAndTs(t)].concat(s)}getConstructorParameters(){return[this.p0,this.p1,this.p2,this.p3,this.tMin,this.tMax]}at(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=1-t,a=n*n*n,o=3*n*n*t,l=3*n*t*t,u=t*t*t;return new ts3dutils.V3(s.x*a+e.x*o+i.x*l+r.x*u,s.y*a+e.y*o+i.y*l+r.y*u,s.z*a+e.z*o+i.z*l+r.z*u)}tangentAt(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=1-t,a=3*n*n,o=6*n*t,l=3*t*t;return new ts3dutils.V3((e.x-s.x)*a+(i.x-e.x)*o+(r.x-i.x)*l,(e.y-s.y)*a+(i.y-e.y)*o+(r.y-i.y)*l,(e.z-s.z)*a+(i.z-e.z)*o+(r.z-i.z)*l)}ddt(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=6*(1-t),a=6*t;return new ts3dutils.V3((i.x-2*e.x+s.x)*n+(r.x-2*i.x+e.x)*a,(i.y-2*e.y+s.y)*n+(r.y-2*i.y+e.y)*a,(i.z-2*e.z+s.z)*n+(r.z-2*i.z+e.z)*a)}normalP(t){const s=this.tangentAt(t);return s.cross(this.ddt(t)).cross(s)}isTsWithPlane(t){ts3dutils.assertInst(P3,t);const{p0:s,p1:e,p2:i,p3:r}=this,n=t.normal1,a=e.minus(i).times(3).minus(s).plus(r),o=s.plus(i).times(3).minus(e.times(6)),l=e.minus(s).times(3),u=s;return ts3dutils.solveCubicReal2(a.dot(n),o.dot(n),l.dot(n),u.dot(n)-t.w).filter(t=>ts3dutils.between(t,this.tMin,this.tMax))}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof SemiCylinderSurface){const s=new P3(t.dir.unit(),0),e=this.project(s);return t.baseCurve.project(s).isInfosWithBezier2D(e).map(t=>t.tOther)}if(t instanceof ProjectedCurveSurface){const s=new P3(t.dir.unit(),0),e=this.project(s);return t.baseCurve.project(s).isInfosWithCurve(e).map(t=>t.tOther)}if(t instanceof EllipsoidSurface){const s=this.transform(t.inverseMatrix),e=t=>s.at(t).length()-1,i=t=>s.at(t).unit().dot(s.tangentAt(t)),r=1/2048,n=(this.tMax,this.tMin,[]);for(let t=this.tMin;t<=this.tMax;t+=r){const a=r*s.tangentAt(t).length();if(abs$2(e(t))<=a){let s=ts3dutils.newtonIterateWithDerivative(e,t,16,i);ts3dutils.eq0(e(s))&&!ts3dutils.eq0(i(s))||(s=ts3dutils.newtonIterate1d(i,t,16)),ts3dutils.eq0(e(s))&&!n.some(t=>ts3dutils.eq(t,s))&&n.push(s)}}return n}if(t instanceof SemiEllipsoidSurface)return this.isTsWithSurface(t.asEllipsoidSurface()).filter(s=>t.containsPoint(this.at(s)));throw new Error}likeCurve(t){return this==t||ts3dutils.hasConstructor(t,BezierCurve)&&this.p0.like(t.p0)&&this.p1.like(t.p1)&&this.p2.like(t.p2)&&this.p3.like(t.p3)}equals(t){return this==t||ts3dutils.hasConstructor(t,BezierCurve)&&this.p0.equals(t.p0)&&this.p1.equals(t.p1)&&this.p2.equals(t.p2)&&this.p3.equals(t.p3)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.p0.hashCode())+this.p1.hashCode())+this.p2.hashCode())+this.p3.hashCode())}isColinearTo(t){if(this===t||this.likeCurve(t))return!0;if(!(t instanceof BezierCurve))return!1;let s,e,i;if(isNaN(s=this.pointT(t.p0))||isNaN(e=this.pointT(t.p3)))return!1;if(ts3dutils.eq(1,s))i=this.split(e)[1].reversed();else{const t=(e-s)/(1-s);i=this.split(s)[1].split(t)[0]}return t.likeCurve(i)}reversed(){return new BezierCurve(this.p3,this.p2,this.p1,this.p0,1-this.tMax,1-this.tMin)}getCoefficients(){const{p0:t,p1:s,p2:e,p3:i}=this;return[s.minus(e).times(3).minus(t).plus(i),t.plus(e).times(3).minus(s.times(6)),s.minus(t).times(3),t]}tangentCoefficients(){const{p0:t,p1:s,p2:e,p3:i}=this,r=s.minus(t),n=e.minus(s),a=i.minus(e),o=r.plus(a).times(3).minus(n.times(6)),l=n.minus(r).times(6),u=r.times(3);return[ts3dutils.V3.O,o,l,u]}pointT(t){return this.closestTToPoint(t)}pointT3(t){const{p0:s,p1:e,p2:i,p3:r}=this,n=e.minus(i).times(3).minus(s).plus(r),a=s.plus(i).times(3).minus(e.times(6)),o=e.minus(s).times(3),l=s.minus(t),u=ts3dutils.NLA_PRECISION<n.maxAbsElement()?n.maxAbsDim():ts3dutils.NLA_PRECISION<a.maxAbsElement()?a.maxAbsDim():ts3dutils.NLA_PRECISION<o.maxAbsElement()?o.maxAbsDim():ts3dutils.assertNever(),c=ts3dutils.solveCubicReal2(n.e(u),a.e(u),o.e(u),l.e(u)).filter(s=>this.at(s).like(t));return 0==c.length?NaN:1==c.length?c[0]:void ts3dutils.assert(!1,"multiple intersection "+this.toString()+t.sce)}pointT2(t){const{p0:s,p1:e,p2:i,p3:r}=this,n=e.minus(i).times(3).minus(s).plus(r).els(),a=s.plus(i).times(3).minus(e.times(6)).els(),o=e.minus(s).times(3).els(),l=s.minus(t).els();let u=void 0;for(let t=0;t<3;t++)if(ts3dutils.eq0(n[t])&&ts3dutils.eq0(a[t])&&ts3dutils.eq0(o[t])){if(!ts3dutils.eq0(l[t]))return NaN}else{const s=ts3dutils.solveCubicReal2(n[t],a[t],o[t],l[t]);if(0==s.length)return NaN;if(1==s.length)return s[0];if(u){if(0==(u=u.filter(t=>s.some(s=>ts3dutils.eq(t,s)))).length)return NaN;if(1==u.length)return u[0]}else u=s}ts3dutils.assert(!1,"multiple intersection "+u+this.toString()+t.sce)}transform(t){return new BezierCurve(t.transformPoint(this.p0),t.transformPoint(this.p1),t.transformPoint(this.p2),t.transformPoint(this.p3),this.tMin,this.tMax)}isClosed(){return this.p0.like(this.p3)}isQuadratic(){return this.p1.like(this.p2)}debugToMesh(t,s){const e=t.addVertexBuffer(s,s);for(let t=-2;t<=2;t+=.01){const i=this.at(t);e[s].push(i,i.plus(this.tangentAt(t).toLength(1))),e[s].push(i,i.plus(this.normalP(t).toLength(1)))}e[s].push(this.p0,this.p1),e[s].push(this.p1,this.p2),e[s].push(this.p2,this.p3)}split(t){const s=1-t,{p0:e,p1:i,p2:r,p3:n}=this,a=e.times(s).plus(i.times(t)),o=i.times(s).plus(r.times(t)),l=r.times(s).plus(n.times(t)),u=a.times(s).plus(o.times(t)),c=o.times(s).plus(l.times(t)),h=u.times(s).plus(c.times(t));return[new BezierCurve(e,a,u,h),new BezierCurve(h,c,l,n)]}containsPoint(t){return isFinite(this.pointT(t))}roots(){const{p0:t,p1:s,p2:e,p3:i}=this,r=s.minus(t),n=e.minus(s),a=i.minus(e),o=r.plus(a).times(3).minus(n.times(6)),l=n.minus(r).times(6),u=r.times(3);return ts3dutils.arrayFromFunction(3,t=>ts3dutils.solveCubicReal2(0,o.e(t),l.e(t),u.e(t)))}isInfosWithLine(t,s,e,i,r=-1e5,n=1e5){const a=s.length();let o=Curve.ispsRecursive(this,this.tMin,this.tMax,new L3$1(t,s.unit()),r,n);return(o=ts3dutils.fuzzyUniquesF(o,t=>t.tOther)).forEach(t=>t.tOther/=a),o}closestPointToLine(t,s,e){s=isFinite(s)?s:this.tMin,e=isFinite(e)?e:this.tMax;const i=t.anchor.dot(t.dir1),r=s=>{const e=this.at(s);return e.minus(t.at(e.dot(t.dir1)-i)).dot(this.tangentAt(s))},n=ts3dutils.arrayFromFunction(32,t=>s+(e-s)*t/32).withMax(t=>-r(t));return ts3dutils.newtonIterate1d(r,n,8)}isInfosWithBezie3(t,s,e,i,r){const n=(s,e)=>{if(!u.some(t=>ts3dutils.eq(t.tThis,s)&&ts3dutils.eq(t.tOther,e))){const i=(s,e)=>this.tangentAt(s).dot(this.at(s).minus(t.at(e))),r=(s,e)=>t.tangentAt(e).dot(this.at(s).minus(t.at(e))),n=(t,s,e,i)=>t.ddt(e).dot(t.at(e).minus(s.at(i)))+t.tangentAt(e).squared(),a=(t,s,e,i)=>-t.tangentAt(e).dot(s.tangentAt(i)),o=ts3dutils.newtonIterate2dWithDerivatives(i,r,s,e,16,n.bind(void 0,this,t),a.bind(void 0,this,t),(s,e)=>-a(t,this,e,s),(s,e)=>-n(t,this,e,s));u.push({tThis:o.x,tOther:o.y,p:this.at(o.x)})}},a=[s="number"==typeof s&&isFinite(s)?s:this.tMin,e="number"==typeof e&&isFinite(e)?e:this.tMax,i="number"==typeof i&&isFinite(i)?i:t.tMin,r="number"==typeof r&&isFinite(r)?r:t.tMax],o=(s+e)/2,l=(i+r)/2,u=(this.getAABB(s,o),this.getAABB(o,e),t.getAABB(i,i),t.getAABB(l,r),[]);for(;a.length;){const s=a.length-4,e=a[s],i=a[s+1],r=a[s+2],o=a[s+3];a.length-=4;const l=this.getAABB(e,i),u=t.getAABB(r,o);if(l&&u&&l.intersectsAABB2d(u)){const t=(e+i)/2,s=(r+o)/2,c=1e-5;i-e<c||o-r<c?(console.log(e,i,r,o),console.log(l.sce),console.log(u.sce),console.log(t,s),n(t,s)):Array.prototype.push.call(a,e,t,r,s,e,t,s,o,t,i,r,s,t,i,s,o)}}return u}isInfosWithBezier(t,s,e,i,r){s="number"==typeof s&&isFinite(s)?s:this.tMin,e="number"==typeof e&&isFinite(e)?e:this.tMax,i="number"==typeof i&&isFinite(i)?i:t.tMin,r="number"==typeof r&&isFinite(r)?r:t.tMax,ts3dutils.assertf(()=>s<e),ts3dutils.assertf(()=>i<r);const n=[],a=this.likeCurve(t),o=this.isColinearTo(t);if(!a&&!o)return Curve.ispsRecursive(this,s,e,t,i,r);{a||(i=this.pointT(t.at(i)),r=this.pointT(t.at(r))),s=Math.min(s,i),e=Math.max(e,r);const o=ts3dutils.fuzzyUniques(this.roots().concatenated().filter(isFinite).concat([s,e])).sort(ts3dutils.MINUS);Array.from(ts3dutils.combinations(o.length-1)).forEach(({i:s,j:e})=>{Math.abs(s-e)>2&&n.push(...Curve.ispsRecursive(this,o[s],o[s+1],t,o[e],o[e+1]))})}return n}selfIntersectionsInfo(){return this.isInfosWithBezier(this)}isInfosWithCurve(t){return t instanceof L3$1?this.isInfosWithLine(t.anchor,t.dir1,t.tMin,t.tMax):t instanceof BezierCurve?this.isInfosWithBezier(t):t.isInfosWithCurve(this).map(({tThis:t,tOther:s,p:e})=>({tThis:s,tOther:t,p:e}))}getAreaInDirSurface(t,s,e,i){ts3dutils.assertf(()=>t.hasLength(1));const r=e=>{const i=this.tangentAt(e),r=this.at(e),n=i.cross(s.normalP(r)),a=Math.sign(n.dot(t));return r.dot(t)*i.rejected1Length(t)*a},n=s=>{const e=this.at(s).dot(t);return this.at(s).minus(t.times(e/2))},a=ts3dutils.gaussLegendreQuadrature24(r,e,i);return{area:a,centroid:ts3dutils.V3.add.apply(void 0,ts3dutils.arrayFromFunction(24,t=>{const s=e+(ts3dutils.gaussLegendre24Xs[t]+1)/2*(i-e);return n(s).times(ts3dutils.gaussLegendre24Weights[t]*r(s))})).div(2*(i-e)*a)}}magic(t=this.tMin,s=this.tMax,e=[]){const i=ts3dutils.arrayFromFunction(20,e=>ts3dutils.lerp(t,s,e/19)),r=i.map(t=>this.at(t)),n=i.map(t=>this.normalP(t).unit()),a=t=>{const s=i.map((s,e)=>new L3$1(r[e],t[e].unit())),e=ts3dutils.arrayFromFunction(19,t=>{const e=t+1,i=s[t],r=s[e];return i.infoClosestToLine(r)}),n=e.map(t=>t.s-t.t),a=e.map(t=>ts3dutils.V3.lerp(t.closest,t.closest2,.5)),o=ts3dutils.arrayFromFunction(19,t=>{const s=ts3dutils.lerp(i[t],i[t+1],.5),e=this.at(s);return Math.pow(e.distanceTo(a[t]),.5)});return n.concat(o)},o=ts3dutils.V3.packXY(n),l=t=>a(ts3dutils.V3.unpackXY(t)),u=new ts3dutils.Vector(new Float64Array(o));for(let t=0;t<2;t++){const t=new ts3dutils.Vector(new Float64Array(l(u.v)));console.log(t.v);const s=ts3dutils.Matrix.jacobi(l,u.v);console.log("jacobi\n",s.toString(t=>""+t));s.getDependentRowIndexes();const e=s.transposed();console.log(s.times(e).str),console.log(s.times(e).inversed().str);const i=e.times(s.times(e).inversed()).timesVector(t);u=u.minus(i)}const c=ts3dutils.V3.unpackXY(u.v),h=ts3dutils.arrayFromFunction(20,t=>new L3$1(r[t],c[t].unit()));return ts3dutils.arrayFromFunction(19,t=>{const s=t+1,e=h[t],i=h[s],n=e.infoClosestToLine(i);return EllipseCurve.circleForCenter2P(n.closest,r[t],r[s],n.s)})}magic2(t=this.tMin,s=this.tMax,e=[]){const i=this.at(t),r=this.at(s),n=this.normalP(t).unit(),a=this.normalP(s).unit(),o=new L3$1(i,n),l=new L3$1(r,a),u=o.infoClosestToLine(l);if(u.s<0||u.t<0||u.distance>.01||!ts3dutils.eq(u.s,u.t,.01));else{const n=ts3dutils.V3.lerp(u.closest,u.closest2,.5),a=ts3dutils.lerp(t,s,.5),o=this.at(a),l=ts3dutils.lerp(t,s,2/3),c=(this.at(l),(u.s+u.t)/2);if(ts3dutils.eq(n.distanceTo(o),c,.01)){const t=EllipseCurve.circleForCenter2P(n,i,r,c);return e.push(t),e}}const c=(t+s)/2;return this.magic(t,c,e),this.magic(c,s,e),e}}BezierCurve.EX2D=BezierCurve.graphXY(2,-3,-3,2),BezierCurve.EX3D=new BezierCurve(ts3dutils.V3.O,ts3dutils.V(-.1,-1,1),ts3dutils.V(1.1,1,1),ts3dutils.V3.X),BezierCurve.QUARTER_CIRCLE=BezierCurve.approximateUnitArc(PI$1/2),BezierCurve.prototype.hlol=Curve.hlol++,BezierCurve.prototype.tIncrement=1/80;const{PI:PI$2,cos:cos$1,sin:sin$1,min:min,max:max,tan:tan,sign:sign,ceil:ceil$2,floor:floor$2,abs:abs$3,sqrt:sqrt,pow:pow,atan2:atan2,round:round}=Math;class EllipseCurve extends XiEtaCurve{constructor(t,s,e,i=-PI$2,r=PI$2){super(t,s,e,i,r),ts3dutils.assert(EllipseCurve.isValidT(i)),ts3dutils.assert(EllipseCurve.isValidT(r))}static isValidT(t){return-Math.PI<=t&&t<=Math.PI}static XYLCValid(t){return ts3dutils.eq(1,t.lengthXY())}static XYLCPointT(t,s){const e=t.angleXY();return e<-Math.PI+ts3dutils.NLA_PRECISION||e>Math.PI-ts3dutils.NLA_PRECISION?(ts3dutils.assert(isFinite(s)),Math.sign(s)*Math.PI):e}static magic(t,s,e){return intersectionUnitCircleLine2(t,s,e).map(([t,s])=>Math.atan2(s,t))}static unitIsInfosWithLine(t,s,e,i){const r=s.dot(s);return ts3dutils.pqFormula(2*s.dot(t)/r,(t.dot(t)-1)/r).map(r=>({tThis:Math.atan2(t.y+r*s.y,t.x+r*s.x),tOther:r,p:L3$1.at(e,i,r)}))}static circle(t,s=ts3dutils.V3.O){return new EllipseCurve(s,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0))}static circleForCenter2P(t,s,e,i){const r=t.to(s),n=r.cross(t.to(e)).cross(r).toLength(r.length()),a=r.angleTo(t.to(e));return new EllipseCurve(t,r,n,0,a)}getVolZAnd(t,s,e){return{volume:ts3dutils.glqInSteps(s=>(function(s){const e=t.times(t.dot(s));return e.lengthXY()*(s.z-e.z/2)})(this.at(s))*this.tangentAt(s).cross(this.normal).unit().z,s,e,4),centroid:void 0}}getAreaInDir(t,s,e,i){ts3dutils.assertf(()=>t.isPerpendicularTo(this.normal)),ts3dutils.assertf(()=>s.isPerpendicularTo(this.normal));const r=this.inverseMatrix.transformVector(s),n=r.cross(ts3dutils.V3.Z),a=e-n.angleXY(),o=i-n.angleXY(),l=this.inverseMatrix.getTranslation().dot(r.unit());Math.PI;function u(t){return(t-Math.sin(t)*Math.cos(t))/2}function c(t){return Math.pow(Math.sin(t),3)/3}function h(t){return(Math.cos(3*t)-9*Math.cos(t))/24}const d=-l*(-Math.cos(o)+Math.cos(a)),f=u(o)-u(a)+d,p=(c(o)-c(a)+-l*(-Math.cos(o)-Math.cos(a))/2*d)/f,m=(h(o)-h(a)- -l/2*d)/f,g=this.matrix.xyAreaFactor();return ts3dutils.assert(!ts3dutils.eq0(g)),{area:f*g,centroid:this.matrix.transformPoint(ts3dutils.M4.rotateZ(n.angleXY()).transformPoint(new ts3dutils.V3(p,m,0)))}}at(t){return this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return ts3dutils.assertNumbers(t),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}tangentAt2(t,s){return this.f2.times(t).minus(this.f1.times(s))}isCircular(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}reversed(){return new this.constructor(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}isColinearTo(t){if(!ts3dutils.hasConstructor(t,EllipseCurve))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&ts3dutils.eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:s,f2:e}=this.rightAngled(),{f1:i,f2:r}=t.rightAngled();return s.length()>e.length()&&([s,e]=[e,s]),i.length()>r.length()&&([i,r]=[r,i]),ts3dutils.eq(s.squared(),Math.abs(s.dot(i)))&&ts3dutils.eq(e.squared(),Math.abs(e.dot(r)))}}eccentricity(){const t=this.rightAngled(),s=t.f1.length(),e=t.f1.length(),[i,r]=s>e?[s,e]:[e,s];return Math.sqrt(1-r*r/i/i)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t,s,e){return ts3dutils.assert(t<s,"startT < endT"),this.isCircular()?this.f1.length()*(s-t):super.arcLength(t,s,e)}circumferenceApproximate(){const{f1:t,f2:s}=this.rightAngled(),e=t.length(),i=s.length(),r=Math.pow(e-i,2)/Math.pow(e+i,2);return Math.PI*(e+i)*(1+3*r/(10+Math.sqrt(4-3*r)))}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s),i=s.squared()-t.squared();if(ts3dutils.eq0(e))return this;const r=2*e,n=i+Math.sqrt(i*i+4*e*e),{x1:a,y1:o}=intersectionUnitCircleLine(r,n,0);return new EllipseCurve(this.center,t.times(a).plus(s.times(o)),t.times(-o).plus(s.times(a)))}isInfosWithEllipse(t){if(this.normal.isParallelTo(t.normal)&&ts3dutils.eq0(this.center.minus(t.center).dot(t.normal))){const s=t.transform(this.inverseMatrix).rightAngled(),e=s.f1.lengthXY(),i=s.f2.lengthXY(),r=s.center.lengthXY(),n=min(e,i),a=max(e,i);if(ts3dutils.lt(r+a,1)||ts3dutils.lt(1,r-a)||ts3dutils.lt(1,n-r)||ts3dutils.eq(1,e)&&ts3dutils.eq(1,i)&&ts3dutils.eq0(r))return[];const o=t=>s.at(t).lengthXY()-1,l=t=>s.at(t).xy().dot(s.tangentAt(t))/s.at(t).lengthXY();ts3dutils.checkDerivate(o,l,-PI$2,PI$2,1);const u=[];ts3dutils.arrayRange(-.8*PI$2,PI$2,PI$2/4).map(t=>[t,l(t),ts3dutils.newtonIterateSmart(o,t,16,l,1e-4),o(ts3dutils.newtonIterateSmart(o,t,16,l,1e-4))]);for(let t=-.8*PI$2;t<PI$2;t+=PI$2/4){let e=ts3dutils.newtonIterateSmart(o,t,16,l,1e-4);ts3dutils.le(e,-PI$2)&&(e+=ts3dutils.TAU),ts3dutils.assert(!isNaN(e)),s.isValidT(e)&&ts3dutils.eq0(o(e))&&!u.some(t=>ts3dutils.eq(e,t))&&u.push(e)}return u.map(e=>{const i=this.matrix.transformPoint(s.at(e));return{tThis:this.pointT(i),tOther:t.pointT(i,PI$2),p:i}})}return this.isTsWithPlane(t.getPlane()).mapFilter(s=>{const e=this.at(s);if(t.containsPoint(e))return{tThis:s,tOther:t.pointT(e),p:e}})}isInfosWithCurve(t){return t instanceof EllipseCurve?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}roots(){return ts3dutils.arrayFromFunction(3,t=>{const s=this.f2.e(t),e=-this.f1.e(t),{x1:i,y1:r,x2:n,y2:a}=intersectionUnitCircleLine(s,e,0);return[Math.atan2(r,i),Math.atan2(a,n)]})}closestTToPoint(t,s){const e=this.inverseMatrix.transformPoint(t).angleXY(),i=t.minus(this.center);return ts3dutils.newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(i)),e)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const s=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.inverseMatrix.transformVector(s).angleXY()}}EllipseCurve.XY=new EllipseCurve(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),EllipseCurve.prototype.hlol=Curve.hlol++,EllipseCurve.prototype.tIncrement=2*Math.PI/3200;const{PI:PI$3,cos:cos$2,sin:sin$2,min:min$1,max:max$1,tan:tan$1,sign:sign$1,ceil:ceil$3,floor:floor$3,abs:abs$4,sqrt:sqrt$1,pow:pow$1,atan2:atan2$1,round:round$1}=Math;class HyperbolaCurve extends XiEtaCurve{constructor(t,s,e,i=-7,r=7){super(t,s,e,i,r)}static XYLCValid(t){return t.x>0&&ts3dutils.eq(1,t.x*t.x-t.y*t.y)}static XYLCPointT(t){return Math.asinh(t.y)}static magic(t,s,e){if(ts3dutils.eq0(s)){const s=ts3dutils.snap0(Math.pow(e,2)/Math.pow(t,2)-1);if(s<0||e*t<0)return[];if(0==s)return[0];const i=Math.sqrt(s);return[-Math.asinh(i),Math.asinh(i)]}if(ts3dutils.eq(abs$4(t),abs$4(s))){if(ts3dutils.le(e*t,0))return[];const i=sign$1(t*s)*(Math.pow(e,2)-Math.pow(t,2))/2/t/e;return[Math.asinh(i)]}{const i=ts3dutils.snap0(Math.pow(s,2)*(-Math.pow(t,2)+Math.pow(s,2)+Math.pow(e,2)));if(i<0)return[];const r=(t*e-Math.sqrt(i))/(Math.pow(t,2)-Math.pow(s,2)),n=(t*e+Math.sqrt(i))/(Math.pow(t,2)-Math.pow(s,2)),a=(Math.pow(s,2)*e-t*Math.sqrt(i))/(s*(Math.pow(s,2)-Math.pow(t,2))),o=(Math.pow(s,2)*e+t*Math.sqrt(i))/(s*(Math.pow(s,2)-Math.pow(t,2)));return[r>0&&Math.asinh(a),n>0&&Math.asinh(o)].filter(t=>!1!==t)}}at(t){return ts3dutils.assertNumbers(t),this.center.plus(this.f1.times(Math.cosh(t))).plus(this.f2.times(Math.sinh(t)))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f1.times(Math.sinh(t)).plus(this.f2.times(Math.cosh(t)))}tangentAt2(t,s){return ts3dutils.assertNumbers(t,s),this.f1.times(s).plus(this.f2.times(t))}ddt(t){return ts3dutils.assertNumbers(t),this.f1.times(Math.cosh(t)).plus(this.f2.times(Math.sinh(t)))}isColinearTo(t){if(!ts3dutils.hasConstructor(t,HyperbolaCurve))return!1;if(!t.center||!this.center.like(t.center))return!1;if(this===t)return!0;const{f1:s,f2:e}=this.rightAngled(),{f1:i,f2:r}=t.rightAngled();return ts3dutils.eq(s.squared(),Math.abs(s.dot(i)))&&ts3dutils.eq(e.squared(),Math.abs(e.dot(r)))}reversed(){return new HyperbolaCurve(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s),i=s.squared()+t.squared();if(ts3dutils.eq0(e))return this;const r=2*e,n=i+Math.sqrt(i*i-4*e*e),{x1:a,y1:o}=intersectionUnitHyperbolaLine(r,n,0);return new HyperbolaCurve(this.center,t.times(a).plus(s.times(o)),t.times(o).plus(s.times(a)))}eccentricity(){const t=this.rightAngled(),s=t.f1.length(),e=t.f1.length(),[i,r]=s>e?[s,e]:[e,s];return Math.sqrt(1+r*r/i/i)}roots(){return ts3dutils.arrayFromFunction(3,t=>{const s=this.f2.e(t),e=this.f1.e(t);return HyperbolaCurve.magic(s,e,0)})}}HyperbolaCurve.XY=new HyperbolaCurve(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),HyperbolaCurve.prototype.tIncrement=PI$3/16;class L3$1 extends Curve{constructor(t,s,e=-4096,i=4096){super(e,i),this.anchor=t,this.dir1=s,ts3dutils.assertVectors(t,s),ts3dutils.assert(s.hasLength(1),"dir must be unit"+s),ts3dutils.assertf(()=>!Number.isNaN(t.x))}static throughPoints(t,s,e,i){return new L3$1(t,s.minus(t).unit(),e,i)}static pointT(t,s,e){return ts3dutils.assertVectors(t,s,e),e.minus(t).dot(s)/s.squared()}static at(t,s,e){return t.plus(s.times(e))}static fromPlanes(t,s){if(ts3dutils.assertInst(P3,t,s),t.normal1.cross(s.normal1).length()<1e-10)throw new Error("Parallel planes");return t.intersectionWithPlane(s)}static containsPoint(t,s,e){const i=L3$1.pointT(t,s,e),r=L3$1.at(t,s,i).distanceTo(e);return ts3dutils.eq0(r)}addToMesh(t,s=4,e=0,i=1,r=this.tMin,n=this.tMax){const a=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/s)),o=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(e,ts3dutils.TAU*t/s)),l=this.tIncrement;Math.ceil((this.tMin+ts3dutils.NLA_PRECISION)/l),Math.floor((this.tMax-ts3dutils.NLA_PRECISION)/l);for(let e=0;e<=1;e+=1){const i=t.vertices.length;if(0!==e)for(let e=0;e<s;e++)tsgl.pushQuad(t.TRIANGLES,!0,i-s+e,i+e,i-s+(e+1)%s,i+(e+1)%s);const l=0==e?r:n,u=this.at(l),c=(this.dir1,this.dir1.getPerpendicular()),h=ts3dutils.M4.forSys(c,this.dir1.cross(c),this.dir1,u);t.normals.push(...h.transformedVectors(a)),t.vertices.push(...h.transformedPoints(o))}}roots(){return[[],[],[]]}containsPoint(t){ts3dutils.assertVectors(t);const s=this.distanceToPoint(t);return ts3dutils.assertNumbers(s),ts3dutils.eq0(s)}likeCurve(t){return this==t||ts3dutils.hasConstructor(t,L3$1)&&this.anchor.like(t.anchor)&&this.dir1.like(t.dir1)}equals(t){return this==t||Object.getPrototypeOf(t)==L3$1.prototype&&this.anchor.equals(t.anchor)&&this.dir1.equals(t.dir1)}isColinearTo(t){return t instanceof L3$1&&this.containsPoint(t.anchor)&&ts3dutils.eq(1,Math.abs(this.dir1.dot(t.dir1)))}distanceToLine(t){if(ts3dutils.assertInst(L3$1,t),this.isParallelToLine(t))return this.distanceToPoint(t.anchor);const s=this.dir1.cross(t.dir1).unit(),e=this.anchor.minus(t.anchor);return Math.abs(e.dot(s))}distanceToPoint(t){ts3dutils.assertVectors(t);const s=t.minus(this.anchor).dot(this.dir1);return this.at(s).distanceTo(t)}asSegmentDistanceToPoint(t,s,e){let i=t.minus(this.anchor).dot(this.dir1);return i=ts3dutils.clamp(i,s,e),this.at(i).minus(t).length()}asSegmentDistanceToLine(t,s,e){ts3dutils.assertInst(L3$1,t);const i=this.dir1.cross(t.dir1),r=i.squared();if(ts3dutils.eq0(r))return;const n=t.anchor.minus(this.anchor);if(!ts3dutils.eq0(n.dot(i.unit())))return;let a=this.infoClosestToLine(t).t;return a=ts3dutils.clamp(a,s,e),this.at(ts3dutils.clamp(a,s,e))}at(t){return ts3dutils.assertNumbers(t),this.anchor.plus(this.dir1.times(t))}pointT(t){return ts3dutils.assertVectors(t),t.minus(this.anchor).dot(this.dir1)}isParallelToLine(t){return ts3dutils.assertInst(L3$1,t),ts3dutils.eq(1,Math.abs(this.dir1.dot(t.dir1)))}angleToLine(t){return ts3dutils.assertInst(L3$1,t),this.dir1.angleTo(t.dir1)}intersectsLine(t){return ts3dutils.eq0(this.distanceToLine(t))}isInfosWithCurve(t){if(t instanceof L3$1){const s=this.dir1.cross(t.dir1),e=s.squared();if(ts3dutils.eq0(e))return[];const i=t.anchor.minus(this.anchor);if(ts3dutils.eq0(i.dot(s))){const r=i.cross(t.dir1).dot(s)/e;return[{tThis:r,tOther:i.cross(this.dir1).dot(s)/e,p:this.at(r)}]}return[]}throw new Error}isInfoWithLine(t){ts3dutils.assertInst(L3$1,t);const s=this.dir1.cross(t.dir1),e=s.squared();if(ts3dutils.eq0(e))return;const i=t.anchor.minus(this.anchor);if(!ts3dutils.eq0(i.dot(s.unit())))return;const r=i.cross(t.dir1).dot(s)/e;return this.at(r)}intersectionLineST(t){ts3dutils.assertInst(L3$1,t);const s=this.dir1.cross(t.dir1),e=s.squared(),i=t.anchor.minus(this.anchor);return{s:i.cross(this.dir1).dot(s)/e,t:i.cross(t.dir1).dot(s)/e}}ddt(t){return ts3dutils.V3.O}getConstructorParameters(){return[this.anchor,this.dir1]}closestTToPoint(t){return t.minus(this.anchor).dot(this.dir1)}infoClosestToLine(t){if(this.isParallelToLine(t))return{t:NaN,s:NaN,distance:this.distanceToLine(t)};const s=t.anchor,e=t.dir1,i=this.anchor,r=this.dir1,n=e.dot(r),a=e.squared(),o=r.squared(),l=s.minus(i),u=n*n-o*a,c=(l.dot(e)*n-l.dot(r)*a)/u,h=(l.dot(e)*o-l.dot(r)*n)/u;return{t:c,s:h,closest:this.at(c),closest2:t.at(h),distance:this.at(c).distanceTo(t.at(h))}}intersectionWithPlane(t){const s=(t.w-t.normal1.dot(this.anchor))/t.normal1.dot(this.dir1);return this.anchor.plus(this.dir1.times(s))}tangentAt(t){return this.dir1}isTWithPlane(t){const s=t.normal1.dot(this.dir1);return ts3dutils.eq0(s)?NaN:(t.w-t.normal1.dot(this.anchor))/s}reversed(){return new L3$1(this.anchor,this.dir1.negated(),-this.tMax,-this.tMin)}isTsWithPlane(t){return[this.isTWithPlane(t)]}flipped(){return new L3$1(this.anchor,this.dir1.negated())}transform(t){const s=t.transformPoint(this.anchor),e=t.transformVector(this.dir1);return new L3$1(s,e.unit(),this.tMin*e.length(),this.tMax*e.length())}hashCode(){return 31*this.anchor.hashCode()+this.dir1.hashCode()}}L3$1.anchorDirection=((t,s)=>new L3$1(t,s.unit())),L3$1.X=new L3$1(ts3dutils.V3.O,ts3dutils.V3.X),L3$1.Y=new L3$1(ts3dutils.V3.O,ts3dutils.V3.Y),L3$1.Z=new L3$1(ts3dutils.V3.O,ts3dutils.V3.Z),L3$1.prototype.hlol=Curve.hlol++;const{floor:floor$4,abs:abs$5,ceil:ceil$4,min:min$2,max:max$2}=Math;class PICurve$1 extends ImplicitCurve{constructor(t,s,e,i,r,n,a,o=1,l,u,c){super(t,s,o,l,u,c),this.parametricSurface=e,this.implicitSurface=i,this.pmPoints=r,this.pmTangents=n,this.stepSize=a,ts3dutils.assert(Array.isArray(r)),ts3dutils.assert(1==o),ts3dutils.assert(a<=1);const h=e.pSTFunc(),d=e.dpds(),f=e.dpdt(),p=i.didp.bind(i);this.dids=((t,s)=>p(h(t,s)).dot(d(t,s))),this.didt=((t,s)=>p(h(t,s)).dot(f(t,s)));for(let s=0;s<t.length-1;s++)ts3dutils.assert(!t[s].equals(t[s+1]))}static forParametricStartEnd(t,s,e,i,r=.02,n,a,o){const l=t.pSTFunc(),u=s.implicitFunction(),c=t.dpds(),h=t.dpdt(),d=s.didp.bind(s),f=exports.MathFunctionR2R.forFFxFy((t,s)=>u(l(t,s)),(t,s)=>d(l(t,s)).dot(c(t,s)),(t,s)=>d(l(t,s)).dot(h(t,s))),{points:p,tangents:m}=followAlgorithm2d(f,e,r,t.bounds.bind(t),i,n);return PICurve$1.forParametricPointsTangents(t,s,p,m,r,1,a,o)}static forStartEnd(t,s,e,i,r=.02,n,a,o){const l=t.stP(e),u=t.dpds()(l.x,l.y),c=t.dpdt()(l.x,l.y),h=n&&ts3dutils.M4.forSys(u,c).inversed().transformVector(n),d=PICurve$1.forParametricStartEnd(t,s,l,t.stP(i),r,h);return d.withBounds(a&&d.pointT(a),o&&d.pointT(o))}static forParametricPointsTangents(t,s,e,i,r,n=1,a,o){const l=t.pSTFunc(),u=(s.implicitFunction(),t.dpds()),c=t.dpdt(),h=e.map(({x:t,y:s})=>l(t,s)),d=e.map(({x:t,y:s},e)=>{const r=u(t,s),n=c(t,s);return r.times(i[e].x).plus(n.times(i[e].y))});return new PICurve$1(h,d,t,s,e,i,r,n,void 0,a,o)}getConstructorParameters(){return[this.points,this.tangents,this.parametricSurface,this.implicitSurface,this.pmPoints,this.pmTangents,this.stepSize,this.dir,this.generator,this.tMin,this.tMax]}reversed(){return ts3dutils.assertNever(),new PICurve$1(this.parametricSurface,this.implicitSurface,this.endPoint,this.startPoint,-this.dir)}implicitCurve(){const t=this.parametricSurface.pSTFunc(),s=this.implicitSurface.implicitFunction();return function(e,i){return s(t(e,i))}}isColinearTo(t){return t instanceof PICurve$1&&(!!this.equals(t)||(this.parametricSurface.isCoplanarTo(t.parametricSurface)&&this.implicitSurface.isCoplanarTo(t.implicitSurface),!1))}containsPoint(t){ts3dutils.assertVectors(t);const s=this.pointT(t);return!isNaN(s)&&this.isValidT(s)}equals(t){return Object.getPrototypeOf(t)==PICurve$1.prototype&&this.parametricSurface.equals(t.parametricSurface)&&this.implicitSurface.equals(t.implicitSurface)&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])&&this.dir===t.dir}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.parametricSurface.hashCode())+this.implicitSurface.hashCode())+this.points[0].hashCode())+this.tangents[0].hashCode())}tangentP(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t),"this.containsPoint(point)"+this.containsPoint(t));const s=this.pointT(t);return this.tangentAt(s)}tangentAt(t){return ts3dutils.V3.lerp(this.tangents[floor$4(t)],this.tangents[ceil$4(t)],t%1)}at(t){if(ts3dutils.assert(!isNaN(t)),t%1==0)return this.points[t];const s=ts3dutils.V3.lerp(this.pmPoints[floor$4(t)],this.pmPoints[ceil$4(t)],t%1);return this.closestPointToParams(s)}stT(t){if(ts3dutils.assert(!isNaN(t)),t%1==0)return this.points[t];const s=ts3dutils.V3.lerp(this.pmPoints[floor$4(t)],this.pmPoints[ceil$4(t)],t%1);return curvePoint(this.implicitCurve(),s,this.dids,this.didt)}closestTToPoint(t,s){return 0}closestPointToParams(t){const s=curvePoint(this.implicitCurve(),t,this.dids,this.didt);return this.parametricSurface.pSTFunc()(s.x,s.y)}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof EllipsoidSurface||t instanceof SemiEllipsoidSurface){const s=this.parametricSurface,e=this.implicitSurface;if(s instanceof ProjectedCurveSurface&&e instanceof SemiEllipsoidSurface){const i=e.isCurvesWithSurface(t).flatMap(t=>t.isTsWithSurface(s).map(s=>t.at(s)));return ts3dutils.fuzzyUniques(i.map(t=>this.pointT(t))).filter(t=>!isNaN(t)&&this.isValidT(t))}}throw new Error}isTsWithPlane(t){ts3dutils.assertInst(P3,t);const s=this.parametricSurface,e=this.implicitSurface,i=s.isCurvesWithPlane(t),r=e.isCurvesWithPlane(t).flatMap(t=>i.flatMap(s=>t.isInfosWithCurve(s)));return ts3dutils.fuzzyUniques(r.map(t=>this.pointT(t.p))).filter(t=>!isNaN(t)&&this.isValidT(t))}pointT(t){if(ts3dutils.assertVectors(t),!this.parametricSurface.containsPoint(t)||!this.implicitSurface.containsPoint(t))return NaN;const s=this.parametricSurface.stPFunc()(t),e=this.points,i=this.pmPoints;let r=0,n=s.distanceTo(i[0]);for(;n>abs$5(this.stepSize)&&r<e.length-1;)r=min$2(i.length-1,r+max$2(1,Math.round(n/abs$5(this.stepSize)/2/2))),n=s.distanceTo(i[r]);if(n>1.1*abs$5(this.stepSize))return NaN;if(r==e.length-1&&r--,e[r].like(t))return r;if(e[r+1].like(t))return r+1;const a=r+ts3dutils.V3.inverseLerp(e[r],e[r+1],t);return a?ts3dutils.newtonIterate1d(s=>this.at(s).distanceTo(t),a,2):void 0}transform(t){const s=t.isMirroring()?-1:1;return PICurve$1.forStartEnd(this.parametricSurface.transform(t),this.implicitSurface.transform(t),t.transformPoint(this.points[0]),t.transformPoint(this.points.last),this.stepSize*s,t.transformVector(this.tangents[0]),t.transformPoint(this.at(this.tMin)),t.transformPoint(this.at(this.tMax)))}roots(){const t=ts3dutils.arrayRange(0,this.points.length);return[t,t,t]}toSource(t=(t=>t)){return ts3dutils.callsce("PICurve.forParametricStartEnd",this.parametricSurface,this.implicitSurface,this.pmPoints[0],this.pmPoints.last,this.stepSize,this.pmTangents[0],this.tMin,this.tMax)}}PICurve$1.prototype.tIncrement=1;class ParabolaCurve extends XiEtaCurve{constructor(t,s,e,i=-10,r=10){super(t,s,e,i,r)}static eccentricity(){return 1}static unitIsInfosWithLine(t,s,e,i){const r=Math.pow(s.x,2);return ts3dutils.pqFormula((t.x*s.x+s.y)/r,(Math.pow(t.x,2)+t.y)/r).filter(e=>ts3dutils.le(0,t.y+e*s.y)).map(r=>({tThis:s.x*r+t.x,tOther:r,p:L3$1.at(e,i,r)}))}static magic(t,s,e){return ts3dutils.pqFormula(t/s,-e/s)}static XYLCValid(t){return ts3dutils.eq(Math.pow(t.x,2),t.y)}static XYLCPointT(t){return t.x}static quadratic(t,s,e){const i=t.plus(e).minus(s.times(2)),r=s.minus(t).times(2);return new ParabolaCurve(t,r,i,0,1)}at(t){return this.center.plus(this.f1.times(t)).plus(this.f2.times(t*t))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f1.plus(this.f2.times(2*t))}ddt(t){return ts3dutils.assertNumbers(t),this.f2.times(2)}tangentAt2(t,s){return ts3dutils.assertNumbers(t,s),this.f1.plus(this.f2.times(2*s))}reversed(){return new this.constructor(this.center,this.f1.negated(),this.f2,-this.tMax,-this.tMin)}roots(){return ts3dutils.arrayFromFunction(3,t=>ts3dutils.eq0(this.f2.e(t))?[]:[-this.f1.e(t)/2/this.f2.e(t)])}isColinearTo(t){if(!ts3dutils.hasConstructor(t,ParabolaCurve))return!1;const s=this.rightAngled(),e=t.rightAngled();return s.center.like(e.center)&&s.f2.like(e.f2)&&s.f1.likeOrReversed(e.f1)}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s);if(ts3dutils.eq0(e)&&t.hasLength(1))return this;const i=-e/s.squared()/2,r=this.at(i),n=this.tangentAt(i),a=n.length(),o=n.unit(),l=t=>this.at(t).minus(r).dot(o);return new ParabolaCurve(r,o,s.div(Math.pow(a,2)),l(this.tMin),l(this.tMax))}arcLength(t,s){let e=this.f1;const i=this.f2,r=e.dot(i);let n=0;ts3dutils.eq0(r)||(n=-r/i.squared()/2,e=e.plus(i.times(2*n)));const a=e.length(),o=i.length()/a;function l(t){return Math.asinh(2*o*t)/4/o+t*Math.sqrt(1+o*o*4*t*t)/2}return a*(l(s-n)-l(t-n))}asBezier(){return BezierCurve.quadratic(this.at(-1),new L3$1(this.at(-1),this.tangentAt(-1).unit()).isInfoWithLine(new L3$1(this.at(1),this.tangentAt(1).unit())),this.at(1))}}ParabolaCurve.XY=new ParabolaCurve(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),ParabolaCurve.YZ=new ParabolaCurve(ts3dutils.V3.O,ts3dutils.V3.Y,ts3dutils.V3.Z),ParabolaCurve.ZX=new ParabolaCurve(ts3dutils.V3.O,ts3dutils.V3.Z,ts3dutils.V3.X),ParabolaCurve.prototype.tIncrement=1/32;const{PI:PI$4,min:min$3,max:max$3}=Math;class SemiEllipseCurve extends XiEtaCurve{constructor(t,s,e,i=0,r=PI$4){super(t,s,e,i,r),ts3dutils.assert(0<=this.tMin&&this.tMin<PI$4),ts3dutils.assert(0<this.tMax&&this.tMax<=PI$4)}static XYLCValid(t){const{x:s,y:e}=t;return ts3dutils.le(0,e)&&ts3dutils.eq0(Math.pow(s,2)+Math.pow(e,2)-1)}static XYLCPointT(t){const s=Math.atan2(t.y,t.x);return s<-PI$4/2?s+ts3dutils.TAU:s}static magic(t,s,e){const i=intersectionUnitCircleLine2(t,s,e),r=[];for(const[t,s]of i)ts3dutils.le(0,s)&&r.push(SemiEllipseCurve.XYLCPointT(new ts3dutils.V3(t,s,0)));return r}static unitIsInfosWithLine(t,s,e,i){const r=s.squared();return ts3dutils.pqFormula(2*s.dot(t)/r,(t.squared()-1)/r).filter(e=>ts3dutils.le(0,t.y+e*s.y)).map(r=>({tThis:SemiEllipseCurve.XYLCPointT(s.times(r).plus(t)),tOther:r,p:L3$1.at(e,i,r)}))}static semicircle(t,s=ts3dutils.V3.O){return new SemiEllipseCurve(s,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0))}static fromEllipse(t,s,e){return[s<0&&new SemiEllipseCurve(t.center,t.f1.negated(),t.f2.negated(),s+PI$4,min$3(0,e)+PI$4),e>0&&new SemiEllipseCurve(t.center,t.f1,t.f2,max$3(0,s),e)].filter(t=>t)}getAreaInDir(t,s,e,i){return EllipseCurve.prototype.getAreaInDir.call(this,t,s,e,i)}at(t){return ts3dutils.assertNumbers(t),this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return ts3dutils.assertNumbers(t),ts3dutils.assert(this.isValidT(t)),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}isCircular(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}isColinearTo(t){if(!(t=>t.constructor==this.constructor)(t))return!1;if(!ts3dutils.hasConstructor(t,SemiEllipseCurve))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&ts3dutils.eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:s,f2:e}=this.rightAngled(),{f1:i,f2:r}=t.rightAngled();return s.length()>e.length()&&([s,e]=[e,s]),i.length()>r.length()&&([i,r]=[r,i]),ts3dutils.eq(s.squared(),Math.abs(s.dot(i)))&&ts3dutils.eq(e.squared(),Math.abs(e.dot(r)))}}isValidT(t){return ts3dutils.le(0,t)&&ts3dutils.le(t,PI$4)}pointT(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t));const s=this.inverseMatrix.transformPoint(t),e=SemiEllipseCurve.XYLCPointT(s);return ts3dutils.assert(this.isValidT(e)),e}reversed(){return new SemiEllipseCurve(this.center,this.f1.negated(),this.f2,PI$4-this.tMax,PI$4-this.tMin)}eccentricity(){const t=this.rightAngled(),s=t.f1.length(),e=t.f1.length(),[i,r]=s>e?[s,e]:[e,s];return Math.sqrt(1-r*r/i/i)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t,s,e=2){ts3dutils.assert(t<s,"startT < endT");const i=this.f1.length();return ts3dutils.eq(i,this.f2.length())?i*(s-t):super.arcLength(t,s,e)}circumferenceApproximate(){const{f1:t,f2:s}=this.rightAngled(),e=t.length(),i=s.length(),r=(e-i)*(e-i)/(e+i)/(e+i);return Math.PI*(e+i)*(1+3*r/(10+Math.sqrt(4-3*r)))}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s),i=s.squared()-t.squared();if(ts3dutils.eq0(e))return this;const r=2*e,n=i+Math.sqrt(i*i+4*e*e),{x1:a,y1:o}=intersectionUnitCircleLine(r,n,0),l=t.times(a).plus(s.times(o)),u=t.times(-o).plus(s.times(a));return new SemiEllipseCurve(this.center,l,u)}asEllipse(){return new EllipseCurve(this.center,this.f1,this.f2,this.tMin,this.tMax)}isInfosWithEllipse(t){return this.normal.isParallelTo(t.normal)&&ts3dutils.eq0(this.center.minus(t.center).dot(t.normal))?(t instanceof SemiEllipseCurve&&(t=t.asEllipse()),this.asEllipse().isInfosWithCurve(t).filter(s=>this.isValidT(s.tThis)&&t.isValidT(s.tOther))):this.isTsWithPlane(P3.normalOnAnchor(t.normal.unit(),t.center)).mapFilter(s=>{const e=this.at(s);if(t.containsPoint(e))return{tThis:s,tOther:t.pointT(e),p:e}})}isInfosWithCurve(t){return t instanceof SemiEllipseCurve||t instanceof EllipseCurve?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}roots(){return ts3dutils.arrayFromFunction(3,t=>{const s=this.f2.e(t),e=-this.f1.e(t),{x1:i,y1:r,x2:n,y2:a}=intersectionUnitCircleLine(s,e,0);return[Math.atan2(r,i),Math.atan2(a,n)]})}closestTToPoint(t){const s=this.inverseMatrix.transformPoint(t).angleXY(),e=t.minus(this.center);return ts3dutils.newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(e)),s)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const s=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.inverseMatrix.transformVector(s).angleXY()}}SemiEllipseCurve.UNIT=new SemiEllipseCurve(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),SemiEllipseCurve.prototype.hlol=Curve.hlol++,SemiEllipseCurve.prototype.tIncrement=2*Math.PI/128;class P3 extends ts3dutils.Transformable{constructor(t,s=0){super(),this.normal1=t,this.w=s,ts3dutils.assertVectors(t),ts3dutils.assertNumbers(s),ts3dutils.assert(t.hasLength(1),"normal1.hasLength(1)"+t)}get anchor(){return this.normal1.times(this.w)}static throughPoints(t,s,e){ts3dutils.assertVectors(t,s,e);const i=s.minus(t).cross(e.minus(t)).unit();return new P3(i,i.dot(t))}static normalOnAnchor(t,s){ts3dutils.assertVectors(t,s);const e=t.unit();return new P3(e,e.dot(s))}static forAxisIntercepts(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=new ts3dutils.V3(1/t,1/s,1/e);return new P3(i.unit(),i.length())}static forAnchorAndPlaneVectors(t,s,e){return ts3dutils.assertVectors(t,s,e),P3.normalOnAnchor(s.cross(e),t)}axisIntercepts(){const t=this.w,s=this.normal1;return new ts3dutils.V3(t/s.x,t/s.y,t/s.z)}isCoplanarToPlane(t){return ts3dutils.assertInst(P3,t),this.like(t)||this.likeFlipped(t)}like(t){return ts3dutils.assertInst(P3,t),ts3dutils.eq(this.w,t.w)&&this.normal1.like(t.normal1)}likeFlipped(t){return ts3dutils.assertInst(P3,t),ts3dutils.eq(this.w,-t.w)&&this.normal1.like(t.normal1.negated())}isParallelToPlane(t){return ts3dutils.assertInst(P3,t),ts3dutils.eq(1,Math.abs(this.normal1.dot(t.normal1)))}isParallelToLine(t){return ts3dutils.assertInst(L3$1,t),ts3dutils.eq0(this.normal1.dot(t.dir1))}isPerpendicularToLine(t){return ts3dutils.assertInst(L3$1,t),ts3dutils.eq(1,Math.abs(this.normal1.dot(t.dir1)))}isPerpendicularToPlane(t){return ts3dutils.assertInst(P3,t),ts3dutils.eq0(this.normal1.dot(t.normal1))}toSource(t){return ts3dutils.callsce("new P3",this.normal1,this.w)}translated(t){return new P3(this.normal1,this.w+t.dot(this.normal1))}transform(t){const s=t.isMirroring(),e=this.normal1.getPerpendicular(),i=e.cross(this.normal1),r=t.transformPoint(this.anchor),n=t.transformPoint(this.anchor.plus(i)),a=t.transformPoint(this.anchor.plus(e));return P3.throughPoints(r,s?a:n,s?n:a)}distanceToLine(t){return ts3dutils.assertInst(L3$1,t),this.isParallelToLine(t)?0:this.distanceToPoint(t.anchor)}containsPoint(t){return ts3dutils.assertVectors(t),ts3dutils.eq(this.w,this.normal1.dot(t))}containsLine(t){return ts3dutils.assertInst(L3$1,t),this.containsPoint(t.anchor)&&this.isParallelToLine(t)}distanceToPointSigned(t){return ts3dutils.assertInst(ts3dutils.V3,t),this.normal1.dot(t)-this.w}distanceToPoint(t){return ts3dutils.assertInst(ts3dutils.V3,t),Math.abs(this.normal1.dot(t)-this.w)}intersectionWithLine(t){return t.intersectionWithPlane(this)}intersectionWithPlane(t){ts3dutils.assertInst(P3,t),ts3dutils.assert(!this.isParallelToPlane(t),"!this.isParallelToPlane(plane)");const s=this.normal1,e=t.normal1,i=s.cross(e).unit(),r=ts3dutils.M4.forRows(s,e,i).inversed().transformVector(new ts3dutils.V3(this.w,t.w,0));return new L3$1(r,i)}projectedPoint(t){return t.minus(this.normal1.times(t.minus(this.anchor).dot(this.normal1)))}projectedVector(t){return t.minus(this.normal1.times(t.dot(this.normal1)))}flipped(){return new P3(this.normal1.negated(),-this.w)}containsCurve(t){if(t instanceof L3$1)return this.containsLine(t);if(t instanceof SemiEllipseCurve||t instanceof EllipseCurve||t instanceof HyperbolaCurve||t instanceof ParabolaCurve)return this.containsPoint(t.center)&&this.normal1.isParallelTo(t.normal);if(t instanceof BezierCurve)return t.points.every(t=>this.containsPoint(t));throw new Error(""+t)}hashCode(){return 31*this.normal1.hashCode()|0+ts3dutils.floatHashCode(this.w)}}P3.YZ=new P3(ts3dutils.V3.X,0),P3.ZX=new P3(ts3dutils.V3.Y,0),P3.XY=new P3(ts3dutils.V3.Z,0);const{ceil:ceil$5,floor:floor$5}=Math;class Surface extends ts3dutils.Transformable{static loopContainsPointGeneral(t,s,e,i){const r=P3.normalOnAnchor(i,s),n=t.map(t=>t.colinearToLine(e));let a=!1;function o(t){const s=e.pointT(t);if(ts3dutils.eq0(s))return!0;s>0&&(a=!a)}for(let a=0;a<t.length;a++){const l=t[a],u=(a+1)%t.length,c=t[u];if(n[a]){const t=e.pointT(l.a),s=e.pointT(l.b);if(Math.min(t,s)<=ts3dutils.NLA_PRECISION&&-ts3dutils.NLA_PRECISION<=Math.max(t,s))return exports.PointVsFace.ON_EDGE;if(!(n[u]||dotCurve(i,c.aDir,c.aDDT)<0)&&o(l.b))return exports.PointVsFace.ON_EDGE}else for(const t of l.edgeISTsWithPlane(r))if(t==l.bT){if(!e.containsPoint(l.b))continue;if(l.b.like(s))return exports.PointVsFace.ON_EDGE;if(dotCurve(i,l.bDir,l.bDDT)>0!=(n[u]||dotCurve(i,c.aDir,c.aDDT)<0)&&o(l.b))return exports.PointVsFace.ON_EDGE}else if(t!=l.aT){const s=l.curve.at(t);if(!e.containsPoint(s))continue;if(o(s))return exports.PointVsFace.ON_EDGE}}return a?exports.PointVsFace.INSIDE:exports.PointVsFace.OUTSIDE}toString(){return this.toSource()}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}isCurvesWithSurface(t){return t.isCurvesWithSurface(this).map(t=>t.reversed())}containsCurve(t){if(t instanceof ImplicitCurve){for(let s=ceil$5(t.tMin);s<=floor$5(t.tMax);s++)if(!this.containsPoint(t.points[s]))return!1;return!0}return!1}flipped2(t){return t?this.flipped():this}clipCurves(t){return t}hashCode(){return this.getConstructorParameters().hashCode()}zDirVolume(t){return this.visit(ZDirVolumeVisitor,t)}calculateArea(t){return this.visit(CalculateAreaVisitor,t)}}!function(t){t[t.INSIDE=0]="INSIDE",t[t.OUTSIDE=1]="OUTSIDE",t[t.ON_EDGE=2]="ON_EDGE"}(exports.PointVsFace||(exports.PointVsFace={}));const{ceil:ceil$6,min:min$4}=Math;class ParametricSurface extends Surface{static isCurvesParametricImplicitSurface(t,s,e,i=e,r){const n=t.pSTFunc(),a=s.implicitFunction(),o=t.dpds(),l=t.dpdt(),u=s.didp.bind(s),c=(t,s)=>u(n(t,s)).dot(o(t,s)),h=(t,s)=>u(n(t,s)).dot(l(t,s)),d=exports.MathFunctionR2R.forFFxFy((t,s)=>a(n(t,s)),c,h);return Curve.breakDownIC(d,t,e,i,r,c,h).map(({points:e,tangents:i},n)=>PICurve$1.forParametricPointsTangents(t,s,e,i,r))}static is(t){return t.pSTFunc}pST(t,s){return this.pSTFunc()(t,s)}pSTFunc(){return this.pST.bind(this)}stP(t){return this.stPFunc()(t)}stPFunc(){return this.stP.bind(this)}bounds(t,s){return this.sMin<=t&&t<=this.sMax&&this.tMin<=s&&s<=this.tMax}boundsSigned(t,s){return min$4(t-this.sMin,this.sMax-t,s-this.tMin,this.tMax-s)}normalP(t){const s=this.stPFunc()(t);return this.normalST(s.x,s.y)}normalSTFunc(){return this.normalST.bind(this)}normalST(t,s){return this.normalSTFunc()(t,s)}parametersValid(t,s){return ts3dutils.between(t,this.sMin,this.sMax)&&ts3dutils.between(s,this.tMin,this.tMax)}pointFoot(t,s,e){throw new Error}toMesh(){return ts3dutils.assert(isFinite(this.tMin)&&isFinite(this.tMax)&&isFinite(this.sMin)&&isFinite(this.sMax)),tsgl.Mesh.parametric(this.pSTFunc(),this.normalSTFunc(),this.sMin,this.sMax,this.tMin,this.tMax,ceil$6((this.sMax-this.sMin)/this.uStep),ceil$6((this.tMax-this.tMin)/this.vStep))}isCurvesWithImplicitSurface(t,s,e,i){return ParametricSurface.isCurvesParametricImplicitSurface(this,t,s,e,i)}}class ImplicitSurface extends Surface{static is(t){return t.implicitFunction}}const{PI:PI$5,cos:cos$3,sin:sin$3,min:min$5,max:max$4,tan:tan$2,ceil:ceil$7,floor:floor$6,abs:abs$6,sqrt:sqrt$2,pow:pow$2,atan2:atan2$2,round:round$2,sign:sign$2}=Math;class ConicSurface extends ParametricSurface{constructor(t,s,e,i){super(),this.center=t,this.f1=s,this.f2=e,this.dir=i,ts3dutils.assertVectors(t,s,e,i),this.matrix=ts3dutils.M4.forSys(s,e,i,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$2(this.f1.cross(this.f2).dot(this.dir)),this.normalMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}get apex(){return this.center}static atApexThroughEllipse(t,s){return ts3dutils.assertVectors(t),ts3dutils.assertInst(SemiEllipseCurve,s),new ConicSurface(t,s.f1,s.f2,t.to(s.center))}static unitISLineTs(t,s){const{x:e,y:i,z:r}=t,{x:n,y:a,z:o}=s,l=n*n+a*a-o*o,u=2*(e*n+i*a-r*o),c=e*e+i*i-r*r;return ts3dutils.pqFormula(u/l,c/l).filter(t=>0<r+t*o)}static unitISPlane(t,s,e){if(ts3dutils.eq0(s)){if(ts3dutils.assert(!ts3dutils.eq0(t)),ts3dutils.eq0(e))return[new L3$1(ts3dutils.V3.O,new ts3dutils.V3(0,-sqrt$2(2)/2,-sqrt$2(2)/2),void 0,0),new L3$1(ts3dutils.V3.O,new ts3dutils.V3(0,-sqrt$2(2)/2,sqrt$2(2)/2),0)];{const s=new ts3dutils.V3(e/t,0,0),i=new ts3dutils.V3(0,0,abs$6(e/t)),r=new ts3dutils.V3(0,e/t,0);return[new HyperbolaCurve(s,i,r)]}}{const i=t*t,r=s*s;if(ts3dutils.eq0(e)){if(ts3dutils.eq(i,r))return[new L3$1(ts3dutils.V3.O,new ts3dutils.V3(s,0,-t).unit())];if(i<r)ts3dutils.assert(!1,"intersection is single point V3.O");else if(i>r)return[new L3$1(ts3dutils.V3.O,new ts3dutils.V3(s,sqrt$2(i-r),-t).unit()),new L3$1(ts3dutils.V3.O,new ts3dutils.V3(s,-sqrt$2(i-r),-t).unit())]}else{if(ts3dutils.eq(i,r)){const i=new ts3dutils.V3(e/2/t,0,e/2/s),r=new ts3dutils.V3(e/2/t,e/s,e/2/s),n=new ts3dutils.V3(0,0,e/s).minus(i);return[new ParabolaCurve(i,r.minus(i),n.z<0?n.negated():n)]}if(i<r){const n=new ts3dutils.V3(-t*e/(r-i),0,e*s/(r-i));if(n.z<0)return[];const a=new ts3dutils.V3(e/(t-s),0,-e/(t-s)),o=new ts3dutils.V3(-t*e/(r-i),e/sqrt$2(r-i),e*s/(r-i));return[new EllipseCurve(n,n.to(a),n.to(o))]}if(i>r){const n=new ts3dutils.V3(-t*e/(r-i),0,e*s/(r-i)),a=new ts3dutils.V3(e/(t-s),0,-e/(t-s)),o=new ts3dutils.V3(-t*e/(r-i),e/sqrt$2(i-r),e*s/(r-i)),l=n.to(a);return[new HyperbolaCurve(n,l.z>0?l:l.negated(),n.to(o))]}}}}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)&&this.dir.equals(t.dir)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}getVectors(){return[{anchor:this.center,dir1:this.dir},{anchor:this.center.plus(this.dir),dir1:this.f1},{anchor:this.center.plus(this.dir),dir1:this.f2}]}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.center,this.f1,this.dir)}loopContainsPoint(t,s){ts3dutils.assertVectors(s);const e=this.center.like(s)?new L3$1(s,this.matrix.transformVector(new ts3dutils.V3(0,1,1)).unit()):L3$1.throughPoints(s,this.apex),i=e.dir1.cross(this.dir);return Surface.loopContainsPointGeneral(t,s,e,i)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.dir]}isTsForLine(t){const s=this.inverseMatrix.transformPoint(t.anchor),e=this.inverseMatrix.transformVector(t.dir1);return ConicSurface.unitISLineTs(s,e)}isCoplanarTo(t){return this===t||!!(t instanceof ConicSurface&&this.apex.like(t.apex))&&this.containsEllipse(new SemiEllipseCurve(t.center.plus(t.dir),t.f1,t.f2))}containsEllipse(t){const s=t.transform(this.inverseMatrix);if(s.center.z<0)return!1;const{f1:e,f2:i}=s.rightAngled(),r=s.center.plus(e),n=s.center.plus(i);return ts3dutils.eq(Math.pow(r.x,2)+Math.pow(r.y,2),Math.pow(r.z,2))&&ts3dutils.eq(Math.pow(n.x,2)+Math.pow(n.y,2),Math.pow(n.z,2))&&(ts3dutils.eq0(e.z)||ts3dutils.eq0(i.z))}containsLine(t){const s=t.transform(this.inverseMatrix),e=s.dir1;return s.containsPoint(ts3dutils.V3.O)&&ts3dutils.eq(e.x*e.x+e.y*e.y,e.z*e.z)}containsParabola(t){ts3dutils.assertInst(ParabolaCurve,t);const s=t.transform(this.inverseMatrix);if(s.center.z<0||s.f2.z<0)return!1;const{center:e,f1:i,f2:r}=s.rightAngled();return ts3dutils.eq(e.x*e.x+e.y*e.y,e.z*e.z)&&ts3dutils.eq0(i.z)&&ts3dutils.eq(r.x*r.x+r.y*r.y,r.z*r.z)}containsHyperbola(t){return ts3dutils.assertInst(HyperbolaCurve,t),!0}containsCurve(t){return t instanceof SemiEllipseCurve?this.containsEllipse(t):t instanceof L3$1?this.containsLine(t):t instanceof HyperbolaCurve?this.containsHyperbola(t):t instanceof ParabolaCurve?this.containsParabola(t):super.containsCurve(t)}transform(t){return new ConicSurface(t.transformPoint(this.center),t.transformVector(this.f1).times(t.isMirroring()?-1:1),t.transformVector(this.f2),t.transformVector(this.dir))}rightAngled(){}flipped(){return new ConicSurface(this.center,this.f1.negated(),this.f2,this.dir)}normalSTFunc(){const{f1:t,f2:s}=this,e=this.dir;return(i,r)=>s.cross(t).plus(s.cross(e.times(Math.cos(i)))).plus(e.cross(t.times(Math.sin(i)))).unit()}normalP(t){const s=this.inverseMatrix.transformPoint(t);return this.normalSTFunc()(s.angleXY(),s.z)}pSTFunc(){return(t,s)=>this.matrix.transformPoint(new ts3dutils.V3(s*cos$3(t),s*sin$3(t),s))}dpds(){return(t,s)=>{const e=new ts3dutils.V3(s*-sin$3(t),s*cos$3(t),0);return this.matrix.transformVector(e)}}dpdt(){return(t,s)=>{const e=new ts3dutils.V3(cos$3(t),sin$3(t),1);return this.matrix.transformVector(e)}}implicitFunction(){return t=>{const s=this.inverseMatrix.transformPoint(t),e=s.lengthXY();return this.normalDir*(e-s.z)}}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}boundsFunction(){ts3dutils.assert(!1)}stP(t){const s=this.inverseMatrix.transformPoint(t),e=s.angleXY();return new ts3dutils.V3(e<-PI$5/2?e+ts3dutils.TAU:e,s.z,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$1?this.isCurvesWithPlane(t.plane):ImplicitSurface.is(t)?ParametricSurface.isCurvesParametricImplicitSurface(this,t,.1,.1/this.dir.length(),.02):super.isCurvesWithSurface(t)}getCenterLine(){return new L3$1(this.center,this.dir)}isCurvesWithPlane(t){ts3dutils.assertInst(P3,t);const s=t.transform(this.inverseMatrix),e=s.normal1,i=e.z,r=e.lengthXY(),n=s.w,a=ts3dutils.M4.rotateZ(e.angleXY()),o=ts3dutils.eq0(e.lengthXY())?this.matrix:this.matrix.times(a);return ConicSurface.unitISPlane(r,i,n).flatMap(s=>{const e=s.transform(o);if(s instanceof EllipseCurve){const t=s.transform(a),i=t.isTsWithPlane(P3.ZX);return ts3dutils.getIntervals(i,-PI$5,PI$5).filter(([s,e])=>t.at((s+e)/2).y>0).flatMap(([t,s])=>SemiEllipseCurve.fromEllipse(e,t,s))}const i=e.at(.2);return this.normalP(i).cross(t.normal1).dot(e.tangentAt(.2))>0?e:e.reversed()})}edgeLoopCCW(t){const s=this.stPFunc();return ts3dutils.isCCW(t.flatMap(t=>t.getVerticesNo0()).map(t=>s(t)),ts3dutils.V3.Z)}}ConicSurface.UNIT=new ConicSurface(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y,ts3dutils.V3.Z),ConicSurface.prototype.uStep=PI$5/16,ConicSurface.prototype.vStep=256,ConicSurface.prototype.sMin=0,ConicSurface.prototype.sMax=PI$5,ConicSurface.prototype.tMin=0,ConicSurface.prototype.tMax=16;const{PI:PI$6,cos:cos$4,sin:sin$4,abs:abs$7,sign:sign$3}=Math;class EllipsoidSurface extends ParametricSurface{constructor(t,s,e,i){super(),this.center=t,this.f1=s,this.f2=e,this.f3=i,ts3dutils.assertVectors(t,s,e,i),this.matrix=ts3dutils.M4.forSys(s,e,i,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$3(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.inverseMatrix)}static unitISTsWithLine(t,s){const e=s.dot(s),i=2*t.dot(s),r=t.dot(t)-1;return ts3dutils.pqFormula(i/e,r/e)}static unitISCurvesWithPlane(t){ts3dutils.assertInst(P3,t);let s=Math.abs(t.w);if(ts3dutils.lt(s,1)){const e=Math.sqrt(1-s*s),i=(t.anchor,t.normal1.getPerpendicular().toLength(e)),r=t.normal1.cross(i);return[new EllipseCurve(t.anchor,i,r)]}return[]}static sphere(t,s){return ts3dutils.assertNumbers(t),s&&ts3dutils.assertVectors(s),new EllipsoidSurface(s||ts3dutils.V3.O,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0),new ts3dutils.V3(0,0,t))}static forABC(t,s,e,i){return new EllipsoidSurface(i||ts3dutils.V3.O,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,s,0),new ts3dutils.V3(0,0,e))}static calculateAreaSpheroid(t,s,e,i){ts3dutils.assertf(()=>t.isPerpendicularTo(s)),ts3dutils.assertf(()=>s.isPerpendicularTo(e)),ts3dutils.assertf(()=>e.isPerpendicularTo(t));const r=ts3dutils.M4.forSys(t,s,e).inversed(),n=t.length(),a=e.unit();return i.map(t=>{if(t.curve instanceof EllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s),o=r.transformPoint(e);return o.angleXY()*n*Math.sqrt(1+Math.pow(o.z,2))*Math.sqrt(1+Math.pow(a.dot(i),2))},e=ts3dutils.glqInSteps(s,t.aT,t.bT,1);return console.log("edge",t,e),e}ts3dutils.assertNever()}).sum()}like(t){return this.isCoplanarTo(t)&&this.isInsideOut()==t.isInsideOut()}edgeLoopCCW(t){throw new Error}rootPoints(){}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3]}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}isCurvesWithPlane(t){const s=t.transform(this.inverseMatrix);return EllipsoidSurface.unitISCurvesWithPlane(s).map(t=>t.transform(this.matrix))}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface){if(t.dir.isParallelTo(this.dir1)){const s=t.baseCurve.transform(ts3dutils.M4.project(this.baseEllipse.getPlane(),this.dir1));return this.baseEllipse.isInfosWithEllipse(s).map(t=>new L3$1(t.p,this.dir1))}ts3dutils.eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),ts3dutils.assert(!1)}else if(t instanceof ProjectedCurveSurface){const s=t.transform(this.inverseMatrix),e=s.baseCurve.project(new P3(s.dir,0)),i=e.isTsWithSurface(EllipsoidSurface.UNIT);return iii(i,EllipsoidSurface.UNIT,e).flatMap(i=>{const r=new L3$1(e.at(i[0]),s.dir),n=EllipsoidSurface.UNIT.isTsForLine(r).map(t=>r.at(t)),a=new L3$1(e.at(i[1]),s.dir),o=EllipsoidSurface.UNIT.isTsForLine(a).map(t=>a.at(t));return[0,1].map(s=>{let e=n[s]||n[0],i=o[s]||o[0];return 0!==s&&([e,i]=[i,e]),ts3dutils.assert(EllipsoidSurface.UNIT.containsPoint(e)),ts3dutils.assert(EllipsoidSurface.UNIT.containsPoint(i)),PICurve.forStartEnd(t,this.asEllipsoidSurface(),e,i)})})}}isTsForLine(t){ts3dutils.assertInst(L3$1,t);const s=this.inverseMatrix.transformPoint(t.anchor),e=this.inverseMatrix.transformVector(t.dir1);return EllipsoidSurface.unitISTsWithLine(s,e)}isCoplanarTo(t){if(this===t)return!0;if(t.constructor!==EllipsoidSurface)return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&ts3dutils.eq(this.f1.length(),this.f2.length());const s=this.inverseMatrix.times(t.matrix);return s.is3x3()&&s.isOrthogonal()}containsEllipse(t){const s=t.transform(this.inverseMatrix),e=s.center.length(),i=Math.sqrt(1-e*e);return ts3dutils.lt(e,1)&&s.isCircular()&&s.f1.hasLength(i)}containsCurve(t){return t instanceof EllipseCurve?this.containsEllipse(t):super.containsCurve(t)}transform(t){return new EllipsoidSurface(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new EllipsoidSurface(this.center,this.f1,this.f2,this.f3.negated())}toMesh(t=3){return tsgl.Mesh.sphere(t).transform(this.matrix)}normalSTFunc(){return(t,s)=>{let{f1:e,f2:i,f3:r}=this;return i.cross(r).times(Math.cos(s)*Math.cos(t)).plus(r.cross(e).times(Math.cos(s)*Math.sin(t))).plus(e.cross(i).times(Math.sin(s))).unit()}}normalP(t){return this.normalMatrix.transformVector(this.inverseMatrix.transformPoint(t)).unit()}normalST(t,s){return this.normalMatrix.transformVector(ts3dutils.V3.sphere(t,s))}pST(t,s){return this.matrix.transformPoint(ts3dutils.V3.sphere(t,s))}dpds(){return(t,s)=>this.matrix.transformVector(new ts3dutils.V3(sin$4(t)*-cos$4(s),cos$4(t)*cos$4(s),0))}dpdt(){return(t,s)=>this.matrix.transformVector(new ts3dutils.V3(sin$4(s)*-cos$4(t),-sin$4(t)*sin$4(s),cos$4(s)))}stPFunc(){return(t,s)=>{const e=this.inverseMatrix.transformPoint(t);let i=e.angleXY();abs$7(i)>Math.PI-ts3dutils.NLA_PRECISION&&(ts3dutils.assert(s==-PI$6||s==PI$6),i=s);let r=Math.asin(e.z);return new ts3dutils.V3(i,r,0)}}isSphere(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&ts3dutils.eq(this.f2.length(),this.f3.length())&&ts3dutils.eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}implicitFunction(){return t=>{return this.inverseMatrix.transformPoint(t).length()-1}}didp(t){const s=this.inverseMatrix.transformPoint(t);return this.inverseMatrix.transformVector(s.unit())}mainAxes(){const{f1:t,f2:s,f3:e}=this;if(ts3dutils.eq0(t.dot(s))&&ts3dutils.eq0(s.dot(e))&&ts3dutils.eq0(e.dot(t)))return this;const{U:i,SIGMA:r}=this.matrix.svd3();ts3dutils.assert(r.isDiagonal()),ts3dutils.assert(i.isOrthogonal());const n=i.times(r),[a,o,l]=ts3dutils.arrayFromFunction(3,t=>new ts3dutils.V3(n.m[t],n.m[t+4],n.m[t+8]));return new EllipsoidSurface(this.center,a,o,l)}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}boundsFunction(){return(t,s)=>ts3dutils.between(s,-PI$6,PI$6)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,s){ts3dutils.assertVectors(s);const e=new EllipseCurve(this.center,this.matrix.transformVector(this.inverseMatrix.transformPoint(s).withElement("z",0).unit()),this.f3),i=e.pointT(s),r=e.normal,n=P3.normalOnAnchor(e.normal,s),a=t.map(t=>t.curve.isColinearTo(e));let o=!1;function l(t){const s=e.pointT(t);if(ts3dutils.eq(i,s))return!0;i<s&&ts3dutils.le(s,PI$6)&&(o=!o)}for(let s=0;s<t.length;s++){const o=t[s],u=(s+1)%t.length,c=t[u];if(a[s]){const t=e.pointT(o.a),s=e.pointT(o.b);if(ts3dutils.le(Math.min(t,s),i)&&ts3dutils.ge(i,Math.max(t,s)))return exports.PointVsFace.ON_EDGE;if((a[u]||dotCurve(r,c.aDir,c.aDDT)<0)&&l(o.b))return exports.PointVsFace.ON_EDGE}else for(const t of o.edgeISTsWithPlane(n))if(t==o.bT){if(!e.containsPoint(o.b))continue;if(dotCurve(r,o.bDir,o.bDDT)<0!=(a[u]||dotCurve(r,c.aDir,c.aDDT)<0)&&l(o.b))return exports.PointVsFace.ON_EDGE}else if(t!=o.aT){const s=o.curve.at(t);if(!e.containsPoint(s))continue;if(l(s))return exports.PointVsFace.ON_EDGE}}return o?exports.PointVsFace.INSIDE:exports.PointVsFace.OUTSIDE}surfaceAreaApprox(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),r=1.6075;return 4*PI$6*Math.pow((Math.pow(s*e,r)+Math.pow(e*i,r)+Math.pow(i*s,r))/3,1/r)}surfaceArea(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),[r,n,a]=[s,e,i].sort(ts3dutils.MINUS);function o(t,s){if(s<t){const e=1-Math.pow(s,2)/Math.pow(t,2),i=Math.sqrt(e);return 2*PI$6*Math.pow(t,2)*(1+(1-e)/Math.sqrt(i)*Math.atanh(i))}{const e=Math.sqrt(1-Math.pow(t,2)/Math.pow(s,2));return 2*PI$6*Math.pow(t,2)*(1+s/t/e*Math.asin(e))}}if(ts3dutils.eq(a,n))return o(a,r);if(ts3dutils.eq(n,r))return o(n,a);if(ts3dutils.eq(r,a))return o(r,n);const l=Math.acos(r/a),u=Math.pow(a,2)*(Math.pow(n,2)-Math.pow(r,2))/(Math.pow(n,2)*(Math.pow(a,2)-Math.pow(r,2))),c=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-u*Math.pow(Math.sin(t),2),-.5),0,l),h=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-u*Math.pow(Math.sin(t),2),.5),0,l);return 2*PI$6*Math.pow(r,2)+2*PI$6*a*n/Math.sin(l)*(h*Math.pow(Math.sin(l),2)+c*Math.pow(Math.cos(l),2))}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.center,this.f1,this.f3)}}EllipsoidSurface.UNIT=new EllipsoidSurface(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y,ts3dutils.V3.Z),EllipsoidSurface.prototype.uStep=PI$6/32,EllipsoidSurface.prototype.vStep=PI$6/32;const{sign:sign$4}=Math;class ProjectedCurveSurface extends ParametricSurface{constructor(t,s,e=t.tMin,i=t.tMax,r=-100,n=100){super(),this.baseCurve=t,this.dir=s,this.sMin=e,this.sMax=i,this.tMin=r,this.tMax=n,ts3dutils.assertInst(Curve,t),ts3dutils.assertInst(ts3dutils.V3,s),ts3dutils.assertNumbers(e,i,r,n),ts3dutils.assert(e<i),ts3dutils.assert(r<n)}getConstructorParameters(){return[this.baseCurve,this.dir,this.sMin,this.sMax,this.tMin,this.tMax]}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.dir.equals(t.dir)&&this.baseCurve.equals(t.baseCurve)}hashCode(){return[this.dir,this.baseCurve].hashCode()}containsLine(t){return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor)}dpds(){return(t,s)=>this.baseCurve.tangentAt(t)}dpdt(){return(t,s)=>this.dir}normalST(t,s){return this.baseCurve.tangentAt(t).cross(this.dir).unit()}pST(t,s){return this.baseCurve.at(t).plus(this.dir.times(s))}pointFoot(t,s,e){const i=new P3(this.dir,0),r=this.baseCurve.project(i),n=i.projectedPoint(t),a=r.closestTToPoint(n,s),o=t.minus(this.baseCurve.at(a)).dot(this.dir);return new ts3dutils.V3(a,o,0)}stPFunc(){const t=new P3(this.dir.unit(),0),s=this.baseCurve.project(t);return e=>{const i=t.projectedPoint(e),r=s.pointT(i),n=L3$1.pointT(this.baseCurve.at(r),this.dir,e);return new ts3dutils.V3(r,n,0)}}isCurvesWithPlane(t){if(ts3dutils.assertInst(P3,t),this.dir.isPerpendicularTo(t.normal1)){return this.baseCurve.isTsWithPlane(t).map(s=>{const e=0<this.baseCurve.tangentAt(s).dot(t.normal1)?this.dir:this.dir.negated();return new L3$1(this.baseCurve.at(s),e.unit())})}{let s=this.baseCurve.transform(ts3dutils.M4.project(t,this.dir));return this.dir.dot(t.normal1)>0&&(s=s.reversed()),[s]}}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof ProjectedCurveSurface){const s=t.dir;if(this.dir.isParallelTo(s)){const e=t.baseCurve;return this.baseCurve.isInfosWithCurve(e).map(e=>{const i=this.normalP(e.p).cross(t.normalP(e.p));return new L3$1(e.p,s.times(sign$4(i.dot(s))))})}if(t instanceof ProjectedCurveSurface){const s=new L3$1(this.baseCurve.at(.5),this.dir),e=s.at(t.isTsForLine(s)[0]);return console.log(e),[new PPCurve(this,t,e)]}}if(t instanceof SemiEllipsoidSurface)return t.isCurvesWithSurface(this);ts3dutils.assertNever()}containsPoint(t){const s=this.stPFunc()(t);return this.pSTFunc()(s.x,s.y).like(t)}containsCurve(t){if(t instanceof L3$1)return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor);if(t instanceof PICurve$1)return super.containsCurve(t);const s=new P3(this.dir.unit(),0),e=this.baseCurve.project(s),i=t.project(s);return e.isColinearTo(i)}isCoplanarTo(t){return this==t||ts3dutils.hasConstructor(t,ProjectedCurveSurface)&&this.dir.isParallelTo(t.dir)&&this.containsCurve(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;const s=this.pSTFunc()(0,0),e=this.normalSTFunc()(0,0),i=t.normalP(s);return 0<e.dot(i)}loopContainsPoint(t,s){ts3dutils.assertVectors(s),ts3dutils.assert(isFinite(s.x),s.y,s.z);const e=new L3$1(s,this.dir.unit()),i=this.stPFunc()(s);isNaN(i.x)&&(console.log(this.sce,s.sce),ts3dutils.assert(!1));const r=this.baseCurve.tangentAt(i.x).rejectedFrom(this.dir);return Surface.loopContainsPointGeneral(t,s,e,r)}edgeLoopCCW(t){if(t.length<56){let s=0;for(let e=0;e<t.length;e++){const i=(e+1)%t.length,r=t[e],n=t[i];s+=r.bDir.angleRelativeNormal(n.aDir,this.normalP(r.b))}return s>0}{const s=this.stPFunc();return ts3dutils.isCCW(t.map(t=>s(t.a)),ts3dutils.V3.Z)}}transform(t){const s=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform(t),t.transformVector(this.dir).times(s),this.sMin,this.sMax,1==s?this.tMin:-this.tMax,1==s?this.tMax:-this.tMin)}isTsForLine(t){ts3dutils.assertInst(L3$1,t);const s=new P3(this.dir.unit(),0),e=s.projectedVector(t.dir1);if(e.likeO())return[];const i=s.projectedPoint(t.anchor);return this.baseCurve.project(s).isInfosWithLine(i,e,this.sMin,this.sMax,t.tMin,t.tMax).map(t=>t.tOther)}flipped(){return new this.constructor(this.baseCurve,this.dir.negated(),this.sMin,this.sMax,-this.tMax,-this.tMin)}}ProjectedCurveSurface.prototype.uStep=.025,ProjectedCurveSurface.prototype.vStep=256;const{PI:PI$7}=Math;class CylinderSurface extends ProjectedCurveSurface{constructor(t,s,e=-1/0,i=1/0){super(t,s,void 0,void 0,e,i),ts3dutils.assert(2==arguments.length),ts3dutils.assertVectors(s),ts3dutils.assertInst(EllipseCurve,t),ts3dutils.assert(s.hasLength(1)),this.matrix=ts3dutils.M4.forSys(t.f1,t.f2,s,t.center),this.inverseMatrix=this.matrix.inversed()}static cylinder(t){return new CylinderSurface(new EllipseCurve(ts3dutils.V3.O,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0)),ts3dutils.V3.Z)}static unitISLineTs(t,s){const{x:e,y:i}=t,{x:r,y:n}=s,a=Math.pow(r,2)+Math.pow(n,2),o=2*(e*r+i*n),l=Math.pow(e,2)+Math.pow(i,2)-1;return ts3dutils.pqFormula(o/a,l/a)}getConstructorParameters(){return[this.baseCurve,this.dir]}loopContainsPoint(t,s){ts3dutils.assertVectors(s);const e=new L3$1(s,this.dir),i=(this.baseCurve.at(PI$7),this.dir.cross(this.normalP(s)));return Surface.loopContainsPointGeneral(t,s,e,i)}isTsForLine(t){ts3dutils.assertInst(L3$1,t);const s=this.inverseMatrix.transformVector(t.dir1);if(s.isParallelTo(ts3dutils.V3.Z))return[];const e=this.inverseMatrix.transformPoint(t.anchor);return ts3dutils.assert(!CylinderSurface.unitISLineTs(e,s).length||!isNaN(CylinderSurface.unitISLineTs(e,s)[0]),"sad "+s),CylinderSurface.unitISLineTs(e,s)}isCoplanarTo(t){return this==t||t instanceof CylinderSurface&&this.dir.isParallelTo(t.dir)&&this.containsEllipse(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsEllipse(t){const s=t.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(s)}containsCurve(t){return t instanceof EllipseCurve?this.containsEllipse(t):t instanceof L3$1?this.containsLine(t):t instanceof SemiEllipseCurve?this.containsEllipse(t):void ts3dutils.assert(!1)}normalP(t){const s=this.inverseMatrix.transformPoint(t);return this.normalSTFunc()(s.angleXY(),s.z)}implicitFunction(){return t=>{const s=this.inverseMatrix.transformPoint(t).lengthXY();return Math.sign(this.baseCurve.normal.dot(this.dir))*(1-s)}}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}pointToParameterFunction(){return(t,s)=>{const e=this.inverseMatrix.transformPoint(t);let i=e.angleXY();return abs(i)>Math.PI-ts3dutils.NLA_PRECISION&&(ts3dutils.assert(s==-PI$7||s==PI$7),i=s),new ts3dutils.V3(i,e.z,0)}}isCurvesWithSurface(t){if(t instanceof PlaneSurface)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface){if(t.dir.isParallelTo(this.dir)){const s=t.baseCurve.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithEllipse(s).map(t=>new L3$1(t.p,this.dir))}ts3dutils.eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),ts3dutils.assert(!1)}}getCenterLine(){return new L3$1(this.baseCurve.center,this.dir)}edgeLoopCCW(t){if(t.length<56){let s=0;for(let e=0;e<t.length;e++){const i=(e+1)%t.length,r=t[e],n=t[i];s+=r.bDir.angleRelativeNormal(n.aDir,this.normalP(r.b))}return s>0}{const s=this.stPFunc();return ts3dutils.isCCW(t.map(t=>s(t.a)),ts3dutils.V3.Z)}}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.baseCurve.center,this.baseCurve.f1,this.dir)}}CylinderSurface.UNIT=new CylinderSurface(EllipseCurve.XY,ts3dutils.V3.Z),CylinderSurface.prototype.uStep=ts3dutils.TAU/128,CylinderSurface.prototype.vStep=256;const{PI:PI$8,cos:cos$5,sin:sin$5,min:min$6,max:max$5,sign:sign$5,tan:tan$3,ceil:ceil$8,floor:floor$7,abs:abs$8,sqrt:sqrt$3,pow:pow$3,atan2:atan2$3,round:round$3}=Math;class RotationREqFOfZ extends ParametricSurface{constructor(t,s,e,i,r,n=(t=>(s(t+EPS)-s(t))/EPS)){super(),this.matrix=t,this.rt=s,this.tMin=e,this.tMax=i,this.normalDir=r,this.drdz=n,ts3dutils.assertInst(ts3dutils.M4,t),ts3dutils.assert(t.isNoProj()),ts3dutils.assert(1==r||-1==r),this.matrixInverse=t.inversed()}getConstructorParameters(){return[this.matrix,this.rt,this.tMin,this.tMax,this.normalDir,this.drdz]}flipped(){return new RotationREqFOfZ(this.matrix,this.rt,this.tMin,this.tMax,-this.normalDir,this.drdz)}transform(t){return new RotationREqFOfZ(t.times(this.matrix),this.rt,this.tMin,this.tMax,this.normalDir,this.drdz)}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}pSTFunc(){return(t,s)=>{const e=this.rt(s);return this.matrix.transformPoint(ts3dutils.V3.polar(e,t,s))}}dpds(){return(t,s)=>{const e=this.rt(s);return this.matrix.transformVector(new ts3dutils.V3(e*-sin$5(t),e*cos$5(t),0))}}dpdt(){return(t,s)=>{const e=this.drdz(s);return this.matrix.transformVector(new ts3dutils.V3(e*cos$5(t),e*sin$5(t),1))}}normalSTFunc(){const t=this.matrix.inversed().transposed();return(s,e)=>{const i=this.drdz(e);return t.transformVector(ts3dutils.V3.polar(1,s,-i)).toLength(this.normalDir)}}implicitFunction(){return t=>{const s=this.matrixInverse.transformPoint(t),e=s.lengthXY();return this.rt(s.z)-e}}stPFunc(){return t=>{const s=this.matrixInverse.transformPoint(t);return new ts3dutils.V3(atan2$3(s.y,s.x),s.z,0)}}}Object.assign(RotationREqFOfZ.prototype,ImplicitSurface.prototype),RotationREqFOfZ.prototype.sMin=0,RotationREqFOfZ.prototype.sMax=PI$8;const{PI:PI$9,cos:cos$6,sin:sin$6,min:min$7,max:max$6,tan:tan$4,sign:sign$6,ceil:ceil$9,floor:floor$8,abs:abs$9,sqrt:sqrt$4,pow:pow$4,atan2:atan2$4,round:round$4}=Math;class SemiCylinderSurface extends ProjectedCurveSurface{constructor(t,s,e,i,r=-1/0,n=1/0){super(t,s,e,i,r,n),ts3dutils.assertInst(SemiEllipseCurve,t),this.matrix=ts3dutils.M4.forSys(t.f1,t.f2,s,t.center),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$6(this.baseCurve.normal.dot(this.dir)),this.normalMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}static semicylinder(t){return new SemiCylinderSurface(new SemiEllipseCurve(ts3dutils.V3.O,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0)),ts3dutils.V3.Z,void 0,void 0)}static unitISLineTs(t,s){const{x:e,y:i}=t,{x:r,y:n}=s,a=Math.pow(r,2)+Math.pow(n,2),o=2*(e*r+i*n),l=Math.pow(e,2)+Math.pow(i,2)-1;return ts3dutils.pqFormula(o/a,l/a).filter(t=>SemiEllipseCurve.XYLCValid(new ts3dutils.V3(e+r*t,i+n*t,0)))}getConstructorParameters(){return[this.baseCurve,this.dir,this.sMin,this.sMax,this.tMin,this.tMax]}normalP(t){return this.normalMatrix.transformVector(this.inverseMatrix.transformPoint(t).xy()).unit()}loopContainsPoint(t,s){if(ts3dutils.assertVectors(s),!this.containsPoint(s))return OUTSIDE;const e=new L3$1(s,this.dir.unit()),i=(this.baseCurve.at(PI$9),this.dir.cross(this.normalP(s)));return Surface.loopContainsPointGeneral(t,s,e,i)}isTsForLine(t){ts3dutils.assertInst(L3$1,t);const s=this.inverseMatrix.transformVector(t.dir1);if(s.isParallelTo(ts3dutils.V3.Z))return[];const e=this.inverseMatrix.transformPoint(t.anchor);return ts3dutils.assert(!SemiCylinderSurface.unitISLineTs(e,s).length||!isNaN(SemiCylinderSurface.unitISLineTs(e,s)[0]),"sad "+s),SemiCylinderSurface.unitISLineTs(e,s)}isCoplanarTo(t){return this==t||ts3dutils.hasConstructor(t,SemiCylinderSurface)&&this.dir.isParallelTo(t.dir)&&this.containsSemiEllipse(t.baseCurve,!1)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsSemiEllipse(t,s=!0){const e=t.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(e)&&(!s||ts3dutils.le(0,t.transform(this.inverseMatrix).getAABB().min.y))}containsCurve(t){return t instanceof L3$1?this.containsLine(t):t instanceof SemiEllipseCurve?this.containsSemiEllipse(t):!(t instanceof BezierCurve)&&super.containsCurve(t)}implicitFunction(){return t=>{const s=this.inverseMatrix.transformPoint(t).lengthXY();return Math.sign(this.baseCurve.normal.dot(this.dir))*(1-s)}}containsPoint(t){const s=this.inverseMatrix.transformPoint(t);return SemiEllipseCurve.XYLCValid(s)}stP(t){ts3dutils.assert(1==arguments.length);const s=this.inverseMatrix.transformPoint(t),e=SemiEllipseCurve.XYLCPointT(s);return new ts3dutils.V3(e,s.z,0)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof SemiCylinderSurface){if(t.dir.isParallelTo(this.dir)){const s=t.baseCurve.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithEllipse(s).map(s=>{const e=sign$6(this.normalP(s.p).cross(t.normalP(s.p)).dot(this.dir))||1;return new L3$1(s.p,this.dir.times(e))})}ts3dutils.eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),ts3dutils.assert(!1)}}getCenterLine(){return new L3$1(this.baseCurve.center,this.dir)}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){let t=this.baseCurve.f1.cross(this.dir);return t=t.times(-sign$6(t.dot(this.baseCurve.f2))),P3.normalOnAnchor(t,this.baseCurve.center)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}}SemiCylinderSurface.UNIT=new SemiCylinderSurface(SemiEllipseCurve.UNIT,ts3dutils.V3.Z,void 0,void 0,0,1),SemiCylinderSurface.prototype.uStep=ts3dutils.TAU/32,SemiCylinderSurface.prototype.vStep=256;const{PI:PI$10,min:min$8,max:max$7,sign:sign$7,abs:abs$10,sqrt:sqrt$5}=Math;class SemiEllipsoidSurface extends EllipsoidSurface{constructor(t,s,e,i){super(t,s,e,i),this.center=t,this.f1=s,this.f2=e,this.f3=i,ts3dutils.assertVectors(t,s,e,i),this.matrix=ts3dutils.M4.forSys(s,e,i,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$7(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.inverseMatrix)}static unitArea(t){return t.map(t=>{if(t.curve instanceof PICurve$1){const s=t.curve.calcSegmentPoints(t.aT,t.bT,t.a,t.b,t.aT>t.bT,!0);let e=0;for(let t=0;t<s.length-1;t++){const i=s[t],r=s[t+1];e+=(abs$10(i.angleXY())+abs$10(r.angleXY()))/2*(r.z-i.z)}return e}if(t.curve instanceof SemiEllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.curve.tangentAt(s);return abs$10(e.angleXY())*i.z};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}ts3dutils.assertNever()}).sum()}static unitISTsWithLine(t,s){const e=s.dot(s),i=2*t.dot(s),r=t.dot(t)-1;return ts3dutils.pqFormula(i/e,r/e).filter(e=>ts3dutils.le(0,t.y+e*s.y))}static unitISCurvesWithPlane(t){const s=Math.abs(t.w);if(ts3dutils.lt(s,1)){const e=Math.sqrt(1-Math.pow(s,2)),i=t.normal1.y*t.w,r=abs$10(s*e);if(ts3dutils.le(i,-r)&&!ts3dutils.eq0(s))return[];if(ts3dutils.le(i,0)&&!t.normal1.isParallelTo(ts3dutils.V3.Y)){let s=t.normal1.isParallelTo(ts3dutils.V3.Y)?ts3dutils.V3.Z:t.normal1.cross(ts3dutils.V3.Y).toLength(e);const r=s.cross(t.normal1),n=-i/r.y,a=max$7(0,Math.asin(n));return[new SemiEllipseCurve(t.anchor,s,r,a,PI$10-a)]}{const s=(t.normal1.isParallelTo(ts3dutils.V3.Y)?ts3dutils.V3.X:t.normal1.cross(ts3dutils.V3.Y)).toLength(e),r=s.cross(t.normal1),n=ts3dutils.eq0(r.y)?-1:-i/r.y,a=Math.acos(max$7(-1,n-ts3dutils.NLA_PRECISION));return[new SemiEllipseCurve(t.anchor,r.negated(),s,PI$10-a,PI$10),new SemiEllipseCurve(t.anchor,r,s.negated(),0,a)]}}return[]}static unitISCurvesWithEllipsoidSurface(t){if(t.isSphere()){const s=t.f1.length(),e=t.center.length();if(ts3dutils.le(1,e-s)||ts3dutils.le(e+s,1)||ts3dutils.le(e-s,-1))return[];{const i=2*function(t,s,e){const i=(t+s+e)/2;return sqrt$5(i*(i-t)*(i-s)*(i-e))}(1,s,e)/e,r=sign$7(1+Math.pow(e,2)-Math.pow(s,2))*sqrt$5(1-Math.pow(i,2)),n=new P3(t.center.unit(),r);return SemiEllipsoidSurface.unitISCurvesWithPlane(n.flipped())}}ts3dutils.assertNever()}static unitISCurvesWithSemiCylinderSurface(t){if(new L3$1(t.baseCurve.center,t.dir).containsPoint(ts3dutils.V3.O)){const s=t.baseCurve.transform(ts3dutils.M4.project(new P3(t.dir,0))),e=s.f1.length(),i=s.f2.length();if(ts3dutils.lt(1,min$8(e,i)))return[];if(s.isCircular()){const i=Math.sqrt(1-Math.pow(min$8(1,e),2)),r=(t.dir.y<0?t.dir.negated():t.dir).times(i);return[new SemiEllipseCurve(r,s.f1,s.f2)]}}ts3dutils.assert(!1)}static sphere(t,s=ts3dutils.V3.O){return ts3dutils.assertNumbers(t),new SemiEllipsoidSurface(s,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0),new ts3dutils.V3(0,0,t))}static forABC(t,s,e,i=ts3dutils.V3.O){return new SemiEllipsoidSurface(i,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,s,0),new ts3dutils.V3(0,0,e))}static calculateAreaSpheroid(t,s,e,i){ts3dutils.assertf(()=>t.isPerpendicularTo(s)),ts3dutils.assertf(()=>s.isPerpendicularTo(e)),ts3dutils.assertf(()=>e.isPerpendicularTo(t));const r=ts3dutils.M4.forSys(t,s,e).inversed(),n=t.length(),a=e.unit();return i.map(t=>{if(t.curve instanceof SemiEllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s),o=r.transformPoint(e);return o.angleXY()*n*Math.sqrt(1+Math.pow(o.z,2))*Math.sqrt(1+Math.pow(a.dot(i),2))};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}ts3dutils.assertNever()}).sum()}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}edgeLoopCCW(t){return SemiEllipsoidSurface.unitArea(t.map(t=>t.transform(this.inverseMatrix)))>0}like(t){return!!this.isCoplanarTo(t)&&this.matrix.determinant3()*t.matrix.determinant3()>0}rootPoints(){}toMesh(){return ParametricSurface.prototype.toMesh.call(this)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3]}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}isCurvesWithPCS(t){let s=ParametricSurface.isCurvesParametricImplicitSurface(t,this,.1,.1/t.dir.length(),.05);return s=this.clipCurves(s),s=t.clipCurves(s)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof SemiCylinderSurface)return this.isCurvesWithSemiCylinderSurface(t);if(t instanceof SemiEllipsoidSurface){const s=t.transform(this.inverseMatrix),e=SemiEllipsoidSurface.unitISCurvesWithEllipsoidSurface(s).map(t=>t.transform(this.matrix));return t.clipCurves(e)}if(t instanceof ProjectedCurveSurface)return this.isCurvesWithPCS(t);if(t instanceof ParametricSurface){let s=ParametricSurface.isCurvesParametricImplicitSurface(t,this,.1,.1,.05);return s=this.clipCurves(s),s=t.clipCurves(s)}ts3dutils.assert(!1)}isCurvesWithPlane(t){const s=t.transform(this.inverseMatrix);return SemiEllipsoidSurface.unitISCurvesWithPlane(s).map(t=>t.transform(this.matrix))}isCurvesWithSemiCylinderSurface(t){if(L3$1.containsPoint(t.baseCurve.center,t.dir,this.center)){ts3dutils.assert(this.isSphere());const s=t.baseCurve.transform(ts3dutils.M4.project(t.baseCurve.getPlane(),t.dir));if(s.isCircular()){const t=this.f1.length(),e=s.f1.length();ts3dutils.eq(t,e),ts3dutils.assert(!1)}}return this.isCurvesWithPCS(t)}isTsForLine(t){ts3dutils.assertInst(L3$1,t);const s=this.inverseMatrix.transformPoint(t.anchor),e=this.inverseMatrix.transformVector(t.dir1);return SemiEllipsoidSurface.unitISTsWithLine(s,e)}isCoplanarTo(t){if(this===t)return!0;if(!ts3dutils.hasConstructor(t,SemiEllipsoidSurface))return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&ts3dutils.eq(this.f1.length(),this.f2.length());const s=this.inverseMatrix.times(t.matrix);return s.is3x3()&&s.isOrthogonal()}containsEllipse(t){const s=t.transform(this.inverseMatrix),e=s.center.length(),i=Math.sqrt(1-Math.pow(e,2));return ts3dutils.lt(e,1)&&s.isCircular()&&s.f1.hasLength(i)}containsCurve(t){return t instanceof SemiEllipseCurve?this.containsEllipse(t):super.containsCurve(t)}transform(t){return new SemiEllipsoidSurface(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3).times(t.isMirroring()?-1:1))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new SemiEllipsoidSurface(this.center,this.f1,this.f2,this.f3.negated())}normalSTFunc(){return(t,s)=>{const{f1:e,f2:i,f3:r}=this;return i.cross(r).times(Math.cos(s)*Math.cos(t)).plus(r.cross(e).times(Math.cos(s)*Math.sin(t))).plus(e.cross(i).times(Math.sin(s))).unit()}}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.inverseMatrix.transformPoint(t)).unit()}normalST(t,s){return this.pLCNormalWCMatrix.transformVector(ts3dutils.V3.sphere(t,s)).unit()}stPFunc(){return t=>{const s=this.inverseMatrix.transformPoint(t),e=abs$10(s.angleXY()),i=Math.asin(ts3dutils.clamp(s.z,-1,1));return ts3dutils.assert(isFinite(e)),ts3dutils.assert(isFinite(i)),new ts3dutils.V3(e,i,0)}}pSTFunc(){return(t,s)=>this.matrix.transformPoint(ts3dutils.V3.sphere(t,s))}isSphere(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&ts3dutils.eq(this.f2.length(),this.f3.length())&&ts3dutils.eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}mainAxes(){const{f1:t,f2:s,f3:e}=this;if(ts3dutils.eq0(t.dot(s))&&ts3dutils.eq0(s.dot(e))&&ts3dutils.eq0(e.dot(t)))return this;const{U:i,SIGMA:r}=this.matrix.svd3();ts3dutils.assert(r.isDiagonal()),ts3dutils.assert(i.isOrthogonal());const n=i.times(r),[a,o,l]=ts3dutils.arrayFromFunction(3,t=>new ts3dutils.V3(n.m[t],n.m[t+4],n.m[t+8]));return new SemiEllipsoidSurface(this.center,a,o,l)}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}boundsFunction(){return(t,s)=>ts3dutils.between(t,0,PI$10)&&ts3dutils.between(s,-PI$10,PI$10)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,s){if(!this.containsPoint(s))return exports.PointVsFace.OUTSIDE;ts3dutils.assertVectors(s);const e=this.inverseMatrix.transformPoint(s).withElement("z",0),i=new SemiEllipseCurve(this.center,this.f3,e.likeO()?this.f2:this.matrix.transformVector(e.unit())),r=i.pointT(s);if(P3.normalOnAnchor(this.f2.unit(),this.center).containsPoint(s)){let e;return t.some(t=>t.curve.containsPoint(s)&&ts3dutils.le(t.minT,e=t.curve.pointT(s))&&ts3dutils.le(e,t.maxT))?exports.PointVsFace.ON_EDGE:exports.PointVsFace.OUTSIDE}const n=i.normal,a=P3.normalOnAnchor(i.normal,s),o=t.map(t=>i.isColinearTo(t.curve));let l=!1;function u(t){const s=i.pointT(t);if(ts3dutils.eq(r,s))return!0;r<s&&ts3dutils.le(s,PI$10)&&(l=!l)}for(let e=0;e<t.length;e++){const r=t[e],l=(e+1)%t.length,c=t[l];if(o[e]){let t;if(r.curve.containsPoint(s)&&ts3dutils.le(r.minT,t=r.curve.pointT(s))&&ts3dutils.le(t,r.maxT))return exports.PointVsFace.ON_EDGE;if(!(o[l]||dotCurve(n,c.aDir,c.aDDT)<0)&&i.containsPoint(r.b)&&u(r.b))return exports.PointVsFace.ON_EDGE}else for(const t of r.edgeISTsWithPlane(a))if(t==r.bT){if(!i.containsPoint(r.b))continue;if(dotCurve2(r.curve,r.bT,n,-sign$7(r.deltaT()))<0!=(o[l]||dotCurve(n,c.aDir,c.aDDT)<0)&&u(r.b))return exports.PointVsFace.ON_EDGE}else if(t!=r.aT){const s=r.curve.at(t);if(!i.containsPoint(s))continue;if(u(s))return exports.PointVsFace.ON_EDGE}}return l?exports.PointVsFace.INSIDE:exports.PointVsFace.OUTSIDE}zDirVolumeForLoop2(t){const s=this.inverseMatrix.getZ().toAngles(),e=ts3dutils.M4.rotateY(-s.theta).times(ts3dutils.M4.rotateZ(-s.phi)).times(this.inverseMatrix),i=ts3dutils.M4.rotateX(PI$10/2);let r=0;return ts3dutils.assert(ts3dutils.V3.X.isParallelTo(e.transformVector(ts3dutils.V3.Z))),t.map(t=>t.transform(e)).forEach((t,s,e)=>{const n=e[(s+1)%e.length];if(t.b.like(ts3dutils.V3.X)){const s=(t.bDir.angleRelativeNormal(n.aDir,ts3dutils.V3.X)+2*PI$10)%(2*PI$10);r+=2/3*s}if(t.b.like(ts3dutils.V3.X.negated())){const s=(t.bDir.angleRelativeNormal(n.aDir,ts3dutils.V3.X)+2*PI$10)%(2*PI$10);r+=2/3*s}const a=ts3dutils.gaussLegendreQuadrature24(function(s){const e=t.curve.at(s).withElement("x",0);return 1/3*(1-(Math.pow(e.y,2)+Math.pow(e.z,2)))*t.tangentAt(s).dot(i.transformVector(e.unit()))},t.aT,t.bT);r+=a}),r*this.f1.dot(this.f2.cross(this.f3))}surfaceAreaApprox(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),r=1.6075;return 4*PI$10*Math.pow((Math.pow(s*e,r)+Math.pow(e*i,r)+Math.pow(i*s,r))/3,1/r)}surfaceArea(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),[r,n,a]=[s,e,i].sort(ts3dutils.MINUS);function o(t,s){if(s<t){const e=1-Math.pow(s,2)/Math.pow(t,2),i=Math.sqrt(e);return 2*PI$10*Math.pow(t,2)*(1+(1-e)/Math.sqrt(i)*Math.atanh(i))}{const e=Math.sqrt(1-Math.pow(t,2)/Math.pow(s,2));return 2*PI$10*Math.pow(t,2)*(1+s/t/e*Math.asin(e))}}if(ts3dutils.eq(a,n))return o(a,r);if(ts3dutils.eq(n,r))return o(n,a);if(ts3dutils.eq(r,a))return o(r,n);const l=Math.acos(r/a),u=Math.pow(a,2)*(Math.pow(n,2)-Math.pow(r,2))/(Math.pow(n,2)*(Math.pow(a,2)-Math.pow(r,2))),c=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-u*Math.pow(Math.sin(t),2),-.5),0,l),h=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-u*Math.pow(Math.sin(t),2),.5),0,l);return 2*PI$10*Math.pow(r,2)+2*PI$10*a*n/Math.sin(l)*(h*Math.pow(Math.sin(l),2)+c*Math.pow(Math.cos(l),2))}getSeamPlane(){const t=P3.forAnchorAndPlaneVectors(this.center,this.f1,this.f3);return t.normal1.dot(this.f2)<0?t:t.flipped()}asEllipsoidSurface(){return new EllipsoidSurface(this.center,this.f1,this.f2,this.f3)}getExtremePoints(){ts3dutils.assert(this.isSphere());const t=this.f1.length();return[ts3dutils.V3.X,ts3dutils.V3.X.negated(),ts3dutils.V3.Y,ts3dutils.V3.Y.negated(),ts3dutils.V3.Z,ts3dutils.V3.Z.negated()].filter(t=>ts3dutils.lt(0,t.dot(this.f2))).map(s=>s.times(t).plus(this.center))}}SemiEllipsoidSurface.UNIT=new SemiEllipsoidSurface(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y,ts3dutils.V3.Z),SemiEllipsoidSurface.prototype.uStep=PI$10/16,SemiEllipsoidSurface.prototype.vStep=PI$10/16,SemiEllipsoidSurface.prototype.sMin=0,SemiEllipsoidSurface.prototype.sMax=PI$10,SemiEllipsoidSurface.prototype.tMin=-PI$10/2,SemiEllipsoidSurface.prototype.tMax=PI$10/2;class PlaneSurface$1 extends ParametricSurface{constructor(t,s=t.normal1.getPerpendicular().unit(),e=t.normal1.cross(s).unit(),i=-100,r=100,n=-100,a=100){super(),this.plane=t,this.right=s,this.up=e,this.sMin=i,this.sMax=r,this.tMin=n,this.tMax=a,ts3dutils.assertInst(P3,t),ts3dutils.assert(this.right.cross(this.up).like(this.plane.normal1)),this.matrix=ts3dutils.M4.forSys(s,e,t.normal1,t.anchor)}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new PlaneSurface",...this.getConstructorParameters())}static throughPoints(t,s,e){return new PlaneSurface$1(P3.throughPoints(t,s,e))}isCoplanarTo(t){return t instanceof PlaneSurface$1&&this.plane.isCoplanarToPlane(t.plane)}isTsForLine(t){return t.isTsWithPlane(this.plane)}like(t){return t instanceof PlaneSurface$1&&this.plane.like(t.plane)}pST(t,s){return this.matrix.transformPoint(new ts3dutils.V3(t,s,0))}implicitFunction(){return t=>this.plane.distanceToPointSigned(t)}isCurvesWithSurface(t){return t instanceof PlaneSurface$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){return this.plane.isParallelToPlane(t)?[]:[this.plane.intersectionWithPlane(t)]}edgeLoopCCW(t){return ts3dutils.isCCW(t.flatMap(t=>t.points()),this.plane.normal1)}loopContainsPoint(t,s){const e=this.right.plus(this.up.times(.123)).unit(),i=new L3$1(s,e),r=e.cross(this.plane.normal1);return Surface.loopContainsPointGeneral(t,s,i,r)}stPFunc(){const t=this.matrix.inversed();return function(s){return t.transformPoint(s)}}pointFoot(t){return this.stP(t)}normalP(t){return this.plane.normal1}containsPoint(t){return this.plane.containsPoint(t)}containsCurve(t){return this.plane.containsCurve(t)}transform(t){return new PlaneSurface$1(this.plane.transform(t))}flipped(){return new PlaneSurface$1(this.plane.flipped(),this.right,this.up.negated())}getConstructorParameters(){return[this.plane,this.right,this.up]}toMesh(t=-10,s=10,e=-10,i=10){const r=(new tsgl.Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal"),n=ts3dutils.M4.forSys(this.right,this.up,this.plane.normal1,this.plane.anchor);return r.vertices=[ts3dutils.V(t,e),ts3dutils.V(s,e),ts3dutils.V(t,i),ts3dutils.V(s,i)].map(t=>n.transformPoint(t)),r.normals=ts3dutils.arrayFromFunction(4,t=>this.plane.normal1),tsgl.pushQuad(r.TRIANGLES,!1,0,1,2,3),r.compile(),r}dpds(){return()=>this.right}dpdt(){return()=>this.up}equals(t){}didp(t){return this.plane.normal1}}const{PI:PI$11}=Math,ZDirVolumeVisitor={[ConicSurface.name](t){return{volume:t.map(t=>{if(t.curve instanceof SemiEllipseCurve||t.curve instanceof HyperbolaCurve||t.curve instanceof ParabolaCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s);return(e.z+e.rejectedFrom(this.dir).z)/2*e.projectedOn(this.dir).lengthXY()*i.dot(ts3dutils.V3.Z.cross(this.dir).unit())},e=t.curve instanceof SemiEllipseCurve?-Math.sign(t.curve.normal.dot(this.dir)):-Math.sign(this.center.to(t.curve.center).cross(t.curve.f1).dot(this.dir));return ts3dutils.glqInSteps(s,t.aT,t.bT,1)*e}if(t.curve instanceof L3)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.normal.dot(this.dir))}},[PlaneSurface$1.name](){const{centroid:t,area:s}=this.calculateArea();return{volume:this.surface.plane.normal1.z*t.z*s,centroid:new ts3dutils.V3(t.x,t.y,t.z/2)}},[SemiCylinderSurface.name](t){if(ts3dutils.V3.Z.cross(this.dir).likeO())return{volume:0};const s=this.dir.cross(ts3dutils.V3.Z).unit(),e=this.dir.rejectedFrom(ts3dutils.V3.Z).unit();return{volume:edges.map(t=>{if(t.curve instanceof SemiEllipseCurve){const i=i=>{const r=t.curve.at(i),n=t.curve.tangentAt(i);return(r.z+r.rejectedFrom(this.dir).z)/2*r.projectedOn(this.dir).dot(e)*n.dot(s)},r=-Math.sign(t.curve.normal.dot(this.dir));return ts3dutils.glqInSteps(i,t.aT,t.bT,1)*r}if(t.curve instanceof L3)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},[CylinderSurface.name](t){if(ts3dutils.V3.Z.cross(this.dir).likeO())return{volume:0};const s=this.dir.cross(ts3dutils.V3.Z).unit(),e=this.dir.rejectedFrom(ts3dutils.V3.Z).unit();return console.log("scalingVector",s.sce),{volume:t.map(t=>{if(t.curve instanceof EllipseCurve){const i=i=>{const r=t.curve.at(i),n=t.curve.tangentAt(i);return(r.z+r.rejectedFrom(this.dir).z)/2*r.projectedOn(this.dir).dot(e)*n.dot(s)},r=-Math.sign(t.curve.normal.dot(this.dir)),n=ts3dutils.glqInSteps(i,t.aT,t.bT,1);return console.log("edge",t,n,r),n*r}if(t.curve instanceof L3)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},[EllipsoidSurface.name](t){const s=this.inverseMatrix.transformVector(ts3dutils.V3.Z).toAngles(),e=ts3dutils.M4.rotateAB(this.inverseMatrix.transformVector(ts3dutils.V3.Z),ts3dutils.V3.Z).times(ts3dutils.M4.rotateZ(-s.phi)).times(this.inverseMatrix);function i(t){let s=0;return assert(ts3dutils.V3.Z.isParallelTo(e.transformVector(ts3dutils.V3.Z))),t.map(t=>t.transform(e)).forEach((t,e,i)=>{i[(e+1)%i.length];const r=ts3dutils.gaussLegendreQuadrature24(function(s){const e=t.curve.at(s),i=t.curve.tangentAt(s),r=e.lengthXY(),n=e.withElement("z",0);return((e.angleXY()+ts3dutils.TAU-ts3dutils.NLA_PRECISION)%ts3dutils.TAU+ts3dutils.NLA_PRECISION)*Math.sqrt(1-r*r)*r*Math.abs(i.dot(n.unit()))*Math.sign(i.z)},t.aT,t.bT);console.log("edge",t,"volume",r),s+=r}),s}const[r,n]=EllipsoidSurface.splitOnPlaneLoop(t.map(t=>t.transform(e)),ccw);return{area:(i(r)+i(n))*this.f1.dot(this.f2.cross(this.f3)),centroid:void 0}},zDirVolumeForLoop2(t){const s=this.inverseMatrix.getZ().toAngles(),e=ts3dutils.M4.rotateY(-s.theta).times(ts3dutils.M4.rotateZ(-s.phi)).times(this.inverseMatrix),i=ts3dutils.M4.rotateX(PI$11/2);let r=0;return assert(ts3dutils.V3.X.isParallelTo(e.transformVector(ts3dutils.V3.Z))),t.map(t=>t.transform(e)).forEach((t,s,e)=>{const n=e[(s+1)%e.length];if(t.b.like(ts3dutils.V3.X)){const s=(t.bDir.angleRelativeNormal(n.aDir,ts3dutils.V3.X)+2*PI$11)%(2*PI$11);r+=2/3*s,console.log("xaa")}if(t.b.like(ts3dutils.V3.X.negated())){const s=(t.bDir.angleRelativeNormal(n.aDir,ts3dutils.V3.X)+2*PI$11)%(2*PI$11);r+=2/3*s,console.log("xbb")}const a=ts3dutils.gaussLegendreQuadrature24(function(s){const e=t.curve.at(s).withElement("x",0),r=1/3*(1-(Math.pow(e.y,2)+Math.pow(e.z,2)))*t.tangentAt(s).dot(i.transformVector(e.unit()));return console.log("at2d",e.sce,"result",r),r},t.aT,t.bT);console.log("edge",t,"volume",a),r+=a}),r*this.f1.dot(this.f2.cross(this.f3))},[SemiEllipsoidSurface.name](t){const s=this.inverseMatrix.transformVector(ts3dutils.V3.Z).toAngles(),e=ts3dutils.M4.rotateAB(this.inverseMatrix.transformVector(ts3dutils.V3.Z),ts3dutils.V3.Z).times(ts3dutils.M4.rotateZ(-s.phi)).times(this.inverseMatrix);function i(t){let s=0;return assert(ts3dutils.V3.Z.isParallelTo(e.transformVector(ts3dutils.V3.Z))),t.map(t=>t.transform(e)).forEach((t,e,i)=>{i[(e+1)%i.length];const r=ts3dutils.gaussLegendreQuadrature24(function(s){const e=t.curve.at(s),i=t.curve.tangentAt(s),r=e.lengthXY(),n=e.withElement("z",0);return((e.angleXY()+ts3dutils.TAU-ts3dutils.NLA_PRECISION)%ts3dutils.TAU+ts3dutils.NLA_PRECISION)*Math.sqrt(1-r*r)*r*Math.abs(i.dot(n.unit()))*Math.sign(i.z)},t.aT,t.bT);s+=r}),s}const[r,n]=SemiEllipsoidSurface.splitOnPlaneLoop(t.map(t=>t.transform(e)),ccw);return{volume:(i(r)+i(n))*this.f1.dot(this.f2.cross(this.f3)),centroid:void 0}}},{PI:PI$12}=Math,CalculateAreaVisitor={[ConicSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve||t.curve instanceof HyperbolaCurve||t.curve instanceof ParabolaCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s);return e.minus(this.center).cross(i.rejectedFrom(this.dir)).length()/2},e=t.curve instanceof SemiEllipseCurve?-Math.sign(t.curve.normal.dot(this.dir)):-Math.sign(this.center.to(t.curve.center).cross(t.curve.f1).dot(this.dir));return ts3dutils.glqInSteps(s,t.aT,t.bT,4)*e}if(t.curve instanceof L3$1)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.normal.dot(this.dir))},[PlaneSurface$1.name](t){let s=ts3dutils.V3.O,e=0,i=0,r=0,n=this.surface.right,a=this.surface.up;for(const o of t){let t,l,u,c;if(o instanceof StraightEdge){const e=o.a.lerp(o.b,.5);t=new ts3dutils.V3(e.x,s.y,s.z/2),u=e.dot(n)/2,c=e.dot(a),l=o.a.distanceTo(o.b)*o.curve.dir1.dot(n),l=(o.a.dot(a)+o.b.dot(a))/2*o.b.to(o.a).dot(n)}else{let t=o.curve;if(t instanceof SemiEllipseCurve){let s=t.getAreaInDir(n,a,o.aT,o.bT);l=s.area;let e=this.surface.stPFunc()(s.centroid);u=e.x,c=e.y}else t instanceof BezierCurve?l=t.getAreaInDirSurface(a,this.surface,o.aT,o.bT).area:ts3dutils.assertNever()}e+=l*u,i+=l*c,r+=l}return s=n.times(e).plus(a.times(i)),ts3dutils.assert(isFinite(r)),{area:r,centroid:s}},[CylinderSurface.name](t){return t.map(t=>{if(t.curve instanceof EllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s);return e.dot(this.dir)*i.rejected1Length(this.dir)},e=-Math.sign(t.curve.normal.dot(this.dir)),i=ts3dutils.glqInSteps(s,t.aT,t.bT,4);return console.log("edge",t,i),i*e}if(t.curve instanceof L3$1)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))},[EllipsoidSurface.name](t,s=!0){ts3dutils.assert(this.isVerticalSpheroid());const{f1:e,f2:i,f3:r}=this,n=e.length(),a=r.unit();return t.map(t=>{if(t.curve instanceof EllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.curve.tangentAt(s),r=this.inverseMatrix.transformPoint(e);let o=r.angleXY();ts3dutils.eq(Math.abs(o),PI$12)&&(o=t.curve.normal.isParallelTo(this.f2)?PI$12*-Math.sign((t.bT-t.aT)*t.curve.normal.dot(this.f2)):PI$12*dotCurve(this.f2,i,t.curve.ddt(s)),console.log(o));const l=o*n*Math.sqrt(1-Math.pow(r.z,2)),u=this.matrix.transformVector(new ts3dutils.V3(-r.z*r.x/r.lengthXY(),-r.z*r.y/r.lengthXY(),r.lengthXY())).unit();i.dot(a);return l*u.dot(i)},e=ts3dutils.glqInSteps(s,t.aT,t.bT,1);return console.log("edge",t,e),e}ts3dutils.assertNever()}).sum()*Math.sign(this.f1.cross(this.f2).dot(this.f3))},[SemiCylinderSurface.name](t,s=!0){ts3dutils.assert(this.isVerticalSpheroid());const{f1:e,f2:i,f3:r}=this,n=e.length(),a=r.unit();return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.curve.tangentAt(s),r=this.inverseMatrix.transformPoint(e);let o=r.angleXY();ts3dutils.eq(Math.abs(o),PI$12)&&(o=t.curve.normal.isParallelTo(this.f2)?PI$12*-Math.sign((t.bT-t.aT)*t.curve.normal.dot(this.f2)):PI$12*dotCurve(this.f2,i,t.curve.ddt(s)));const l=o*n*Math.sqrt(1-Math.pow(r.z,2)),u=this.matrix.transformVector(new ts3dutils.V3(-r.z*r.x/r.lengthXY(),-r.z*r.y/r.lengthXY(),r.lengthXY())).unit();i.dot(a);return l*u.dot(i)};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}ts3dutils.assertNever()}).sum()*Math.sign(this.f1.cross(this.f2).dot(this.f3))},[ProjectedCurveSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s);return e.dot(this.dir)*i.rejected1Length(this.dir)},e=-Math.sign(t.curve.normal.dot(this.dir));return ts3dutils.glqInSteps(s,t.aT,t.bT,4)*e}if(t.curve instanceof L3$1)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))},[SemiCylinderSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s);return e.dot(this.dir)*i.rejected1Length(this.dir)},e=-Math.sign(t.curve.normal.dot(this.dir));return ts3dutils.glqInSteps(s,t.aT,t.bT,4)*e}if(t.curve instanceof L3$1)return 0;ts3dutils.assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},{PI:PI$13,min:min$9,max:max$8,ceil:ceil$10}=Math;function projectCurve(t,s,e){if(t instanceof L3$1){const i=s.cross(t.dir1).toLength(e?-1:1);return new PlaneSurface$1(P3.normalOnAnchor(i,t.anchor))}if(t instanceof SemiEllipseCurve){const i=e?s:s.negated();return new SemiCylinderSurface(t,i.unit(),void 0,void 0)}if(t instanceof BezierCurve||t instanceof XiEtaCurve){const i=s.times(e?1:-1);return new ProjectedCurveSurface(t,i,0,1,e?0:-1,e?1:0)}throw new Error}!function(t){function s(s,e=P3.XY,i=ts3dutils.V3.Z,r="extrude"+getGlobalId(),n,a){s=u(s),ts3dutils.assertf(()=>Edge.isLoop(s));const o=new Map,l=new PlaneSurface$1(e),c=ts3dutils.M4.translate(i),h=s.map(t=>t.transform(c,"top")),d=s.length,f=a&&a.extrudeBottom(l,s),p=new PlaneFace(l,s,[],r+"Bottom",f),m=h.map(t=>t.flipped()).reverse(),g=new PlaneSurface$1(e.flipped().translated(i)),P=a&&a.extrudeBottom(g,m),v=new PlaneFace(g,m,[],r+"Top",P);s.forEach(s=>t.registerVertexName(o,s.name+"A",s.a)),m.forEach(s=>t.registerVertexName(o,s.name+"A",s.a));const C=ts3dutils.arrayFromFunction(d,t=>StraightEdge.throughPoints(s[t].a,h[t].a,r+"Rib"+t)),S=s.map((t,e)=>{const n=r+"Wall"+e,o=(e+1)%d,l=[s[e].flipped(),C[e],h[e],C[o].flipped()],u=projectCurve(t.curve,i,t.reversed),c=a&&a.extrudeWall(e,u,l);return Face.create(u,l,void 0,n,c)});return S.push(p,v),n=n||ts3dutils.callsce("B2T.extrudeEdges",s,e,i,r),new B2(S,e.normal1.dot(i)>0,n,o)}function e(t=1,s="sphere"+getGlobalId(),e=ts3dutils.TAU){const r=PCurveEdge.create(new SemiEllipseCurve(ts3dutils.V3.O,new ts3dutils.V3(0,0,-t),new ts3dutils.V3(t,0,0)),new ts3dutils.V3(0,0,-t),new ts3dutils.V3(0,0,t),0,PI$13,void 0,new ts3dutils.V3(t,0,0),new ts3dutils.V3(-t,0,0)),n=ts3dutils.callsce("B2T.sphere",t,s,e);return i([StraightEdge.throughPoints(r.b,r.a),r],e,s,n)}function i(t,s,e,i,r){ts3dutils.assert(!ts3dutils.eq(PI$13,s)||PI$13==s),ts3dutils.assertf(()=>ts3dutils.lt(0,s)&&ts3dutils.le(s,ts3dutils.TAU)),s=ts3dutils.snap(s,ts3dutils.TAU);const n=new PlaneSurface$1(P3.ZX.flipped()).edgeLoopCCW(t)?new PlaneSurface$1(P3.ZX.flipped()):new PlaneSurface$1(P3.ZX);ts3dutils.assertf(()=>Edge.isLoop(t));ceil$10((s-ts3dutils.NLA_PRECISION)/PI$13);const a=!ts3dutils.eq(s,2*PI$13),o=t.map(t=>{const s=t.a,e=s.lengthXY();if(!ts3dutils.eq0(e))return new SemiEllipseCurve(ts3dutils.V(0,0,s.z),ts3dutils.V(e,0,0),ts3dutils.V(0,e,0))}),l=t.map((s,e)=>{const i=(e+1)%t.length;if(s instanceof StraightEdge){const t=s.curve;if(t.dir1.isParallelTo(ts3dutils.V3.Z)){if(ts3dutils.eq0(s.a.x))return;const t=s.a.z>s.b.z,[i,r]=[0,s.b.z-s.a.z].sort(ts3dutils.MINUS);return new SemiCylinderSurface(o[e],t?ts3dutils.V3.Z.negated():ts3dutils.V3.Z,void 0,void 0,i,r)}if(t.dir1.isPerpendicularTo(ts3dutils.V3.Z)){const t=s.a.x>s.b.x;let e=new PlaneSurface$1(new P3(ts3dutils.V3.Z,s.a.z));return t||(e=e.flipped()),e}{const t=s.a,r=s.b,n=t.z-t.x*(r.z-t.z)/(r.x-t.x),a=new ts3dutils.V3(0,0,n),l=s.a.z>s.b.z,u=o[t.x>r.x?e:i],c=ConicSurface.atApexThroughEllipse(a,u);return l!=(-1==c.normalDir)?c.flipped():c}}if(s.curve instanceof SemiEllipseCurve){const t=s.a.z>s.b.z,e=s.curve.rightAngled();ts3dutils.assert(e.normal.isPerpendicularTo(ts3dutils.V3.Z)),ts3dutils.assert(L3$1.Z.containsPoint(e.center));let i=e.f1.length(),r=e.f2.length();return e.isCircular()||(ts3dutils.assert(e.f1.isParallelTo(ts3dutils.V3.Z)&&e.f2.isParallelTo(ts3dutils.V3.X)||e.f2.isParallelTo(ts3dutils.V3.Z)&&e.f1.isParallelTo(ts3dutils.V3.X)),e.f1.isParallelTo(ts3dutils.V3.Z)&&([i,r]=[r,i])),SemiEllipsoidSurface.forABC(i,(t?-1:1)*i,r,e.center)}ts3dutils.assert(!1,s)});let u,c=t;const h=[];for(let i=0;i<s;i+=PI$13){const n=0,a=min$9(s-i,PI$13),d=ts3dutils.M4.rotateZ(i+a);ts3dutils.M4.rotateZ(i);u=i+a==ts3dutils.TAU?t:t.map(t=>t.transform(d));const f=ts3dutils.arrayFromFunction(t.length,t=>{const s=c[t].a,r=s.lengthXY(),l=u[t].a;if(!ts3dutils.eq0(r)){const r=0==i?o[t]:o[t].rotateZ(i);return new PCurveEdge(r,s,l,n,a,void 0,r.tangentAt(n),r.tangentAt(a),e+"rib"+t)}});for(let s=0;s<t.length;s++)if(l[s]){const n=c[s],a=(s+1)%t.length,o=[c[s].flipped(),!ts3dutils.eq0(n.a.x)&&f[s],u[s],!ts3dutils.eq0(n.b.x)&&f[a].flipped()].filter(t=>t),d=0==i?l[s]:l[s].rotateZ(i),p=r&&r.extrudeWall(s,d,o,void 0);h.push(Face.create(d,o,void 0,e+"Wall"+s,p))}c=u}if(a){const i=Edge.reversePath(u),a=r&&r.rotationStart(n,t,void 0),o=r&&r.rotationEnd(n.flipped().rotateZ(s),i,void 0);h.push(new PlaneFace(n,t,void 0,e+"start",a),new PlaneFace(n.flipped().rotateZ(s),i,void 0,e+"end",o))}const d=new PlaneSurface$1(P3.ZX).edgeLoopCCW(t);return new B2(h,d,i)}t.box=function(s=1,e=1,i=1,r){ts3dutils.assertNumbers(s,e,i),ts3dutils.assertInst("string"==typeof r);const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(0,e,0),new ts3dutils.V3(s,e,0),new ts3dutils.V3(s,0,0)],a=ts3dutils.callsce("B2T.box",s,e,i,r);return t.extrudeVertices(n,P3.XY.flipped(),new ts3dutils.V3(0,0,i),r,a)},t.puckman=function(s,e,i,r){ts3dutils.assertf(()=>ts3dutils.lt(0,s)),ts3dutils.assertf(()=>ts3dutils.lt(0,e)&&ts3dutils.le(e,ts3dutils.TAU)),ts3dutils.assertf(()=>ts3dutils.lt(0,i));const n=StraightEdge.chain([ts3dutils.V3.O,new ts3dutils.V3(s,0,0),new ts3dutils.V3(s,0,i),new ts3dutils.V3(0,0,i)],!0);return t.rotateEdges(n,e,r||"puckman"+getGlobalId())},t.registerVertexName=function(t,s,e){Array.from(t.keys()).some(t=>t.like(e))||t.set(e,s)},t.extrudeEdges=s,t.cylinder=function(t=1,s=1,e=ts3dutils.TAU,r="cylinder"+getGlobalId()){const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,0),new ts3dutils.V3(t,0,s),new ts3dutils.V3(0,0,s)];return i(StraightEdge.chain(n,!0),e,r)},t.cone=function(t=1,s=1,e=ts3dutils.TAU,r="cone"+getGlobalId()){const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,s),new ts3dutils.V3(0,0,s)];return i(StraightEdge.chain(n,!0),e,r)},t.sphere=e,t.menger=function(s=2,e="menger"+getGlobalId()){let i=t.box(1,1,1);if(0==s)return i;const r=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped();function n(t,s){if(i=i.and(r.transform(s)),a=i,t>1){const e=s.times(ts3dutils.M4.scale(1/3,1/3,1));for(let s=0;s<9;s++)4!=s&&n(t-1,e.times(ts3dutils.M4.translate(s%3,s/3|0,0)))}}return n(s,ts3dutils.M4.IDENTITY),n(s,ts3dutils.M4.YZX),n(s,ts3dutils.M4.ZXY),i},t.menger2=function(s=2,e="menger"+getGlobalId()){if(0==s)return t.box(1,1,1);const i=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped(),r=[];!function t(s,e){if(r.push(...i.transform(e).faces),s>1){const i=e.times(ts3dutils.M4.scale(1/3,1/3,1));for(let e=0;e<9;e++)4!=e&&t(s-1,i.times(ts3dutils.M4.translate(e%3,e/3|0,0)))}}(s,ts3dutils.M4.IDENTITY);const n=new B2(r,!0);return t.box().and(n).and(n.transform(ts3dutils.M4.YZX)).and(n.transform(ts3dutils.M4.ZXY))},t.torus=function(s,e,i,r){ts3dutils.assertNumbers(s,e,i),ts3dutils.assertf(()=>e>s);const n=SemiEllipseCurve.semicircle(s,new ts3dutils.V3(e,0,0)),a=[PCurveEdge.forCurveAndTs(n,-Math.PI,0),PCurveEdge.forCurveAndTs(n,0,Math.PI)];return t.rotateEdges(a,i,r||"torus"+getGlobalId())},t.torusUnsplit=function(s,e,i,r){ts3dutils.assertNumbers(s,e,i),ts3dutils.assertf(()=>e>s);const n=PCurveEdge.forCurveAndTs(SemiEllipseCurve.semicircle(s,new ts3dutils.V3(e,0,0)),-Math.PI,Math.PI);return t.rotateEdges([n],i,r||"torus"+getGlobalId())},t.rotateEdges=i,t.quaffle=function(){const s=t.sphere(1).translate(0,1.7).flipped(),e=new B2(t.TETRAHEDRON_VERTICES.flatMap(t=>s.rotateAB(ts3dutils.V3.Y,t).faces),!1);return t.sphere().and(e)},t.extrudeFace=function(t,e){return new B2(s(t.contour,t.surface.plane,e).faces.slice(0,-2).concat(t,t.translate(e.x,e.y,e.z).flipped(),t.holes.flatMap(i=>s(i,t.surface.plane.flipped(),e).faces.slice(0,-2))),!1)},t.loadFonts=function(){return o("fonts/FiraSansMedium.woff").then(s=>t.defaultFont=s)};const n=new Map;function o(t){return new Promise(function(s,e){const i=n.get(t);i?s(i):opentype.load(t,function(i,r){i?e(i):(n.set(t,r),s(r))})})}function l(s,e,i=1,r=t.defaultFont){const n=[];r.getPath(s,0,0,e).commands.forEach(t=>{"M"==t.type&&n.push([]),n.last.push(t)});const a=n.map(t=>{const s=new opentype.Path;s.commands=t;const e=Edge.reversePath(Edge.pathFromSVG(s.toPathData(13))).map(t=>t.mirrorY());return ts3dutils.assert(Edge.isLoop(e)),e}),o=Face.assembleFacesFromLoops(a,new PlaneSurface$1(P3.XY),PlaneFace),l=`B2T.text(${s.sce}, ${e}, ${i})`;return B2.join(o.map(s=>t.extrudeFace(s,ts3dutils.V(0,0,-i))),l)}function u(t){return t.flatMap(t=>{const s=t.curve;if(s instanceof EllipseCurve){return(t.minT<0&&t.maxT>0?t.split(0):[t]).map(t=>t.minT>=0?Edge.create(new SemiEllipseCurve(s.center,s.f1,s.f2,max$8(0,s.tMin),s.tMax),t.a,t.b,t.aT,t.bT,void 0,t.aDir,t.bDir,t.name):Edge.create(new SemiEllipseCurve(s.center,s.f1.negated(),s.f2.negated(),s.tMin+PI$13,min$9(PI$13,s.tMax+PI$13)),t.a,t.b,t.aT+PI$13,t.bT+PI$13,void 0,t.aDir,t.bDir,t.name))}return s instanceof BezierCurve&&t.a.like(t.b)?t.split(ts3dutils.lerp(t.aT,t.bT,.5)):t})}t.loadFont=o,t.loadFontsAsync=function(s){t.defaultFont?s():opentype.load("fonts/FiraSansMedium.woff",function(e,i){if(e)throw new Error("Could not load font: "+e);t.defaultFont=i,s()})},t.text=l,t.minorityReport=function(){const s=t.sphere(),e=t.text("LEO CROW",64,128).scale(.1/32).translate(-.5,-.05,1.2).flipped(),i=t.sphere(.98);return s.and(e).plus(i)},t.whatever=function(){const t=p(),s=B2.join(t.faces.map((t,s)=>{const e=l(""+(s+1),.4,-2),i=t.contour.map(t=>t.a).reduce((t,s)=>t.plus(s),ts3dutils.V3.O).div(3),r=ts3dutils.M4.forSys(t.contour[0].aDir,i.cross(t.contour[0].aDir),i.unit(),i);return e.transform(r.times(ts3dutils.M4.translate(-e.getAABB().size().x/2,-.1,-.04)))})),i=e(.9);return t.and(i).and(s)},t.d20=function(){const t=p(),s=B2.join(t.faces.map((t,s)=>{const e=l(""+(s+1),.4,-2),i=t.contour.map(t=>t.a).reduce((t,s)=>t.plus(s),ts3dutils.V3.O).div(3),r=ts3dutils.M4.forSys(t.contour[0].aDir,i.cross(t.contour[0].aDir),i.unit(),i);return e.transform(r.times(ts3dutils.M4.translate(-e.getAABB().size().x/2,-.1,-.04)))})),i=e(.9);return t.and(i).and(s)},t.rotStep=function(t,s,e){const i=s/e,n=!ts3dutils.eq(s,2*PI$13),a=n?e+1:e,o=ts3dutils.arrayFromFunction(a,s=>{if(0==s)return t;const e=ts3dutils.M4.rotateZ(i*s);return t.map(t=>t.transform(e))}),l=ts3dutils.arrayFromFunction(e,s=>{const e=(s+1)%a;return ts3dutils.arrayFromFunction(t.length,i=>{if(!ts3dutils.eq0(t[i].a.lengthXY()))return StraightEdge.throughPoints(o[s][i].a,o[e][i].a)})}),u=[];let c;if(t.forEach((s,i)=>{const h=(i+1)%t.length,d=ts3dutils.V3.O,f=projectCurve(o[r][i],d,o[r][i].deltaT()<0);if(s instanceof StraightEdge&&s.curve.dir1.isPerpendicularTo(ts3dutils.V3.Z)){const t=s.a.x>s.b.x;if(f=new PlaneSurface$1(t?new P3(ts3dutils.V3.Z,s.a.z):new P3(ts3dutils.V3.Z.negated(),-s.a.z)),n){const t=[];ts3dutils.eq0(s.a.x)||t.push(...ts3dutils.arrayFromFunction(e,t=>l[t][i])),t.push(o[e][i]),ts3dutils.eq0(s.b.x)||t.push(...ts3dutils.arrayFromFunction(e,t=>l[e-t-1][h].flipped())),t.push(s.flipped()),c=new PlaneFace(f,t)}else{const r=t?ts3dutils.arrayFromFunction(e,t=>l[t][i]):ts3dutils.arrayFromFunction(e,t=>l[e-t-1][h].flipped());let n;t&&!ts3dutils.eq0(s.b.x)?n=ts3dutils.arrayFromFunction(e,t=>l[e-t-1][h].flipped()):t||ts3dutils.eq0(s.a.x)||(n=ts3dutils.arrayFromFunction(e,t=>l[t][i])),c=new PlaneFace(f,r,n?[n]:[])}u.push(c)}else if(!(s instanceof StraightEdge&&ts3dutils.eq0(s.a.lengthXY())&&ts3dutils.eq0(s.b.lengthXY())))for(let t=0;t<e;t++){const e=(t+1)%a,r=[o[t][i].flipped(),l[t][i],o[e][i],l[t][h]&&l[t][h].flipped()].filter(t=>t);if(s instanceof StraightEdge){const t=new PlaneSurface$1(P3.throughPoints(r[0].a,r[1].a,r[2].a));u.push(new PlaneFace(t,r))}else ts3dutils.assert(!1,s.toString())}}),n){const i=o[e].map(t=>t.flipped()).reverse(),r=new PlaneFace(new PlaneSurface$1(P3.ZX.rotateZ(s)),i);u.push(new PlaneFace(new PlaneSurface$1(P3.ZX.flipped()),t),r)}return new B2(u)},t.fixEdges=u,t.extrudeVertices=function(s,e,i,r,n){ts3dutils.assert(s.every(t=>t instanceof ts3dutils.V3),"baseVertices.every(v => v instanceof V3)"),ts3dutils.assertInst(P3,e),ts3dutils.assertVectors(i),e.normal1.dot(i)>0&&(e=e.flipped());const a=StraightEdge.chain(s,!0);return n=n||ts3dutils.callsce("B2T.extrudeVertices",s,e,i,r),t.extrudeEdges(a,e,i,r,n)},t.tetrahedron=function(t,s,e,i,r="tetra"+getGlobalId()){ts3dutils.assertVectors(t,s,e,i);const n=P3.throughPoints(t,s,e).distanceToPointSigned(i);if(ts3dutils.eq0(n))throw new Error("four points are coplanar");n>0&&([e,i]=[i,e]);const a=StraightEdge.throughPoints(t,s),o=StraightEdge.throughPoints(t,e),l=StraightEdge.throughPoints(t,i),u=StraightEdge.throughPoints(s,e),c=StraightEdge.throughPoints(s,i),h=StraightEdge.throughPoints(e,i),d=[new PlaneFace(PlaneSurface$1.throughPoints(t,s,e),[a,u,o.flipped()],[],r+"abc"),new PlaneFace(PlaneSurface$1.throughPoints(t,i,s),[l,c.flipped(),a.flipped()],[],r+"adb"),new PlaneFace(PlaneSurface$1.throughPoints(s,i,e),[c,h.flipped(),u.flipped()],[],r+"bdc"),new PlaneFace(PlaneSurface$1.throughPoints(e,i,t),[h,l.flipped(),o],[],r+"cda")],f=`B2T.tetrahedron(${t.sce}, ${s.sce}, ${e.sce}, ${i.sce})`;return new B2(d,!1,f)};const c=1/ts3dutils.GOLDEN_RATIO,h=2-ts3dutils.GOLDEN_RATIO;t.TETRAHEDRON_VERTICES=[new ts3dutils.V3(1,0,-1/Math.sqrt(2)),new ts3dutils.V3(-1,0,-1/Math.sqrt(2)),new ts3dutils.V3(0,-1,1/Math.sqrt(2)),new ts3dutils.V3(0,1,1/Math.sqrt(2))].map(t=>t.unit()),t.DODECAHEDRON_VERTICES=[new ts3dutils.V3(h,0,1),new ts3dutils.V3(-h,0,1),new ts3dutils.V3(-c,c,c),new ts3dutils.V3(0,1,h),new ts3dutils.V3(c,c,c),new ts3dutils.V3(c,-c,c),new ts3dutils.V3(0,-1,h),new ts3dutils.V3(-c,-c,c),new ts3dutils.V3(h,0,-1),new ts3dutils.V3(-h,0,-1),new ts3dutils.V3(-c,-c,-c),new ts3dutils.V3(0,-1,-h),new ts3dutils.V3(c,-c,-c),new ts3dutils.V3(c,c,-c),new ts3dutils.V3(0,1,-h),new ts3dutils.V3(-c,c,-c),new ts3dutils.V3(1,h,0),new ts3dutils.V3(-1,h,0),new ts3dutils.V3(-1,-h,0),new ts3dutils.V3(1,-h,0)].map(t=>t.unit()),t.DODECAHEDRON_FACE_VERTICES=[[4,3,2,1,0],[7,6,5,0,1],[12,11,10,9,8],[15,14,13,8,9],[14,3,4,16,13],[3,14,15,17,2],[11,6,7,18,10],[6,11,12,19,5],[4,0,5,19,16],[12,8,13,16,19],[15,9,10,18,17],[7,1,2,17,18]],t.OCTAHEDRON_VERTICES=[new ts3dutils.V3(1,0,0),new ts3dutils.V3(-1,0,0),new ts3dutils.V3(0,1,0),new ts3dutils.V3(0,-1,0),new ts3dutils.V3(0,0,1),new ts3dutils.V3(0,0,-1)],t.OCTAHEDRON_FACE_VERTICES=[[0,2,4],[2,1,4],[1,3,4],[3,0,4],[2,0,5],[1,2,5],[3,1,5],[0,3,5]];const{x:d,y:f}=new ts3dutils.V3(1,ts3dutils.GOLDEN_RATIO,0).unit();function p(){return m(t.ISOCAHEDRON_VERTICES,t.ISOCAHEDRON_FACE_VERTICES,"B2T.octahedron()")}function m(t,s,e){const i=new Map,r=s.map(s=>{const e=PlaneSurface$1.throughPoints(t[s[0]],t[s[1]],t[s[2]]),r=ts3dutils.arrayFromFunction(s.length,e=>{const r=(e+1)%s.length,n=s[e],a=s[r],o=min$9(n,a),l=max$8(n,a),u=o*t.length+l;let c=i.get(u);return!c&&i.set(u,c=StraightEdge.throughPoints(t[o],t[l])),n<a?c:c.flipped()});return new PlaneFace(e,r)});return new B2(r,!1,e)}t.ISOCAHEDRON_VERTICES=[new ts3dutils.V3(-d,f,0),new ts3dutils.V3(d,f,0),new ts3dutils.V3(-d,-f,0),new ts3dutils.V3(d,-f,0),new ts3dutils.V3(0,-d,f),new ts3dutils.V3(0,d,f),new ts3dutils.V3(0,-d,-f),new ts3dutils.V3(0,d,-f),new ts3dutils.V3(f,0,-d),new ts3dutils.V3(f,0,d),new ts3dutils.V3(-f,0,-d),new ts3dutils.V3(-f,0,d)],t.ISOCAHEDRON_FACE_VERTICES=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],t.dodecahedron=function(){return m(t.DODECAHEDRON_VERTICES,t.DODECAHEDRON_FACE_VERTICES,"B2T.dodecahedron()")},t.octahedron=function(){return m(t.OCTAHEDRON_VERTICES,t.OCTAHEDRON_FACE_VERTICES,"B2T.octahedron()")},t.isocahedron=p,t.pyramidEdges=function(t,s,e="pyramid"+getGlobalId()){ts3dutils.assertInst(Edge,...t),ts3dutils.assertVectors(s);const i=t.map(t=>StraightEdge.throughPoints(s,t.a)),r=t.map((s,r)=>{const n=e+"Wall"+r,a=(r+1)%t.length,o=[i[r],s,i[a].flipped()];return Face.create(void 0,o,void 0,n)}),n=Face.create(baseSurface,t);r.push(n);const a=ts3dutils.callsce("B2T.pyramidEdges",t,s,e);return new B2(r,!1,a,e)}}(exports.B2T||(exports.B2T={}));class CustomPlane extends P3{constructor(t,s,e,i,r=ts3dutils.randomColor(),n=-500,a=500,o=-500,l=500){const{normal1:u,w:c}=P3.forAnchorAndPlaneVectors(t,s,e);super(u,c),this.up=e,this.right=s,this.sMin=n,this.sMax=a,this.tMin=o,this.tMax=l,this.color=r,this.name=i}get plane(){return this}toPlaneSurface(){return new PlaneSurface$1(this,this.right,this.up)}static forPlane(t,s,e){const i=t.normal1.getPerpendicular().unit(),r=i.cross(t.normal1);return new CustomPlane(t.anchor,r,i,e,s)}static fromPlaneSurface(t){return new CustomPlane(t.plane.anchor,t.right,t.up,"genCustomPlane"+getGlobalId())}distanceTo(t,s){return[new L3$1(this.anchor.plus(this.right.times(this.sMin)),this.up),new L3$1(this.anchor.plus(this.right.times(this.sMax)),this.up),new L3$1(this.anchor.plus(this.up.times(this.tMin)),this.right),new L3$1(this.anchor.plus(this.up.times(this.tMax)),this.right)].map((e,i)=>{const r=e.infoClosestToLine(t);return(isNaN(r.t)||i<2&&this.tMin<=r.t&&r.t<=this.tMax||i>=2&&this.sMin<=r.t&&r.t<=this.sMax)&&r.distance<=s?r.s:1/0}).min()}distanceTo2(t,s){return[new L3$1(this.anchor.plus(this.right.times(this.sMin)),this.up),new L3$1(this.anchor.plus(this.right.times(this.sMax)),this.up),new L3$1(this.anchor.plus(this.up.times(this.tMin)),this.right),new L3$1(this.anchor.plus(this.up.times(this.tMax)),this.right)].map((e,i)=>{const r=e.infoClosestToLine(t);return(isNaN(r.t)||i<2&&this.tMin<=r.t&&r.t<=this.tMax||i>=2&&this.sMin<=r.t&&r.t<=this.sMax)&&r.distance<=s?r.distance:1/0}).min()}}const{PI:PI$14,sign:sign$8,ceil:ceil$11,floor:floor$9,abs:abs$11}=Math;class Edge extends ts3dutils.Transformable{constructor(t,s,e,i,r,n,a){super(),this.curve=t,this.a=s,this.b=e,this.aT=i,this.bT=r,this.flippedOf=n,this.name=a,ts3dutils.assertNumbers(i,r),ts3dutils.assert(!ts3dutils.eq(i,r)),ts3dutils.assertVectors(s,e),ts3dutils.assertf(()=>t instanceof Curve,t),ts3dutils.assertf(()=>!t.isValidT||t.isValidT(i)&&t.isValidT(r),i+" "+r),ts3dutils.assertf(()=>t.at(i).like(s),+s),ts3dutils.assertf(()=>t.at(r).like(e),""+t.at(r)+e),ts3dutils.assertf(()=>ts3dutils.fuzzyBetween(i,t.tMin,t.tMax)),ts3dutils.assertf(()=>ts3dutils.fuzzyBetween(r,t.tMin,t.tMax)),this.aT=ts3dutils.clamp(i,t.tMin,t.tMax),this.bT=ts3dutils.clamp(r,t.tMin,t.tMax),this.reversed=this.aT>this.bT}get minT(){return Math.min(this.aT,this.bT)}get maxT(){return Math.max(this.aT,this.bT)}static forCurveAndTs(t,s=t.tMin,e=t.tMax){return Edge.create(t,t.at(s),t.at(e),s,e,void 0,s<e?t.tangentAt(s):t.tangentAt(s).negated(),s<e?t.tangentAt(e):t.tangentAt(e).negated())}static create(t,s,e,i,r,n,a,o,l){return t instanceof L3$1?new StraightEdge(t,s,e,i,r,n,l):new PCurveEdge(t,s,e,i,r,n,a,o,l)}static isLoop(t){return t.every((s,e)=>s.b.like(t[(e+1)%t.length].a))}static edgesIntersect(t,s){ts3dutils.assertNumbers(t.curve.hlol,s.curve.hlol),ts3dutils.assertInst(Edge,t,s),t.curve.hlol<s.curve.hlol&&([s,t]=[t,s]);const e=t.curve.isInfosWithCurve(s.curve);return e.some(t=>isNaN(t.tThis)||isNaN(t.tOther))&&(console.log(t.sce),console.log(s.sce),ts3dutils.assert(!1)),e.some(({tThis:e,tOther:i})=>t.tValueInside(e)&&s.tValueInside(i))}static assertLoop(t){t.forEach((s,e)=>{const i=(e+1)%t.length;ts3dutils.assert(s.b.like(t[i].a),`edges[${e}].b != edges[${i}].a (${t[e].b.sce} != ${t[i].a.sce})`)})}static ngon(t=3,s=1){return StraightEdge.chain(ts3dutils.arrayFromFunction(t,e=>ts3dutils.V3.polar(s,ts3dutils.TAU*e/t)))}static star(t=5,s=1,e=.5){const i=ts3dutils.arrayFromFunction(2*t,i=>ts3dutils.V3.polar(0==i%2?s:e,ts3dutils.TAU*i/t/2));return StraightEdge.chain(i)}static reversePath(t,s=!0){return s?ts3dutils.arrayFromFunction(t.length,s=>t[t.length-1-s].flipped()):t}static rect(t=1,s=t){const e=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,0),new ts3dutils.V3(t,s,0),new ts3dutils.V3(0,s,0)];return StraightEdge.chain(e)}static reuleaux(t=3,s=1){ts3dutils.assert(3<=t),ts3dutils.assert(1==t%2);const e=ts3dutils.arrayFromFunction(t,e=>ts3dutils.V3.polar(s,ts3dutils.TAU*e/t));return ts3dutils.arrayFromFunction(t,s=>{const i=(s+floor$9(t/2))%t,r=(s+ceil$11(t/2))%t,n=e[i],a=e[r],o=e[s],l=o.to(n),u=new SemiEllipseCurve(o,l,ts3dutils.V3.Z.cross(l));return Edge.create(u,n,a,0,u.pointT(a),void 0,ts3dutils.V3.Z.cross(l),ts3dutils.V3.Z.cross(o.to(a)))})}static round(t,s){if(ts3dutils.eq0(s))return t;const e=t.map((e,i)=>{const r=(i+1)%t.length,n=t[r];if(!e.b.like(n.a))return;const a=e.bDir.angleTo(n.aDir),o=e.curve,l=n.curve;if(o instanceof L3$1&&l instanceof L3$1){const t=o.dir1.cross(l.dir1);if(ts3dutils.eq0(a))return;const e=t.cross(o.dir1),i=t.cross(l.dir1),r=o.transform(ts3dutils.M4.translate(e.toLength(s))),n=l.transform(ts3dutils.M4.translate(i.toLength(s))),u=r.isInfoWithLine(n);if(!u)throw new Error("tangential curves");const c=u.plus(e.toLength(-s)),h=u.plus(i.toLength(-s)),d=e.toLength(-s),f=new SemiEllipseCurve(u,d,t.cross(d).toLength(s));return Edge.create(f,c,h,0,f.pointT(h),void 0,o.dir1,l.dir1)}return Edge.arbitraryCorner(e,n,s)});return t.flatMap((s,i)=>{const r=(i+t.length-1)%t.length,n=(t.length,e[r]),a=e[i];if(!n&&!a)return s;const[o,l,u]=n?[s.curve.pointT(n.b),n.b,n.bDir]:[s.aT,s.a,s.aDir],[c,h,d]=a?[s.curve.pointT(a.a),a.a,a.aDir]:[s.bT,s.b,s.bDir],f=Edge.create(s.curve,l,h,o,c,void 0,u,d);return a?[f,a]:f})}static arbitraryCorner(t,s,e){const i=t.curve,r=s.curve;const n=t.bT-e*sign$8(t.deltaT())/t.bDir.length(),a=s.aT+e*sign$8(s.deltaT())/s.aDir.length(),[o,l]=ts3dutils.newtonIterate(function([t,s]){const n=i.at(t),a=r.at(s),o=i.tangentAt(t),l=r.tangentAt(s),u=o.cross(l),c=u.cross(o).unit(),h=u.cross(l).unit(),d=c.cross(h);u.likeO()&&ts3dutils.assert(!1);const f=n.to(a);ts3dutils.eq0(f.dot(u))||ts3dutils.assert(!1);const p=new L3$1(n,c),m=new L3$1(a,h),g=(p.infoClosestToLine(m),p.isInfoWithLine(m),f.cross(h).dot(d)/d.squared()),P=f.cross(c).dot(d)/d.squared(),v=n.plus(c.times(g)),C=a.plus(h.times(P));return ts3dutils.assert(v.like(C)),[abs$11(g)-e,abs$11(P)-e]},[n,a]),u=t.curve.at(o),c=s.curve.at(l),h=(i.at(o),r.at(l),i.tangentAt(o)),d=r.tangentAt(l),f=h.cross(d),p=f.cross(h).unit(),m=(f.cross(d).unit(),p.toLength(-e)),g=u.minus(m),P=new SemiEllipseCurve(g,m,f.cross(m).toLength(e));return Edge.create(P,u,c,0,P.pointT(c),void 0,i.tangentAt(o),r.tangentAt(l))}static pathFromSVG(t){let s=void 0;const e=new svgPathdata.SVGPathData(t).toAbs().normalizeHVZ().sanitize(ts3dutils.NLA_PRECISION).annotateArcs().commands,i=[];for(const t of e){ts3dutils.assert("x"in t&&"y"in t);const e=new ts3dutils.V3(t.x,t.y,0);switch(t.type){case svgPathdata.SVGPathData.LINE_TO:i.push(StraightEdge.throughPoints(s,e));break;case svgPathdata.SVGPathData.CURVE_TO:{const r=new ts3dutils.V3(t.x1,t.y1,0),n=new ts3dutils.V3(t.x2,t.y2,0),a=new BezierCurve(s,r,n,e,0,1),o=new PCurveEdge(a,s,e,0,1,void 0,a.tangentAt(0),a.tangentAt(1));i.push(o);break}case svgPathdata.SVGPathData.QUAD_TO:{const r=new ts3dutils.V3(t.x1,t.y1,0),n=ParabolaCurve.quadratic(s,r,e).rightAngled(),a=new PCurveEdge(n,s,e,n.tMin,n.tMax,void 0,n.tangentAt(n.tMin),n.tangentAt(n.tMax));i.push(a);break}case svgPathdata.SVGPathData.ARC:{const r=t.phi1*ts3dutils.DEG,n=t.phi2*ts3dutils.DEG,[a,o]=[r,n].sort(ts3dutils.MINUS),l=ts3dutils.arrayRange(-3,4,1).map(t=>t*PI$14).filter(t=>a<=t&&t<=o),u=ts3dutils.V(t.cX,t.cY),c=ts3dutils.V3.polar(t.rX,t.xRot*ts3dutils.DEG),h=ts3dutils.V3.polar(t.rY,t.xRot*ts3dutils.DEG+Math.PI/2),d=ts3dutils.getIntervals(l,a,o).map(([t,i])=>{const a=i-t,o=ts3dutils.mod(t,ts3dutils.TAU),l=o+a;ts3dutils.assert(o>=0==l>=0);const d=o>PI$14||l>PI$14,f=d?o-PI$14:o,p=d?l-PI$14:l,m=new SemiEllipseCurve(u,d?c.negated():c,d?h.negated():h),g=r==t?s:n==t?e:m.at(f),P=r==i?s:n==i?e:m.at(p);return new PCurveEdge(m,g,P,f,p,void 0,m.tangentAt(f),m.tangentAt(p))});i.push(...t.phiDelta>0?d:Edge.reversePath(d));break}}s=e}return i}toString(){return ts3dutils.callsce("new "+this.constructor.name,this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir)}split(t){const s=this.curve.at(t),e=this.tangentAt(t);return[Edge.create(this.curve,this.a,s,this.aT,t,void 0,this.aDir,e,this.name+"left"),Edge.create(this.curve,s,this.b,t,this.bT,void 0,e,this.bDir,this.name+"left")]}colinearToLine(t){return this.curve instanceof L3$1&&this.curve.isColinearTo(t)}tValueInside(t){return this.aT<this.bT?ts3dutils.lt(this.aT,t)&&ts3dutils.lt(t,this.bT):ts3dutils.lt(this.bT,t)&&ts3dutils.lt(t,this.aT)}isValidT(t){return this.aT<this.bT?ts3dutils.le(this.aT,t)&&ts3dutils.le(t,this.bT):ts3dutils.le(this.bT,t)&&ts3dutils.le(t,this.aT)}clampedT(t){return this.aT<this.bT?ts3dutils.clamp(t,this.aT,this.bT):ts3dutils.clamp(t,this.bT,this.aT)}equals(t){return this===t||this.constructor==t.constructor&&this.a.equals(t.a)&&this.b.equals(t.b)&&this.curve.equals(t.curve)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.a.hashCode())+this.b.hashCode())+this.curve.hashCode())}like(t){return this===t||t instanceof Edge&&this.curve.isColinearTo(t.curve)&&this.a.like(t.a)&&this.b.like(t.b)}isCanon(){return!this.reversed}getCanon(){return this.reversed?this.flipped():this}overlaps(t,s){ts3dutils.assert(this.curve.isColinearTo(t.curve));const e=this.curve.containsPoint(t.a)&&this.curve.pointT(t.a),i=this.curve.containsPoint(t.b)&&this.curve.pointT(t.b);if(!1===e&&!1===i)return!s&&t.overlaps(this,!0);!1!==e?this.tangentAt(e).dot(t.aDir):this.tangentAt(i).dot(t.bDir);return!(ts3dutils.le(edgeMaxT,this.minT)||ts3dutils.le(this.maxT,edgeMinT))}getAABB(){const t=[1/0,1/0,1/0],s=[-1/0,-1/0,-1/0];this.curve.roots().forEach((e,i)=>{e.forEach(e=>{ts3dutils.lt(this.minT,e)&&ts3dutils.lt(e,this.maxT)&&(t[i]=Math.min(t[i],this.curve.at(e).e(i)),s[i]=Math.max(s[i],this.curve.at(e).e(i)))})});const e=new ts3dutils.AABB(ts3dutils.V(t),ts3dutils.V(s));return e.addPoint(this.a),e.addPoint(this.b),e}length(t=1){return this.curve.arcLength(this.minT,this.maxT,t)}deltaT(){return this.bT-this.aT}atAvgT(){return this.curve.at((this.minT+this.maxT)/2)}}class PCurveEdge extends Edge{constructor(t,s,e,i,r,n,a,o,l){super(t,s,e,i,r,n,l),this.flippedOf=n,this.aDir=a,this.bDir=o,ts3dutils.assertVectors(a,o),ts3dutils.assertf(()=>!a.likeO(),t),ts3dutils.assertf(()=>!o.likeO(),t),t instanceof PICurve$1||(ts3dutils.assertf(()=>t.tangentAt(i).likeOrReversed(a),""+i+t.tangentAt(i).sce+" "+a.sce),ts3dutils.assertf(()=>t.tangentAt(r).likeOrReversed(o))),ts3dutils.assert(this.reversed===this.aDir.dot(t.tangentAt(i))<0,i+" "+r+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(i)),ts3dutils.assert(this.reversed===this.bDir.dot(t.tangentAt(r))<0,i+" "+r+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(i))}static forCurveAndTs(t,s,e,i){return new PCurveEdge(t,t.at(s),t.at(e),s,e,void 0,s<e?t.tangentAt(s):t.tangentAt(s).negated(),s<e?t.tangentAt(e):t.tangentAt(e).negated(),i)}toSource(){return ts3dutils.callsce("new PCurveEdge",this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir,this.name)}getVerticesNo0(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!1)}pointsCount(){return this.points().length}points(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!0)}rotViaPlane(t,s){let e=this.aDir.angleRelativeNormal(this.bDir,t);return t.dot(this.curve.normal)>0==!this.reversed?e<0&&(e+=2*Math.PI):e>0&&(e-=2*Math.PI),e}edgeISTsWithSurface(t){return this.curve.isTsWithSurface(t).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}edgeISTsWithPlane(t){return this.curve.isTsWithPlane(t).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(t){return this.reversed?this.curve.tangentAt(t).negated():this.curve.tangentAt(t)}flipped(){return this.flippedOf||(this.flippedOf=new PCurveEdge(this.curve,this.b,this.a,this.bT,this.aT,this,this.bDir.negated(),this.aDir.negated(),this.name))}transform(t,s){return new PCurveEdge(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT,this.bT,void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+s)}isCoEdge(t){return this===t||this===t.flippedOf||this.curve.isColinearTo(t.curve)&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}}class StraightEdge extends Edge{constructor(t,s,e,i,r,n,a){super(t,s,e,i,r,n,a),this.flippedOf=n,ts3dutils.assertInst(L3$1,t),!n||ts3dutils.assertInst(StraightEdge,n),!a||ts3dutils.assertf(()=>"string"==typeof a,a),ts3dutils.assert(!s.like(e),"!a.like(b)"+s+e),this.tangent=this.aT<this.bT?this.curve.dir1:this.curve.dir1.negated()}get aDir(){return this.tangent}get bDir(){return this.tangent}static throughPoints(t,s,e){return new StraightEdge(L3$1.throughPoints(t,s,0,t.to(s).length()),t,s,0,t.to(s).length(),void 0,e)}static chain(t,s=!0){const e=t.length;return ts3dutils.arrayFromFunction(s?e:e-1,s=>StraightEdge.throughPoints(t[s],t[(s+1)%e]))}toSource(){return ts3dutils.callsce("new StraightEdge",this.curve,this.a,this.b,this.aT,this.bT)}getVerticesNo0(){return[this.b]}pointsCount(){return 2}points(){return[this.a,this.b]}edgeISTsWithPlane(t){const s=ts3dutils.snap2(this.curve.isTWithPlane(t),this.aT,this.bT);return this.minT<=s&&s<=this.maxT?[s]:[]}edgeISTsWithSurface(t){return t instanceof PlaneSurface$1?this.edgeISTsWithPlane(t.plane):t.isTsForLine(this.curve).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(){return this.tangent}flipped(){return this.flippedOf||(this.flippedOf=new StraightEdge(this.curve,this.b,this.a,this.bT,this.aT,this,this.name))}transform(t,s){const e=t.transformVector(this.curve.dir1).length();return new StraightEdge(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT*e,this.bT*e,void 0,""+this.name+s)}isCoEdge(t){return this===t||this===t.flippedOf||t.constructor===StraightEdge&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}getEdgeT(t){ts3dutils.assertVectors(t);let s=t.minus(this.curve.anchor).dot(this.curve.dir1);if(ts3dutils.eq0(this.curve.at(s).distanceTo(t)))return s=ts3dutils.snap2(s,this.aT,this.bT),this.minT<=s&&s<=this.maxT?s:void 0}}class FaceInfoFactory{static makeStatic(t){return new class extends FaceInfoFactory{constructor(){super()}info(s,e,i){return t}}}info(t,s,e){throw new Error("no default implementation")}extrudeBottom(t,s,e=[]){return this.info(t,s,e)}extrudeTop(t,s,e=[]){return this.info(t,s,e)}extrudeWall(t,s,e,i=[]){return this.info(s,e,i)}rotationWall(t,s,e,i=[]){return this.info(s,e,i)}rotationStart(t,s,e=[]){return this.info(t,s,e)}rotationEnd(t,s,e=[]){return this.info(t,s,e)}newSubFace(t,s,e,i=[]){return t.info}transform(t,s,e,i,r,n=[]){return t.info}}const{PI:PI$15,min:min$10,max:max$9,sign:sign$9,ceil:ceil$12,floor:floor$10,abs:abs$12}=Math;class Face extends ts3dutils.Transformable{constructor(t,s,e=[],i,r){super(),this.surface=t,this.contour=s,this.holes=e,this.name=i,this.info=r,Edge.assertLoop(s),ts3dutils.assert(s.every(t=>t instanceof Edge),()=>"contour.every(f => f instanceof Edge)"+s),s.forEach(s=>{ts3dutils.assert(t.containsCurve(s.curve),"edge not in surface "+s+t)}),ts3dutils.assert(t.edgeLoopCCW(s),t.toString()+s.join("\n")),e&&e.forEach(t=>Edge.assertLoop(t)),e&&e.forEach(s=>ts3dutils.assert(!t.edgeLoopCCW(s))),ts3dutils.assert(!e||e.constructor==Array,e&&e.toString()),this.allEdges=Array.prototype.concat.apply(this.contour,this.holes)}static assembleFacesFromLoops(t,s,e){const i=[],r=[];return t.forEach(t=>(function t(e,i){if(0==i.length)i.push(e);else{const r=i.find(t=>B2.loop1ContainsLoop2(t.loop,t.ccw,e.loop,e.ccw,s));if(r)t(e,r.subloops);else{for(let t=i.length;--t>=0;){const r=i[t];B2.loop1ContainsLoop2(e.loop,e.ccw,r.loop,r.ccw,s)&&(e.subloops.push(r),i.splice(t,1))}i.push(e)}}})({loop:t,ccw:s.edgeLoopCCW(t),subloops:[]},r)),r.forEach(t=>(function t(r){i.push(new e(s,r.ccw?r.loop:Edge.reversePath(r.loop),r.subloops.map(t=>t.ccw?Edge.reversePath(t.loop):t.loop))),r.subloops.forEach(s=>s.subloops.forEach(s=>t(s)))})(t)),i}static create(t,s,e,i,r){return t instanceof PlaneSurface$1?new PlaneFace(t,s,e,i,r):new RotationFace(t,s,e,i,r)}intersectFace(t,s,e,i,r,n,a){function o(t,s){return a.has(new javasetmap_ts.Pair(t,s))}function l(t,s){return a.add(new javasetmap_ts.Pair(t,s))}function u(a,u,c){if(!u&&!c){let s=h.surface.normalP(a.a).cross(t.surface.normalP(a.a));if(s.likeO()){const e=ts3dutils.lerp(a.aT,a.bT,1/ts3dutils.GOLDEN_RATIO),i=a.curve.at(e);s=h.surface.normalP(i).cross(t.surface.normalP(i))}if(s.likeO()){const s=a.a,e=P3.normalOnAnchor(a.aDir,s),r=h.surface.normalP(s),n=r.dot(t.surface.normalP(s))>0,o=e.normal1.cross(r),l=h.surface.isCurvesWithPlane(e)[0],u=l.pointT(s),c=sign$9(o.dot(l.tangentAt(u))),d=t.surface.isCurvesWithPlane(e)[0],f=d.pointT(s),p=sign$9(o.dot(l.tangentAt(f))),m=l.diff(u,EPS*c).dot(r),g=d.diff(f,EPS*p).dot(r);g<m&&ts3dutils.mapPush(i,t,n?a.flipped():a),r.dot(t.surface.normalP(s))<0==g<m&&ts3dutils.mapPush(i,h,a.flipped());const P=l.diff(u,EPS*c).dot(r),v=d.diff(f,EPS*p).dot(r);v<P&&ts3dutils.mapPush(i,t,n?a:a.flipped()),n!=v<P&&ts3dutils.mapPush(i,h,a)}else s.dot(a.aDir)<0&&(a=a.flipped()),ts3dutils.mapPush(i,h,a),ts3dutils.mapPush(i,t,a.flipped());return!0}function d(t,s,e,r,n,l,u,c,h){if(t&&!s){if(o(t.getCanon(),r))return!1;const s=r.surface;n.edgeFaces.get(t.getCanon()).forEach(t=>{const s=fff(t,r.surface),e=s==INSIDE||!u&&s==COPLANAR_SAME,n=t.edge.tangentAt(t.edge.curve.pointT(a.a)).like(a.aDir)?a:a.flipped();ts3dutils.assert(t.edge.tangentAt(t.edge.curve.pointT(n.a)).like(n.aDir)),e&&ts3dutils.mapPush(i,t.face,n)});const e=s.normalP(a.a),l=e.cross(a.aDir),c=splitsVolumeEnclosingFacesP(n,t.getCanon(),a.a,l,e);let h,d;(h=c==INSIDE||u&&c==COPLANAR_SAME)&&ts3dutils.mapPush(i,r,a);const f=splitsVolumeEnclosingFacesP(n,t.getCanon(),a.a,l.negated(),e);if((d=f==INSIDE||u&&f==COPLANAR_SAME)&&ts3dutils.mapPush(i,r,a.flipped()),h||d||c==COPLANAR_SAME&&f==INSIDE||f==COPLANAR_SAME&&c==INSIDE)return!0}}const f=d(u,c,0,t,s,0,!1),p=d(c,u,0,h,e,0,!0);if(f||p)return!0;if(u&&c){if(o(u.getCanon(),c.getCanon()))return!1;function m(t,s,e,r,n,o,l,u){for(const l of e.edgeFaces.get(t.getCanon())){const e=splitsVolumeEnclosingFaces(r,s.getCanon(),l.inside,l.normalAtCanonA),u=e==INSIDE||n&&e==COPLANAR_SAME,c=l.edge.aDir.like(a.aDir)?a:a.flipped();if(u){ts3dutils.mapPush(i,l.face,c);const s=t.getCanon().curve.pointT(a.a);ts3dutils.eq(s,t.aT)||ts3dutils.eq(s,t.bT)||splitsVolumeEnclosingCone2(r,a.a,a.curve,a.aT,-Math.sign(a.deltaT()))==INSIDE&&ts3dutils.mapPush(o,t.getCanon(),{p:a.a,edgeT:s});const e=t.getCanon().curve.pointT(a.b);ts3dutils.eq(e,t.aT)||ts3dutils.eq(e,t.bT)||splitsVolumeEnclosingCone2(r,a.b,a.curve,a.bT,Math.sign(a.deltaT()))==INSIDE&&ts3dutils.mapPush(o,t.getCanon(),{p:a.b,edgeT:e})}}}return l(u.getCanon(),c.getCanon()),m(u,c,s,e,!0,r),m(c,u,e,s,!1,n),!1}}function c(t,i,a){if(t&&!i&&(t.colinear||t.edgeT==t.edge.aT||t.edgeT==t.edge.bT||(ts3dutils.mapPush(r,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))),i&&!t&&(i.colinear||i.edgeT==i.edge.aT||i.edgeT==i.edge.bT||(ts3dutils.mapPush(n,i.edge.getCanon(),i),ts3dutils.assert(i.edge.isValidT(i.edgeT)))),t&&i){function o(t,s,e,i,r,n,a,o,u,c){if(!t.colinear&&t.edgeT!=t.edge.aT&&t.edgeT!=t.edge.bT)if(l(t.edge.getCanon(),s.edge.getCanon()),t.p.like(s.edge.a)||t.p.like(s.edge.b)){const e=t.p.like(s.edge.a)?s.edge.a:s.edge.b,i=splitsVolumeEnclosingCone2(o,e,t.edge.curve,t.edgeT,1),r=splitsVolumeEnclosingCone2(o,e,t.edge.curve,t.edgeT,-1);INSIDE!=i&&INSIDE!=r||(ts3dutils.mapPush(c,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))}else{const e=splitsVolumeEnclosingFacesP2(o,s.edge.getCanon(),t.p,t.edge.curve,t.edgeT,1,r.normalP(t.p)),i=splitsVolumeEnclosingFacesP2(o,s.edge.getCanon(),t.p,t.edge.curve,t.edgeT,-1,r.normalP(t.p));INSIDE!=e&&INSIDE!=i||(ts3dutils.mapPush(c,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))}}ts3dutils.assert(t.colinear||i.colinear||ts3dutils.eq(t.t,i.t)),o(t,i,0,0,d,0,0,e,0,r),o(i,t,0,0,f,0,0,s,0,n)}}ts3dutils.assertInst(Face,t);const h=this,d=h.surface,f=t.surface;if(!this.getAABB().fuzzyTouchesAABB(t.getAABB()))return;if(d.isCoplanarTo(f))return;const p=d.isCurvesWithSurface(f);if(0!=p.length){for(const t of p){const s=(t.tMin+t.tMax)/2,e=t.at(s),i=(t.tangentAt(s),d.normalP(e)),r=f.normalP(e),n=i.cross(r);ts3dutils.assert(d.containsCurve(t)),ts3dutils.assert(f.containsCurve(t)),n.likeO()}for(let s=0;s<p.length;s++){const e=p[s],i=h.edgeISPsWithSurface(e,t.surface),r=t.edgeISPsWithSurface(e,h.surface);function m(t,s){return 0==t.length?isFinite(e.tMin)&&s.containsPoint2(e.at(e.tMin))==exports.PointVsFace.INSIDE:t[0].insideDir.dot(e.tangentAt(t[0].t))<0}ts3dutils.assertf(()=>0==i.length||!ts3dutils.eq0(i[0].insideDir.dot(e.tangentAt(i[0].t))),()=>i[0].insideDir.dot(e.tangentAt(i[0].t))),ts3dutils.assertf(()=>0==r.length||!ts3dutils.eq0(r[0].insideDir.dot(e.tangentAt(r[0].t))),()=>r[0].insideDir.dot(e.tangentAt(r[0].t)));let n,a,o=m(i,h),l=m(r,t);if(0==i.length&&!o||0==r.length&&!l)continue;let d,f,g,P,v=0,C=0,S=o&&l&&e.at(e.tMin),M=e.tMin;for(;v<i.length||C<r.length;){ts3dutils.assert(v<=i.length),ts3dutils.assert(C<=r.length);const t=i[v],s=r[C];if(ts3dutils.assert(t||s),C==r.length||v<i.length&&ts3dutils.lt(t.t,s.t)?(d=t,o=!o,t.used=!0,o&&(n=t.colinear&&t),v++):v==i.length||ts3dutils.gt(t.t,s.t)?(d=s,s.used=!0,(l=!l)&&(a=s.colinear&&s),C++):(d=t,t.used=!0,s.used=!0,l=!l,(o=!o)&&(n=t.colinear&&t),l&&(a=s.colinear&&s),v++,C++),!S||o&&l)o&&l&&(S=d.p,f=d.insideDir,M=d.t,g=t&&t.used&&t,P=s&&s.used&&s);else{if(f=e.tangentAt(M),ts3dutils.eq(M,d.t)){S=void 0;continue}ts3dutils.assert(ts3dutils.lt(M,d.t)),M>d.t&&(f=f.negated());let i=e.tangentAt(d.t);M>d.t&&(i=i.negated());const r=Edge.create(e,S,d.p,M,d.t,void 0,f,i,"genseg"+getGlobalId());S=void 0,u(r,n&&n.edge,a&&a.edge)&&(c(g||n,P||a),c(t&&t.used&&t||n,s&&s.used&&s||a))}}if(o&&l&&M!==e.tMax){const t=e.tMax;f=e.tangentAt(M),M>t&&(f=f.negated());let s=e.tangentAt(t);M>t&&(s=s.negated());const i=Edge.create(e,S,e.at(t),M,t,void 0,f,s,"genseg"+getGlobalId());u(i,n&&n.edge,a&&a.edge)&&c(g||n,P||a)}}h.getAllEdges().forEach(s=>{a.add(new javasetmap_ts.Pair(s.getCanon(),t))}),t.getAllEdges().forEach(t=>{a.add(new javasetmap_ts.Pair(t.getCanon(),h))})}}edgeISPsWithSurface(t,s){const e=this.surface,i=this.holes.concat([this.contour]),r=[];for(const n of i){const i=n.map(s=>s.curve.isColinearTo(t));for(let a=0;a<n.length;a++){const o=n[a],l=(a+1)%n.length,u=n[l];if(i[a]){if(t.containsPoint(o.a)){const s=(a-1+n.length)%n.length,l=n[s],u=t.pointT(o.a),c=o.aDir.cross(e.normalP(o.a));!i[s]&&dotCurve2(l.curve,l.bT,c,-sign$9(l.deltaT()))>0&&r.push({p:l.b,insideDir:o.aDir.negated(),t:u,edge:l,edgeT:l.bT,colinear:!1}),r.push({p:o.a,insideDir:o.aDir,t:u,edge:o,edgeT:o.aT,colinear:!0})}if(t.containsPoint(o.b)){const s=t.pointT(o.b),n=o.bDir.cross(e.normalP(o.b));!i[l]&&dotCurve2(u.curve,u.aT,n,sign$9(u.deltaT()))>0&&r.push({p:o.b,insideDir:o.bDir,t:s,edge:u,edgeT:u.aT,colinear:!1}),r.push({p:o.b,insideDir:o.bDir.negated(),t:s,edge:o,edgeT:o.bT,colinear:!0})}}else{const n=o.edgeISTsWithSurface(s);for(const a of n){const n=o.curve.at(a);if(!t.containsPoint(n))continue;const u=t.pointT(n);ts3dutils.assert(!isNaN(u));const c=o.tangentAt(a).cross(e.normalP(n)).negated(),h=t.tangentAt(u);sign$9(h.dot(o.curve.tangentAt(a))),s.normalP(n);if(a==o.bT){if(!i[l]){if(!ts3dutils.eq(u,t.tMax)){const s=this.pointsToInside3(o.b,t,u,1);ts3dutils.assert(s!=exports.PointVsFace.ON_EDGE),exports.PointVsFace.INSIDE==s&&r.push({p:o.b,insideDir:h,t:u,edge:o,edgeT:o.bT,colinear:!1})}if(!ts3dutils.eq(u,t.tMin)){const s=this.pointsToInside3(o.b,t,u,-1);ts3dutils.assert(s!=exports.PointVsFace.ON_EDGE),exports.PointVsFace.INSIDE==s&&r.push({p:o.b,insideDir:h.negated(),t:u,edge:o,edgeT:o.bT,colinear:!1})}}}else if(a!=o.aT)if(ts3dutils.eq0(c.dot(h))){const s=sign$9(h.dot(o.curve.tangentAt(a))),e=1e-4;for(const i of[-1,1]){if(-1==i*s&&a==o.minT||1==i*s&&a==o.maxT||-1==i&&u==t.tMin||1==i&&u==t.tMax)continue;t.at(u).to(t.at(u+i*e)).dot(c)-o.curve.at(a).to(o.curve.at(a+i*s*e)).dot(c)>0&&r.push({p:n,insideDir:h.times(i),t:u,edge:o,edgeT:a,colinear:!1})}}else r.push({p:n,insideDir:c,t:u,edge:o,edgeT:a,colinear:!1})}}}}return r.sort((s,e)=>s.t-e.t||s.insideDir.dot(t.tangentAt(s.t))),r}transform(t){const s=t.isMirroring(),e=Edge.reversePath(this.contour.map(s=>s.transform(t)),s),i=this.holes.map(e=>Edge.reversePath(e.map(s=>s.transform(t)),s));return new this.constructor(this.surface.transform(t),e,i,this.name,this.info)}flipped(){const t=this.contour.map(t=>t.flipped()).reverse(),s=this.holes.map(t=>t.map(t=>t.flipped()).reverse());return new this.constructor(this.surface.flipped(),t,s,this.name,this.info)}toString(){return"new "+this.constructor.name+"("+this.surface+", ["+this.contour.map(t=>"\n\t"+t).join()+"]"+this.holes.map(t=>"\n\t\thole: "+t.join())+")"}toSource(){return`new ${this.constructor.name}(${this.surface.toSource()}, [${this.contour.map(t=>"\n\t"+t.toSource()).join(",")}], [${this.holes.map(t=>"["+t.map(t=>"\n\t"+t.toSource()).join(",")+"]").join(",")}])`}equals(t){function s(t,s){return t.length==s.length&&ts3dutils.arrayRange(0,t.length,1).some(e=>t.every((i,r)=>i.equals(s[(e+r)%t.length])))}return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.holes.length==t.holes.length&&s(this.contour,t.contour)&&this.holes.every(e=>t.holes.some(t=>s(e,t)))}hashCode(){function t(t){let s=0;for(const e of t)s=31*s+e|0;return s}function s(s){return t(s.map(t=>t.hashCode()).sort(ts3dutils.MINUS))}let e=0;return e=31*(e=31*(e=31*e+t(this.holes.map(t=>s(t)).sort(ts3dutils.MINUS))|0)+s(this.contour)|0)+this.surface.hashCode()|0}likeFace(t){function s(t,s){return t.length==s.length&&ts3dutils.arrayRange(0,t.length,1).some(e=>t.every((i,r)=>i.like(s[(e+r)%t.length])))}return ts3dutils.assertInst(Face,t),this.surface.like(t.surface)&&this.holes.length==t.holes.length&&s(this.contour,t.contour)&&this.holes.every(e=>t.holes.some(t=>s(e,t)))}getAllEdges(){return this.allEdges}addEdgeLines(t){ts3dutils.assert(!1,"buggy, fix");const s=this.contour.flatMap(t=>t.getVerticesNo0()),e=t.vertices.length;for(let i=0;i<s.length;i++)t.vertices.push(s[i]),t.LINES.push(e+i,e+(i+1)%s.length)}containsPoint(t){return ts3dutils.assertVectors(t),this.surface.loopContainsPoint(this.contour,t)!=exports.PointVsFace.OUTSIDE&&!this.holes.some(s=>this.surface.loopContainsPoint(s,t)!=exports.PointVsFace.OUTSIDE)}containsPoint2(t){ts3dutils.assertVectors(t);const s=this.surface.loopContainsPoint(this.contour,t);if(s!=exports.PointVsFace.INSIDE)return s;for(const s of this.holes){const e=this.surface.loopContainsPoint(s,t);if(e!=exports.PointVsFace.OUTSIDE)return e==exports.PointVsFace.ON_EDGE?exports.PointVsFace.ON_EDGE:exports.PointVsFace.OUTSIDE}return exports.PointVsFace.INSIDE}intersectsLine(t){if(ts3dutils.assertInst(L3$1,t),!this.getAABB().intersectsLine(t))return NaN;const s=this.surface.isTsForLine(t).filter(s=>this.containsPoint(t.at(s))).withMax(t=>-t);return void 0!=s?s:NaN}toMesh(){const t=(new tsgl.Mesh).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES").addVertexBuffer("normals","LGL_Normal");return this.addToMesh(t),t}zDirVolume(){return this.surface.zDirVolume(this.getAllEdges())}calcArea(){return this.surface.calculateArea(this.getAllEdges())}getLoops(){return this.holes.concat(this.contour)}getAABB(){return this.aabb||(this.aabb=ts3dutils.AABB.forAABBs(this.contour.map(t=>t.getAABB())))}pointsToInside3(t,s,e,i){const r=this.surface.normalP(t),n=s.tangentAt(e).times(i),a=r.cross(n),o=s.at(e).to(s.at(e+1e-6*i)).dot(a);let l,u=1/0,c=!1;for(const e of this.getAllEdges()){const i=e.a.like(t),h=e.b.like(t);if(ts3dutils.assert(i==e.a.like(t)),ts3dutils.assert(h==e.b.like(t)),!i&&!h)continue;const d=i?e.aDir:e.bDir.negated(),f=n.angleRelativeNormal(d,r);if(ts3dutils.eq0(f)){if(s.isColinearTo(e.curve))return exports.PointVsFace.ON_EDGE;const t=i?e.aT:e.bT,r=(i?1:-1)*sign$9(e.deltaT()),n=e.curve.diff(t,1e-6*r).dot(a)-o;n>0&&(!c||n<u)&&(c=!0,u=n,l=i?exports.PointVsFace.OUTSIDE:exports.PointVsFace.INSIDE)}else if(!c){const t=(f+ts3dutils.TAU)%ts3dutils.TAU;t<u&&(u=t,l=i?exports.PointVsFace.OUTSIDE:exports.PointVsFace.INSIDE)}}if(void 0==l)throw new Error;return l}pointsToInside2(t,s){return this.pointsToInside3(t,L3$1.anchorDirection(t,s),0,1)}}class PlaneFace extends Face{constructor(t,s,e,i,r){ts3dutils.assert(t instanceof P3||t instanceof PlaneSurface$1),super(t instanceof P3?new PlaneSurface$1(t):t,s,e,i,r)}static forVertices(t,s,...e){const i=t instanceof P3?new PlaneSurface$1(t):t;ts3dutils.assert(ts3dutils.isCCW(s,i.plane.normal1),"isCCW(vs, planeSurface.plane.normal1)");const r=StraightEdge.chain(s);e.forEach(t=>ts3dutils.assert(ts3dutils.doubleSignedArea(t,i.plane.normal1)>=0,"doubleSignedArea(vs, planeSurface.plane.normal1) >= 0"));const n=e.map(t=>StraightEdge.chain(t));return new PlaneFace(t,r,n)}addToMesh(t){const s=t.vertices.length,e=this.surface.plane.normal1,i=this.contour.flatMap(t=>t.getVerticesNo0());for(let e=0;e<i.length;e++)t.LINES.push(s+e,s+(e+1)%i.length);const r=[];this.holes.forEach(t=>{r.push(i.length),i.push(...t.flatMap(t=>t.getVerticesNo0()))});const n=triangulateVertices(e,i,r).map(t=>t+s);Array.prototype.push.apply(t.vertices,i),Array.prototype.push.apply(t.TRIANGLES,n),Array.prototype.push.apply(t.normals,ts3dutils.arrayFromFunction(i.length,()=>e))}intersectsLine(t){ts3dutils.assertInst(L3$1,t);const s=t.isTWithPlane(this.surface.plane);return Number.isFinite(s)&&this.containsPoint(t.at(s))?s:NaN}withHole(t){return new PlaneFace(this.surface,this.contour,[t])}pointsToInside(t,s){return this.containsPoint2(t.plus(s.times(8*ts3dutils.NLA_PRECISION)))}edgeISPsWithPlane(t,s){ts3dutils.assert(this.surface.plane.containsLine(t)),ts3dutils.assert(s.containsLine(t));const e=this.surface.plane,i=[];return[this.contour].concat(this.holes).forEach(r=>{const n=r.map(s=>s.colinearToLine(t)&&-sign$9(s.aDir.dot(t.dir1))),a=t.dir1.cross(e.normal1);r.forEach((e,r,o)=>{const l=(r+1)%o.length,u=o[l];if(n[r]){const s=t.pointT(e.a),o=t.pointT(e.b);i.push({p:e.a,insideDir:e.aDir,t:s,edge:e,edgeT:e.aT,colinear:!0},{p:e.b,insideDir:e.bDir.negated(),t:o,edge:e,edgeT:e.bT,colinear:!0});const c=n[l]||dotCurve(a,u.aDir,u.aDDT);n[r]*c<0&&i.push({p:u.a,insideDir:e.bDir,t:o,edge:u,edgeT:u.aT,colinear:!1})}else{const r=e.edgeISTsWithPlane(s);ts3dutils.assert(r.every(t=>s.containsPoint(e.curve.at(t))),r);for(const o of r)if(o==e.bT){-dotCurve(a,e.bDir,e.bDDT)*(n[l]||dotCurve(a,u.aDir,u.aDDT))<0&&i.push({p:e.b,insideDir:s.normal1.negated(),t:t.pointT(e.b),edge:e,edgeT:e.bT,colinear:!1})}else if(o!=e.aT){const r=e.curve.at(o);ts3dutils.assert(s.containsPoint(r),e.toString(),r,o,s.distanceToPoint(r)),ts3dutils.assert(t.containsPoint(r),e.toString(),r,o,t.distanceToPoint(r));const n=s.normal1.negated();i.push({p:r,insideDir:n,t:t.pointT(r),edge:e,edgeT:o,colinear:!1})}}})}),i.sort((s,e)=>s.t-e.t||s.insideDir.dot(t.dir1)),i}}class RotationFace extends Face{constructor(t,s,e,i,r){super(t,s,e,i,r)}static loopDoesNotCrossPlane(t,s){let e=0;function i(t){if(0!=e)return!e||e*t<0;e=t}for(const e of t){const t=e.edgeISTsWithPlane(s);if(0==t.length){if(!(e.curve instanceof L3$1)&&i(s.distanceToPointSigned(e.a)))return!1}else for(const r of t){if(e.aT!=r&&i(dotCurve2(e.curve,r,s.normal1,-sign$9(e.bT-e.aT))))return!1;if(e.bT!=r&&i(dotCurve2(e.curve,r,s.normal1,sign$9(e.bT-e.aT))))return!1}}return!0}getAABB(){return this.aabb?this.aabb:this.surface instanceof SemiEllipsoidSurface||this.surface instanceof EllipsoidSurface?(this.aabb=ts3dutils.AABB.forAABBs(this.contour.map(t=>t.getAABB())),this.aabb.addPoints(this.surface.getExtremePoints().filter(t=>this.containsPoint(t))),this.aabb):super.getAABB()}getCanonSeamU(){const t=this.surface.stPFunc();for(const s of this.contour){let e=t(s.a,PI$15).x;if(e!=PI$15&&!ts3dutils.eq0(e))return sign$9(e)*PI$15;if((e=t(s.curve.at((s.aT+s.bT)/2),PI$15).x)!=PI$15&&!ts3dutils.eq0(e))return sign$9(e)*PI$15}const s=this.contour[0].transform(this.surface.inverseMatrix);if(P3.ZX.containsCurve(s.curve)){const t=s.a.cross(s.aDir);return sign$9(t.dot(ts3dutils.V3.Y))*PI$15}ts3dutils.assert(!1,"Couldn't find canon seam u")}unrollLoop(t){const s=[],e=this.surface.stPFunc(),i=t.map(t=>t.getVerticesNo0()),r=i.findIndex(t=>!ts3dutils.eq(e(t[0],Math.PI).x,Math.PI));ts3dutils.assert(-1!=r);let n=Math.PI;for(let a=0;a<t.length;a++){const o=(a+r)%t.length;for(let t=0;t<i[o].length;t++){const r=i[o][t],a=e(r,n);Math.abs(a.x)<Math.PI-ts3dutils.NLA_PRECISION&&(n=a.x),s.push(a)}}return t.forEach((t,i)=>{let r=t.bDir;t instanceof StraightEdge&&t.curve.dir1.isParallelTo(this.surface.dir||this.surface.dir1)&&(r=this.surface.normalP(t.b).cross(t.bDir)),t.getVerticesNo0().forEach(t=>{s.push(e(t,r))})}),console.log("vs\n",s.join("\n"),s.length),s}unrollEllipsoidLoops(t,s,e){const i=[],r=[],n=[],a=this.surface,o=a.stPFunc(),l=a instanceof SemiEllipsoidSurface?t=>t.like(a.center.plus(a.f3))||t.like(a.center.minus(a.f3)):t=>t.like(this.surface.center);for(const s of t){n.push(i.length);const t=this.getCanonSeamU();for(let e=0;e<s.length;e++){const n=(e+1)%s.length,u=s[e].getVerticesNo0();if(r.push(...u),i.push(...u.map(t=>o(t))),l(s[n].a)){const o=a.inverseMatrix.transformVector(s[e].bDir),l=a.inverseMatrix.transformVector(s[n].aDir);let u=Math.atan2(-o.y,-o.x);abs$12(u)>Math.PI-ts3dutils.NLA_PRECISION&&(ts3dutils.assert(t==-PI$15||t==PI$15),u=t);let c=Math.atan2(l.y,l.x);abs$12(c)>Math.PI-ts3dutils.NLA_PRECISION&&(ts3dutils.assert(t==-PI$15||t==PI$15),c=t);const h=i.pop();i.push(new ts3dutils.V3(u,h.y,0),new ts3dutils.V3(c,h.y,0)),r.push(r.last)}i.forEach(({x:t,y:s})=>{ts3dutils.assert(isFinite(t)),ts3dutils.assert(isFinite(s))})}}let u;if(this.surface instanceof EllipsoidSurface)u=r.map(t=>a.normalP(t));else{const t=a.normalSTFunc();u=i.map(({x:s,y:e})=>t(s,e))}return ts3dutils.assert(r.length==r.length),{verticesUV:i.map(t=>new ts3dutils.V3(t.x/s,t.y/e,0)),vertices:r,normals:u,loopStarts:n}}unrollCylinderLoops(t,s,e){const i=t.map(t=>t.flatMap(t=>t.getVerticesNo0())),r=this.surface,n=i.concatenated(),a=i.reduce((t,s)=>(t.push(t.last+s.length),t),[0]),o=r.stPFunc(),l=n.map(t=>o(t)),u=l.map(t=>new ts3dutils.V3(t.x/s,t.y/e,0)),c=r.normalSTFunc();return{verticesUV:u,vertices:n,normals:l.map(({x:t,y:s})=>c(t,s)),loopStarts:a}}addToMesh(t,s=this.surface.uStep,e=this.surface.vStep){ts3dutils.assertf(()=>s>0&&e>0,s,e,"Surface: "+this.surface);const i=[],r=(t,i)=>this.surface.pSTFunc()(t*s,i*e),n=(t,i)=>this.surface.normalSTFunc()(t*s,i*e),a=[this.contour].concat(this.holes),{vertices:o,verticesUV:l,normals:u,loopStarts:c}=this.surface instanceof SemiEllipsoidSurface||this.surface instanceof ConicSurface?this.unrollEllipsoidLoops(a,s,e):this.unrollCylinderLoops(a,s,e);c.push(o.length);for(let s=0;s<a.length;s++){const e=c[s],i=c[s+1]-e,r=t.vertices.length+c[s];for(let s=0;s<i;s++)t.LINES.push(r+s,r+(s+1)%i)}ts3dutils.disableConsole();let h=1/0,d=-1/0,f=1/0,p=-1/0;l.forEach(({x:t,y:s})=>{ts3dutils.assert(isFinite(t)),ts3dutils.assert(isFinite(s)),h=min$10(h,t),d=max$9(d,t),f=min$10(f,s),p=max$9(p,s)}),ParametricSurface.is(this.surface)&&(ts3dutils.assert(this.surface.boundsSigned(h*s,f*e)>-ts3dutils.NLA_PRECISION),ts3dutils.assert(this.surface.boundsSigned(d*s,p*e)>-ts3dutils.NLA_PRECISION));const m=floor$10(h+ts3dutils.NLA_PRECISION),g=floor$10(f+ts3dutils.NLA_PRECISION),P=ceil$12(d-ts3dutils.NLA_PRECISION)-m,v=ceil$12(p-ts3dutils.NLA_PRECISION)-g;if(console.log(s,e,P,v),1==P&&1==v){const t=triangulateVertices(ts3dutils.V3.Z,l,c.slice(1,1+this.holes.length));i.push(...t)}else{const t=new Array(P*v);function C(s,e,i){ts3dutils.assert(e<P&&i<v,`${e}, ${i}, ${P}, ${v}`),console.log("complete part",s,e,i),ts3dutils.assert(s.length);const r=e+m,n=i+g;for(const t of s)ts3dutils.assert(ts3dutils.le(r,l[t].x)&&ts3dutils.le(l[t].x,r+1),`${t} ${l[t].str} ${r} ${r}`),ts3dutils.assert(ts3dutils.le(n,l[t].y)&&ts3dutils.le(l[t].y,n+1));const a=i*P+e;(t[a]||(t[a]=[])).push(s)}for(let t=0;t<a.length;t++){let s,e=void 0,i=-1,r=-1,n=-1,a=-1,o=0;const u=c[t],h=c[t+1]-u;for(let t=0;t<h;t++){const c=u+t,d=l[c],f=u+(t+1)%h,p=l[f],M=d.to(p);ts3dutils.assert(d);const x=M.x,T=M.y;let E=c,I=d,V=0,w=400;for(;--w;){const t=I.x,l=I.y,u=floor$10(t+(ts3dutils.eq0(x)?-sign$9(T):sign$9(x))*ts3dutils.NLA_PRECISION)-m,c=floor$10(l+(ts3dutils.eq0(T)?sign$9(x):sign$9(T))*ts3dutils.NLA_PRECISION)-g;ts3dutils.assert(u<P&&c<v,`${u}, ${c}, ${P}, ${v}`);const h=ceil$12(sign$9(x)*t+ts3dutils.NLA_PRECISION)-sign$9(x)*t,M=ceil$12(sign$9(T)*l+ts3dutils.NLA_PRECISION)-sign$9(T)*l,w=V+h/abs$12(x),b=V+M/abs$12(T);if(a==u&&n==c||(e&&(s?(o++,C(e,a,n)):(s=e,i=a,r=n)),e=[E]),a=u,n=c,V=min$10(w,b),ts3dutils.ge(V,1)){e.push(f);break}{const t=d.lerp(p,V),s=S(t.x,t.y);e.push(s),I=t,E=s}}ts3dutils.assert(w,"whileLimit")}0==o&&ts3dutils.assert(!1,"found a hole, try increasing resolution"),i==a&&r==n?(e.pop(),C(e.concat(s),a,n)):(C(s,i,r),C(e,a,n)),console.log("firstPart",s)}console.log("calculated parts",t);const s=new Array((P+1)*(v+1));function S(t,s){return l.push(new ts3dutils.V3(t,s,0)),u.push(n(t,s)),o.push(r(t,s))-1}function M(t,e){const i=e*(P+1)+t;return s[i]||(s[i]=S(t+m,e+g))}for(let s=0;s<P;s++){let e=!1;for(let r=0;r<v;r++){const n=m+s,a=g+r,o=t[r*P+s];if(o){function x(t){const s=l[t],e=s.x-n,i=s.y-a;return ts3dutils.assert(-ts3dutils.NLA_PRECISION<e&&e<1+ts3dutils.NLA_PRECISION&&-ts3dutils.NLA_PRECISION<i&&i<1+ts3dutils.NLA_PRECISION,"oob u1 v1 "+e+" "+i+" "+t+" "+s.str+"IF THIS FAILS check canonSeamU is correct"),i<e?e+i:4-e-i}for(;o.length;){const t=[],n=o[0];ts3dutils.assert(n.length>0);let a=n;do{t.push(...a);const i=x(a.last),n=o.indexWithMax(t=>-ts3dutils.mod(x(t[0])-i,4)),l=o.removeIndex(n);let u=i;const c=x(l[0])>u?x(l[0]):x(l[0])+4;let h=ceil$12(u+ts3dutils.NLA_PRECISION),d=ts3dutils.eq0((u+ts3dutils.NLA_PRECISION)%1-ts3dutils.NLA_PRECISION);for(;ts3dutils.lt(h,c);){switch(h%4){case 0:t.push(M(s,r));break;case 1:e=e!=d,t.push(M(s+1,r));break;case 2:t.push(M(s+1,r+1));break;case 3:e=e!=d,t.push(M(s,r+1))}d=!0,h++}e=e!=(d&&h%2==1&&ts3dutils.eq(h,c)),u=h,a=l}while(a!=n);if(3==t.length)i.push(...t);else{const s=triangulateVertices(ts3dutils.V3.Z,t.map(t=>l[t]),[]).map(s=>t[s]);i.push(...s)}}}else e&&tsgl.pushQuad(i,!1,M(s,r),M(s+1,r),M(s,r+1),M(s+1,r+1))}}}Array.prototype.push.apply(t.TRIANGLES,i.map(s=>s+t.vertices.length)),Array.prototype.push.apply(t.vertices,o),Array.prototype.push.apply(t.normals,u),ts3dutils.enableConsole()}addToMesh2(t){const s=[];let e=1/0,i=-1/0;const r=this.surface.pSTFunc(),n=this.surface.normalSTFunc(),a=this.holes.concat([this.contour]).map(t=>this.unrollLoop(t));a.forEach(t=>{t.forEach(({x:t,y:r})=>{const n=s.binaryIndexOf(t,(t,s)=>ts3dutils.snap(t.value-s,0));n<0&&s.splice(-n-1,0,{value:t,left:[],right:[]}),e=min$10(e,r),i=max$9(i,r)})}),console.log("zzzs",e,i,a[0].toSource().replace(/\), /g,",\n"));a.forEach(t=>{t.forEach((t,e,i)=>{let r=i[(e+1)%i.length],n=r.x-t.x;if(ts3dutils.eq0(n))return;n<0&&([t,r]=[r,t],n=-n);const a=s.binaryIndexOf(t.x,(t,s)=>ts3dutils.snap(t.value-s,0)),o=s.binaryIndexOf(r.x,(t,s)=>ts3dutils.snap(t.value-s,0));s[a].right.binaryInsert(t.y);for(let e=(a+1)%s.length;e!=o;e=(e+1)%s.length){const i=(s[e].value-t.x)/n,a=r.y*i+t.y*(1-i);s[e].left.binaryInsert(a),s[e].right.binaryInsert(a)}s[o].left.binaryInsert(r.y)})});const o=[],l=[],u=[];for(let t=0;t<s.length;t++){const e=s[t],i=s[(t+1)%s.length];ts3dutils.assert(e.right.length==i.left.length);for(let t=0;t<e.right.length;t++)o.push(r(e.value,e.right[t]),r(i.value,i.left[t])),u.push(n(e.value,e.right[t]),n(i.value,i.left[t]))}const c=o.length,h=(i-e)/8,d=ts3dutils.arrayFromFunction(7,t=>e+(1+t)*h);console.log("detailsZs",d);for(let t=0;t<s.length;t++){const e=s[t].value;for(let t=0;t<d.length;t++)o.push(r(e,d[t])),u.push(n(e,d[t]))}let f=0;const p=s.length-1;for(let t=0;t<p;t++){const e=(t+1)%s.length;let i=!1,r=0;const n=s[t],a=s[(t+1)%s.length];for(let s=0;s<d.length+1;s++){const o=d[s]||1e5;i?n.right[r]<o||a.left[r]<o?(tsgl.pushQuad(l,!0,c+t*d.length+s-1,c+e*d.length+s-1,f+2*r,f+2*r+1),i=!1,r++,(n.right[r]<o||a.left[r]<o)&&s--):tsgl.pushQuad(l,!0,c+t*d.length+s,c+t*d.length+s-1,c+e*d.length+s,c+e*d.length+s-1):n.right[r]<o&&a.left[r]<o&&(n.right[r+1]<o||a.left[r+1]<o?(tsgl.pushQuad(l,!0,f+2*r,f+2*(r+1),f+2*r+1,f+2*(r+1)+1),r+=2,(n.right[r]<o||a.left[r]<o)&&s--):(tsgl.pushQuad(l,!0,f+2*r,f+2*r+1,c+t*d.length+s,c+e*d.length+s),i=!0,r++))}f+=2*n.right.length}const m=l.map(s=>s+t.vertices.length);Array.prototype.push.apply(t.vertices,o),Array.prototype.push.apply(t.TRIANGLES,m),Array.prototype.push.apply(t.normals,u)}}const{PI:PI$16,sign:sign$10,abs:abs$13,sqrt:sqrt$6}=Math,EPS=1e-5;let globalId=0;function getGlobalId(){return globalId++}function addLikeSurfaceFaces(t,s,e){for(let i=0;i<t.length;i++){const r=t[i];let n=!1,a=!1;for(let t=0;t<r.length;t++){const i=r[t];i==s&&(n=!0),i==e&&(a=!0)}if(n!=a)return void r.push(n?e:s);if(n)return}t.push([s,e])}function assembleFaceFromLooseEdges(t,s,e){const i=new Set;const r=[];let n,a;for(;n=t.find(t=>!i.has(t));){a=n;const e=[];let o=0;do{i.add(a),e.push(a);const r=t.filter(t=>a.b.like(t.a)),n=s.normalP(a.b),o=r.indexWithMax((t,s)=>a.bDir.angleRelativeNormal(t.aDir,n));a=r[o]}while(n!=a&&o++<200);ts3dutils.assert(201!=o),r.push(e)}const o=B2.assembleFacesFromLoops(r,s,e);return ts3dutils.assertf(()=>1==o.length),o[0]}function calcNextEdgeIndex(t,s,e){let i=-20,r=!1,n=Number.MAX_SAFE_INTEGER;const a=t.bDir.cross(e),o=sign$10(t.deltaT()),l=t.curve.diff(t.bT,1e-4*-o).dot(a);for(let o=s.length;o--;){const u=s[o],c=(t.bDir.negated().angleRelativeNormal(u.aDir,e)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION;if(ts3dutils.eq0(c)){if(t.curve.isColinearTo(u.curve))continue;const s=sign$10(u.deltaT()),e=u.curve.diff(u.aT,1e-4*s).dot(a)-l;e<0&&(!r||e>i)&&(r=!0,i=e,n=o)}else r||ts3dutils.gt(c,i)&&(i=c,n=o)}return n==Number.MAX_SAFE_INTEGER?0:n}class B2 extends ts3dutils.Transformable{constructor(t,s,e,i){super(),this.faces=t,ts3dutils.assertInst(Face,...t),this.infiniteVolume=s,ts3dutils.assert(!1===this.infiniteVolume||!0===this.infiniteVolume),this.generator=e,this.vertexNames=i,this.edgeFaces=void 0}static loop1ContainsLoop2(t,s,e,i,r){for(const s of e){const e=r.loopContainsPoint(t,s.a);if(exports.PointVsFace.ON_EDGE!=e)return exports.PointVsFace.INSIDE==e}for(const s of e){const e=s.curve.at(.2*s.aT+.8*s.bT),i=r.loopContainsPoint(t,e);if(exports.PointVsFace.ON_EDGE!=i)return exports.PointVsFace.INSIDE==i}if(s!=i)return i;throw new Error(t.sce+e.sce)}static assembleFacesFromLoops(t,s,e,i){const r=[],n=[];return t.forEach(t=>(function t(e,i){if(0==i.length)i.push(e);else{const r=i.find(t=>B2.loop1ContainsLoop2(t.loop,t.ccw,e.loop,e.ccw,s));if(r)t(e,r.subloops);else{for(let t=i.length;--t>=0;){const r=i[t];B2.loop1ContainsLoop2(e.loop,e.ccw,r.loop,r.ccw,s)&&(e.subloops.push(r),i.splice(t,1))}i.push(e)}}})({loop:t,ccw:s.edgeLoopCCW(t),subloops:[]},n)),n.forEach(t=>(function t(n){if(n.ccw)if(n.subloops.every(t=>!t.ccw)){const a=n.subloops.map(t=>t.loop),o=i&&i.newSubFace(e,s,n.loop,a),l=new e.constructor(s,n.loop,a,"genface"+getGlobalId(),o);r.push(l),n.subloops.forEach(s=>s.subloops.forEach(s=>s.ccw&&t(s)))}else n.subloops.forEach(s=>s.ccw&&t(s))})(t)),r}static join(t,s){return new B2(t.flatMap(t=>t.faces),!1,s)}containsPoint(t,s=!1){const e=[ts3dutils.V(-.3920414696448526,-.12936136783391444,-.9108068525164064),ts3dutils.V(.6520650903544943,-.07151288645511984,-.7547827667692488),ts3dutils.V(.9433494201061395,-.2402757256238473,-.22882186797013926),ts3dutils.V(.13678704228501923,-.04480387361087783,.9895867410047372),ts3dutils.V(.0662057922721913,-.5865836917435423,.8071780259955845),ts3dutils.V(-.7322576567870621,-.12953393611526787,.6685953061989045),ts3dutils.V(.6579719127258273,-.012300218400456116,.7529420075219719),ts3dutils.V(-.5576497966736425,.8006695748324647,.2189861552871446)];t:for(const i of e){const e=new L3$1(t,i);let r=this.infiniteVolume;for(const t of this.faces){ts3dutils.assert(!t.surface.containsCurve(e));const i=t.surface.isTsForLine(e);for(const n of i){const i=e.at(n),a=t.containsPoint2(i);if(!s&&ts3dutils.assert(!ts3dutils.eq0(n)),n>0){if(a==exports.PointVsFace.ON_EDGE)continue t;a==exports.PointVsFace.INSIDE&&(r=!r)}}}return r}return!1}withMergedFaces(){const t=[];for(let s=0;s<this.faces.length;s++){let e=!1;for(let i=0;i<s;i++)if(this.faces[s].surface.isCoplanarTo(this.faces[i].surface)){const r=t.find(t=>t.includes(this.faces[i]));r&&(r.push(this.faces[s]),e=!0)}!e&&t.push([this.faces[s]])}if(console.log("likeSurfaceFaces",t),t.every(t=>1==t.length))return this;const s=[];let e=0;for(const i of t)if(console.log(i),1==i.length)s.push(i[0]);else{const t=i.flatMap(t=>t.getAllEdges());for(let s=t.length;s-- >0;)for(let i=0;i<s;i++)if(console.log("blugh",e),ts3dutils.assert(s>=0&&i>=0&&e++<500,s+" "+i+" "+e),t[s].isCoEdge(t[i])){t.splice(s,1),t.splice(i,1),s--;break}const r=assembleFaceFromLooseEdges(t,i[0].surface,i[0].constructor);s.push(r)}return new B2(s,this.infiniteVolume,this.generator&&this.generator+".withMergedFaces()",this.vertexNames)}calculateVolume(){return this.faces.map(t=>t.zDirVolume().volume).sum()}toMesh(){const t=(new tsgl.Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");t.faceIndexes=new Map;for(const s of this.faces){const e=t.TRIANGLES.length;s.addToMesh(t),t.faceIndexes.set(s,{start:e,count:t.TRIANGLES.length-e})}return t}minus(t,s){const e=this.generator&&t.generator&&this.generator+".minus("+t.generator+")";return this.intersection(t.flipped(),!0,!0,e,s)}plus(t,s){const e=this.generator&&t.generator&&ts3dutils.callsce(this.generator+".plus",t.generator);return this.flipped().intersection(t.flipped(),!0,!0,e,s).flipped()}and(t,s){const e=this.generator&&t.generator&&ts3dutils.callsce(this.generator+".and",t.generator);return this.intersection(t,!0,!0,e,s)}xor(t,s){const e=this.generator&&t.generator&&ts3dutils.callsce(this.generator+".xor",t.generator);return new B2(this.minus(t).faces.concat(t.minus(this).faces),this.infiniteVolume!=t.infiniteVolume,e)}equals(t){return this.faces.length==t.faces.length&&this.faces.every(s=>t.faces.some(t=>s.equals(t)))}like(t){return this.faces.length==t.faces.length&&this.faces.every(s=>t.faces.some(t=>s.likeFace(t)))}toString(){return`new B2([\n${this.faces.join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}getConstructorParameters(){return[this.faces,this.infiniteVolume]}toSource(t=!0){return t&&this.generator||`new B2([\n${this.faces.map(ts3dutils.SCE).join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}reconstituteFaces(t,s,e,i,r){const n=new Map,a=[];for(const l of t){const t=l.getAllEdges().filter(t=>!s.get(t)),u=l.getAllEdges().mapFilter(t=>s.get(t)).concatenated(),c=e.get(l)||[];if(c.length||u.length){n.set(l,"partial");const s=[];function o(){return c.find(t=>!e.has(t))||u.find(t=>!e.has(t))||t.find(t=>!e.has(t))}const e=new Set;let h;for(;h=o();){const i=h,r=[];let n=0;do{e.add(h),r.push(h);const s=t.filter(t=>h.b.like(t.a)),n=u.filter(t=>h.b.like(t.a)),a=c.filter(t=>h.b.like(t.a)),o=s.concat(n,a);if(0==o.length)break;ts3dutils.assert(0<o.length,()=>l.sce);const d=l.surface.normalP(h.b),f=(o.indexWithMax((t,s)=>(h.bDir.angleRelativeNormal(t.aDir,d)+ts3dutils.NLA_PRECISION+PI$16)%ts3dutils.TAU),calcNextEdgeIndex(h,o,d));if(h=o[f],e.has(h))break;ts3dutils.assert(h),ts3dutils.assert(h!=i)}while(++n<400);400==n&&ts3dutils.assert(!1,"too many"),r.length>1&&h==i&&s.push(r)}const d=B2.assembleFacesFromLoops(s,l.surface,l,r);i.push(...d);const f=d.flatMap(t=>t.getAllEdges());a.push(...t.filter(t=>f.includes(t)))}}for(;0!=a.length;){const t=a.pop();this.edgeFaces.get(t.getCanon()).forEach(t=>{n.has(t.face)||(n.set(t.face,"inside"),a.push.apply(a,t.face.getAllEdges()))})}i.push(...t.filter(t=>"inside"==n.get(t)))}getLooseEdgeSegments(t,s){const e=new javasetmap_ts.JavaMap;for(const[r,n]of t){if(0==n.length)continue;const t=s.get(r);n.sort((t,s)=>ts3dutils.snap0(t.edgeT-s.edgeT)||+!!t.faces);let a,o=r.a,l=r.aDir,u=r.aT;function i(s,i,n){for(let a=0;a<t.length;a++){const o=t[a];!s||!s.faces||s.faces[a];(!i||!i.faces)&&ts3dutils.mapPush(e,o.reversed?r.flipped():r,o.reversed?n.flipped():n)}}for(let t=0;t<n.length;t++){const s=n[t],e=r.tangentAt(s.edgeT);if(!ts3dutils.eq(s.edgeT,u)){i(a,s,Edge.create(r.curve,o,s.p,u,s.edgeT,void 0,l,e,"looseSegment"+getGlobalId()))}o=s.p,u=s.edgeT,a=s,l=e}if(a&&!ts3dutils.eq(u,r.bT)){i(a,void 0,Edge.create(r.curve,o,r.b,u,r.bT,void 0,l,r.bDir,"looseSegment"+getGlobalId()))}}return e}getIntersectionEdges(t){const s=new Map,e=new javasetmap_ts.JavaMap,i=new javasetmap_ts.JavaMap,r=[];return this.faces.forEach(n=>{t.faces.forEach(a=>{n.intersectFace(a,this,t,s,e,i,r)})}),Array.from(s.values()).concatenated()}shellCount(){const t=new Set;let s,e=0;for(;s=this.faces.find(s=>!t.has(s));){e++;const i=[s];for(;s=i.pop();)for(const e of s.getAllEdges())for(const{face:r}of this.edgeFaces.get(e.getCanon()))s===r||t.has(r)||(t.add(r),i.push(r))}return e}getAABB(){return ts3dutils.AABB.forAABBs(this.faces.map(t=>t.getAABB()))}assertSanity(){if(!ts3dutils.NLA_DEBUG)return;const t=this.faces.flatMap(t=>t.getAllEdges());for(const{i:s,j:e}of ts3dutils.combinations(t.length)){t[s],t[e]}this.buildAdjacencies();for(const[t,s]of this.edgeFaces)ts3dutils.assert(s.length%2==0,()=>t+s.sce)}buildAdjacencies(){if(this.edgeFaces)return this;this.edgeFaces=new javasetmap_ts.JavaMap;for(const t of this.faces)for(const s of t.getAllEdges()){const e=s.getCanon(),i=t.surface.normalP(e.a),r=i.cross(e==s?s.aDir:s.bDir);ts3dutils.mapPush(this.edgeFaces,e,{face:t,edge:s,normalAtCanonA:i,reversed:e!=s,inside:r,angle:0})}for(const[t,s]of this.edgeFaces){const e=s.find(t=>t.reversed);e?(s.forEach(s=>{s!=e&&(s.angle=e.inside.angleRelativeNormal(s.inside,t.aDir.unit()),s.angle<0&&(s.angle+=2*Math.PI))}),s.sort((t,s)=>ts3dutils.snap(t.angle-s.angle,0))):console.warn("invalid brep")}return this}intersection(t,s,e,i,r){this.assertSanity(),t.assertSanity(),this.buildAdjacencies(),t.buildAdjacencies();const n=new Map,a=new javasetmap_ts.JavaMap,o=new javasetmap_ts.JavaMap,l=new javasetmap_ts.JavaSet;for(const s of this.faces)for(const e of t.faces)s.intersectFace(e,this,t,n,a,o,l);for(const t of a.keys())ts3dutils.assert(this.edgeFaces.get(t));for(const s of o.keys())ts3dutils.assert(t.edgeFaces.get(s));const u=[];if(0==n.size&&0==a.size&&0==o.size){!t.containsPoint(this.faces[0].contour[0].a,!0)&&this.containsPoint(t.faces[0].contour[0].a);return this}if(s){const t=this.getLooseEdgeSegments(a,this.edgeFaces);this.faces.map(s=>[s,Array.from(t.entries()).filter(([t,e])=>s.getAllEdges().some(s=>s.equals(t))).concatenated()]);this.reconstituteFaces(this.faces,t,n,u,r)}if(e){const s=this.getLooseEdgeSegments(o,t.edgeFaces);t.faces.map(t=>[t,Array.from(s.entries()).filter(([s,e])=>t.getAllEdges().some(t=>t.equals(s))).flatMap(([t,s])=>s)]);t.reconstituteFaces(t.faces,s,n,u,r)}return new B2(u,this.infiniteVolume&&t.infiniteVolume,i)}transform(t,s){let e;return this.vertexNames&&(e=new Map,this.vertexNames.forEach((i,r)=>e.set(t.transformPoint(r),i+s))),new B2(this.faces.map(s=>s.transform(t)),this.infiniteVolume,this.generator&&s&&this.generator+s,e)}flipped(){return new B2(this.faces.map(t=>t.flipped()),!this.infiniteVolume,this.generator&&this.generator+".flipped()",this.vertexNames)}}function dotCurve(t,s,e){let i=t.dot(s);return ts3dutils.eq0(i)&&(i=t.dot(e)),ts3dutils.assert(!ts3dutils.eq0(i)),i}function dotCurve2(t,s,e,i){ts3dutils.assert(1==i||-1==i,i);const r=t.tangentAt(s).dot(e);if(!ts3dutils.eq0(r))return i*r;const n=t.ddt(s).dot(e);if(!ts3dutils.eq0(n))return n;const a=t.at(s).to(t.at(s+4*i*ts3dutils.NLA_PRECISION)).dot(e);return ts3dutils.assert(!(t instanceof L3$1)),a}B2.EMPTY=new B2([],!1,"B2.EMPTY",new Map).buildAdjacencies(),B2.R3=new B2([],!0,"B2.R3",new Map).buildAdjacencies();const INSIDE=0,OUTSIDE$1=1,COPLANAR_SAME=2,COPLANAR_OPPOSITE=3,ALONG_EDGE_OR_PLANE=4;function splitsVolumeEnclosingFaces(t,s,e,i){ts3dutils.assert(4==arguments.length),ts3dutils.assert(s==s.getCanon());const r=t.edgeFaces.get(s);ts3dutils.assertf(()=>r.length%2==0),ts3dutils.assertf(()=>t.edgeFaces);const n=r[0],a=s.aDir.unit(),o=(n.inside.angleRelativeNormal(e,a)+2*Math.PI+ts3dutils.NLA_PRECISION)%(2*Math.PI)-ts3dutils.NLA_PRECISION,l=r.findIndex(t=>ts3dutils.lt(o,t.angle)),u=r[-1==l?r.length-1:l-1];if(ts3dutils.eq(u.angle,o)){return u.normalAtCanonA.dot(i)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}return u.reversed?INSIDE:OUTSIDE$1}function splitsVolumeEnclosingFacesP(t,s,e,i,r){ts3dutils.assert(5==arguments.length),ts3dutils.assert(s==s.getCanon()),ts3dutils.assertf(()=>t.edgeFaces);const n=t.edgeFaces.get(s);ts3dutils.assertf(()=>n.length%2==0);const a=s.tangentAt(s.curve.pointT(e)).unit(),o=t=>{const s=t.edge.getCanon()==t.edge?a:a.negated(),r=t.face.surface.normalP(e).cross(s);return-((i.angleRelativeNormal(r,a)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION)},l=n.withMax(o);if(ts3dutils.eq0(o(l))){return l.normalAtCanonA.dot(r)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}return l.reversed?OUTSIDE$1:INSIDE}function splitsVolumeEnclosingFacesP2(t,s,e,i,r,n,a){ts3dutils.assert(s==s.getCanon()),ts3dutils.assertf(()=>t.edgeFaces);const o=t.edgeFaces.get(s);ts3dutils.assertf(()=>o.length%2==0);const l=s.tangentAt(s.curve.pointT(e)).unit();let u=i.tangentAt(r).times(n);u.isParallelTo(l)&&(u=(u=i.diff(r,1e-4*n/i.tangentAt(r).length()).rejectedFrom(l)).div(u.length()));let c=20,h=!1,d=OUTSIDE$1;for(const t of o){const s=t.edge.getCanon()==t.edge?l:l.negated(),o=t.face.surface.normalP(e).cross(s),f=(u.angleRelativeNormal(o,l)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION;if(ts3dutils.eq0(f)){const s=t.face.surface.normalP(e);if(t.face.surface.containsCurve(i)){return s.dot(a)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}const o=P3.normalOnAnchor(l,e),f=t.face.surface.isCurvesWithPlane(o)[0],p=f.pointT(e),m=sign$10(f.tangentAt(p).dot(u)),g=1e-4,P=(f.at(p).to(f.at(p+n*m*g)).dot(s)-i.at(r).to(i.at(r+n*g)).dot(s))*(t.reversed?-1:1);P>0&&(!h||P<c)&&(h=!0,c=P,d=t.reversed?OUTSIDE$1:INSIDE)}else h||f<c&&(c=f,d=t.reversed?OUTSIDE$1:INSIDE)}return d}function splitsVolumeEnclosingCone(t,s,e){const i=P3.forAnchorAndPlaneVectors(s,e,e.getPerpendicular()),r=[];for(let n=0;n<t.faces.length;n++){const a=t.faces[n];if(ts3dutils.assertf(()=>a instanceof PlaneFace),a.getAllEdges().some(t=>t.a.like(s)))if(i.isParallelToPlane(a.surface.plane)){if(a.pointsToInside(s,e)!=exports.PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE}else{const t=L3$1.fromPlanes(i,a.surface.plane),n=a.edgeISPsWithPlane(t,i);let o=0;for(;o<n.length;){const a=n[o++],l=n[o++],u=a.p.like(s);if(u||l.p.like(s)){const s=u?t.dir1:t.dir1.negated(),n=(e.angleRelativeNormal(s,i.normal1)+2*Math.PI+ts3dutils.NLA_PRECISION/2)%(2*Math.PI);r.push({angle:n,out:u})}}}}return r.sort((t,s)=>t.angle-s.angle),ts3dutils.eq0(r[0].angle)?ALONG_EDGE_OR_PLANE:r[0].out?OUTSIDE$1:INSIDE}function splitsVolumeEnclosingCone2(t,s,e,i,r){ts3dutils.assert(e.containsPoint(s));const n=e.tangentAt(i).times(r),a=(P3.forAnchorAndPlaneVectors(s,n,n.getPerpendicular()),t.faces.filter(t=>t.getAllEdges().some(t=>t.a.like(s))));for(let t=0;t<a.length;t++){const n=a[t];if(n.surface.containsCurve(e)&&n.pointsToInside3(s,e,i,r)!=exports.PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE}return t.containsPoint(e.at(i+1e-6*r),!0)?INSIDE:OUTSIDE$1}function fff(t,s){const e=t.edge.reversed?t.edge.b:t.edge.a,i=s.normalP(e),r=ts3dutils.snap0(t.inside.dot(i));return 0!==r?0<r?OUTSIDE$1:INSIDE:s.isCoplanarTo(t.face.surface)?0<t.normalAtCanonA.dot(i)?COPLANAR_SAME:COPLANAR_OPPOSITE:void ts3dutils.assert(!1)}function triangulateVertices(t,s,e){const i=t.maxAbsDim(),r=sign$10(t.e(i)),n=new Float64Array(2*s.length);let a=s.length;for(;a--;)switch(i){case 0:n[2*a]=s[a].y*r,n[2*a+1]=s[a].z;break;case 1:n[2*a]=s[a].z*r,n[2*a+1]=s[a].x;break;case 2:n[2*a]=s[a].x*r,n[2*a+1]=s[a].y}return earcut(n,e)}function intersectionUnitCircleLine(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=sqrt$6(t*t+s*s-e*e);return{x1:(t*e+s*i)/(t*t+s*s),x2:(t*e-s*i)/(t*t+s*s),y1:(s*e-t*i)/(t*t+s*s),y2:(s*e+t*i)/(t*t+s*s)}}function intersectionUnitCircleLine2(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=ts3dutils.snap0(t*t+s*s-e*e);if(i<0)return[];if(0==i)return[[t*e/(t*t+s*s),s*e/(t*t+s*s)]];{const r=sqrt$6(i);return[[(t*e+s*r)/(t*t+s*s),(s*e-t*r)/(t*t+s*s)],[(t*e-s*r)/(t*t+s*s),(s*e+t*r)/(t*t+s*s)]]}}function intersectionCircleLine(t,s,e,i){ts3dutils.assertNumbers(t,s,e,i);const r=sqrt$6(i*i*(t*t+s*s)-e*e);return{x1:(t*e+s*r)/(t*t+s*s),x2:(t*e-s*r)/(t*t+s*s),y1:(s*e-t*r)/(t*t+s*s),y2:(s*e+t*r)/(t*t+s*s)}}function intersectionUnitHyperbolaLine(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=t*t,r=s*s,n=e*e,a=2*sqrt$6(r*n+r*r-i*r),o=sqrt$6(4*n*r-4*(r-i)*(n-i));return{x1:(-2*t*e+a)/2/(r-i),x2:(-2*t*e-a)/2/(r-i),y1:(2*s*e-o)/2/(r-i),y2:(2*s*e+o)/2/(r-i)}}function followAlgorithm2d(t,s,e=.5,i,r=s,n){ts3dutils.assertNumbers(e,t(0,0)),ts3dutils.assertVectors(s),n||(n=new ts3dutils.V3(-t.y(s.x,s.y),t.x(s.x,s.y),0).toLength(e)),ts3dutils.assertVectors(n);const a=[],o=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let l=0,u=s,c=n;do{a.push(u),o.push(c);const s=u.plus(c);ts3dutils.assert(s);const n=curvePointMF(t,s),h=t.x(n.x,n.y),d=t.y(n.x,n.y),f=new ts3dutils.V3(-d,h,0).toLength(e);if(u.equals(n)&&ts3dutils.assertNever(),c.dot(f)<0){const s=ts3dutils.newtonIterate2d(t.x,t.y,u.x,u.y);if(ts3dutils.eq0(t(s.x,s.y))&&s.distanceTo(u)<abs$13(e)){a.push(s),o.push(u.to(s));break}throw new Error}if(l>4){if(!i(u.x,u.y))break;if(u.distanceTo(r)<e){a.push(r);const s=new ts3dutils.V3(-t.y(r.x,r.y),t.x(r.x,r.y),0).toLength(e);o.push(s);break}}ts3dutils.assert(ts3dutils.eq0(t(n.x,n.y),2*ts3dutils.NLA_PRECISION),u,n,s),c=f,u=n}while(++l<1e3);return ts3dutils.assert(l<1e3),{points:a,tangents:o}}function followAlgorithm2dAdjustable(t,s,e=.5,i,r=s){ts3dutils.assertNumbers(e,t(0,0)),ts3dutils.assertVectors(s);const n=[],a=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let o=s,l=o,u=0;do{const s=t.x(o.x,o.y),e=t.y(o.x,o.y),i=t.xx(o.x,o.y),r=t.yy(o.x,o.y),u=t.xy(o.x,o.y),c=abs$13((Math.pow(e,2)*i-2*s*e*u+Math.pow(s,2)*r)/Math.pow(Math.pow(s,2)+Math.pow(e,2),2)),h=new ts3dutils.V3(s,e,0).times(c),d=1/16/h.length(),f=new ts3dutils.V3(-e,s,0).unit(),p=(o.minus(l).dot(f),o.plus(f.times(d).plus(h.times(Math.pow(d,2)/2))));n.push(o),a.push(f),l=o;const m=curvePointMF(t,p);m.equals(o)&&ts3dutils.assertNever(),console.log(o.to(m).length()),o=m,ts3dutils.assert(ts3dutils.eq0(t(o.x,o.y)))}while(u++<1e3&&(u<4||l.distanceTo(r)>e)&&i(o.x,o.y));ts3dutils.assert(1e3!=u);const c=u<4||l.distanceTo(r)>e?o:r,h=new ts3dutils.V3(-t.y(c.x,c.y),t.x(c.x,c.y),0).toLength(e);return n.push(c),a.push(h),{points:n,tangents:a}}function intersectionICurveICurve(t,s,e,i,r,n){ts3dutils.assertNumbers(r,t(0,0),n(0,0)),ts3dutils.assertVectors(s,e),ts3dutils.assert(!i||i instanceof ts3dutils.V3);const a=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y))),r=r||.5;let o=s,l=o,u=0;for(;u++<1e3&&(u<4||o.distanceTo(e)>1.1*r);){const s=t(o.x,o.y),e=(t(o.x+1e-5,o.y)-s)/1e-5,i=(t(o.x,o.y+1e-5)-s)/1e-5;let n=new ts3dutils.V3(-i,e,0).toLength(r);o.minus(l).dot(n)<0&&(n=n.negated()),l=o,o=curvePoint(t,o.plus(n)),a.push(o)}return a}function intersectionICurveICurve2(t,s,e){let i,r=s[0],n=e(r.x,r.y);const a=[];for(let o=0;o<s.length;o++)i=n,(n=e(r=s[o]))*i<=0&&a.push(ts3dutils.newtonIterate2d(t,e,r.x,r.y));return a}function intersectionICurvePSurface(t,s,e){}function cassini(t,s){return(e,i)=>(e*e+i*i)*(e*e+i*i)-2*s*s*(e*e-i*i)-(Math.pow(t,4)-Math.pow(s,4))}!function(t){t.forNerdamer=function(t,s=["x","y"]){const e=nerdamer(t),i=nerdamer.diff(e,s[0]),r=nerdamer.diff(e,s[1]),n=e.buildFunction(s);return n.x=i.buildFunction(s),n.y=r.buildFunction(s),n.xx=nerdamer.diff(i,s[0]).buildFunction(s),n.xy=nerdamer.diff(i,s[1]).buildFunction(s),n.yy=nerdamer.diff(r,s[1]).buildFunction(s),n},t.nerdamerToR2_R=function(t,s=["x","y"]){return t.buildFunction(s)},t.forFFxFy=function(t,s,e){return t.x=s,t.y=e,t}}(exports.MathFunctionR2R||(exports.MathFunctionR2R={}));const cas2=cassini(.9,1.02);function doNotSerialize(t,s){(t.__SERIALIZATION_BLACKLIST||(t.__SERIALIZATION_BLACKLIST={}))[s]="no"}class ClassSerializer{constructor(){this.CLASS_NAMES=new Map,this.NAME_CLASSES=new Map,this.addClass("Object",Object)}addClass(t,s){if(this.NAME_CLASSES.has(t))throw new Error(t);return this.NAME_CLASSES.set(t,s),this.CLASS_NAMES.set(s,t),this}addNamespace(t,s){return Object.keys(t).forEach(e=>{const i=t[e];"function"==typeof i&&i.name&&this.addClass((s?s+".":"")+e,i)}),this}setUpdater(t){return this.updater=t,this}serialize(t){return JSON.stringify(this.serializeObj(t))}serializeObj(t){const s=[],e=t=>{if(void 0!==t&&t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor));else if(Array.isArray(t))if(r.has(t))n.has(t)||(n.set(t,a.length),a.push(t));else{r.add(t);for(let i=0;i<t.length;i++)s.push(""+i),e(t[i]),s.pop()}else if(void 0!==t&&"object"==typeof t)if(r.has(t))n.has(t)||(n.set(t,a.length),a.push(t));else{if(ts3dutils.assert(!t.__noxTarget||!r.has(t.__noxTarget)),ts3dutils.assert(!t.__noxProxy||!r.has(t.__noxProxy)),r.add(t),!t.getConstructorParameters)for(const i of Object.keys(t).sort())"__noxProxy"!=i&&"__noxTarget"!=i&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[i]||(s.push(i),e(t[i]),s.pop()));s.push("proto"),e(Object.getPrototypeOf(t)),s.pop()}},i=(t,s,e)=>{if("string"==typeof t||"number"==typeof t||"boolean"==typeof t||null===t)return t;if(void 0===t)return{"#REF":-1};if(t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor))return{"#REF":this.CLASS_NAMES.get(t.constructor)};let r;if(s&&!e&&void 0!==(r=n.get(t)))return{"#REF":r};if(Array.isArray(t))return t.map(t=>i(t,s));if("object"==typeof t){if(t.getConstructorParameters)return{"#CONSTRUCTOR":this.CLASS_NAMES.get(t.constructor),"#ARGS":i(t.getConstructorParameters(),!1)};const e={};Object.prototype!==Object.getPrototypeOf(t)&&(e["#PROTO"]=i(Object.getPrototypeOf(t),s));for(const r of Object.keys(t))"__noxProxy"!=r&&"__noxTarget"!=r&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[r]||(e[r]=i(t[r],s)));return e}throw new Error("?"+typeof t+t.toString())},r=new Set,n=new Map;let a=[];return n.set(t,0),a.push(t),e(t),a=a.map(t=>i(t,!0,!0))}unserialize(t){let s=0;const e=(t,n)=>{if(++s>100)throw new Error;if(t&&t.constructor===Array){n(t);for(let s=0;s<t.length;s++)e(t[s],e=>t[s]=e)}else if("object"==typeof t&&void 0!=t)if("#CONSTRUCTOR"in t){const s=t["#CONSTRUCTOR"],i=this.NAME_CLASSES.get(s);let r;ts3dutils.assert(i,s+" Missing "),e(t["#ARGS"],t=>r=t),n(new i(...r))}else if("#REF"in t){const s=t["#REF"];"string"==typeof s?n(this.NAME_CLASSES.get(s).prototype):"number"==typeof s&&(-1==s?n(void 0):r[s]?n(r[s]):e(i[s],t=>n(r[s]=t)))}else{let s;"#PROTO"in t?e(t["#PROTO"],t=>{s=Object.create(t),n(s)}):n(s=t);const i=Object.keys(t);for(let r=0;r<i.length;r++)"#PROTO"!=i[r]&&e(t[i[r]],t=>s[i[r]]=t);Object.defineProperty(s,"loadID",{value:getGlobalId(),enumerable:!1,writable:!1}),this.updater&&this.updater(s)}else n(t);s--},i=JSON.parse(t),r=new Array(i.length);return e({"#REF":0},()=>{}),r[0]}}const fragmentShaderLighting="\n\tprecision highp float;\n\tuniform vec4 color;\n\tuniform vec3 camPos;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tvec3 normal1 = normalize(normal);\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\n\t\tvec3 lightDir = normalize(vPosition.xyz - lightPos);\n        vec3 reflectionDirection = reflect(lightDir, normal1);\n        vec3 eyeDirection = normalize(camPos.xyz-vPosition.xyz);\n        float uMaterialShininess = 256.0;\n\t\tfloat specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n\t\tfloat lightIntensity = 0.6 + 0.2 * max(0.0, -dot(lightDir, normal1)) + 0.2*specularLightWeighting;\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\n\t}\n",vertexShaderLighting="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tuniform mat4 LGL_ModelViewMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n        vPosition = LGL_ModelViewMatrix * LGL_Vertex;\n\t\tnormal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t}\n",vertexShaderWaves="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tuniform mat4 LGL_ModelViewMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tnormal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t\tfloat offset = mod  (((LGL_Vertex.x + LGL_Vertex.y + LGL_Vertex.z) * 31.0), 20.0) - 10.0;\n\t\tvec4 modPos = LGL_Vertex + vec4(normal * offset, 0);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * modPos;\n        vPosition = LGL_ModelViewMatrix * modPos;\n\t}\n",vertexShaderBasic="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t}\n",vertexShaderColor="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tattribute vec4 color;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t\tfragColor = color;\n\t}\n",vertexShaderArc="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float step, offset;\n\tuniform float radius, width;\n\tvoid main() {\n\t\tfloat r = radius;\n\t\tfloat t = offset + LGL_Vertex.x * step;\n\t\tfloat pRadius = r - LGL_Vertex.y * width;\n\t\tvec4 p = vec4(pRadius * cos(t), pRadius * sin(t), 0, 1);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * p;\n}\n",vertexShaderConic3d="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec3 center, f1, f2;\n\tuniform int mode;\n\tfloat sinh(float x) { return (exp(x) - exp(-x)) / 2.0; }\n\tfloat cosh(float x) { return (exp(x) + exp(-x)) / 2.0; }\n\tvoid main() {\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT);\n\n\t\tvec3 normal = normalize(cross(f1, f2));\n\n\t\tvec3 p, tangent;\n\t\tif (0 == mode) { // ellipse\n\t\t\tp = center + f1 * cos(t) + f2 * sin(t);\n\t\t\ttangent = f1 * -sin(t) + f2 * cos(t);\n\t\t}\n\t\tif (1 == mode) { // parabola\n\t\t\tp = center + f1 * t + f2 * t * t;\n\t\t\ttangent = f1 + f2 * t;\n\t\t}\n\t\tif (2 == mode) { // hyperbola\n\t\t\tp = center + f1 * cosh(t) + f2 * sinh(t);\n\t\t\ttangent = f1 * sinh(t) + f2 * cosh(t);\n\t\t}\n\t\tvec3 outDir = normalize(cross(normal, tangent));\n\t\tvec3 p2 = p + scale * (outDir * LGL_Vertex.y + normal * LGL_Vertex.z);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderBezier="\n    // calculates a bezier curve using LGL_Vertex.x as the (t) parameter of the curve\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float width, startT, endT;\n\tuniform vec3 p0, p1, p2, p3;\n\tvoid main() {\n\t\t// LGL_Vertex.y is in [0, 1]\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 pPos = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 pNormal = normalize(vec3(pTangent.y, -pTangent.x, 0));\n\t\tvec4 p = vec4(pPos - LGL_Vertex.y * width * pNormal, 1);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * p;\n\t}\n",vertexShaderBezier3d="\n    // calculates a bezier curve using LGL_Vertex.x as the (t) parameter of the curve\n\tuniform float scale, startT, endT;\n\tuniform vec3 ps[4];\n\tuniform vec3 p0, p1, p2, p3, normal;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\t// LGL_Vertex.y is in [0, 1]\n\t\tvec3 p5 = ps[0];\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 p = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 outDir = normalize(cross(normal, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * LGL_Vertex.y + correctNormal * LGL_Vertex.z);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderGeneric="\n\tuniform float scale;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tvoid main() {\n\t\tvec3 normal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t\tvec4 vertexPos = LGL_Vertex + vec4(normal * scale, 0);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vertexPos;\n\t}\n",vertexShaderRing="\n\t#define M_PI 3.1415926535897932384626433832795\n\tuniform float step;\n\tuniform float innerRadius, outerRadius;\n\tattribute float index;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(index, index, index, 1);\n\t\tfloat id = atan(LGL_Vertex.x, LGL_Vertex.y) / M_PI  * 32.0;\n\t\tfloat radius = mod(id, 2.0) < 1.0 ? outerRadius : innerRadius;\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(radius * cos(index * step), radius * sin(index * step), 0, 1);\n\t}\n",fragmentShaderColor="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = color;\n\t}\n",fragmentShaderVaryingColor="\n\tprecision highp float;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_FragColor = fragColor;\n\t}\n",fragmentShaderColorHighlight="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tfloat diagonal = (gl_FragCoord.x + 2.0 * gl_FragCoord.y);\n\t\tif (mod(diagonal, 50.0) > 40.0) { // mod(diagonal, 2.0) > 1.0\n\t\t\tdiscard;\n\t\t\t//gl_FragColor = color + vec4(0.2,0.2,0.2,0);\n\t\t} else {\n\t\t\tgl_FragColor = color - vec4(0.2,0.2,0.2,0);\n\t\t}\n\t}\n",vertexShaderTexture="\n\tvarying vec2 texturePos;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tvoid main() {\n\t\ttexturePos = LGL_Vertex.xy;\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t}\n",fragmentShaderTextureColor="\n\tprecision highp float;\n\tvarying vec2 texturePos;\n\tuniform vec4 color;\n\tuniform sampler2D texture;\n\tvoid main() {\n\t\tgl_FragColor = texture2D(texture, texturePos) * color;\n\t}\n",{pow:pow$5,sign:sign$11}=Math;function parseGetParams(t){const s={};return t.split("&").forEach(function(t){const e=t.indexOf("=");-1==e?s[t]=t:s[t.substr(0,e)]=decodeURI(t.substr(e+1))}),s}const COLORS={RD_FILL:chroma("#9EDBF9"),RD_STROKE:chroma("#77B0E0"),TS_FILL:chroma("#D19FE3"),TS_STROKE:chroma("#A76BC2"),PP_FILL:chroma("#F3B6CF"),PP_STROKE:chroma("#EB81B4")};class BREPGLContext{constructor(t){this.cachedMeshes=new WeakMap,this.shaders=initShaders(t),initMeshes(this.meshes={},t)}static create(t){return ts3dutils.addOwnProperties(t,BREPGLContext.prototype),ts3dutils.addOwnProperties(t,new BREPGLContext(t)),t}drawPoint(t,s=tsgl.GL_COLOR_BLACK,e=5){this.pushMatrix(),this.translate(t),this.scale(e,e,e),this.shaders.singleColor.uniforms({color:s}).draw(this.meshes.sphere1),this.popMatrix()}drawEdge(t,s=tsgl.GL_COLOR_BLACK,e=2){CURVE_PAINTERS[t.curve.constructor.name](this,t.curve,s,t.minT,t.maxT,e)}drawCurve(t,s=tsgl.GL_COLOR_BLACK,e=2,i,r){CURVE_PAINTERS[t.constructor.name](this,t,s,i,r,e)}drawVector(t,s,e=tsgl.GL_COLOR_BLACK,i=1){this.pushMatrix();const r=t.getPerpendicular().unit();this.multMatrix(ts3dutils.M4.forSys(t,r,t.cross(r).unit(),s)),1!=i&&this.scale(i,i,i),this.shaders.singleColor.uniforms({color:e}).draw(this.meshes.vector),this.popMatrix()}drawVectors(t){this.drawVector(ts3dutils.V3.X,ts3dutils.V3.O,chroma("red").gl(),void 0),this.drawVector(ts3dutils.V3.Y,ts3dutils.V3.O,chroma("green").gl(),void 0),this.drawVector(ts3dutils.V3.Z,ts3dutils.V3.O,chroma("blue").gl(),void 0),t.forEach(t=>this.drawVector(t.dir1,t.anchor,t.color,void 0))}drawPlane(t,s,e=!1){this.pushMatrix(),this.multMatrix(ts3dutils.M4.forSys(t.right,t.up,t.normal1)),this.translate(t.sMin,t.tMin,t.w),this.scale(t.sMax-t.sMin,t.tMax-t.tMin,1);const i=e?this.meshes.xyDottedLinePlane:this.meshes.xyLinePlane;this.shaders.singleColor.uniforms({color:s}).draw(i,tsgl.DRAW_MODES.LINES),this.popMatrix()}}function conicPainter(t,s,e,i,r,n,a=2){s.shaders.ellipse3d.uniforms({f1:e.f1,f2:e.f2,center:e.center,color:i,startT:r,endT:n,scale:a,mode:t}).draw(s.meshes.pipe)}const CURVE_PAINTERS={[SemiEllipseCurve.name]:conicPainter.bind(void 0,0),[EllipseCurve.name]:conicPainter.bind(void 0,0),[ParabolaCurve.name]:conicPainter.bind(void 0,1),[HyperbolaCurve.name]:conicPainter.bind(void 0,2),[ImplicitCurve.name](t,s,e,i,r,n=2,a=ts3dutils.V3.Z){let o=t.cachedMeshes.get(s);o||(o=(new tsgl.Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal"),s.addToMesh(o),o.compile(),t.cachedMeshes.set(s,o)),t.shaders.generic3d.uniforms({color:e,scale:n}).draw(o)},[BezierCurve.name](t,s,e,i,r,n=2,a=ts3dutils.V3.Z){t.shaders.bezier3d.uniforms({p0:s.p0,p1:s.p1,p2:s.p2,p3:s.p3,color:e,startT:i,endT:r,scale:n,normal:a}).draw(t.meshes.pipe)},[L3$1.name](t,s,e,i,r,n=2,a=ts3dutils.V3.Z){t.pushMatrix();const o=s.at(i),l=s.at(r).minus(o),u=l.getPerpendicular().unit(),c=ts3dutils.M4.forSys(l,u,l.cross(u).unit(),o);t.multMatrix(c),t.scale(1,n,n),t.shaders.singleColor.uniforms({color:e}).draw(t.meshes.pipe),t.popMatrix()}};function initMeshes(t,s){s.makeCurrent(),t.sphere1=tsgl.Mesh.sphere(2),t.segment=tsgl.Mesh.plane({startY:-.5,height:1,detailX:128}),t.text=tsgl.Mesh.plane(),t.vector=tsgl.Mesh.rotation([ts3dutils.V3.O,ts3dutils.V(0,.05,0),ts3dutils.V(.8,.05),ts3dutils.V(.8,.1),ts3dutils.V(1,0)],L3$1.X,ts3dutils.TAU,16,!0),t.pipe=tsgl.Mesh.rotation(ts3dutils.arrayFromFunction(128,t=>new ts3dutils.V3(t/127,-.5,0)),L3$1.X,ts3dutils.TAU,8,!0),t.xyLinePlane=tsgl.Mesh.plane(),t.xyDottedLinePlane=makeDottedLinePlane()}function initShaders(t){return t.makeCurrent(),{singleColor:tsgl.Shader.create(vertexShaderBasic,fragmentShaderColor),multiColor:tsgl.Shader.create(vertexShaderColor,fragmentShaderVaryingColor),singleColorHighlight:tsgl.Shader.create(vertexShaderBasic,fragmentShaderColorHighlight),textureColor:tsgl.Shader.create(vertexShaderTexture,fragmentShaderTextureColor),arc:tsgl.Shader.create(vertexShaderRing,fragmentShaderColor),arc2:tsgl.Shader.create(vertexShaderArc,fragmentShaderColor),ellipse3d:tsgl.Shader.create(vertexShaderConic3d,fragmentShaderColor),generic3d:tsgl.Shader.create(vertexShaderGeneric,fragmentShaderColor),bezier3d:tsgl.Shader.create(vertexShaderBezier3d,fragmentShaderColor),bezier:tsgl.Shader.create(vertexShaderBezier,fragmentShaderColor),lighting:tsgl.Shader.create(vertexShaderLighting,fragmentShaderLighting),waves:tsgl.Shader.create(vertexShaderWaves,fragmentShaderLighting)}}function makeDottedLinePlane(t=128){const s=(new tsgl.Mesh).addIndexBuffer("LINES"),e=ts3dutils.arrayFromFunction(t,s=>new ts3dutils.V3(s/t,0,0));return s.vertices.push(...e),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.Y,ts3dutils.V3.O,ts3dutils.V3.O,ts3dutils.V3.X).transformedPoints(e)),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.X.negated(),ts3dutils.V3.O,ts3dutils.V3.O,new ts3dutils.V3(1,1,0)).transformedPoints(e)),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.Y.negated(),ts3dutils.V3.O,ts3dutils.V3.O,ts3dutils.V3.Y).transformedPoints(e)),s.LINES=ts3dutils.arrayFromFunction(4*t,s=>s-(s>=2*t?1:0)),s.compile(),s}function initNavigationEvents(t,s,e){const i=t.canvas;let r=ts3dutils.V3.O;i.addEventListener("mousemove",i=>{const n=ts3dutils.V(i.pageX,i.pageY),a=r.to(n);if(4&i.buttons){const i=ts3dutils.V(2*-a.x/t.canvas.width,2*a.y/t.canvas.height),r=t.projectionMatrix.inversed().transformVector(i);s.pos=s.pos.plus(r),s.focus=s.focus.plus(r),setupCamera(s,t),e()}if(2&i.buttons){const i=-a.x/6*ts3dutils.DEG,r=-a.y/6*ts3dutils.DEG;let n=ts3dutils.M4.rotateLine(s.focus,s.up,i);const o=s.up.cross(s.pos.minus(s.focus));n=n.times(ts3dutils.M4.rotateLine(s.focus,o,r)),s.pos=n.transformPoint(s.pos),s.up=n.transformVector(s.up),setupCamera(s,t),e()}r=n}),i.addEventListener("wheel",function(i){const r=2*-sign$11(i.deltaY);s.zoomFactor*=pow$5(.9,-r);const n=getPosOnTarget(i),a=ts3dutils.V(2*n.x/t.canvas.offsetWidth-1,2*-n.y/t.canvas.offsetHeight+1,0),o=a.times(1-1/pow$5(.9,-r)),l=t.projectionMatrix.inversed(),u=l.transformVector(o);s.pos=s.pos.plus(u),s.focus=s.focus.plus(u);const c=l.transformPoint(a),h=ts3dutils.M4.rotateLine(c,s.pos.to(s.focus),10*-sign$11(i.deltaX)*ts3dutils.DEG);s.up=h.transformVector(s.up),s.pos=h.transformPoint(s.pos),s.focus=h.transformPoint(s.focus),setupCamera(s,t),e(),i.preventDefault()})}function getMouseLine(t,s){const e=ts3dutils.V(2*t.x/s.canvas.width-1,2*-t.y/s.canvas.height+1,0),i=ts3dutils.V(2*t.x/s.canvas.width-1,2*-t.y/s.canvas.height+1,1),r=s.projectionMatrix.inversed(),n=r.transformPoint(e),a=r.transformPoint(i).minus(n);return L3$1.anchorDirection(n,a)}function getPosOnTarget(t){const s=t.target.getBoundingClientRect();return{x:t.clientX-s.left,y:t.clientY-s.top}}function setupCamera(t,s){const{pos:e,focus:i,up:r,zoomFactor:n}=t;s.matrixMode(s.PROJECTION),s.loadIdentity();const a=s.canvas.width/2/n,o=s.canvas.height/2/n;s.ortho(-a,a,-o,o,-1e4,1e4),s.lookAt(e,i,r),s.matrixMode(s.MODELVIEW),cameraChangeListeners.forEach(s=>s(t))}CURVE_PAINTERS[PICurve$1.name]=CURVE_PAINTERS[ImplicitCurve.name];const cameraChangeListeners=[],SHADERS_TYPE_VAR=!1;exports.Curve=Curve,exports.curvePoint=curvePoint,exports.curvePointMF=curvePointMF,exports.XiEtaCurve=XiEtaCurve,exports.ImplicitCurve=ImplicitCurve,exports.BezierCurve=BezierCurve,exports.EllipseCurve=EllipseCurve,exports.HyperbolaCurve=HyperbolaCurve,exports.L3=L3$1,exports.PICurve=PICurve$1,exports.ParabolaCurve=ParabolaCurve,exports.SemiEllipseCurve=SemiEllipseCurve,exports.P3=P3,exports.Surface=Surface,exports.ParametricSurface=ParametricSurface,exports.ImplicitSurface=ImplicitSurface,exports.ConicSurface=ConicSurface,exports.EllipsoidSurface=EllipsoidSurface,exports.ProjectedCurveSurface=ProjectedCurveSurface,exports.CylinderSurface=CylinderSurface,exports.RotationREqFOfZ=RotationREqFOfZ,exports.SemiCylinderSurface=SemiCylinderSurface,exports.SemiEllipsoidSurface=SemiEllipsoidSurface,exports.PlaneSurface=PlaneSurface$1,exports.ZDirVolumeVisitor=ZDirVolumeVisitor,exports.CalculateAreaVisitor=CalculateAreaVisitor,exports.CustomPlane=CustomPlane,exports.Edge=Edge,exports.PCurveEdge=PCurveEdge,exports.StraightEdge=StraightEdge,exports.FaceInfoFactory=FaceInfoFactory,exports.Face=Face,exports.PlaneFace=PlaneFace,exports.RotationFace=RotationFace,exports.EPS=EPS,exports.getGlobalId=getGlobalId,exports.addLikeSurfaceFaces=addLikeSurfaceFaces,exports.assembleFaceFromLooseEdges=assembleFaceFromLooseEdges,exports.calcNextEdgeIndex=calcNextEdgeIndex,exports.B2=B2,exports.dotCurve=dotCurve,exports.dotCurve2=dotCurve2,exports.INSIDE=INSIDE,exports.OUTSIDE=OUTSIDE$1,exports.COPLANAR_SAME=COPLANAR_SAME,exports.COPLANAR_OPPOSITE=COPLANAR_OPPOSITE,exports.ALONG_EDGE_OR_PLANE=ALONG_EDGE_OR_PLANE,exports.splitsVolumeEnclosingFaces=splitsVolumeEnclosingFaces,exports.splitsVolumeEnclosingFacesP=splitsVolumeEnclosingFacesP,exports.splitsVolumeEnclosingFacesP2=splitsVolumeEnclosingFacesP2,exports.splitsVolumeEnclosingCone=splitsVolumeEnclosingCone,exports.splitsVolumeEnclosingCone2=splitsVolumeEnclosingCone2,exports.fff=fff,exports.triangulateVertices=triangulateVertices,exports.intersectionUnitCircleLine=intersectionUnitCircleLine,exports.intersectionUnitCircleLine2=intersectionUnitCircleLine2,exports.intersectionCircleLine=intersectionCircleLine,exports.intersectionUnitHyperbolaLine=intersectionUnitHyperbolaLine,exports.followAlgorithm2d=followAlgorithm2d,exports.followAlgorithm2dAdjustable=followAlgorithm2dAdjustable,exports.intersectionICurveICurve=intersectionICurveICurve,exports.intersectionICurveICurve2=intersectionICurveICurve2,exports.intersectionICurvePSurface=intersectionICurvePSurface,exports.cassini=cassini,exports.cas2=cas2,exports.doNotSerialize=doNotSerialize,exports.ClassSerializer=ClassSerializer,exports.parseGetParams=parseGetParams,exports.COLORS=COLORS,exports.BREPGLContext=BREPGLContext,exports.CURVE_PAINTERS=CURVE_PAINTERS,exports.initMeshes=initMeshes,exports.initShaders=initShaders,exports.initNavigationEvents=initNavigationEvents,exports.getMouseLine=getMouseLine,exports.getPosOnTarget=getPosOnTarget,exports.setupCamera=setupCamera,exports.cameraChangeListeners=cameraChangeListeners,exports.SHADERS_TYPE_VAR=!1;