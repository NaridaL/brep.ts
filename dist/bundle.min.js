"use strict";function _interopDefault(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var opentype=require("opentype.js"),svgPathdata=require("svg-pathdata"),earcut=_interopDefault(require("earcut")),javasetmap_ts=require("javasetmap.ts"),nerdamer=_interopDefault(require("nerdamer")),chroma=_interopDefault(require("chroma-js")),ts3dutils=require("ts3dutils"),tsgl=require("tsgl");const{abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,atan2:atan2,ceil:ceil,cbrt:cbrt,expm1:expm1,clz32:clz32,cos:cos,cosh:cosh,exp:exp,floor:floor,fround:fround,hypot:hypot,imul:imul,log:log,log1p:log1p,log2:log2,log10:log10,max:max,min:min,pow:pow,random:random,round:round,sign:sign,sin:sin,sinh:sinh,sqrt:sqrt,tan:tan,tanh:tanh,trunc:trunc,E:E,LN10:LN10,LN2:LN2,LOG10E:LOG10E,LOG2E:LOG2E,PI:PI,SQRT1_2:SQRT1_2,SQRT2:SQRT2}=Math;let insideIsInfosWithCurve=!1;class Curve$$1 extends ts3dutils.Transformable{constructor(t,s){super(),this.tMin=t,this.tMax=s,ts3dutils.assertNumbers(t,s),ts3dutils.assert("number"==typeof t&&!isNaN(t)),ts3dutils.assert("number"==typeof s&&!isNaN(s)),ts3dutils.assert(t<s,"tMin < tMax "+t+" < "+s)}static integrate(t,s,e,i){const r=(e-s)/i;let n=0,o=t.at(s),a=0,u=s+r;for(;a<i;a++,u+=r){const s=t.at(u);n+=o.distanceTo(s),o=s}return n}static ispsRecursive(t,s,e,i,r,n){const o=[];return function s(e,r,n,a,u,l,c=0){const h=ts3dutils.NLA_PRECISION;if(u.touchesAABBfuzzy(l)){const u=(e+r)/2,l=(n+a)/2;if(Math.abs(r-e)<h||Math.abs(a-n)<h)return function(s,e){if(!o.some(t=>ts3dutils.eq(t.tThis,s)&&ts3dutils.eq(t.tOther,e))){const r=(s,e)=>t.tangentAt(s).dot(t.at(s).minus(i.at(e))),n=(s,e)=>i.tangentAt(e).dot(t.at(s).minus(i.at(e))),a=(t,s,e,i)=>t.ddt(e).dot(t.at(e).minus(s.at(i)))+t.tangentAt(e).squared(),u=(t,s,e,i)=>-t.tangentAt(e).dot(s.tangentAt(i)),l=ts3dutils.newtonIterate2dWithDerivatives(r,n,s,e,16,a.bind(void 0,t,i),u.bind(void 0,t,i),(s,e)=>-u(i,t,e,s),(s,e)=>-a(i,t,e,s));ts3dutils.assert(isFinite(l.x)),ts3dutils.assert(isFinite(l.y)),void 0==l&&console.log(s,e,t.sce,i.sce),o.push({tThis:l.x,tOther:l.y,p:t.at(l.x)})}}(u,l),!0;{const o=t.getAABB(e,u),h=i.getAABB(n,l);let d,p;s(e,u,n,l,o,h,c+1)||s(e,u,l,a,o,p=i.getAABB(l,a),c+1)||s(u,r,n,l,d=t.getAABB(u,r),h,c+1)||s(u,r,l,a,d,p,c+1)}}return!1}(s,e,r,n,t.getAABB(s,e),i.getAABB(r,n)),ts3dutils.fuzzyUniquesF(o,t=>t.tThis)}static breakDownIC(t,s,e,i,r,n){const{uMin:o,uMax:a,vMin:u,vMax:l}=s,c=l-u,h=ceil((a-o)/e),d=ceil(c/i),p=new Array(h*d).fill(0),f=(t,s)=>p[s*h+t],m=(t,s)=>0<=t&&t<h&&0<=s&&s<d&&(p[s*h+t]=1),$=[],g=[];for(let a=0;a<h;a++)t:for(let l=0;l<d;l++){if(f(a,l))continue;m(a,l);let c=o+(a+.5)*e,h=u+(l+.5)*i;const d=c,p=h;for(let s=0;s<8;s++){const s=t(c,h),e=t.x(c,h),i=t.y(c,h);if(0===Math.pow(e,2)+Math.pow(i,2))continue t;const r=s/(Math.pow(e,2)+Math.pow(i,2));c-=r*e,h-=r*i}const v=floor((c-o)/e),P=floor((h-u)/i);if(g.push({i:a,j:l,li:v,lj:P,startS:d,startT:p,u:c,v:h,"bounds(u, v)":uvInAABB2$$1(s,c,h),"ic(s,t)":t(c,h)}),(a==v&&l==P||!f(v,P))&&(m(v,P),uvInAABB2$$1(s,c,h)&&n(c,h)&&ts3dutils.eq0(t(c,h)))){const a=mkcurves(t,c,h,r,s,n);for(const t of a){ts3dutils.assert(t.points.length>2);for(const{x:s,y:r}of t.points){const t=(s-o)/e,n=(r-u)/i;m(t-.5|0,n-.5|0),m(t-.5|0,n+.5|0),m(t+.5|0,n-.5|0),m(t+.5|0,n+.5|0)}}$.push(...a)}}for(const{points:t}of $)for(let s=0;s<t.length-1;s++)ts3dutils.assert(!t[s].equals(t[s+1]));return $}toString(){return this.toSource()}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters(),this.tMin,this.tMax)}withBounds(t=this.tMin,s=this.tMax){return new this.constructor(...this.getConstructorParameters(),t,s)}closestPointToPoint(t){return this.at(this.closestTToPoint(t))}isValidT(t){return ts3dutils.le(this.tMin,t)&&ts3dutils.le(t,this.tMax)}diff(t,s){return this.at(t).to(this.at(t+s))}closestTToPoint(t,s,e=this.tMin,i=this.tMax){return void 0===s&&(s=ts3dutils.arrayFromFunction(32,t=>e+(i-e)*t/31).withMax(s=>-this.at(s).distanceTo(t))),ts3dutils.newtonIterateWithDerivative(s=>this.at(s).minus(t).dot(this.tangentAt(s)),s,16,s=>this.tangentAt(s).squared()+this.at(s).minus(t).dot(this.ddt(s)))}calcSegmentPoints(t,s,e,i,r,n){ts3dutils.assert(this.tIncrement,"tIncrement not defined on "+this);const o=this.tIncrement,a=[];if(n&&a.push(e),ts3dutils.assert(r!=t<s),t<s){const e=Math.ceil((t+ts3dutils.NLA_PRECISION)/o),i=Math.floor((s-ts3dutils.NLA_PRECISION)/o);for(let t=e;t<=i;t++)a.push(this.at(t*o))}else{const e=Math.floor((t-ts3dutils.NLA_PRECISION)/o),i=Math.ceil((s+ts3dutils.NLA_PRECISION)/o);for(let t=e;t>=i;t--)a.push(this.at(t*o))}return a.push(i),a}calcSegmentTs(t,s,e,i){ts3dutils.assert(this.tIncrement,"tIncrement not defined on "+this);const r=this.tIncrement,n=[];if(i&&n.push(t),ts3dutils.assert(e!=t<s),t<s){const e=Math.ceil((t+ts3dutils.NLA_PRECISION)/r),i=Math.floor((s-ts3dutils.NLA_PRECISION)/r);for(let t=e;t<=i;t++)n.push(t*r)}else{const e=Math.floor((t-ts3dutils.NLA_PRECISION)/r),i=Math.ceil((s+ts3dutils.NLA_PRECISION)/r);for(let t=e;t>=i;t--)n.push(t*r)}return n.push(s),n}distanceToPoint(t,s,e){const i=this.closestTToPoint(t,s,e);return this.at(i).distanceTo(t)}asSegmentDistanceToPoint(t,s,e){let i=this.closestTToPoint(t,s,e);return i=ts3dutils.clamp(i,s,e),this.at(i).distanceTo(t)}isInfosWithCurve(t){if(insideIsInfosWithCurve)return Curve$$1.ispsRecursive(this,this.tMin,this.tMax,t,t.tMin,t.tMax);try{return insideIsInfosWithCurve=!0,t.isInfosWithCurve(this).map(t=>{ts3dutils.assert(t);const{tThis:s,tOther:e,p:i}=t;return{tOther:s,tThis:e,p:i}})}finally{insideIsInfosWithCurve=!1}}isTsWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isTsWithPlane(t.plane);if(t instanceof ProjectedCurveSurface$$1){const s=new P3$$1(t.dir.unit(),0),e=this.project(s);return t.baseCurve.project(s).isInfosWithCurve(e).map(t=>t.tOther)}if(t instanceof EllipsoidSurface$$1){const s=this.transform(t.matrixInverse);if(!s.getAABB().touchesAABBfuzzy(new ts3dutils.AABB(ts3dutils.V3.XYZ.negated(),ts3dutils.V3.XYZ)))return[];const e=t=>s.at(t).length()-1,i=t=>s.at(t).unit().dot(s.tangentAt(t)),r=1/2048,n=[];for(let t=this.tMin;t<=this.tMax;t+=r){const o=r*s.tangentAt(t).length();if(abs(e(t))<=o){let s=ts3dutils.newtonIterateWithDerivative(e,t,16,i);ts3dutils.eq0(e(s))&&!ts3dutils.eq0(i(s))||(s=ts3dutils.newtonIterate1d(i,t,16)),ts3dutils.eq0(e(s))&&!n.some(t=>ts3dutils.eq(t,s))&&n.push(s)}}return n.filter(s=>t.containsPoint(this.at(s)))}throw new Error}arcLength(t,s,e=1){return ts3dutils.assert(t<s,"startT < endT"),ts3dutils.glqInSteps(t=>this.tangentAt(t).length(),t,s,e)}equals(t){return this===t||ts3dutils.hasConstructor(t,this.constructor)&&this.getConstructorParameters().equals(t.getConstructorParameters())}hashCode(){return this.getConstructorParameters().hashCode()}getAABB(t=this.tMin,s=this.tMax){t=isFinite(t)?t:this.tMin,s=isFinite(s)?s:this.tMax;const e=this.at(t),i=this.at(s),r=this.roots(),n=new Array(3),o=new Array(3);for(let a=0;a<3;a++){const u=r[a];n[a]=Math.min(e.e(a),i.e(a)),o[a]=Math.max(e.e(a),i.e(a));for(const e of u)t<e&&e<s&&(n[a]=Math.min(n[a],this.at(e).e(a)),o[a]=Math.max(o[a],this.at(e).e(a)))}return new ts3dutils.AABB(ts3dutils.V3.fromArray(n),ts3dutils.V3.fromArray(o))}reversed(){throw new Error}clipPlane(t){const s=this.isTsWithPlane(t).filter(t=>this.tMin<=t&&t<=this.tMax);return ts3dutils.getIntervals(s,this.tMin,this.tMax).mapFilter(([s,e])=>{const i=(s+e)/2;return!ts3dutils.eq(s,e)&&t.distanceToPointSigned(this.at(i))<0&&this.withBounds(s,e)})}}function mkcurves(t,s,e,i,r,n){const o=ts3dutils.V(s,e);ts3dutils.assert(i>0);const{points:a,tangents:u}=followAlgorithm2d$$1(t,o,i,r,n);if(a.length>4&&a[0].distanceTo(a.last)<=abs(i)){for(let t=0;t<a.length-1;t++)ts3dutils.assert(!a[t].equals(a[t+1]));const t=floor(a.length/2),s=a.slice(0,t),e=a.slice(t-1,a.length),i=u.slice(0,t),r=u.slice(t-1,u.length);for(let t=0;t<s.length-1;t++)ts3dutils.assert(!s[t].equals(s[t+1]));for(let t=0;t<e.length-1;t++)ts3dutils.assert(!e[t].equals(e[t+1]));return[{points:s,tangents:i},{points:e,tangents:r}]}{const{points:s,tangents:e}=followAlgorithm2d$$1(t,o,-i,r,n),a=followAlgorithm2d$$1(t,s.last,i,r,n,void 0,e.last.negated());return ts3dutils.assert(a.points.length>2),[a]}}function breakDownPPCurves$$1(t,s,e,i,r){const{uMin:n,uMax:o,vMin:a,vMax:u}=t,l=uvInAABB2$$1.bind(void 0,t),c=uvInAABB2$$1.bind(void 0,s),h=u-a,d=ceil((o-n)/e),p=ceil(h/i),f=new Array(d*p).fill(0),m=(t,s)=>f[s*d+t],$=(t,s)=>0<=t&&t<d&&0<=s&&s<p&&(f[s*d+t]=1),g=[],v=[];for(let o=0;o<d;o++)t:for(let u=0;u<p;u++){if(m(o,u))continue;$(o,u);const h=n+(o+.5)*e,d=a+(u+.5)*i,p=curvePointPP$$1(t,s,t.pUV(h,d));if(void 0===p)continue t;const{p:f,st1:{x:P,y:x},st2:{x:C,y:M}}=p,V=floor((P-n)/e),w=floor((x-a)/i);if(v.push({i:o,j:u,li:V,lj:w,startU:h,startV:d,u:P,v:x,"bounds(u, v)":l(P,x)}),(o==V&&u==w||!m(V,w))&&($(V,w),l(P,x)&&c(C,M))){console.log(ts3dutils.V(P,x).sce);const o=mkPPCurves(t,s,f,r,l,c);for(const t of o){ts3dutils.assert(t.st1s.length>2);for(const{x:s,y:r}of t.st1s){const t=(s-n)/e,o=(r-a)/i;$(t-.5|0,o-.5|0),$(t-.5|0,o+.5|0),$(t+.5|0,o-.5|0),$(t+.5|0,o+.5|0)}}g.push(...o)}}console.table(v);for(const{points:t}of g)for(let s=0;s<t.length-1;s++)ts3dutils.assert(!t[s].equals(t[s+1]));return g.map(({points:e,tangents:i,st1s:n})=>new PPCurve$$1(e,i,t,s,n,void 0,r,1))}function mkPPCurves(t,s,e,i,r,n){const{points:o,tangents:a,st1s:u}=followAlgorithmPP$$1(t,s,e,i,r,n);if(o[0].distanceTo(o.last)<i&&o.length>2){for(let t=0;t<o.length-1;t++)ts3dutils.assert(!o[t].equals(o[t+1]));const t=floor(o.length/2),s=o.slice(0,t),e=o.slice(t-1,o.length),i=a.slice(0,t),r=a.slice(t-1,a.length),n=u.slice(0,t),l=u.slice(t-1,a.length);r[r.length-1]=i[0],e[r.length-1]=s[0],l[r.length-1]=n[0];for(let t=0;t<s.length-1;t++)ts3dutils.assert(!s[t].equals(s[t+1]));for(let t=0;t<e.length-1;t++)ts3dutils.assert(!e[t].equals(e[t+1]));return[{points:s,tangents:i,st1s:n},{points:e,tangents:r,st1s:l}]}{const{points:o}=followAlgorithmPP$$1(t,s,e,-i,r,n),a=followAlgorithmPP$$1(t,s,o.last,i,r,n);return ts3dutils.assert(a.points.length>2),[a]}}function AABB2$$1(t,s,e,i){return{uMin:t,uMax:s,vMin:e,vMax:i}}function uvInAABB2$$1(t,s,e){return t.uMin<=s&&s<=t.uMax&&t.vMin<=e&&e<=t.vMax}function curvePoint$$1(t,s,e,i){let r=s;for(let s=0;s<8;s++){const s=t(r.x,r.y),n=e(r.x,r.y),o=i(r.x,r.y),a=s/(n*n+o*o);r=r.minus(new ts3dutils.V3(a*n,a*o,0))}return r}function curvePointMF$$1(t,s,e=8,i=1/(1<<30)){let r=s;for(let s=0;s<e;s++){const s=t(r.x,r.y),e=t.x(r.x,r.y),n=t.y(r.x,r.y),o=s/(e*e+n*n);if(r=r.minus(new ts3dutils.V3(o*e,o*n,0)),abs(s)<=i)break}return r}Curve$$1.hlol=0;class XiEtaCurve$$1 extends Curve$$1{constructor(t,s,e,i,r){if(super(i,r),this.center=t,this.f1=s,this.f2=e,this.tMin=i,this.tMax=r,ts3dutils.assertVectors(t,s,e),this.normal=s.cross(e),this.normal.likeO()){this.matrix=ts3dutils.M4.forSys(s,e,s.unit(),t);const i=s.getPerpendicular();this.matrixInverse=new ts3dutils.M4(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1).times(ts3dutils.M4.forSys(s,i,s.cross(i),t).inversed())}else this.normal=this.normal.unit(),this.matrix=ts3dutils.M4.forSys(s,e,this.normal,t),this.matrixInverse=this.matrix.inversed()}static intersectionUnitLine(t,s,e,i,r){throw new Error("abstract")}static forAB(t,s,e=ts3dutils.V3.O){return new this(e,ts3dutils.V(t,0,0),ts3dutils.V(0,s,0))}static XYLCValid(t){throw new Error("abstract")}static XYLCPointT(t,s,e){throw new Error("abstract")}static unitIsInfosWithLine(t,s,e,i,r,n){throw new Error("abstract")}addToMesh(t,s=4,e=0,i=1){const r=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/s)),n=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(e,ts3dutils.TAU*t/s)),o=this.tIncrement,a=Math.ceil((this.tMin+ts3dutils.NLA_PRECISION)/o),u=Math.floor((this.tMax-ts3dutils.NLA_PRECISION)/o);for(let e=a;e<=u;e+=i){const i=e*o,a=t.vertices.length;if(0!==e)for(let e=0;e<s;e++)tsgl.pushQuad(t.TRIANGLES,!0,a-s+e,a+e,a-s+(e+1)%s,a+(e+1)%s);const u=this.at(i),l=this.tangentAt(i),c=ts3dutils.M4.forSys(this.normal,l.cross(this.normal),l,u);t.normals.push(...c.transformedVectors(r)),t.vertices.push(...c.transformedPoints(n))}}getConstructorParameters(){return[this.center,this.f1,this.f2]}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1,this.tMin,this.tMax,t.tMin,t.tMax):t instanceof BezierCurve$$1?this.isInfosWithBezier(t):t instanceof XiEtaCurve$$1&&!this.normal.isParallelTo(t.normal)?this.isTsWithPlane(t.getPlane()).mapFilter(s=>{const e=this.at(s);if(t.containsPoint(e))return{tThis:s,tOther:t.pointT(e),p:e}}):super.isInfosWithCurve(t)}transform(t){return new this.constructor(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),this.tMin,this.tMax)}equals(t){return this==t||void 0!=t&&this.constructor==t.constructor&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.center.hashCode())+this.f1.hashCode())+this.f2.hashCode())}likeCurve(t){return ts3dutils.hasConstructor(t,this.constructor)&&this.center.like(t.center)&&this.f1.like(t.f1)&&this.f2.like(t.f2)}normalP(t){return this.tangentAt(t).cross(this.normal)}getPlane(){return P3$$1.normalOnAnchor(this.normal,this.center)}isTsWithPlane(t){if(ts3dutils.assertInst(P3$$1,t),t.normal1.isParallelTo(this.normal))return[];const s=t.normal1,e=t.w,i=this.center,r=this.f1,n=this.f2,o=s.dot(r),a=s.dot(n),u=e-s.dot(i);return this.constructor.intersectionUnitLine(o,a,u,this.tMin,this.tMax)}pointT(t){ts3dutils.assertVectors(t);const s=this.matrixInverse.transformPoint(t);return this.constructor.XYLCPointT(s)}containsPoint(t){const s=this.matrixInverse.transformPoint(t);return ts3dutils.eq0(s.z)&&this.isValidT(this.constructor.XYLCPointT(s,this.tMin,this.tMax))}isInfosWithLine(t,s,e=this.tMin,i=this.tMax,r=-1e5,n=1e5){const o=this.matrixInverse.transformPoint(t),a=this.matrixInverse.transformVector(s);if(ts3dutils.eq0(a.z)){if(ts3dutils.eq0(o.z))return this.constructor.unitIsInfosWithLine(o,a,t,s,e,i)}else{const e=o.z/a.z,i=a.times(e).plus(o);if(this.constructor.XYLCValid(i))return[{tThis:this.constructor.XYLCPointT(i),tOther:e,p:t.plus(s.times(e))}]}return[]}isTsWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isTsWithPlane(t.plane);if(t instanceof EllipsoidSurface$$1){return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).filter(s=>t.containsPoint(s.p)).map(t=>t.tThis)}if(t instanceof ProjectedCurveSurface$$1||t instanceof ConicSurface$$1)return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).map(t=>t.tThis);throw new Error}isInfosWithBezier(t){const s=t.transform(this.matrixInverse);if(new PlaneSurface$$1(P3$$1.XY).containsCurve(s))return this.isInfosWithBezier2D(t);return s.isTsWithPlane(P3$$1.XY).mapFilter(e=>{const i=s.at(e);if(this.constructor.XYLCValid(i))return{tOther:e,p:t.at(e),tThis:this.constructor.XYLCPointT(i)}})}isInfosWithBezier2D(t,s=t.tMin,e=t.tMax){return Curve$$1.ispsRecursive(this,this.tMin,this.tMax,t,s,e)}isOrthogonal(){return this.f1.isPerpendicularTo(this.f2)}at2(t,s){return ts3dutils.assertNumbers(t,s),this.center.plus(this.f1.times(t)).plus(this.f2.times(s))}debugInfo(){return{points:[this.center,this.at2(.5,0),this.at2(0,1/3),this.at2(0,2/3)],lines:[this.center,this.at2(0,1),this.center,this.at2(1,0)]}}}function parabola4Projection$$1(t,s,e){return HyperbolaCurve$$1.XY.rotateZ(45*ts3dutils.DEG)}class ImplicitCurve$$1 extends Curve$$1{constructor(t,s,e=1,i,r=(1==e?0:-(t.length-1)),n=(1==e?t.length-1:0)){super(r,n),this.points=t,this.tangents=s,this.dir=e,this.generator=i,ts3dutils.assert(t.length>2),ts3dutils.assert(0<=r&&r<=t.length-1,r,t.length),ts3dutils.assert(0<=n&&n<=t.length-1,n,t.length)}likeCurve(t){throw new Error("Method not implemented.")}toSource(t=(t=>t)){return this.generator||super.toSource(t)}containsPoint(t){return ts3dutils.assertVectors(t),!isNaN(this.pointT(t))}equals(t){return this==t||Object.getPrototypeOf(t)==PICurve$$1.prototype&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])}hashCode(){return[this.points[0],this.tangents[0]].hashCode()}tangentP(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t),"this.containsPoint(pWC)"+this.containsPoint(t));const s=this.pointT(t);return this.tangentAt(s)}tangentAt(t){return t=ts3dutils.clamp(t,this.tMin,this.tMax),ts3dutils.V3.lerp(this.tangents[floor(t)],this.tangents[ceil(t)],t%1)}at(t){return ts3dutils.assert(isFinite(t)),ts3dutils.V3.lerp(this.points[floor(t)],this.points[ceil(t)],t%1)}getConstructorParameters(){throw new Error}roots(){const t=ts3dutils.arrayRange(0,this.points.length);return[t,t,t]}addToMesh(t,s=4,e=0,i=1){const r=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/s)),n=ts3dutils.arrayFromFunction(s,t=>ts3dutils.V3.polar(e,ts3dutils.TAU*t/s));let o=ts3dutils.V3.Z,a=ts3dutils.M4.IDENTITY;for(let e=0;e<this.points.length;e+=i){const i=t.vertices.length;if(0!==e)for(let e=0;e<s;e++)tsgl.pushQuad(t.TRIANGLES,!0,i-s+e,i+e,i-s+(e+1)%s,i+(e+1)%s);const u=this.points[e],l=this.tangents[e],c=ts3dutils.M4.rotateAB(o,l).times(a);t.normals.push(...c.transformedVectors(r));const h=ts3dutils.M4.translate(u).times(c);t.vertices.push(...h.transformedPoints(n)),o=l,a=c}}rootsApprox(){const t=[[],[],[]],s=this.points;let e=s[1].minus(s[0]);for(let i=2;i<s.length;i++){const r=s[i].minus(s[i-1]);for(let s=0;s<3;s++)Math.sign(e.e(s))!=Math.sign(r.e(s))&&t[s].push(i);e=r}return t}pointT(t){const s=ts3dutils.arrayRange(floor(this.tMin),ceil(this.tMax),1).withMax(s=>-t.distanceTo(this.points[s]));if(void 0===s)throw new Error;if(this.points[s].like(t))return s;const e=max(0,s-1),i=min(this.points.length-1,s+1),r=this.tangentAt(s),n=ts3dutils.bisect(s=>this.at(s).to(t).dot(r),e,i,32);return isFinite(n)&&ts3dutils.eq0(this.at(n).distanceTo(t))?n:NaN}}function surfaceIsICurveIsInfosWithLine$$1(t,s,e,i,r,n,o,a){const u=new L3$$1(e,i.unit()),l=t.isTsForLine(u),c=s.isTsForLine(u);l.filter(t=>c.some(s=>ts3dutils.eq(t,s))).map(t=>({tThis:0,tOther:t/i.length(),p:u.at(t)})).filter(t=>this.containsPoint(t.p)).forEach(t=>t.tThis=this.pointT(t.p))}ImplicitCurve$$1.prototype.tIncrement=1;class BezierCurve$$1 extends Curve$$1{constructor(t,s,e,i,r=-.1,n=1.1){super(r,n),ts3dutils.assertVectors(t,s,e,i),ts3dutils.assert(isFinite(r)&&isFinite(n)),this.p0=t,this.p1=s,this.p2=e,this.p3=i}get points(){return[this.p0,this.p1,this.p2,this.p3]}static graphXY(t,s,e,i,r,n){const o=i,a=e/3+o,u=s/3-o+2*a,l=t+o-3*a+3*u;return new BezierCurve$$1(ts3dutils.V(0,o),ts3dutils.V(1/3,a),ts3dutils.V(2/3,u),ts3dutils.V(1,l),r,n)}static quadratic(t,s,e,i=0,r=1){const n=L3$$1.throughPoints(t,e);return n.containsPoint(s)?n:new BezierCurve$$1(t,s.times(2).plus(t).div(3),s.times(2).plus(e).div(3),e,i,r)}static approximateUnitArc(t){const s=4/3*Math.tan(t/4);return new BezierCurve$$1(ts3dutils.V3.X,new ts3dutils.V3(1,s,0),new ts3dutils.V3(cos(t)+s*sin(t),sin(t)-s*cos(t),0),ts3dutils.V3.sphere(t,0),0,1)}getConstructorParameters(){return[this.p0,this.p1,this.p2,this.p3]}at(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=1-t,o=n*n*n,a=3*n*n*t,u=3*n*t*t,l=t*t*t;return new ts3dutils.V3(s.x*o+e.x*a+i.x*u+r.x*l,s.y*o+e.y*a+i.y*u+r.y*l,s.z*o+e.z*a+i.z*u+r.z*l)}tangentAt(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=1-t,o=3*n*n,a=6*n*t,u=3*t*t;return new ts3dutils.V3((e.x-s.x)*o+(i.x-e.x)*a+(r.x-i.x)*u,(e.y-s.y)*o+(i.y-e.y)*a+(r.y-i.y)*u,(e.z-s.z)*o+(i.z-e.z)*a+(r.z-i.z)*u)}ddt(t){ts3dutils.assertNumbers(t);const s=this.p0,e=this.p1,i=this.p2,r=this.p3,n=6*(1-t),o=6*t;return new ts3dutils.V3((i.x-2*e.x+s.x)*n+(r.x-2*i.x+e.x)*o,(i.y-2*e.y+s.y)*n+(r.y-2*i.y+e.y)*o,(i.z-2*e.z+s.z)*n+(r.z-2*i.z+e.z)*o)}normalP(t){const s=this.tangentAt(t);return s.cross(this.ddt(t)).cross(s)}isTsWithPlane(t){ts3dutils.assertInst(P3$$1,t);const{p0:s,p1:e,p2:i,p3:r}=this,n=t.normal1,o=e.minus(i).times(3).minus(s).plus(r),a=s.plus(i).times(3).minus(e.times(6)),u=e.minus(s).times(3),l=s;return ts3dutils.solveCubicReal2(o.dot(n),a.dot(n),u.dot(n),l.dot(n)-t.w).filter(t=>ts3dutils.between(t,this.tMin,this.tMax))}isTsWithSurface(t){if(t instanceof CylinderSurface$$1){const s=new P3$$1(t.dir.unit(),0),e=this.project(s);return t.baseCurve.project(s).isInfosWithBezier2D(e).map(t=>t.tOther)}return super.isTsWithSurface(t)}likeCurve(t){return this==t||ts3dutils.hasConstructor(t,BezierCurve$$1)&&this.p0.like(t.p0)&&this.p1.like(t.p1)&&this.p2.like(t.p2)&&this.p3.like(t.p3)}equals(t){return this==t||ts3dutils.hasConstructor(t,BezierCurve$$1)&&this.p0.equals(t.p0)&&this.p1.equals(t.p1)&&this.p2.equals(t.p2)&&this.p3.equals(t.p3)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.p0.hashCode())+this.p1.hashCode())+this.p2.hashCode())+this.p3.hashCode())}isColinearTo(t){if(this===t||this.likeCurve(t))return!0;if(!(t instanceof BezierCurve$$1))return!1;let s,e,i;if(isNaN(s=this.pointT(t.p0))||isNaN(e=this.pointT(t.p3)))return!1;if(ts3dutils.eq(1,s))i=this.split(e)[1].reversed();else{const t=(e-s)/(1-s);i=this.split(s)[1].split(t)[0]}return t.likeCurve(i)}selectPart(t,s){const e=(s-t)/(1-t);return this.split(t)[1].split(e)[0]}reversed(){return new BezierCurve$$1(this.p3,this.p2,this.p1,this.p0,1-this.tMax,1-this.tMin)}getCoefficients(){const{p0:t,p1:s,p2:e,p3:i}=this;return[s.minus(e).times(3).minus(t).plus(i),t.plus(e).times(3).minus(s.times(6)),s.minus(t).times(3),t]}tangentCoefficients(){const{p0:t,p1:s,p2:e,p3:i}=this,r=s.minus(t),n=e.minus(s),o=i.minus(e),a=r.plus(o).times(3).minus(n.times(6)),u=n.minus(r).times(6),l=r.times(3);return[ts3dutils.V3.O,a,u,l]}pointT2(t,s=this.tMin,e=this.tMax){const i=this.closestTToPoint(t,void 0,s,e);return ts3dutils.assert(this.at(i).like(t)),i}pointT(t){const{p0:s,p1:e,p2:i,p3:r}=this,n=e.minus(i).times(3).minus(s).plus(r),o=s.plus(i).times(3).minus(e.times(6)),a=e.minus(s).times(3),u=s.minus(t),l=ts3dutils.NLA_PRECISION<n.maxAbsElement()?n.maxAbsDim():ts3dutils.NLA_PRECISION<o.maxAbsElement()?o.maxAbsDim():ts3dutils.NLA_PRECISION<a.maxAbsElement()?a.maxAbsDim():ts3dutils.assertNever(),c=ts3dutils.solveCubicReal2(n.e(l),o.e(l),a.e(l),u.e(l)).filter(s=>this.at(s).like(t));if(0==c.length)return NaN;if(1==c.length)return c[0];throw new Error("multiple intersection "+this.toString()+t.sce)}pointT3(t){const{p0:s,p1:e,p2:i,p3:r}=this,n=e.minus(i).times(3).minus(s).plus(r).els(),o=s.plus(i).times(3).minus(e.times(6)).els(),a=e.minus(s).times(3).els(),u=s.minus(t).els();let l=void 0;for(let t=0;t<3;t++)if(ts3dutils.eq0(n[t])&&ts3dutils.eq0(o[t])&&ts3dutils.eq0(a[t])){if(!ts3dutils.eq0(u[t]))return NaN}else{const s=ts3dutils.solveCubicReal2(n[t],o[t],a[t],u[t]);if(0==s.length)return NaN;if(1==s.length)return s[0];if(l){if(0==(l=l.filter(t=>s.some(s=>ts3dutils.eq(t,s)))).length)return NaN;if(1==l.length)return l[0]}else l=s}throw new Error("multiple intersection "+l+this.toString()+t.sce)}transform(t){return ts3dutils.assert(t.isNoProj(),t.str),new BezierCurve$$1(t.transformPoint(this.p0),t.transformPoint(this.p1),t.transformPoint(this.p2),t.transformPoint(this.p3),this.tMin,this.tMax)}isClosed(){return this.p0.like(this.p3)}isQuadratic(){return this.p0.lerp(this.p1,1.5).like(this.p3.lerp(this.p2,1.5))}debugInfo(){return{lines:[0,1,1,2,2,3].map(t=>this.points[t]),points:this.points}}split(t){const s=1-t,{p0:e,p1:i,p2:r,p3:n}=this,o=e.times(s).plus(i.times(t)),a=i.times(s).plus(r.times(t)),u=r.times(s).plus(n.times(t)),l=o.times(s).plus(a.times(t)),c=a.times(s).plus(u.times(t)),h=l.times(s).plus(c.times(t));return[new BezierCurve$$1(e,o,l,h),new BezierCurve$$1(h,c,u,n)]}containsPoint(t){return isFinite(this.pointT(t))}roots(){const{p0:t,p1:s,p2:e,p3:i}=this,r=s.minus(t),n=e.minus(s),o=i.minus(e),a=r.plus(o).times(3).minus(n.times(6)),u=n.minus(r).times(6),l=r.times(3);return ts3dutils.arrayFromFunction(3,t=>ts3dutils.solveCubicReal2(0,a.e(t),u.e(t),l.e(t)))}isInfosWithLine(t,s,e,i,r=-1e5,n=1e5){const{p0:o,p1:a,p2:u,p3:l}=this,c=a.minus(u).times(3).minus(o).plus(l),h=ts3dutils.V3.UNITS[c.minAbsDim()],d=P3$$1.forAnchorAndPlaneVectors(t,s,h.isParallelTo(s)?c:h);return this.isTsWithPlane(d).map(e=>{const i=this.at(e);return{tThis:e,tOther:L3$$1.pointT(t,s,i),p:i}}).filter(e=>L3$$1.containsPoint(t,s,e.p))}closestPointToLine(t,s,e){s=isFinite(s)?s:this.tMin,e=isFinite(e)?e:this.tMax;const i=t.anchor.dot(t.dir1),r=s=>{const e=this.at(s);return e.minus(t.at(e.dot(t.dir1)-i)).dot(this.tangentAt(s))},n=ts3dutils.arrayFromFunction(32,t=>s+(e-s)*t/32).withMax(t=>-r(t));return ts3dutils.newtonIterate1d(r,n,8)}isInfosWithBezier3(t,s,e,i,r){const n=(s,e)=>{if(!a.some(t=>ts3dutils.eq(t.tThis,s)&&ts3dutils.eq(t.tOther,e))){const i=(s,e)=>this.tangentAt(s).dot(this.at(s).minus(t.at(e))),r=(s,e)=>t.tangentAt(e).dot(this.at(s).minus(t.at(e))),n=(t,s,e,i)=>t.ddt(e).dot(t.at(e).minus(s.at(i)))+t.tangentAt(e).squared(),o=(t,s,e,i)=>-t.tangentAt(e).dot(s.tangentAt(i)),u=ts3dutils.newtonIterate2dWithDerivatives(i,r,s,e,16,n.bind(void 0,this,t),o.bind(void 0,this,t),(s,e)=>-o(t,this,e,s),(s,e)=>-n(t,this,e,s));a.push({tThis:u.x,tOther:u.y,p:this.at(u.x)})}},o=[s=void 0!==s?s:this.tMin,e=void 0!==e?e:this.tMax,i=void 0!==i?i:t.tMin,r=void 0!==r?r:t.tMax],a=[];for(;o.length;){const s=o.length-4,e=o[s],i=o[s+1],r=o[s+2],a=o[s+3];o.length-=4;const u=this.getAABB(e,i),l=t.getAABB(r,a);if(u&&l&&u.intersectsAABB2d(l)){const t=(e+i)/2,s=(r+a)/2,c=1e-5;i-e<c||a-r<c?(console.log(e,i,r,a),console.log(u.sce),console.log(l.sce),console.log(t,s),n(t,s)):o.push(e,t,r,s,e,t,s,a,t,i,r,s,t,i,s,a)}}return a}isInfosWithBezier(t,s,e,i,r){s=void 0!==s?s:this.tMin,e=void 0!==e?e:this.tMax,i=void 0!==i?i:t.tMin,r=void 0!==r?r:t.tMax,ts3dutils.assertf(()=>s<e),ts3dutils.assertf(()=>i<r);const n=[],o=this.likeCurve(t),a=this.isColinearTo(t);if(!o&&!a)return Curve$$1.ispsRecursive(this,s,e,t,i,r);{o||(i=this.pointT(t.at(i)),r=this.pointT(t.at(r))),s=Math.min(s,i),e=Math.max(e,r);const a=ts3dutils.fuzzyUniques(this.roots().concatenated().filter(isFinite).concat([s,e])).sort(ts3dutils.MINUS);Array.from(ts3dutils.combinations(a.length-1)).forEach(({i:s,j:e})=>{Math.abs(s-e)>2&&n.push(...Curve$$1.ispsRecursive(this,a[s],a[s+1],t,a[e],a[e+1]))})}return n}selfIntersectionsInfo(){return this.isInfosWithBezier(this)}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1,t.tMin,t.tMax):t instanceof BezierCurve$$1?this.isInfosWithBezier(t):t.isInfosWithCurve(this).map(({tThis:t,tOther:s,p:e})=>({tThis:s,tOther:t,p:e}))}circleApprox(t=this.tMin,s=this.tMax,e=1/1024,i=[]){const r=this.at(t),n=this.at(s),o=(t+s)/2,a=this.at(o),u=L3$$1.throughPoints(r,n);if(!u.containsPoint(a)&&ts3dutils.between(u.pointT(a),0,u.pointT(n))){const o=EllipseCurve$$1.circleThroughPoints(r,a,n),u=o.f1.length(),l=this.at(ts3dutils.lerp(t,s,.25)),c=this.at(ts3dutils.lerp(t,s,.75));if(abs(o.center.distanceTo(l)/u-1)<=e&&abs(o.center.distanceTo(c)/u-1)<=e)return i.push(o),i}return this.circleApprox(t,o,e,i),this.circleApprox(o,s,e,i),i}}BezierCurve$$1.EX2D=BezierCurve$$1.graphXY(2,-3,-3,2),BezierCurve$$1.EX3D=new BezierCurve$$1(ts3dutils.V3.O,ts3dutils.V(-.1,-1,1),ts3dutils.V(1.1,1,1),ts3dutils.V3.X),BezierCurve$$1.QUARTER_CIRCLE=BezierCurve$$1.approximateUnitArc(PI/2),BezierCurve$$1.prototype.hlol=Curve$$1.hlol++,BezierCurve$$1.prototype.tIncrement=1/80;class HyperbolaCurve$$1 extends XiEtaCurve$$1{constructor(t,s,e,i=-7,r=7){super(t,s,e,i,r)}static XYLCValid(t){return t.x>0&&ts3dutils.eq(1,t.x*t.x-t.y*t.y)}static XYLCPointT(t){return Math.asinh(t.y)}static intersectionUnitLine(t,s,e){if(ts3dutils.eq0(s)){const s=ts3dutils.snap0(Math.pow(e,2)/Math.pow(t,2)-1);if(s<0||e*t<0)return[];if(0==s)return[0];const i=Math.sqrt(s);return[-Math.asinh(i),Math.asinh(i)]}if(ts3dutils.eq(abs(t),abs(s))){if(ts3dutils.le(e*t,0))return[];const i=sign(t*s)*(Math.pow(e,2)-Math.pow(t,2))/2/t/e;return[Math.asinh(i)]}{const i=ts3dutils.snap0(Math.pow(s,2)*(-Math.pow(t,2)+Math.pow(s,2)+Math.pow(e,2)));if(i<0)return[];const r=(t*e-Math.sqrt(i))/(Math.pow(t,2)-Math.pow(s,2)),n=(t*e+Math.sqrt(i))/(Math.pow(t,2)-Math.pow(s,2)),o=(Math.pow(s,2)*e-t*Math.sqrt(i))/(s*(Math.pow(s,2)-Math.pow(t,2))),a=(Math.pow(s,2)*e+t*Math.sqrt(i))/(s*(Math.pow(s,2)-Math.pow(t,2)));return[r>0&&Math.asinh(o),n>0&&Math.asinh(a)].filter(t=>!1!==t)}}at(t){return ts3dutils.assertNumbers(t),this.center.plus(this.f1.times(Math.cosh(t))).plus(this.f2.times(Math.sinh(t)))}toString(){return`${this.center} + ${this.f1} * cosh(t) + ${this.f2} * sinh(t)`}tangentAt(t){return ts3dutils.assertNumbers(t),this.f1.times(Math.sinh(t)).plus(this.f2.times(Math.cosh(t)))}tangentAt2(t,s){return ts3dutils.assertNumbers(t,s),this.f1.times(s).plus(this.f2.times(t))}ddt(t){return ts3dutils.assertNumbers(t),this.f1.times(Math.cosh(t)).plus(this.f2.times(Math.sinh(t)))}isColinearTo(t){if(!ts3dutils.hasConstructor(t,HyperbolaCurve$$1))return!1;if(!t.center||!this.center.like(t.center))return!1;if(this===t)return!0;const{f1:s,f2:e}=this.rightAngled(),{f1:i,f2:r}=t.rightAngled();return ts3dutils.eq(s.squared(),Math.abs(s.dot(i)))&&ts3dutils.eq(e.squared(),Math.abs(e.dot(r)))}reversed(){return new HyperbolaCurve$$1(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s),i=s.squared()+t.squared();if(ts3dutils.eq0(e))return this;const r=2*e,n=i+Math.sqrt(i*i-4*e*e),{x1:o,y1:a}=intersectionUnitHyperbolaLine$$1(r,n,0);return new HyperbolaCurve$$1(this.center,t.times(o).plus(s.times(a)),t.times(a).plus(s.times(o)))}eccentricity(){const t=this.rightAngled(),s=t.f1.length(),e=t.f1.length(),[i,r]=s>e?[s,e]:[e,s];return Math.sqrt(1+r*r/i/i)}roots(){return ts3dutils.arrayFromFunction(3,t=>{const s=this.f2.e(t),e=this.f1.e(t);return HyperbolaCurve$$1.intersectionUnitLine(s,e,0)})}transform4(t){const s=t=>sign(t)*min(10,sqrt(-(1-cosh(t))/(1+cosh(t)))),e=new ts3dutils.M4(0,1,0,1,2,0,0,0,0,0,1,0,0,-1,0,1);return parabola4Projection$$1(ts3dutils.M4.product(t,this.matrix,e),s(this.tMin),s(this.tMax))}}HyperbolaCurve$$1.XY=new HyperbolaCurve$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),HyperbolaCurve$$1.prototype.tIncrement=PI/16;class L3$$1 extends Curve$$1{constructor(t,s,e=-4096,i=4096){super(e,i),this.anchor=t,this.dir1=s,ts3dutils.assertVectors(t,s),ts3dutils.assert(s.hasLength(1),"dir must be unit"+s),ts3dutils.assertf(()=>!Number.isNaN(t.x))}isTsWithSurface(t){return t.isTsForLine(this)}static throughPoints(t,s,e=0,i){const r=s.minus(t);return new L3$$1(t,r.unit(),e,void 0!==i?i:r.length())}static anchorDirection(t,s,e=0,i=s.length()){const r=s.unit();return new L3$$1(t,r,"number"==typeof e?e:e.minus(t).dot(r),"number"==typeof i?i:i.minus(t).dot(r))}static pointT(t,s,e){return ts3dutils.assertVectors(t,s,e),e.minus(t).dot(s)/s.squared()}static at(t,s,e){return t.plus(s.times(e))}static fromPlanes(t,s){if(ts3dutils.assertInst(P3$$1,t,s),t.normal1.cross(s.normal1).length()<1e-10)throw new Error("Parallel planes");return t.intersectionWithPlane(s)}static containsPoint(t,s,e){const i=L3$$1.pointT(t,s,e),r=L3$$1.at(t,s,i).distanceTo(e);return ts3dutils.eq0(r)}roots(){return[[],[],[]]}containsPoint(t){ts3dutils.assertVectors(t);const s=this.distanceToPoint(t);return ts3dutils.assertNumbers(s),ts3dutils.eq0(s)}likeCurve(t){return this==t||ts3dutils.hasConstructor(t,L3$$1)&&this.anchor.like(t.anchor)&&this.dir1.like(t.dir1)}equals(t){return this==t||Object.getPrototypeOf(t)==L3$$1.prototype&&this.anchor.equals(t.anchor)&&this.dir1.equals(t.dir1)}isColinearTo(t){return t instanceof L3$$1&&this.containsPoint(t.anchor)&&ts3dutils.eq(1,Math.abs(this.dir1.dot(t.dir1)))}distanceToLine(t){if(ts3dutils.assertInst(L3$$1,t),this.isParallelToLine(t))return this.distanceToPoint(t.anchor);const s=this.dir1.cross(t.dir1).unit(),e=this.anchor.minus(t.anchor);return Math.abs(e.dot(s))}distanceToPoint(t){ts3dutils.assertVectors(t);const s=t.minus(this.anchor).dot(this.dir1);return this.at(s).distanceTo(t)}asSegmentDistanceToPoint(t,s,e){let i=t.minus(this.anchor).dot(this.dir1);return i=ts3dutils.clamp(i,s,e),this.at(i).minus(t).length()}asSegmentDistanceToLine(t,s,e){ts3dutils.assertInst(L3$$1,t);const i=this.dir1.cross(t.dir1),r=i.squared();if(ts3dutils.eq0(r))return;const n=t.anchor.minus(this.anchor);if(!ts3dutils.eq0(n.dot(i.unit())))return;let o=this.infoClosestToLine(t).t;return o=ts3dutils.clamp(o,s,e),this.at(ts3dutils.clamp(o,s,e))}at(t){return ts3dutils.assertNumbers(t),this.anchor.plus(this.dir1.times(t))}pointT(t){return ts3dutils.assertVectors(t),t.minus(this.anchor).dot(this.dir1)}isParallelToLine(t){return ts3dutils.assertInst(L3$$1,t),ts3dutils.eq(1,Math.abs(this.dir1.dot(t.dir1)))}angleToLine(t){return ts3dutils.assertInst(L3$$1,t),this.dir1.angleTo(t.dir1)}intersectsLine(t){return ts3dutils.eq0(this.distanceToLine(t))}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1):super.isInfosWithCurve(t)}isInfosWithLine(t,s){const e=this.dir1.cross(s),i=e.squared();if(ts3dutils.eq0(i))return[];const r=t.minus(this.anchor);if(ts3dutils.eq0(r.dot(e))){const t=r.cross(s).dot(e)/i;return[{tThis:t,tOther:r.cross(this.dir1).dot(e)/i,p:this.at(t)}]}return[]}isInfoWithLine(t){ts3dutils.assertInst(L3$$1,t);const s=this.dir1.cross(t.dir1),e=s.squared();if(ts3dutils.eq0(e))return;const i=t.anchor.minus(this.anchor);if(!ts3dutils.eq0(i.dot(s.unit())))return;const r=i.cross(t.dir1).dot(s)/e;return this.at(r)}intersectionLineST(t){ts3dutils.assertInst(L3$$1,t);const s=this.dir1.cross(t.dir1),e=s.squared(),i=t.anchor.minus(this.anchor);return{s:i.cross(this.dir1).dot(s)/e,t:i.cross(t.dir1).dot(s)/e}}ddt(){return ts3dutils.V3.O}getConstructorParameters(){return[this.anchor,this.dir1]}closestTToPoint(t){return t.minus(this.anchor).dot(this.dir1)}infoClosestToLine(t){if(this.isParallelToLine(t))return{t:NaN,s:NaN,distance:this.distanceToLine(t)};const s=t.anchor,e=t.dir1,i=this.anchor,r=this.dir1,n=e.dot(r),o=e.squared(),a=r.squared(),u=s.minus(i),l=n*n-a*o,c=(u.dot(e)*n-u.dot(r)*o)/l,h=(u.dot(e)*a-u.dot(r)*n)/l;return{t:c,s:h,closest:this.at(c),closest2:t.at(h),distance:this.at(c).distanceTo(t.at(h))}}intersectionWithPlane(t){const s=(t.w-t.normal1.dot(this.anchor))/t.normal1.dot(this.dir1);return this.anchor.plus(this.dir1.times(s))}tangentAt(){return this.dir1}isTWithPlane(t){const s=t.normal1.dot(this.dir1);return ts3dutils.eq0(s)?NaN:(t.w-t.normal1.dot(this.anchor))/s}reversed(){return new L3$$1(this.anchor,this.dir1.negated(),-this.tMax,-this.tMin)}isTsWithPlane(t){const s=this.isTWithPlane(t);return isNaN(s)?[]:[s]}flipped(){return new L3$$1(this.anchor,this.dir1.negated())}transform(t){const s=t.transformPoint(this.anchor),e=t.transformVector(this.dir1);return new L3$$1(s,e.unit(),this.tMin*e.length(),this.tMax*e.length())}transform4(t){const s=P3$$1.vanishingPlane(t);if(!s)return this.transform(t);const e=this.at(this.tMin),i=this.at(this.tMax);if(ts3dutils.le(s.distanceToPointSigned(e),0)||ts3dutils.le(s.distanceToPointSigned(i),0))throw new Error("line must be in front of vanishingPlane in [tMin, tMax]");const r=ts3dutils.lt(0,s.distanceToPointSigned(this.anchor))?this.anchor:this.at((this.tMin+this.tMax)/2),n=t.timesVector(ts3dutils.VV(r.x,r.y,r.z,1)),o=t.timesVector(ts3dutils.VV(this.dir1.x,this.dir1.y,this.dir1.z,0)),a=o.times(n.w).minus(n.times(o.w)).V3(),u=n.p3();return L3$$1.anchorDirection(u,a,t.transformPoint(e),t.transformPoint(i))}hashCode(){return 31*this.anchor.hashCode()+this.dir1.hashCode()}}L3$$1.X=new L3$$1(ts3dutils.V3.O,ts3dutils.V3.X),L3$$1.Y=new L3$$1(ts3dutils.V3.O,ts3dutils.V3.Y),L3$$1.Z=new L3$$1(ts3dutils.V3.O,ts3dutils.V3.Z),L3$$1.prototype.hlol=Curve$$1.hlol++,L3$$1.prototype.tIncrement=256;class PICurve$$1 extends ImplicitCurve$$1{constructor(t,s,e,i,r,n,o,a=1,u,l,c){super(t,s,a,u,l,c),this.parametricSurface=e,this.implicitSurface=i,this.pmPoints=r,this.pmTangents=n,this.stepSize=o,ts3dutils.assert(Array.isArray(r)),ts3dutils.assert(1==a),ts3dutils.assert(o<=1);const h=e.pUVFunc(),d=e.dpdu(),p=e.dpdv(),f=i.didp.bind(i);this.didu=((t,s)=>f(h(t,s)).dot(d(t,s))),this.didv=((t,s)=>f(h(t,s)).dot(p(t,s)));for(let s=0;s<t.length-1;s++)ts3dutils.assert(!t[s].equals(t[s+1]));{const t=this.parametricSurface,s=i,e=t.pUVFunc(),r=s.implicitFunction(),n=t.dpdu(),a=t.dpdv(),u=s.didp.bind(s),l=exports.MathFunctionR2R.forFFxFy((t,s)=>r(e(t,s)),(t,s)=>u(e(t,s)).dot(n(t,s)),(t,s)=>u(e(t,s)).dot(a(t,s))),{points:c}=followAlgorithm2d$$1(l,this.pmPoints[0],o,t,(t,i)=>s.containsPoint(e(t,i)),this.pmPoints.last,this.pmTangents[0]);c.length!==this.points.length&&followAlgorithm2d$$1(l,this.pmPoints[0],o,t,(t,i)=>s.containsPoint(e(t,i)),this.pmPoints.last,this.pmTangents[0]),ts3dutils.assert(c.length==this.points.length,c.length,this.points.length)}}static forParametricStartEnd(t,s,e,i,r=.02,n,o,a){const u=t.pUVFunc(),l=s.implicitFunction(),c=t.dpdu(),h=t.dpdv(),d=s.didp.bind(s),p=exports.MathFunctionR2R.forFFxFy((t,s)=>l(u(t,s)),(t,s)=>d(u(t,s)).dot(c(t,s)),(t,s)=>d(u(t,s)).dot(h(t,s))),{points:f,tangents:m}=followAlgorithm2d$$1(p,e,r,t,(t,e)=>s.containsPoint(u(t,e)),i,n);return PICurve$$1.forParametricPointsTangents(t,s,f,m,r,1,o,a)}static forStartEnd(t,s,e,i,r=.02,n,o,a){const u=t.uvP(e),l=t.dpdu()(u.x,u.y),c=t.dpdv()(u.x,u.y),h=n&&ts3dutils.M4.forSys(l,c).inversed().transformVector(n),d=PICurve$$1.forParametricStartEnd(t,s,u,t.uvP(i),r,h);return d.withBounds(o&&d.pointT(o),a&&d.pointT(a))}static forParametricPointsTangents(t,s,e,i,r,n=1,o,a){const u=t.pUVFunc(),l=t.dpdu(),c=t.dpdv(),h=e.map(({x:t,y:s})=>u(t,s)),d=e.map(({x:t,y:s},e)=>{const r=l(t,s),n=c(t,s);return r.times(i[e].x).plus(n.times(i[e].y))});return new PICurve$$1(h,d,t,s,e,i,r,n,void 0,o,a)}getConstructorParameters(){return[this.points,this.tangents,this.parametricSurface,this.implicitSurface,this.pmPoints,this.pmTangents,this.stepSize,this.dir,this.generator]}implicitCurve(){const t=this.parametricSurface.pUVFunc(),s=this.implicitSurface.implicitFunction();return(e,i)=>s(t(e,i))}isColinearTo(t){return t instanceof PICurve$$1&&(!!this.equals(t)||(this.parametricSurface.isCoplanarTo(t.parametricSurface)&&this.implicitSurface.isCoplanarTo(t.implicitSurface),!1))}containsPoint(t){ts3dutils.assertVectors(t);const s=this.pointT(t);return!isNaN(s)&&this.isValidT(s)}equals(t){return Object.getPrototypeOf(t)==PICurve$$1.prototype&&this.parametricSurface.equals(t.parametricSurface)&&this.implicitSurface.equals(t.implicitSurface)&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])&&this.dir===t.dir}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.parametricSurface.hashCode())+this.implicitSurface.hashCode())+this.points[0].hashCode())+this.tangents[0].hashCode())}tangentP(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t),"this.containsPoint(point)");const s=this.pointT(t);return this.tangentAt(s)}tangentAt(t){if(ts3dutils.assert(!isNaN(t)),0==t%1)return this.tangents[t];const s=this.uvT(t),e=new ts3dutils.V3(-this.didv(s.x,s.y),this.didu(s.x,s.y),0).toLength(this.stepSize),i=this.parametricSurface.dpdu()(s.x,s.y),r=this.parametricSurface.dpdv()(s.x,s.y);return i.times(e.x).plus(r.times(e.y))}at(t){if(ts3dutils.assert(!isNaN(t)),0==t%1)return this.points[t];const s=ts3dutils.V3.lerp(this.pmPoints[floor(t)],this.pmPoints[ceil(t)],t%1);return this.closestPointToParams(s)}uvT(t){if(ts3dutils.assert(!isNaN(t)),0==t%1)return this.pmPoints[t];const s=ts3dutils.V3.lerp(this.pmPoints[floor(t)],this.pmPoints[ceil(t)],t%1);return curvePoint$$1(this.implicitCurve(),s,this.didu,this.didv)}closestTToPoint(t,s){return 0}closestPointToParams(t){const s=curvePoint$$1(this.implicitCurve(),t,this.didu,this.didv);return this.parametricSurface.pUVFunc()(s.x,s.y)}isTsWithSurface(t){if(t instanceof EllipsoidSurface$$1){const s=this.parametricSurface,e=this.implicitSurface;if(s instanceof ProjectedCurveSurface$$1&&e instanceof EllipsoidSurface$$1){const i=e.isCurvesWithSurface(t).flatMap(t=>t.isTsWithSurface(s).map(s=>t.at(s)));return ts3dutils.fuzzyUniques(i.map(t=>this.pointT(t))).filter(t=>!isNaN(t)&&this.isValidT(t))}}else if(ImplicitSurface$$1.is(t)){const s=[],e=t.implicitFunction();let i=e(this.points[0]);for(let r=1;r<this.points.length;r++){const n=this.points[r],o=e(n);if(i*o<=0){const n=this.parametricSurface.pUVFunc(),a=this.parametricSurface.dpdu(),u=this.parametricSurface.dpdv(),l=this.pmPoints[abs(i)<abs(o)?r-1:r],c=ts3dutils.newtonIterate2dWithDerivatives(this.implicitCurve(),(t,s)=>e(n(t,s)),l.x,l.y,4,this.didu,this.didv,(s,e)=>a(s,e).dot(t.didp(n(s,e))),(s,e)=>u(s,e).dot(t.didp(n(s,e))));s.push(this.pointT(this.parametricSurface.pUV(c.x,c.y)))}i=o}return s}throw new Error}isTsWithPlane(t){return this.isTsWithSurface(new PlaneSurface$$1(t))}pointT(t){if(ts3dutils.assertVectors(t),!this.parametricSurface.containsPoint(t)||!this.implicitSurface.containsPoint(t))return NaN;const s=this.parametricSurface.uvPFunc()(t),e=this.points,i=this.pmPoints;let r=0,n=s.distanceTo(i[0]);for(;n>abs(this.stepSize)&&r<e.length-1;)r=min(i.length-1,r+max(1,Math.round(n/abs(this.stepSize)/2/2))),n=s.distanceTo(i[r]);if(n>1.1*abs(this.stepSize))return NaN;if(r==e.length-1&&r--,e[r].like(t))return r;if(e[r+1].like(t))return r+1;const o=ts3dutils.arrayRange(floor(this.tMin),ceil(this.tMax),1).withMax(t=>-s.distanceTo(i[t]));if(void 0===o)throw new Error;if(e[o].like(t))return o;const a=max(0,o-1),u=min(this.points.length-1,o+1),l=this.tangentAt(o);return r=ts3dutils.bisect(s=>this.at(ts3dutils.clamp(s,0,this.points.length-1)).to(t).dot(l),a,u,32),!isFinite(r)||this.at(r).distanceTo(t)>abs(this.stepSize)?NaN:r}transform(t){const s=t.isMirroring()?-1:1;return PICurve$$1.forStartEnd(this.parametricSurface.transform(t),this.implicitSurface.transform(t),t.transformPoint(this.points[0]),t.transformPoint(this.points.last),this.stepSize*s,t.transformVector(this.tangents[0]),t.transformPoint(this.at(this.tMin)),t.transformPoint(this.at(this.tMax)))}roots(){const t=ts3dutils.arrayRange(0,this.points.length);return[t,t,t]}isInfosWithLine(t,s,e,i,r,n){return surfaceIsICurveIsInfosWithLine$$1.call(this,t,s,e,i,r,n)}toSource(t=(t=>t)){return ts3dutils.callsce("PICurve.forParametricStartEnd",this.parametricSurface,this.implicitSurface,this.pmPoints[0],this.pmPoints.last,this.stepSize,this.pmTangents[0],this.tMin,this.tMax)}}PICurve$$1.prototype.tIncrement=1;class PPCurve$$1 extends ImplicitCurve$$1{constructor(t,s,e,i,r,n,o,a=1,u,l,c){super(t,s,a,u,l,c),this.parametricSurface1=e,this.parametricSurface2=i,this.st1s=r,this.pmTangents=n,this.stepSize=o,ts3dutils.assert(ParametricSurface$$1.is(e)),ts3dutils.assert(ParametricSurface$$1.is(i)),ts3dutils.assert(Array.isArray(r)),ts3dutils.assert(1==a),ts3dutils.assert(o<=1)}at(t){if(ts3dutils.assert(!isNaN(t)),0==t%1)return this.points[t];const s=ts3dutils.V3.lerp(this.points[floor(t)],this.points[ceil(t)],t%1);return curvePointPP$$1(this.parametricSurface1,this.parametricSurface2,s).p}isColinearTo(t){return t instanceof PPCurve$$1&&(!!this.equals(t)||(this.parametricSurface1.isCoplanarTo(t.parametricSurface1)&&this.parametricSurface1.isCoplanarTo(t.parametricSurface2),!1))}containsPoint(t){return ts3dutils.assertVectors(t),this.parametricSurface1.containsPoint(t)&&this.parametricSurface2.containsPoint(t)&&!isNaN(this.pointT(t))}rootPoints(){const t=this.parametricSurface1.pUVFunc(),s=this.parametricSurface2.pUVFunc(),e=this.parametricSurface1.normalUVFunc(),i=this.parametricSurface2.normalUVFunc(),r=this.rootsApprox(),n=[[],[],[]];for(let a=0;a<3;a++)for(let u=0;u<r[a].length;u++){const l=r[a][u],c=this.at(l);ts3dutils.assert(this.parametricSurface1.containsPoint(c));const h=this.parametricSurface1.uvP(c),{x:d,y:p}=this.parametricSurface2.uvP(c),f=[h.x,h.y,d,p];function o(r){const[n,o,u,l]=r,c=t(n,o).minus(s(u,l)),h=e(n,o),d=i(u,l),p=h.cross(d);return[c.x,c.y,c.z,p.e(a)]}const m=ts3dutils.newtonIterate(o,f,8),$=t(m[0],m[1]);n[a].push($)}return n}roots(){return this.rootPoints().map(t=>t.map(t=>this.pointT(t)))}pointTangent(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t),"this.containsPoint(pWC)");const s=this.parametricSurface1.normalP(t),e=this.parametricSurface2.normalP(t);return s.cross(e)}transform(t){return new PPCurve$$1(t.transformedPoints(this.points),t.transformedVectors(this.tangents),this.parametricSurface1.transform(t),this.parametricSurface2.transform(t),this.st1s,void 0,this.stepSize,this.dir,void 0)}toSource(){return ts3dutils.callsce("PPCurve.forStartEnd",this.parametricSurface1,this.parametricSurface2,this.points[0],this.points.last,this.stepSize)}static forStartEnd(t,s,e,i,r=.02){const{points:n,tangents:o,st1s:a}=followAlgorithmPP$$1(t,s,e,r);return new PPCurve$$1(n,o,t,s,a,void 0,r,1)}isInfosWithLine(t,s,e,i,r,n){return surfaceIsICurveIsInfosWithLine$$1.call(this,t,s,e,i,r,n)}isTsWithSurface(t){if(ImplicitSurface$$1.is(t)){const s=[],e=t.implicitFunction(),i=this.parametricSurface1.pUVFunc(),r=this.parametricSurface2.pUVFunc();let n=e(this.points[0]);for(let t=1;t<this.points.length;t++){const o=this.points[t],a=e(o);if(n*a<=0){const o=abs(n)<abs(a)?t-1:t,u=this.points[o],l=this.st1s[o],c=this.parametricSurface2.uvP(u),h=ts3dutils.newtonIterate(([t,s,n,o])=>{const a=i(t,s),u=r(n,o);return[...a.to(u),e(a)]},[l.x,l.y,c.x,c.y]);s.push(this.pointT(this.parametricSurface1.pUV(h[0],h[1])))}n=a}return s}throw new Error("Method not implemented.")}isTsWithPlane(t){return this.isTsWithSurface(new PlaneSurface$$1(t))}}class ParabolaCurve$$1 extends XiEtaCurve$$1{constructor(t,s,e,i=-10,r=10){super(t,s,e,i,r)}static eccentricity(){return 1}static unitIsInfosWithLine(t,s,e,i){const r=Math.pow(s.x,2);return ts3dutils.pqFormula((t.x*s.x+s.y)/r,(Math.pow(t.x,2)+t.y)/r).filter(e=>ts3dutils.le(0,t.y+e*s.y)).map(r=>({tThis:s.x*r+t.x,tOther:r,p:L3$$1.at(e,i,r)}))}static intersectionUnitLine(t,s,e){return ts3dutils.pqFormula(t/s,-e/s)}static XYLCValid(t){return ts3dutils.eq(Math.pow(t.x,2),t.y)}static XYLCPointT(t){return t.x}static quadratic(t,s,e){const i=t.plus(e).minus(s.times(2)),r=s.minus(t).times(2);return new ParabolaCurve$$1(t,r,i,0,1)}at(t){return this.center.plus(this.f1.times(t)).plus(this.f2.times(t*t))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f1.plus(this.f2.times(2*t))}ddt(t){return ts3dutils.assertNumbers(t),this.f2.times(2)}tangentAt2(t,s){return ts3dutils.assertNumbers(t,s),this.f1.plus(this.f2.times(2*s))}reversed(){return new this.constructor(this.center,this.f1.negated(),this.f2,-this.tMax,-this.tMin)}roots(){return ts3dutils.arrayFromFunction(3,t=>ts3dutils.eq0(this.f2.e(t))?[]:[-this.f1.e(t)/2/this.f2.e(t)])}isColinearTo(t){if(!ts3dutils.hasConstructor(t,ParabolaCurve$$1))return!1;const s=this.rightAngled(),e=t.rightAngled();return s.center.like(e.center)&&s.f2.like(e.f2)&&s.f1.likeOrReversed(e.f1)}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s);if(ts3dutils.eq0(e)&&t.hasLength(1))return this;const i=-e/s.squared()/2,r=this.at(i),n=this.tangentAt(i),o=n.length(),a=n.unit(),u=t=>this.at(t).minus(r).dot(a);return new ParabolaCurve$$1(r,a,s.div(Math.pow(o,2)),u(this.tMin),u(this.tMax))}arcLength(t,s){let e=this.f1;const i=this.f2,r=e.dot(i);let n=0;ts3dutils.eq0(r)||(n=-r/i.squared()/2,e=e.plus(i.times(2*n)));const o=e.length(),a=i.length()/o;function u(t){return Math.asinh(2*a*t)/4/a+t*Math.sqrt(1+a*a*4*t*t)/2}return o*(u(s-n)-u(t-n))}transform4(t){return parabola4Projection$$1(this.matrix.transform(t),this.tMin,this.tMax)}asBezier(){return BezierCurve$$1.quadratic(this.at(-1),new L3$$1(this.at(-1),this.tangentAt(-1).unit()).isInfoWithLine(new L3$$1(this.at(1),this.tangentAt(1).unit())),this.at(1))}recenter(t){return new ParabolaCurve$$1(this.at(t),this.f1.plus(this.f2.times(2*t)),this.f2)}}ParabolaCurve$$1.XY=new ParabolaCurve$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),ParabolaCurve$$1.YZ=new ParabolaCurve$$1(ts3dutils.V3.O,ts3dutils.V3.Y,ts3dutils.V3.Z),ParabolaCurve$$1.ZX=new ParabolaCurve$$1(ts3dutils.V3.O,ts3dutils.V3.Z,ts3dutils.V3.X),ParabolaCurve$$1.prototype.tIncrement=1/32;class EllipseCurve$$1 extends XiEtaCurve$$1{constructor(t,s,e,i=0,r=PI){super(t,s,e,i,r),ts3dutils.assert(-PI<=this.tMin&&this.tMin<PI),ts3dutils.assert(-PI<this.tMax&&this.tMax<=PI)}static andFixTs(t,s,e,i=0,r=PI){if(-PI<=i&&r<=PI)return new EllipseCurve$$1(t,s,e,i,r);if(0<=i&&r<=ts3dutils.TAU)return new EllipseCurve$$1(t,s.negated(),e.negated(),i-PI,r-PI);if(-ts3dutils.TAU<=i&&r<=0)return new EllipseCurve$$1(t,s.negated(),e.negated(),i+PI,r+PI);throw new Error("Method not implemented.")}static XYLCValid(t){const{x:s,y:e}=t;return ts3dutils.eq0(Math.pow(s,2)+Math.pow(e,2)-1)}static XYLCPointT(t,s,e){ts3dutils.assertNumbers(s,e);const i=atan2(t.y,t.x);return i<ts3dutils.lerp(s,e-ts3dutils.TAU,.5)?i+ts3dutils.TAU:i>ts3dutils.lerp(e,s+ts3dutils.TAU,.5)?i-ts3dutils.TAU:i}static intersectionUnitLine(t,s,e,i,r){const n=intersectionUnitCircleLine2$$1(t,s,e),o=[];for(const[t,s]of n){const e=EllipseCurve$$1.XYLCPointT(new ts3dutils.V3(t,s,0),i,r);ts3dutils.fuzzyBetween(e,i,r)&&o.push(e)}return o}static unitIsInfosWithLine(t,s,e,i,r,n){const o=s.squared();return ts3dutils.pqFormula(2*s.dot(t)/o,(t.squared()-1)/o).filter(e=>ts3dutils.le(0,t.y+e*s.y)).map(o=>({tThis:EllipseCurve$$1.XYLCPointT(s.times(o).plus(t),r,n),tOther:o,p:L3$$1.at(e,i,o)}))}static semicircle(t,s=ts3dutils.V3.O,e,i){return new EllipseCurve$$1(s,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0),e,i)}static circleForCenter2P(t,s,e,i,r,n){const o=t.to(s),a=o.cross(t.to(e)).cross(o).toLength(o.length());return new EllipseCurve$$1(t,o,a,void 0!==r?r:0,void 0!==n?n:o.angleTo(t.to(e)))}split(t=this.tMin,s=this.tMax){const e=[];return t<0&&e.push(new EllipseCurve$$1(this.center,this.f1.negated(),this.f2.negated(),t+PI,min(0,s)+PI)),s>0&&e.push(new EllipseCurve$$1(this.center,this.f1,this.f2,max(0,t),s)),e}static forAB(t,s,e=ts3dutils.V3.O){return super.forAB(t,s,e)}static circleThroughPoints(t,s,e,i=0,r){ts3dutils.assertf(()=>!L3$$1.throughPoints(t,e).containsPoint(s));const n=t.to(s).cross(s.to(e)),o=new L3$$1(t.lerp(s,.5),n.cross(t.to(s)).unit()).isInfoWithLine(new L3$$1(s.lerp(e,.5),n.cross(s.to(e)).unit())),a=o.to(t).negated();return new EllipseCurve$$1(o,a,n.unit().cross(a),-PI,void 0===r?a.angleRelativeNormal(o.to(e),n.unit()):r)}getAreaInDir(t,s,e,i){ts3dutils.assertf(()=>t.isPerpendicularTo(this.normal)),ts3dutils.assertf(()=>s.isPerpendicularTo(this.normal));const r=this.matrixInverse.transformVector(s),n=r.cross(ts3dutils.V3.Z),o=e-n.angleXY(),a=i-n.angleXY(),u=this.matrixInverse.getTranslation().dot(r.unit());function l(t){return(t-Math.sin(t)*Math.cos(t))/2}function c(t){return Math.pow(Math.sin(t),3)/3}function h(t){return(Math.cos(3*t)-9*Math.cos(t))/24}const d=-u*(-Math.cos(a)+Math.cos(o)),p=l(a)-l(o)+d,f=(c(a)-c(o)+-u*(-Math.cos(a)-Math.cos(o))/2*d)/p,m=(h(a)-h(o)- -u/2*d)/p,$=this.matrix.xyAreaFactor();return ts3dutils.assert(!ts3dutils.eq0($)),{area:p*$,centroid:this.matrix.transformPoint(ts3dutils.M4.rotateZ(n.angleXY()).transformPoint(new ts3dutils.V3(f,m,0)))}}at(t){return ts3dutils.assertNumbers(t),this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return ts3dutils.assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return ts3dutils.assertNumbers(t),ts3dutils.assert(this.isValidT(t)),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}tangentAt2(t,s){return this.f2.times(t).minus(this.f1.times(s))}isCircular(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}isColinearTo(t){if(!ts3dutils.hasConstructor(t,EllipseCurve$$1))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&ts3dutils.eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:s,f2:e}=this.rightAngled(),{f1:i,f2:r}=t.rightAngled();return s.length()>e.length()&&([s,e]=[e,s]),i.length()>r.length()&&([i,r]=[r,i]),ts3dutils.eq(s.squared(),Math.abs(s.dot(i)))&&ts3dutils.eq(e.squared(),Math.abs(e.dot(r)))}}pointT(t){ts3dutils.assertVectors(t),ts3dutils.assert(this.containsPoint(t));const s=this.matrixInverse.transformPoint(t),e=EllipseCurve$$1.XYLCPointT(s,this.tMin,this.tMax);return ts3dutils.assert(this.isValidT(e)),e}reversed(){return new EllipseCurve$$1(this.center,this.f1.negated(),this.f2,PI-this.tMax,PI-this.tMin)}eccentricity(){const t=this.rightAngled(),s=t.f1.length(),e=t.f1.length(),[i,r]=s>e?[s,e]:[e,s];return Math.sqrt(1-r*r/i/i)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t=this.tMin,s=this.tMax,e=2){ts3dutils.assert(t<s,"startT < endT");const i=this.f1.length();return ts3dutils.eq(i,this.f2.length())?i*(s-t):super.arcLength(t,s,e)}circumferenceApproximate(){const{f1:t,f2:s}=this.rightAngled(),e=t.length(),i=s.length(),r=Math.pow(e-i,2)/Math.pow(e+i,2);return Math.PI*(e+i)*(1+3*r/(10+Math.sqrt(4-3*r)))}rightAngled(){const t=this.f1,s=this.f2,e=t.dot(s),i=s.squared()-t.squared();if(ts3dutils.eq0(e))return this;const r=2*e,n=i+Math.sqrt(i*i+4*e*e),{x1:o,y1:a}=intersectionUnitCircleLine$$1(r,n,0),u=t.times(o).plus(s.times(a)),l=t.times(-a).plus(s.times(o));return new EllipseCurve$$1(this.center,u,l,-PI,PI)}isInfosWithEllipse(t){if(this.normal.isParallelTo(t.normal)&&ts3dutils.eq0(this.center.minus(t.center).dot(t.normal))){const s=t.transform(this.matrixInverse).rightAngled(),e=s.f1.lengthXY(),i=s.f2.lengthXY(),r=s.center.lengthXY(),n=min(e,i),o=max(e,i);if(ts3dutils.lt(r+o,1)||ts3dutils.lt(1,r-o)||ts3dutils.lt(1,n-r)||ts3dutils.eq(1,e)&&ts3dutils.eq(1,i)&&ts3dutils.eq0(r))return[];const a=t=>s.at(t).lengthXY()-1,u=t=>s.at(t).xy().dot(s.tangentAt(t))/s.at(t).lengthXY();ts3dutils.checkDerivate(a,u,-PI,PI,1);const l=[];for(let t=-.8*PI;t<PI;t+=PI/4){let s=ts3dutils.newtonIterateSmart(a,t,16,u,1e-4);ts3dutils.le(s,-PI)&&(s+=ts3dutils.TAU),ts3dutils.assert(!isNaN(s)),ts3dutils.between(s,-PI,PI)&&ts3dutils.eq0(a(s))&&!l.some(t=>ts3dutils.eq(s,t))&&l.push(s)}const c=[];for(const e of l){const i=this.matrix.transformPoint(s.at(e));this.containsPoint(i)&&t.containsPoint(i)&&c.push({tThis:this.pointT(i),tOther:t.pointT(i),p:i})}return c}return this.isTsWithPlane(P3$$1.normalOnAnchor(t.normal.unit(),t.center)).mapFilter(s=>{const e=this.at(s);if(t.containsPoint(e))return{tThis:s,tOther:t.pointT(e),p:e}})}isInfosWithCurve(t){return t instanceof EllipseCurve$$1?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}transform4(t){const s=t=>sign(t)*sqrt((1-cos(t))/(1+cos(t))),e=new ts3dutils.M4(0,-1,0,1,2,0,0,0,0,0,1,0,0,1,0,1);return parabola4Projection$$1(ts3dutils.M4.product(t,this.matrix,e),s(this.tMin),s(this.tMax))}roots(){return ts3dutils.arrayFromFunction(3,t=>{return intersectionUnitCircleLine2$$1(this.f2.e(t),-this.f1.e(t),0).map(([t,s])=>Math.atan2(s,t)).filter(t=>this.isValidT(t))})}closestTToPoint(t,s){s=s||this.matrixInverse.transformPoint(t).angleXY();const e=t.minus(this.center);return ts3dutils.newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(e)),s,8)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const s=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.matrixInverse.transformVector(s).angleXY()}}EllipseCurve$$1.UNIT=new EllipseCurve$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y),EllipseCurve$$1.prototype.hlol=Curve$$1.hlol++,EllipseCurve$$1.prototype.tIncrement=2*Math.PI/128;class NURBS$$1 extends Curve$$1{constructor(t,s,e=NURBS$$1.openUniformKnots(t.length,s),i=e[s],r=e[e.length-s-1]){super(i,r),this.points=t,this.degree=s,this.knots=e;const n=t.length+s+1;ts3dutils.assert(e.length===n,"bad knot vector length: expected "+n+" (degree = "+s+" pcount = "+t.length+"), but was "+e.length),ts3dutils.assert(e[s]<=i),ts3dutils.assert(r<=e[e.length-s-1]);for(let s=0;s<t.length;s++)ts3dutils.assert(4==t[s].dim());ts3dutils.assert(s>=1,"degree must be at least 1 (linear)"),ts3dutils.assert(s%1==0),ts3dutils.assert(-1==e.firstUnsorted(ts3dutils.MINUS),"knot values must be in ascending order")}getConstructorParameters(){return[this.points,this.degree,this.knots]}at4(t){ts3dutils.assert(ts3dutils.between(t,this.tMin,this.tMax),t);const{points:s,degree:e,knots:i}=this,r=this.tInterval(t),n=ts3dutils.Vector.pack(s,new Float64Array(4*(e+1)),r-e,0,e+1);for(let s=0;s<e;s++)for(let o=e;o>s;o--){const a=(t-i[o+r-e])/(i[o+r-s]-i[o+r-e]);for(let t=0;t<4;t++)n[4*o+t]=(1-a)*n[4*(o-1)+t]+a*n[4*o+t]}return new ts3dutils.Vector(n.slice(4*e,4*(e+1)))}at(t){return this.at4(t).p3()}ptDtDdt4(t){const{points:s,degree:e,knots:i}=this,r=this.tInterval(t),n=ts3dutils.Vector.pack(s,new Float64Array(4*(e+1)),r-e,0,e+1);let o,a=ts3dutils.Vector.Zero(4);for(let s=0;s<e;s++){if(s==e-2){const t=new ts3dutils.Vector(n.slice(4*e,4*(e+1))),s=new ts3dutils.Vector(n.slice(4*(e-1),4*e)),o=new ts3dutils.Vector(n.slice(4*(e-2),4*(e-1)));function u(t,s,r,n){return n.minus(r).times(t/(i[s+e-t]-i[s-1]))}a=u(e,r+1,u(e-1,r+1,t,s),u(e-1,r,s,o))}if(s==e-1){const t=new ts3dutils.Vector(n.slice(4*e,4*(e+1)));o=new ts3dutils.Vector(n.slice(4*(e-1),4*e)).minus(t).times(e/(i[r]-i[r+1]))}for(let o=e;o>s;o--){const a=(t-i[o+r-e])/(i[o+r-s]-i[o+r-e]);for(let t=0;t<4;t++)n[4*o+t]=(1-a)*n[4*(o-1)+t]+a*n[4*o+t]}}return[new ts3dutils.Vector(n.slice(4*e,4*e+4)),o,a]}tangentAt(t){const[s,e]=this.ptDtDdt4(t);return e.times(s.w).minus(s.times(e.w)).div(Math.pow(s.w,2)).V3()}ddt(t){const[s,e,i]=this.ptDtDdt4(t);return ts3dutils.Vector.add(s.times(-s.w*i.w+2*Math.pow(e.w,2)),e.times(-2*s.w*e.w),i.times(Math.pow(s.w,2))).div(Math.pow(s.w,3)).V3()}ptDtDdt(t){const[s,e,i]=this.ptDtDdt4(t);return[s.p3(),e.times(s.w).minus(s.times(e.w)).div(Math.pow(s.w,2)).V3(),ts3dutils.Vector.add(s.times(-s.w*i.w+2*Math.pow(e.w,2)),e.times(-2*s.w*e.w),i.times(Math.pow(s.w,2))).div(Math.pow(s.w,3)).V3()]}pointT(t){return this.closestTToPoint(t)}closestTToPoint(t,s,e=this.tMin,i=this.tMax){return void 0===s&&(s=ts3dutils.arraySamples(e,i,32).withMax(s=>-this.at(s).distanceTo(t))),ts3dutils.newtonIterateWithDerivative2(s=>{const[e,i,r]=this.ptDtDdt(s);return[e.minus(t).dot(i),i.squared()+e.minus(t).dot(r)]},s,8,this.tMin,this.tMax)}containsPoint(t){const s=this.closestTToPoint(t);return void 0!==s&&this.at(s).like(t)}derivate(){const t=this.degree,s=ts3dutils.arrayFromFunction(this.points.length-1,s=>this.points[s].to(this.points[s+1]).times(t/(this.knots[s+t+1]-this.knots[s+1])));return new NURBS$$1(s,this.degree-1,this.knots.slice(1,-1),this.tMin,this.tMax)}withKnot(t,s=1){ts3dutils.assert(ts3dutils.between(t,this.tMin,this.tMax));const e=this.tInterval(t),{knots:i,points:r,degree:n}=this,o=ts3dutils.arrayFromFunction(this.degree,s=>{const o=e-n+1+s,a=t-i[o],u=0==a?0:a/(i[o+n]-i[o]);return ts3dutils.assert(ts3dutils.between(u,0,1)),ts3dutils.Vector.lerp(r[o-1],r[o],u)}),a=r.slice();a.splice(e-n+1,n-1,...o);const u=i.slice();return u.splice(e+1,0,t),new NURBS$$1(a,n,u,this.tMin,this.tMax)}removeKnot(t){const{knots:s,points:e,degree:i}=this;let r=this.tInterval(t),n=0;for(;s[r+1]==t;)r++,n++;if(0==n)throw new Error("There is no knot "+t+"!");const o=[e[r-i-1]],a=s.slice();a.splice(r,1);for(let s=r-i;s<=r-n;s++){const r=(a[s+i]-a[s])/(t-a[s]),n=ts3dutils.Vector.lerp(o.last,e[s],r);o.push(n)}if(o.last.like(e[r+1-n])){const t=e.slice();return t.splice(r-i-1,i-n+3,...o),new NURBS$$1(t,i,a)}}static openUniformKnots(t,s,e=0,i=1){const r=t+s+1;return ts3dutils.arrayFromFunction(r,t=>t<=s?e:t>=r-s-1?i:ts3dutils.lerp(e,i,(t-s)/(r-2*s-1)))}static bezierKnots(t,s=0,e=1){const i=new Array(2*(t+1));for(let r=0;r<t+1;r++)i[r]=s,i[t+1+r]=e;return i}static fromBezier(t){const s=t.selectPart(t.tMin,t.tMax);return NURBS$$1.Bezier(s.points)}static Bezier(t,s=0,e=1){return new NURBS$$1(t.map(t=>t instanceof ts3dutils.V3?new ts3dutils.Vector(new Float64Array([t.x,t.y,t.z,1])):t),t.length-1,ts3dutils.arrayFromFunction(2*t.length,s=>s<t.length?0:1),s,e)}static fromHyperbola(t,s=t.tMin,e=t.tMax){const i=HyperbolaCurve$$1.XY.at(s),r=HyperbolaCurve$$1.XY.at(e),n=new ts3dutils.V3((sinh(s)-sinh(e))/sinh(s-e),(cosh(s)-cosh(e))/sinh(s-e),0),o=i.lerp(r,.5),a=1/sqrt(1-Math.pow(o.y/o.x,2)),u=(a-o.x)/(n.x-a);return NURBS$$1.fromV3s([i,n,r],2,void 0,[1,u,1]).transform(t.matrix)}static fromParabola(t){return NURBS$$1.fromBezier(t.asBezier())}static fromEllipse(t){return new NURBS$$1([ts3dutils.VV(1,0,0,1),ts3dutils.VV(1,1,0,1).times(SQRT1_2),ts3dutils.VV(0,1,0,1),ts3dutils.VV(-1,1,0,1).times(SQRT1_2),ts3dutils.VV(-1,0,0,1),ts3dutils.VV(-1,-1,0,1).times(SQRT1_2),ts3dutils.VV(0,-1,0,1)],2,[0,0,0,PI/2,PI/2,PI,PI,3*PI/2,3*PI/2,2*PI]).transform(t.matrix)}static fromV3s(t,s,e,i=ts3dutils.arrayFromFunction(t.length,()=>1)){return ts3dutils.assert(t.length==i.length),new NURBS$$1(t.map((t,s)=>ts3dutils.Vector.fromV3AndWeight(t,i[s])),s,e)}isUniform(t=0){const s=ts3dutils.arrayFromFunction(this.knots.length-1,t=>this.knots[t+1]-this.knots[t]),[e,i]=minAndMax(s);return ts3dutils.eq(e,i,t)}isBSpline(t=0){const[s,e]=minAndMax(this.points.map(t=>t.w));return ts3dutils.eq(s,e,t)}isBezier(t=0){if(this.degree+1!=this.points.length)return!1;const[s,e]=minAndMax(this.knots,0,this.degree+1);if(!ts3dutils.eq(s,e,t))return!1;const[i,r]=minAndMax(this.knots,this.degree+1);return!!ts3dutils.eq(i,r,t)}getSegments(){const{knots:t,points:s,degree:e}=this,i=[],r=ts3dutils.Vector.pack(s,new Float64Array(4*s.length)),n=t=>new ts3dutils.Vector(r.slice(4*t,4*(t+1)));let o=e+1;for(;o<t.length-e-1;){const s=t[o],a=t[o-1];let u=1;for(;t[o+1]==s;)o++,u++;const l=new Array(e+1);for(let t=0;t<u+1;t++)l[t]=n(o-e-u+t);for(let i=1;i<=e-u;i++){for(let n=o-e;n<=o-u-i;n++){const i=(s-a)/(t[n+e+1]-a);for(let t=0;t<4;t++)r[4*n+t]=(1-i)*r[4*n+t]+i*r[4*(n+1)+t]}l[u+i]=n(o-e)}const c=ts3dutils.arrayFromFunction(2*(e+1),i=>i<e+1?t[o-u]:s);i.push(new NURBS$$1(l,e,c)),o++}const a=ts3dutils.arrayFromFunction(e+1,t=>n(s.length-e-1+t)),u=ts3dutils.arrayFromFunction(2*(e+1),s=>s<e+1?t[o-1]:t[o]);return i.push(new NURBS$$1(a,e,u)),i}split(t){const{knots:s,points:e,degree:i}=this;ts3dutils.assert(ts3dutils.le(this.tMin,t)&&ts3dutils.le(t,this.tMax));let r=this.tInterval(t),n=0;for(;s[r+1]==t;)r++,n++;const o=t=>new ts3dutils.Vector(l.slice(4*t,4*(t+1))),a=new Array(r+1-n);for(let t=0;t<r+n-i+1;t++)a[t]=this.points[t];const u=e.length-(r-i),l=ts3dutils.Vector.pack(e,new Float64Array(4*u),r-i);for(let e=1;e<=i-n;e++){for(let o=r-i;o<=r-n-e;o++){const n=(t-s[o+e])/(s[o+i+1]-s[o+e]),a=o-(r-i);for(let t=0;t<4;t++)l[4*a+t]=(1-n)*l[4*a+t]+n*l[4*(a+1)+t]}a[r-i+e]=o(0)}const c=s.slice(0,r+i+2-n);for(let s=0;s<i-n+1;s++)c[r-n+1+s]=t;const h=s.slice(r-i);for(let s=0;s<i+1;s++)h[s]=t;const d=ts3dutils.arrayFromFunction(u,t=>ts3dutils.vArrGet(l,4,t));return[new NURBS$$1(a,i,c),new NURBS$$1(d,i,h)]}simplify(){if(ts3dutils.assert(this.isBezier()),3==this.degree&&this.isBSpline())return new BezierCurve$$1(this.points[0].p3(),this.points[1].p3(),this.points[2].p3(),this.points[3].p3(),this.tMin,this.tMax);if(2==this.degree){const[t,s,e]=this.points,[i,r,n]=this.points.map(t=>t.p3()),o=NURBS$$1.simplifyUnit2(t.w,s.w,e.w).transform(ts3dutils.M4.forSys(r.to(i),r.to(n),void 0,r)),[a,u]=[o.pointT(i),o.pointT(n)].sort();return o.withBounds(ts3dutils.snap(a,o.tMin),ts3dutils.snap(u,o.tMax))}return 1==this.degree?L3$$1.throughPoints(this.points[0].p3(),this.points[1].p3()):this}static simplifyUnit2(t,s,e){const i=t*e-Math.pow(s,2),r=t*e/2/i,n=new ts3dutils.V3(r,r,0),o=(Math.pow(s,2)+i-2*s*sqrt(abs(i)))/2/i,a=ts3dutils.V3.X,u=new ts3dutils.V3(o,r,0);return ts3dutils.eq0(i)?new ParabolaCurve$$1(new ts3dutils.V3(.25,.25,0),new ts3dutils.V3(1,-1,0),new ts3dutils.V3(1,1,0),-.5,.5):i<0?new HyperbolaCurve$$1(n,n.to(a),n.to(u)):new EllipseCurve$$1(n,n.to(a),n.to(u),0)}elevateDegreeBezier(){ts3dutils.assert(this.isBezier());const t=new Array(this.points.length+1);t[0]=this.points[0],t[this.points.length]=this.points[this.points.length-1];for(let s=1;s<this.points.length;s++)t[s]=ts3dutils.Vector.lerp(this.points[s],this.points[s-1],s/(this.degree+1));const s=NURBS$$1.bezierKnots(this.degree+1,this.knots[0],this.knots[this.degree+1]);return new NURBS$$1(t,this.degree+1,s,this.tMin,this.tMax)}elevateDegree(){const t=this.getSegments().map(t=>t.elevateDegreeBezier()),s=new Array(2+t.length*this.degree);s[0]=t[0].points[0],s.last=t.last.points.last;for(let e=0;e<t.length;e++)for(let i=1;i<t[e].points.length-1;i++)s[e*(t[0].points.length-2)+i]=t[e].points[i];const e=new Array(s.length+this.degree+2);for(let t=0;t<this.degree+2;t++)e[t]=this.knots[0];for(let s=0;s<t.length;s++)for(let i=1;i<t[s].points.length-1;i++)e[s*(t[0].points.length-2)+i+this.degree+1]=t[s].knots.last;e[e.length-1]=this.knots.last,e[e.length-2]=this.knots.last;let i=new NURBS$$1(s,this.degree+1,e,this.tMin,this.tMax);for(let s=0;s<t.length-1;s++){let e;for(;e=i.removeKnot(t[s].knots.last);)i=e}return i}transform(t){return this.transform4(t)}transform4(t){return new NURBS$$1(this.points.map(s=>t.timesVector(s)),this.degree,this.knots,this.tMin,this.tMax)}tInterval(t){const{degree:s,knots:e}=this;for(let i=s;i<e.length-1-s;i++)if(t>=e[i]&&t<=e[i+1])return i;throw new Error(t+" "+e)}static UnitCircle(t=2,s=0,e=PI){const i=(e-s)/t,r=sin(PI/2-i/2);console.log(i/2/ts3dutils.DEG);const n=1/cos(i/2),o=ts3dutils.arrayFromFunction(2*t+1,i=>{const o=ts3dutils.lerp(s,e,i/2/t);return i%2==0?ts3dutils.VV(cos(o),sin(o),0,1):ts3dutils.VV(n*r*cos(o),n*r*sin(o),0,r)}),a=[];a.push(s,s,s);for(let i=0;i<t-1;i++){const r=ts3dutils.lerp(s,e,(i+1)/t);a.push(r,r)}return a.push(e,e,e),new NURBS$$1(o,2,a)}debugInfo(){return{points:[...this.knots.slice(this.degree,-this.degree).map(t=>this.at(t)),...this.points.map(t=>t.p3())],lines:this.points.flatMap((t,s,e)=>e[s+1]?[t.p3(),e[s+1].p3()]:[])}}isTsWithPlane(t){const{knots:s,degree:e,points:i}=this,r=[s[e],...i.slice(1,-1).map((t,i)=>this.closestTToPoint(t.p3(),void 0,s[i+3],s[i+e])),s[s.length-e-1]],n=[];for(let s=0;s<this.points.length-1;s++){const e=s=>{console.log("startT",s);const e=s=>{const[e,i]=this.ptDtDdt(s);return[t.distanceToPointSigned(e),t.normal1.dot(i)]};let i=ts3dutils.newtonIterateWithDerivative2(e,s,8,this.tMin,this.tMax),[r,o]=void 0===i?[]:e(i);void 0!==i&&ts3dutils.eq0(r)&&!ts3dutils.eq0(o)||(i=ts3dutils.newtonIterateWithDerivative2(s=>{const[,e,i]=this.ptDtDdt(s);return[t.normal1.dot(e),t.normal1.dot(i)]},s,8,this.tMin,this.tMax)),[r,o]=void 0===i?[]:e(i),void 0!==i&&ts3dutils.eq0(r)&&!n.some(t=>ts3dutils.eq(t,i))&&n.push(i)},i=this.points[s].p3(),o=this.points[s+1].p3(),a=ts3dutils.snap0(t.distanceToPointSigned(i)),u=ts3dutils.snap0(t.distanceToPointSigned(o));if(a*u<0){e(ts3dutils.lerp(r[s],r[s+1],a/(a-u)))}else 0==u&&e(this.closestTToPoint(o,r[s+1]))}return n}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1):super.isInfosWithCurve(t)}isInfosWithLine(t,s){const e=P3$$1.fromPoints(this.points.map(t=>t.p3())),i=L3$$1.anchorDirection(t,s),r=this.points.map(t=>e.distanceToPoint(t.p3())).max(),n=ts3dutils.eq0(r);if(n&&!e.containsLine(i)){const[r]=i.isTsWithPlane(e);if(void 0===r)return[];const n=i.at(r);return this.containsPoint(n)?[{tThis:this.pointT(n),tOther:L3$$1.pointT(t,s,n),p:n}]:[]}{const i=this.isTsWithPlane(P3$$1.normalOnAnchor(e.normal1.cross(s),t)).map(e=>{const i=this.at(e);return{tThis:e,tOther:L3$$1.pointT(t,s,i),p:i}});return n?i:i.filter(e=>L3$$1.containsPoint(t,s,e.p))}}roots(){console.log(this.tMin,this.tMax),ts3dutils.arraySamples(this.tMin,this.tMax,30).forEach(t=>{console.log(t+","+this.tangentAt(t).z)});const t=[[],[],[]];for(let s=0;s<this.points.length-1;s++){const e=(s,e)=>{console.log("d",e,"startT",s);const i=ts3dutils.newtonIterateWithDerivative2(t=>{const[,s,i]=this.ptDtDdt(t);return[s.e(e),i.e(e)]},s,8,this.tMin,this.tMax);void 0!==i&&t[e].push(i),console.log("d",e,"startT",s,"root",i)},i=this.points[s].p3(),r=this.points[s+1].p3(),n=i.to(r);for(let t=0;t<3;t++)if(0!==s&&ts3dutils.eq0(n.e(t))){e(ts3dutils.lerp(this.knots[s],this.knots[s+this.degree+2],.5),t)}else if(s<this.points.length-2){const i=r.to(this.points[s+2].p3());!ts3dutils.eq0(i.e(t))&&n.e(t)*i.e(t)<0&&e(this.closestTToPoint(r,this.guessTClosestToControlPoint(s+1)),t)}}return console.log(t),t}guessTClosestToControlPoint(t){return ts3dutils.lerp(this.knots[t],this.knots[t+this.degree+1],.5)}likeCurve(t){return this==t||ts3dutils.hasConstructor(t,NURBS$$1)&&this.degree===t.degree&&this.points.every((s,e)=>s.like(t.points[e]))&&this.knots.every((s,e)=>ts3dutils.eq(s,t.knots[e]))}isColinearTo(t){throw new Error("This doesn't even make sense.")}}function minAndMax(t,s=0,e=t.length){let i=1/0,r=-1/0;for(let n=s;n<e;n++)i>t[n]&&(i=t[n]),r<t[n]&&(r=t[n]);return[i,r]}NURBS$$1.EX2D=NURBS$$1.fromV3s([ts3dutils.V(51,141),ts3dutils.V(11,76),ts3dutils.V(29,32),ts3dutils.V(46,102),ts3dutils.V(74,148),ts3dutils.V(189,107),ts3dutils.V(56,10),ts3dutils.V(206,10),ts3dutils.V(211,98),ts3dutils.V(195,141),ts3dutils.V(139,148)],4),NURBS$$1.EX3D=new NURBS$$1([ts3dutils.VV(94,0,-34,1),ts3dutils.VV(69,57,45,.5),ts3dutils.VV(-20,44,91,1),ts3dutils.VV(-89,-13,47,.5),ts3dutils.VV(-56,-97,-7,1),ts3dutils.VV(34,-83,-54,.5),ts3dutils.VV(112,-53,16,1),ts3dutils.VV(79,30,70,.5),ts3dutils.VV(-2,-9,141,1),ts3dutils.VV(-80,-40,72,.5),ts3dutils.VV(-38,-150,43,1),ts3dutils.VV(43,-110,-29,.5),ts3dutils.VV(130,-106,65,1)],2,[-12,-12,-12,-8,-8,-4,-4,0,0,4,4,8,8,12,12,12]),NURBS$$1.prototype.tIncrement=1/128;class P3$$1 extends ts3dutils.Transformable{constructor(t,s=0){super(),this.normal1=t,this.w=s,ts3dutils.assertVectors(t),ts3dutils.assertNumbers(s),ts3dutils.assert(t.hasLength(1),"normal1.hasLength(1)"+t)}get anchor(){return this.normal1.times(this.w)}static throughPoints(t,s,e){ts3dutils.assertVectors(t,s,e);const i=s.minus(t).cross(e.minus(t)).unit();return new P3$$1(i,i.dot(t))}static normalOnAnchor(t,s){ts3dutils.assertVectors(t,s);const e=t.unit();return new this(e,e.dot(s))}static forAxisIntercepts(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=new ts3dutils.V3(1/t,1/s,1/e);return new P3$$1(i.unit(),i.length())}static forAnchorAndPlaneVectors(t,s,e){return ts3dutils.assertVectors(t,s,e),ts3dutils.assert(!s.isParallelTo(e)),this.normalOnAnchor(s.cross(e),t)}static forPointAndLine(t,s){return this.forAnchorAndPlaneVectors(s.anchor,s.dir1,s.anchor.to(t))}static forABCD(t,s,e,i){const r=Math.hypot(t,s,e);if(!ts3dutils.eq0(r))return new P3$$1(new ts3dutils.V3(t/r,s/r,e/r),-i/r)}static vanishingPlane(t){return P3$$1.forABCD(t.m[12],t.m[13],t.m[14],t.m[15])}static forAABB(t,s=0){return[new P3$$1(ts3dutils.V3.X,t.max.x+s),new P3$$1(ts3dutils.V3.X.negated(),-t.min.x-s),new P3$$1(ts3dutils.V3.Y,t.max.y+s),new P3$$1(ts3dutils.V3.Y.negated(),-t.min.y-s),new P3$$1(ts3dutils.V3.Z,t.max.z+s),new P3$$1(ts3dutils.V3.Z.negated(),-t.min.z-s)]}static fromPoints(t){const s=t.length;if(s<3)return;const e=ts3dutils.V3.add(...t).div(s);let i=0,r=0,n=0,o=0,a=0,u=0;for(const s of t){const t=s.minus(e);i+=t.x*t.x,r+=t.x*t.y,n+=t.x*t.z,o+=t.y*t.y,a+=t.y*t.z,u+=t.z*t.z}i/=s,r/=s,n/=s,o/=s,a/=s,u/=s;let l=ts3dutils.V3.O;{const t=o*u-a*a,s=new ts3dutils.V3(t,n*a-r*u,r*a-n*o);let e=t*t;l.dot(s)<0&&(e=-e),l=l.plus(s.times(e))}{const t=i*u-n*n,s=new ts3dutils.V3(n*a-r*u,t,r*n-a*i);let e=t*t;l.dot(s)<0&&(e=-e),l=l.plus(s.times(e))}{const t=i*o-r*r,s=new ts3dutils.V3(r*a-n*o,r*n-a*i,t);let e=t*t;l.dot(s)<0&&(e=-e),l=l.plus(s.times(e))}const c=l.unit();return P3$$1.normalOnAnchor(c,e)}axisIntercepts(){const t=this.w,s=this.normal1;return new ts3dutils.V3(t/s.x,t/s.y,t/s.z)}isCoplanarToPlane(t){return ts3dutils.assertInst(P3$$1,t),this.like(t)||this.likeFlipped(t)}like(t){return ts3dutils.assertInst(P3$$1,t),ts3dutils.eq(this.w,t.w)&&this.normal1.like(t.normal1)}likeFlipped(t){return ts3dutils.assertInst(P3$$1,t),ts3dutils.eq(this.w,-t.w)&&this.normal1.like(t.normal1.negated())}isParallelToPlane(t){return ts3dutils.assertInst(P3$$1,t),ts3dutils.eq(1,Math.abs(this.normal1.dot(t.normal1)))}isParallelToLine(t){return ts3dutils.assertInst(L3$$1,t),ts3dutils.eq0(this.normal1.dot(t.dir1))}isPerpendicularToLine(t){return ts3dutils.assertInst(L3$$1,t),ts3dutils.eq(1,Math.abs(this.normal1.dot(t.dir1)))}isPerpendicularToPlane(t){return ts3dutils.assertInst(P3$$1,t),ts3dutils.eq0(this.normal1.dot(t.normal1))}toSource(){return ts3dutils.callsce("new P3",this.normal1,this.w)}translated(t){return new P3$$1(this.normal1,this.w+t.dot(this.normal1))}transform(t){const s=ts3dutils.M4.transpose(ts3dutils.M4.inverse(t,ts3dutils.M4.temp0),ts3dutils.M4.temp1),[e,i,r]=this.normal1,n=s.timesVector(ts3dutils.VV(e,i,r,-this.w));return P3$$1.forABCD(n.x,n.y,n.z,n.w)}distanceToLine(t){return ts3dutils.assertInst(L3$$1,t),this.isParallelToLine(t)?0:this.distanceToPoint(t.anchor)}containsPoint(t){return ts3dutils.assertVectors(t),ts3dutils.eq(this.w,this.normal1.dot(t))}containsLine(t){return ts3dutils.assertInst(L3$$1,t),this.containsPoint(t.anchor)&&this.isParallelToLine(t)}distanceToPointSigned(t){return ts3dutils.assertInst(ts3dutils.V3,t),this.normal1.dot(t)-this.w}distanceToPoint(t){return ts3dutils.assertInst(ts3dutils.V3,t),Math.abs(this.normal1.dot(t)-this.w)}intersectionWithLine(t){return t.intersectionWithPlane(this)}intersectionWithPlane(t){if(ts3dutils.assertInst(P3$$1,t),this.isParallelToPlane(t))return;const s=this.normal1,e=t.normal1,i=s.cross(e).unit(),r=ts3dutils.M4.forRows(s,e,i).inversed().transformVector(new ts3dutils.V3(this.w,t.w,0));return new L3$$1(r,i)}projectedPoint(t){return t.minus(this.normal1.times(t.minus(this.anchor).dot(this.normal1)))}projectedVector(t){return t.minus(this.normal1.times(t.dot(this.normal1)))}flipped(){return new P3$$1(this.normal1.negated(),-this.w)}containsCurve(t){if(t instanceof L3$$1)return this.containsLine(t);if(t instanceof EllipseCurve$$1||t instanceof HyperbolaCurve$$1||t instanceof ParabolaCurve$$1)return this.containsPoint(t.center)&&this.normal1.isParallelTo(t.normal);if(t instanceof BezierCurve$$1)return t.points.every(t=>this.containsPoint(t));throw new Error(""+t)}equals(t){return ts3dutils.hasConstructor(t,P3$$1)&&this.normal1.equals(t.normal1)&&this.w==t.w}hashCode(){return 31*this.normal1.hashCode()|0+ts3dutils.floatHashCode(this.w)}}P3$$1.YZ=new P3$$1(ts3dutils.V3.X,0),P3$$1.ZX=new P3$$1(ts3dutils.V3.Y,0),P3$$1.XY=new P3$$1(ts3dutils.V3.Z,0);class Surface$$1 extends ts3dutils.Transformable{static loopContainsPointGeneral(t,s,e,i){const r=P3$$1.normalOnAnchor(i,s),n=t.map(t=>t.colinearToLine(e));let o=!1;function a(t){const s=e.pointT(t);return!!ts3dutils.eq0(s)||(s>0&&(o=!o),!1)}for(let o=0;o<t.length;o++){const u=t[o],l=(o+1)%t.length,c=t[l];if(n[o]){const t=e.pointT(u.a),s=e.pointT(u.b);if(Math.min(t,s)<=ts3dutils.NLA_PRECISION&&-ts3dutils.NLA_PRECISION<=Math.max(t,s))return exports.PointVsFace.ON_EDGE;if(!(n[l]||dotCurve2$$1(c.curve,c.aT,i,sign(c.deltaT()))<0)&&a(u.b))return exports.PointVsFace.ON_EDGE}else for(const t of u.edgeISTsWithPlane(r))if(t==u.bT){if(!e.containsPoint(u.b))continue;if(u.b.like(s))return exports.PointVsFace.ON_EDGE;if(dotCurve2$$1(u.curve,u.bT,i,-sign(u.deltaT()))<0!=(n[l]||dotCurve2$$1(c.curve,c.aT,i,sign(c.deltaT()))<0)&&a(u.b))return exports.PointVsFace.ON_EDGE}else if(t!=u.aT){const s=u.curve.at(t);if(!e.containsPoint(s))continue;if(a(s))return exports.PointVsFace.ON_EDGE}}return o?exports.PointVsFace.INSIDE:exports.PointVsFace.OUTSIDE}static loopContainsPointEllipse(t,s,e,i){const r=e.normal,n=P3$$1.normalOnAnchor(e.normal,s),o=t.map(t=>e.isColinearTo(t.curve));let a=!1;void 0===i&&(i=e.pointT(s));const u=i;function l(t){const s=e.pointT(t);return!!ts3dutils.eq(u,s)||(u<s&&ts3dutils.le(s,PI)&&(a=!a),!1)}for(let i=0;i<t.length;i++){const a=t[i],u=(i+1)%t.length,c=t[u];if(o[i]){let t;if(a.curve.containsPoint(s)&&ts3dutils.le(a.minT,t=a.curve.pointT(s))&&ts3dutils.le(t,a.maxT))return exports.PointVsFace.ON_EDGE;if(!(o[u]||dotCurve2$$1(c.curve,c.aT,r,sign(c.deltaT()))<0)&&e.containsPoint(a.b)&&l(a.b))return exports.PointVsFace.ON_EDGE}else for(const t of a.edgeISTsWithPlane(n))if(t==a.bT){if(!e.containsPoint(a.b))continue;if(dotCurve2$$1(a.curve,a.bT,r,-sign(a.deltaT()))<0!=(o[u]||dotCurve2$$1(c.curve,c.aT,r,sign(c.deltaT()))<0)&&l(a.b))return exports.PointVsFace.ON_EDGE}else if(t!=a.aT){const s=a.curve.at(t);if(!e.containsPoint(s))continue;if(l(s))return exports.PointVsFace.ON_EDGE}}return a?exports.PointVsFace.INSIDE:exports.PointVsFace.OUTSIDE}toString(){return this.toSource()}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}getExtremePoints(){return[]}isCurvesWithSurface(t){return t.isCurvesWithSurface(this)}containsCurve(t){if(t instanceof PPCurve$$1&&(this.equals(t.parametricSurface1)||this.equals(t.parametricSurface2)))return!0;if(t instanceof ImplicitCurve$$1){for(let s=ceil(t.tMin)+1;s<=floor(t.tMax)-1;s++)if(!this.containsPoint(t.points[s]))return!1;return!0}return!1}flipped2(t){return t?this.flipped():this}clipCurves(t){return t}equals(t){return this===t||this.constructor===t.constructor&&this.getConstructorParameters().equals(t.getConstructorParameters())}hashCode(){return this.getConstructorParameters().hashCode()}zDirVolume(t){return this.visit(ZDirVolumeVisitor$$1,t)}calculateArea(t){return this.visit(CalculateAreaVisitor$$1,t)}}!function(t){t[t.INSIDE=0]="INSIDE",t[t.OUTSIDE=1]="OUTSIDE",t[t.ON_EDGE=2]="ON_EDGE"}(exports.PointVsFace||(exports.PointVsFace={}));class ImplicitSurface$$1 extends Surface$$1{static is(t){return t.implicitFunction&&t.didp}}class ParametricSurface$$1 extends Surface$$1{constructor(t,s,e,i){super(),this.uMin=t,this.uMax=s,this.vMin=e,this.vMax=i,ts3dutils.assertNumbers(t,s,e,i),ts3dutils.assert(t<s),ts3dutils.assert(e<i),ts3dutils.assert((t=>t[t.length-4])(this.getConstructorParameters())==this.uMin,this.getConstructorParameters(),this.uMin)}static isCurvesParametricImplicitSurface(t,s,e,i=e,r){const n=t.pUVFunc(),o=s.implicitFunction(),a=t.dpdu(),u=t.dpdv(),l=s.didp.bind(s),c=exports.MathFunctionR2R.forFFxFy((t,s)=>o(n(t,s)),(t,s)=>l(n(t,s)).dot(a(t,s)),(t,s)=>l(n(t,s)).dot(u(t,s)));return Curve$$1.breakDownIC(c,t,e,i,r,(t,e)=>s.containsPoint(n(t,e))).map(({points:e,tangents:i},n)=>PICurve$$1.forParametricPointsTangents(t,s,e,i,r))}static isCurvesParametricParametricSurface(t,s,e,i=e,r){return breakDownPPCurves$$1(t,s,e,i,r)}static is(t){return t.pUVFunc}pUV(t,s){return this.pUVFunc()(t,s)}pUVFunc(){return this.pUV.bind(this)}uvP(t){return this.uvPFunc()(t)}uvPFunc(){return this.uvP.bind(this)}bounds(t,s){return this.uMin<=t&&t<=this.uMax&&this.vMin<=s&&s<=this.vMax}boundsSigned(t,s){return min(t-this.uMin,this.uMax-t,s-this.vMin,this.vMax-s)}normalP(t){const s=this.uvPFunc()(t);return this.normalUV(s.x,s.y)}normalUVFunc(){return this.normalUV.bind(this)}normalUV(t,s){return this.normalUVFunc()(t,s)}parametersValid(t,s){return ts3dutils.between(t,this.uMin,this.uMax)&&ts3dutils.between(s,this.vMin,this.vMax)}toMesh(t=this.uStep,s=this.vStep){return ts3dutils.assert(isFinite(this.vMin)&&isFinite(this.vMax)&&isFinite(this.uMin)&&isFinite(this.uMax)),ts3dutils.assert(isFinite(t)&&isFinite(s)),tsgl.Mesh.parametric(this.pUVFunc(),this.normalUVFunc(),this.uMin,this.uMax,this.vMin,this.vMax,ceil((this.uMax-this.uMin)/t),ceil((this.vMax-this.vMin)/s))}isCurvesWithImplicitSurface(t,s,e,i){return ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,s,e,i)}edgeLoopCCW(t){const s=this.uvPFunc();return ts3dutils.isCCW(t.flatMap(t=>t.getVerticesNo0()).map(t=>s(t)),ts3dutils.V3.Z)}like(t){if(!this.isCoplanarTo(t))return!1;const s=this.pUVFunc()(this.uMin,this.vMin),e=this.normalUVFunc()(this.uMin,this.vMin),i=t.normalP(s);return 0<e.dot(i)}getApproxAABB(){const t=new ts3dutils.AABB;t.addPoints(this.getExtremePoints());const s=[ts3dutils.V(0,0),ts3dutils.V(0,1),ts3dutils.V(1,0),ts3dutils.V(1,1),ts3dutils.V(.5,.5)].map(t=>this.pUV(ts3dutils.lerp(this.uMin,this.uMax,t.x),ts3dutils.lerp(this.vMin,this.vMax,t.y)));return t.addPoints(s),t}}class ConicSurface$$1 extends ParametricSurface$$1{constructor(t,s,e,i,r=0,n=PI,o=0,a=16){super(r,n,o,a),this.center=t,this.f1=s,this.f2=e,this.dir=i,ts3dutils.assertVectors(t,s,e,i),ts3dutils.assert(0<=o),this.matrix=ts3dutils.M4.forSys(s,e,i,t),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.f1.cross(this.f2).dot(this.dir)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}pointFoot(t,s,e){if(void 0===s||void 0===e){const i=this.matrixInverse.transformPoint(t),r=i.angleXY();void 0===s&&(s=r<-PI/2?r+ts3dutils.TAU:r),void 0===e&&(e=i.z+(i.lengthXY()-i.z)*SQRT1_2)}const{0:i,1:r}=ts3dutils.newtonIterate(([s,e])=>{const i=this.pUV(s,e).to(t);return[this.dpdu()(s,e).dot(i),this.dpdv()(s).dot(i)]},[s,e]);return new ts3dutils.V3(i,r,0)}get apex(){return this.center}static atApexThroughEllipse(t,s,e,i,r,n){return ts3dutils.assertVectors(t),ts3dutils.assertInst(EllipseCurve$$1,s),new ConicSurface$$1(t,s.f1,s.f2,t.to(s.center),e,i,r,n)}static unitISLineTs(t,s){const{x:e,y:i,z:r}=t,{x:n,y:o,z:a}=s,u=n*n+o*o-a*a,l=2*(e*n+i*o-r*a),c=e*e+i*i-r*r;return ts3dutils.pqFormula(l/u,c/u).filter(t=>0<r+t*a)}static unitISPlane(t,s,e){if(ts3dutils.eq0(s)){if(ts3dutils.assert(!ts3dutils.eq0(t)),ts3dutils.eq0(e))return[new L3$$1(ts3dutils.V3.O,new ts3dutils.V3(0,-SQRT1_2,-SQRT1_2),void 0,0),new L3$$1(ts3dutils.V3.O,new ts3dutils.V3(0,-SQRT1_2,SQRT1_2),0)];{const s=new ts3dutils.V3(e/t,0,0),i=new ts3dutils.V3(0,0,abs(e/t)),r=new ts3dutils.V3(0,e/t,0);return[new HyperbolaCurve$$1(s,i,r)]}}{const i=t*t,r=s*s;if(ts3dutils.eq0(e)){if(ts3dutils.eq(i,r))return[new L3$$1(ts3dutils.V3.O,new ts3dutils.V3(s,0,-t).unit())];if(i<r)throw new Error("intersection is single point V3.O");if(i>r)return[new L3$$1(ts3dutils.V3.O,new ts3dutils.V3(s,sqrt(i-r),-t).unit()),new L3$$1(ts3dutils.V3.O,new ts3dutils.V3(s,-sqrt(i-r),-t).unit())]}else{if(ts3dutils.eq(i,r)){const i=new ts3dutils.V3(e/2/t,0,e/2/s),r=new ts3dutils.V3(e/2/t,e/s,e/2/s),n=new ts3dutils.V3(0,0,e/s).minus(i);return[new ParabolaCurve$$1(i,r.minus(i),n.z<0?n.negated():n)]}if(i<r){const n=new ts3dutils.V3(-t*e/(r-i),0,e*s/(r-i));if(n.z<0)return[];const o=new ts3dutils.V3(e/(t-s),0,-e/(t-s)),a=new ts3dutils.V3(-t*e/(r-i),e/sqrt(r-i),e*s/(r-i));return[new EllipseCurve$$1(n,n.to(o),n.to(a),-PI,PI)]}if(i>r){const n=new ts3dutils.V3(-t*e/(r-i),0,e*s/(r-i)),o=new ts3dutils.V3(e*s/(i-r),0,-e*t/(i-r)),a=new ts3dutils.V3(0,e/sqrt(i-r),0);return[new HyperbolaCurve$$1(n,o.z>0?o:o.negated(),a)]}}}throw new Error("???")}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)&&this.dir.equals(t.dir)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}getVectors(){return[{anchor:this.center,dir1:this.dir},{anchor:this.center.plus(this.dir),dir1:this.f1},{anchor:this.center.plus(this.dir),dir1:this.f2}]}getSeamPlane(){return P3$$1.forAnchorAndPlaneVectors(this.center,this.f1,this.dir)}loopContainsPoint(t,s){ts3dutils.assertVectors(s);const e=this.center.like(s)?new L3$$1(s,this.matrix.transformVector(new ts3dutils.V3(0,1,1)).unit()):L3$$1.throughPoints(s,this.apex),i=e.dir1.cross(this.dir);return Surface$$1.loopContainsPointGeneral(t,s,e,i)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.dir,this.uMin,this.uMax,this.vMin,this.vMax]}isTsForLine(t){const s=this.matrixInverse.transformPoint(t.anchor),e=this.matrixInverse.transformVector(t.dir1);return ConicSurface$$1.unitISLineTs(s,e)}isCoplanarTo(t){return this===t||!!(t instanceof ConicSurface$$1&&this.apex.like(t.apex))&&this.containsEllipse(new EllipseCurve$$1(t.center.plus(t.dir),t.f1,t.f2))}containsEllipse(t){const s=t.transform(this.matrixInverse);if(s.center.z<0)return!1;const{f1:e,f2:i}=s.rightAngled(),r=s.center.plus(e),n=s.center.plus(i);return ts3dutils.eq(Math.pow(r.x,2)+Math.pow(r.y,2),Math.pow(r.z,2))&&ts3dutils.eq(Math.pow(n.x,2)+Math.pow(n.y,2),Math.pow(n.z,2))&&(ts3dutils.eq0(e.z)||ts3dutils.eq0(i.z))}containsLine(t){const s=t.transform(this.matrixInverse),e=s.dir1;return s.containsPoint(ts3dutils.V3.O)&&ts3dutils.eq(e.x*e.x+e.y*e.y,e.z*e.z)}containsParabola(t){ts3dutils.assertInst(ParabolaCurve$$1,t);const s=t.transform(this.matrixInverse);if(s.center.z<0||s.f2.z<0)return!1;const{center:e,f1:i,f2:r}=s.rightAngled();return ts3dutils.eq(e.x*e.x+e.y*e.y,e.z*e.z)&&ts3dutils.eq0(i.z)&&ts3dutils.eq(r.x*r.x+r.y*r.y,r.z*r.z)}containsHyperbola(t){ts3dutils.assertInst(HyperbolaCurve$$1,t);const s=t.transform(this.matrixInverse).rightAngled(),e=s.center.xy();if(e.likeO())return!1;const i=e.angleXY(),{center:r,f1:n,f2:o}=s.rotateZ(-i);return n.z>0&&ts3dutils.eq(r.x,n.z)&&ts3dutils.eq(r.z,n.x)&&ts3dutils.eq0(r.y)&&ts3dutils.eq0(n.y)&&ts3dutils.eq(sqrt(abs(Math.pow(r.x,2)-Math.pow(r.z,2))),abs(o.y))&&ts3dutils.eq0(o.x)&&ts3dutils.eq0(o.z)}containsCurve(t){return t instanceof EllipseCurve$$1?this.containsEllipse(t):t instanceof L3$$1?this.containsLine(t):t instanceof HyperbolaCurve$$1?this.containsHyperbola(t):t instanceof ParabolaCurve$$1?this.containsParabola(t):super.containsCurve(t)}transform(t){return new ConicSurface$$1(t.transformPoint(this.center),t.transformVector(this.f1).times(t.isMirroring()?-1:1),t.transformVector(this.f2),t.transformVector(this.dir),this.uMin,this.uMax,this.vMin,this.vMax)}transform4(t){const s=t.timesVector(ts3dutils.Vector.fromV3AndWeight(this.center,1)),e=t=>new EllipseCurve$$1(new ts3dutils.V3(0,0,t),new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0));if(ts3dutils.eq0(s.w)){const i=s.V3(),r=e(this.vMin).transform4(t.times(this.matrix)),n=ts3dutils.M4.forSys(r.f1,r.f2,i.unit(),r.center).inversed(),o=e(this.vMax).transform4(n.times(t.times(this.matrix))).getAABB();return new CylinderSurface$$1(r,i.unit(),this.uMin,this.uMax,min(0,o.min.z,o.max.z),max(0,o.min.z,o.max.z))}{const s=t.transformPoint(this.center),i=t.transformVector2(this.f1,this.center).times(t.isMirroring()?-1:1),r=t.transformVector2(this.f2,this.center),n=t.transformVector2(this.dir,this.center),o=ts3dutils.M4.forSys(i,r,n,s).inversed(),a=e(this.vMin).transform4(o.times(t.times(this.matrix))).getAABB().addAABB(e(this.vMax).transform4(o.times(t.times(this.matrix))).getAABB());return new ConicSurface$$1(s,i,r,n,this.uMin,this.uMax,a.min.z,a.max.z)}}flipped(){return new ConicSurface$$1(this.center,this.f1.negated(),this.f2,this.dir)}normalUVFunc(){const{f1:t,f2:s}=this,e=this.dir;return(i,r)=>s.cross(t).plus(s.cross(e.times(Math.cos(i)))).plus(e.cross(t.times(Math.sin(i)))).unit()}normalP(t){const s=this.matrixInverse.transformPoint(t);return this.normalUVFunc()(s.angleXY(),s.z)}pUVFunc(){return(t,s)=>{const e=new ts3dutils.V3(s*cos(t),s*sin(t),s);return this.matrix.transformPoint(e)}}dpdu(){return(t,s)=>{const e=new ts3dutils.V3(s*-sin(t),s*cos(t),0);return this.matrix.transformVector(e)}}dpdv(){return t=>{const s=new ts3dutils.V3(cos(t),sin(t),1);return this.matrix.transformVector(s)}}implicitFunction(){return t=>{const s=this.matrixInverse.transformPoint(t),e=s.lengthXY();return this.normalDir*(e-s.z)}}didp(t){const s=this.matrixInverse.transformPoint(t);return this.pLCNormalWCMatrix.transformVector(s.xy().unit().withElement("z",-1).times(this.normalDir))}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}uvP(t){const s=this.matrixInverse.transformPoint(t),e=s.angleXY();return new ts3dutils.V3(e<-PI/2?e+ts3dutils.TAU:e,s.z,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):ImplicitSurface$$1.is(t)?ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/this.dir.length(),.02):super.isCurvesWithSurface(t)}getCenterLine(){return new L3$$1(this.center,this.dir)}isCurvesWithPlane(t){ts3dutils.assertInst(P3$$1,t);const s=t.transform(this.matrixInverse),e=s.normal1,i=e.z,r=e.lengthXY(),n=s.w,o=ts3dutils.M4.rotateZ(e.angleXY()),a=ts3dutils.eq0(e.lengthXY())?this.matrix:this.matrix.times(o);return ConicSurface$$1.unitISPlane(r,i,n).flatMap(s=>{const e=s.transform(a);if(s instanceof EllipseCurve$$1){const t=s.transform(o),i=t.isTsWithPlane(P3$$1.ZX);return ts3dutils.getIntervals(i,-PI,PI).filter(([s,e])=>t.at((s+e)/2).y>0).flatMap(([t,s])=>e.split(t,s))}const i=e.at(.2);return this.normalP(i).cross(t.normal1).dot(e.tangentAt(.2))>0?e:e.reversed()})}debugInfo(){return{ps:[this.center],lines:[this.center,this.center.plus(this.f1),this.center.plus(this.f2),this.center.plus(this.dir)]}}}ConicSurface$$1.UNIT=new ConicSurface$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y,ts3dutils.V3.Z),ConicSurface$$1.prototype.uStep=PI/16,ConicSurface$$1.prototype.vStep=256;class ProjectedCurveSurface$$1 extends ParametricSurface$$1{constructor(t,s,e=t.tMin,i=t.tMax,r=-100,n=100){super(e,i,r,n),this.baseCurve=t,this.dir=s,ts3dutils.assertInst(Curve$$1,t),ts3dutils.assertInst(ts3dutils.V3,s),ts3dutils.assert(e<i),ts3dutils.assert(r<n)}getConstructorParameters(){return[this.baseCurve,this.dir,this.uMin,this.uMax,this.vMin,this.vMax]}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.dir.equals(t.dir)&&this.baseCurve.equals(t.baseCurve)}hashCode(){return[this.dir,this.baseCurve].hashCode()}containsLine(t){return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor)}dpdu(){return(t,s)=>this.baseCurve.tangentAt(t)}dpdv(){return(t,s)=>this.dir}normalUV(t,s){return this.baseCurve.tangentAt(t).cross(this.dir).unit()}pUV(t,s){return this.baseCurve.at(t).plus(this.dir.times(s))}pointFoot(t,s){const e=new P3$$1(this.dir.unit(),0),i=this.baseCurve.project(e),r=e.projectedPoint(t),n=i.closestTToPoint(r,s,this.uMin,this.uMax),o=L3$$1.pointT(this.baseCurve.at(n),this.dir,t);return new ts3dutils.V3(n,o,0)}uvPFunc(){const t=new P3$$1(this.dir.unit(),0),s=this.baseCurve.project(t);return e=>{const i=t.projectedPoint(e);ts3dutils.assertNumbers(this.uMin);const r=s.pointT(i,this.uMin,this.uMax),n=L3$$1.pointT(this.baseCurve.at(r),this.dir,e);return new ts3dutils.V3(r,n,0)}}isCurvesWithPlane(t){if(ts3dutils.assertInst(P3$$1,t),this.dir.isPerpendicularTo(t.normal1)){return this.baseCurve.isTsWithPlane(t).map(s=>{const e=0<this.baseCurve.tangentAt(s).dot(t.normal1)?this.dir:this.dir.negated();return new L3$$1(this.baseCurve.at(s),e.unit())})}{let s=this.baseCurve.transform(ts3dutils.M4.project(t,this.dir));return this.dir.dot(t.normal1)>0&&(s=s.reversed()),[s]}}isCurvesWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isCurvesWithPlane(t.plane);if(t instanceof ProjectedCurveSurface$$1){const s=t.dir;if(this.dir.isParallelTo(s)){return t.baseCurve.isTsWithSurface(this).map(e=>{const i=t.baseCurve.at(e),r=this.normalP(i).cross(t.normalP(i));return new L3$$1(i,s.times(sign(r.dot(s))))})}if(ImplicitSurface$$1.is(t)){let s=ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/t.dir.length(),.05);return s=t.clipCurves(s)}{let s=ParametricSurface$$1.isCurvesParametricParametricSurface(this,t,.05,.1/t.dir.length(),.05);return s=this.clipCurves(s),s=t.clipCurves(s)}}return t instanceof EllipsoidSurface$$1?t.isCurvesWithSurface(this):super.isCurvesWithSurface(t)}containsPoint(t){const s=this.uvPFunc()(t);return this.pUVFunc()(s.x,s.y).like(t)}containsCurve(t){if(t instanceof L3$$1)return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor);if(t instanceof ImplicitCurve$$1)return super.containsCurve(t);const s=new P3$$1(this.dir.unit(),0),e=this.baseCurve.project(s),i=t.project(s);return e.isColinearTo(i)}isCoplanarTo(t){return this==t||ts3dutils.hasConstructor(t,ProjectedCurveSurface$$1)&&this.dir.isParallelTo(t.dir)&&this.containsCurve(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;const s=this.pUVFunc()(0,0),e=this.normalUVFunc()(0,0),i=t.normalP(s);return 0<e.dot(i)}loopContainsPoint(t,s){ts3dutils.assertVectors(s),ts3dutils.assert(isFinite(s.x),s.y,s.z);const e=new L3$$1(s,this.dir.unit()),i=this.uvPFunc()(s);isNaN(i.x)&&(console.log(this.sce,s.sce),ts3dutils.assert(!1));const r=this.baseCurve.tangentAt(i.x).rejectedFrom(this.dir);return Surface$$1.loopContainsPointGeneral(t,s,e,r)}transform(t){const s=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform(t),t.transformVector(this.dir).times(s),this.uMin,this.uMax,1==s?this.vMin:-this.vMax,1==s?this.vMax:-this.vMin)}transform4(t){const s=t.vanishingPoint(this.dir);if(!s){const s=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform4(t),t.normalized().transformVector(this.dir).times(s),void 0,void 0,1==s?this.tMin:-this.tMax,1==s?this.tMax:-this.tMin)}const e=this.baseCurve.transform4(t);return e instanceof EllipseCurve$$1?(console.log(s.sce,e.sce),ConicSurface$$1.atApexThroughEllipse(s,t.isMirroring()?e:e.reversed(),this.sMin,this.sMax,1,2)):new PointProjectedSurface$$1(e,s,P3$$1.throughPoints(e.at(e.tMin),e.at((e.tMin+e.tMax)/2),e.at(e.tMax)),1,this.sMin,this.sMax,1,2)}isTsForLine(t){ts3dutils.assertInst(L3$$1,t);const s=new P3$$1(this.dir.unit(),0),e=s.projectedVector(t.dir1);if(e.likeO())return[];const i=s.projectedPoint(t.anchor);return this.baseCurve.project(s).isInfosWithLine(i,e,this.uMin,this.uMax,t.tMin,t.tMax).map(t=>t.tOther)}flipped(){return new this.constructor(this.baseCurve,this.dir.negated(),this.uMin,this.uMax,-this.vMax,-this.vMin)}}ProjectedCurveSurface$$1.prototype.uStep=1/128,ProjectedCurveSurface$$1.prototype.vStep=256;class RotatedCurveSurface$$1 extends ParametricSurface$$1{constructor(t,s=ts3dutils.M4.IDENTITY,e=0,i=PI,r=t.tMin,n=t.tMax){super(e,i,r,n),this.curve=t,this.matrix=s,ts3dutils.assertInst(ts3dutils.M4,s),ts3dutils.assert(s.isNoProj()),ts3dutils.assert(ts3dutils.eq0(t.at(r).y)),this.matrixInverse=s.inversed(),this.vStep=this.curve.tIncrement}getConstructorParameters(){return[this.curve,this.matrix,this.uMin,this.uMax,this.vMin,this.vMax]}flipped(){return new RotatedCurveSurface$$1(this.curve,this.matrix.times(ts3dutils.M4.mirror(P3$$1.YZ)),this.uMin,this.uMax,this.vMin,this.vMax)}transform(t){return new RotatedCurveSurface$$1(this.curve,t.isMirroring()?t.times(this.matrix).times(ts3dutils.M4.mirror(P3$$1.YZ)):t.times(this.matrix),this.uMin,this.uMax,this.vMin,this.vMax)}containsPoint(t){const s=this.matrixInverse.transformPoint(t),e=s.lengthXY();return this.curve.containsPoint(new ts3dutils.V3(e,0,s.z))}pUVFunc(){return(t,s)=>{const{x:e,z:i}=this.curve.at(s);return this.matrix.transformPoint(ts3dutils.V3.polar(e,t,i))}}dpdu(){return(t,s)=>{const e=this.curve.at(s).x,i=new ts3dutils.V3(e*-sin(t),e*cos(t),0);return this.matrix.transformVector(i)}}dpdv(){return(t,s)=>{const{x:e,z:i}=this.curve.tangentAt(s);return this.matrix.transformVector(ts3dutils.V3.polar(e,t,i))}}normalUVFunc(){const t=this.matrix.inversed().transposed().as3x3(),s=this.matrix.isMirroring()?-1:1;return(e,i)=>{const{x:r,z:n}=this.curve.tangentAt(i);return t.transformVector(ts3dutils.V3.polar(n,e,-r)).toLength(s)}}uvPFunc(){return t=>{const s=this.matrixInverse.transformPoint(t),e=EllipseCurve$$1.XYLCPointT(s,this.uMin,this.uMax),i=s.lengthXY();return new ts3dutils.V3(e,this.curve.pointT(new ts3dutils.V3(i,0,s.z)),0)}}pointFoot(t,s,e){const i=this.matrixInverse.transformPoint(t),r=abs(i.angleXY()),n=i.lengthXY();return new ts3dutils.V3(r,this.curve.closestTToPoint(new ts3dutils.V3(n,0,i.z)),0)}isTsForLine(t){const s=this.matrixInverse.transformPoint(t.anchor),e=this.matrixInverse.transformVector(t.dir1);if(e.isParallelTo(ts3dutils.V3.Z))return ts3dutils.fuzzyBetween(s.angleXY(),this.uMin,this.uMax)?this.curve.isInfosWithLine(new ts3dutils.V3(s.lengthXY(),0,s.z),e).map(t=>t.tOther):[];if(L3$$1.containsPoint(s.xy(),e.xy(),ts3dutils.V3.O)){const t=e.xy().unit();return[...this.curve.isInfosWithLine(new ts3dutils.V3(t.dot(s),0,s.z),new ts3dutils.V3(t.dot(e),0,e.z)),...this.curve.isInfosWithLine(new ts3dutils.V3(-t.dot(s),0,s.z),new ts3dutils.V3(-t.dot(e),0,e.z))].map(t=>t.tOther).filter(t=>ts3dutils.fuzzyBetween(L3$$1.at(s,e,t).angleXY(),this.uMin,this.uMax))}if(e.isPerpendicularTo(ts3dutils.V3.Z)){const t=this.isCurvesWithPlaneLC(new P3$$1(ts3dutils.V3.Z,s.z));return t?t.flatMap(t=>t.isInfosWithLine(s,e).map(t=>t.tOther)):[]}{const t=-s.xy().dot(e.xy())/e.xy().squared(),i=L3$$1.at(s,e,t),r=i.lengthXY(),n=r*(e.z/e.lengthXY());return HyperbolaCurve$$1.XY.transform(ts3dutils.M4.rotateX(90*ts3dutils.DEG).scale(r,0,n).translate(0,0,i.z)).isInfosWithCurve(this.curve).map(t=>(t.p.z-s.z)/e.z).filter(t=>ts3dutils.fuzzyBetween(L3$$1.at(s,e,t).angleXY(),this.uMin,this.uMax))}}isCurvesWithPlaneLC(t){return t.normal1.isParallelTo(ts3dutils.V3.Z)?this.curve.isTsWithPlane(t).map(s=>{const{x:e}=this.curve.at(s);return new EllipseCurve$$1(new ts3dutils.V3(0,0,t.w),new ts3dutils.V3(e,0,0),new ts3dutils.V3(0,e,0),this.uMin,this.uMax).transform(this.matrix)}):t.normal1.isPerpendicularTo(ts3dutils.V3.Z)&&t.containsPoint(ts3dutils.V3.O)?[this.curve.rotateZ(ts3dutils.V3.Y.angleRelativeNormal(t.normal1,ts3dutils.V3.Z)).transform(this.matrix)]:void 0}isCurvesWithPlane(t){const s=t.transform(this.matrixInverse),e=this.isCurvesWithPlaneLC(s);return e?e.map(t=>t.transform(this.matrix)):ParametricSurface$$1.isCurvesParametricImplicitSurface(this,new PlaneSurface$$1(t),.05,.05,.02)}loopContainsPoint(t,s){const e=this.matrixInverse.transformPoint(s),i=EllipseCurve$$1.XYLCPointT(e,this.uMin,this.uMax),r=EllipseCurve$$1.semicircle(e.lengthXY(),new ts3dutils.V3(0,0,e.z)).transform(this.matrix);return Surface$$1.loopContainsPointEllipse(t,s,r,i)}isCoplanarTo(t){if(this===t)return!0;if(!ts3dutils.hasConstructor(t,RotatedCurveSurface$$1))return!1;const s=this.matrixInverse.times(t.matrix);ts3dutils.assert(!s.X.xy().likeO());const e=s.X.angleXY();return t.curve.transform(ts3dutils.M4.rotateZ(-e).times(s)).isColinearTo(this.curve)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}containsCurve(t){if(t.constructor==this.curve.constructor){const s=t.transform(this.matrixInverse),e=[0,.5,1].map(t=>ts3dutils.lerp(s.tMin,s.tMax,t)).withMax(t=>s.at(t).lengthXY()),i=s.at(e).angleXY(),r=s.rotateZ(-i);if(this.curve.isColinearTo(r))return!0}if(t instanceof EllipseCurve$$1){const s=t.transform(this.matrixInverse);return!!s.normal.isParallelTo(ts3dutils.V3.Z)&&(s.isCircular()&&this.curve.containsPoint(new ts3dutils.V3(s.f1.length(),0,s.center.z)))}return super.containsCurve(t)}getExtremePoints(){return getExtremePointsHelper$$1.call(this,this.curve)}asNURBSSurface(){const t=NURBS$$1.fromEllipse(this.curve),s=NURBS$$1.UnitCircle(2,this.tMin,this.tMax);return new NURBSSurface$$1(s.points.flatMap(s=>t.points.map(t=>this.matrix.timesVector(ts3dutils.VV(s.x*t.x,s.y*t.x,t.z*s.w,s.w*t.w)))),t.knots,s.knots,t.degree,s.degree,t.tMin,t.tMax,s.tMin,s.tMax)}}function getExtremePointsHelper$$1(t){const s=this.matrix.X,e=this.matrix.Y;return[0,1,2].flatMap(i=>{const r=e.e(i),n=-s.e(i);return(ts3dutils.eq0(r)&&ts3dutils.eq0(n)?[[1,0]]:intersectionUnitCircleLine2$$1(r,n,0)).flatMap(([s,e])=>{const r=Math.atan2(e,s);return ts3dutils.lt(this.uMin,r)&&ts3dutils.lt(r,this.uMax)?t.transform(this.matrix.times(ts3dutils.M4.rotateZ(r))).roots()[i].map(t=>this.pUV(r,t)):[]})})}RotatedCurveSurface$$1.prototype.uStep=EllipseCurve$$1.prototype.tIncrement;class CylinderSurface$$1 extends ProjectedCurveSurface$$1{constructor(t,s,e=t.tMin,i=t.tMax,r=-1/0,n=1/0){super(t,s,e,i,r,n),this.baseCurve=t,ts3dutils.assertInst(EllipseCurve$$1,t),this.matrix=ts3dutils.M4.forSys(t.f1,t.f2,s,t.center),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.baseCurve.normal.dot(this.dir)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.matrixInverse)}static semicylinder(t,s,e,i,r){return new CylinderSurface$$1(new EllipseCurve$$1(ts3dutils.V3.O,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0)),ts3dutils.V3.Z,s,e,i,r)}static unitISLineTs(t,s){const{x:e,y:i}=t,{x:r,y:n}=s,o=Math.pow(r,2)+Math.pow(n,2),a=2*(e*r+i*n),u=Math.pow(e,2)+Math.pow(i,2)-1;return ts3dutils.pqFormula(a/o,u/o).filter(t=>EllipseCurve$$1.XYLCValid(new ts3dutils.V3(e+r*t,i+n*t,0)))}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(t).xy()).unit()}loopContainsPoint(t,s){if(ts3dutils.assertVectors(s),!this.containsPoint(s))return OUTSIDE$$1;const e=new L3$$1(s,this.dir.unit()),i=this.dir.cross(this.normalP(s));return Surface$$1.loopContainsPointGeneral(t,s,e,i)}isTsForLine(t){ts3dutils.assertInst(L3$$1,t);const s=this.matrixInverse.transformVector(t.dir1);if(s.isParallelTo(ts3dutils.V3.Z))return[];const e=this.matrixInverse.transformPoint(t.anchor);return ts3dutils.assert(!CylinderSurface$$1.unitISLineTs(e,s).length||!isNaN(CylinderSurface$$1.unitISLineTs(e,s)[0]),"sad "+s),CylinderSurface$$1.unitISLineTs(e,s)}isCoplanarTo(t){return this==t||ts3dutils.hasConstructor(t,CylinderSurface$$1)&&this.dir.isParallelTo(t.dir)&&this.containsEllipse(t.baseCurve,!1)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsEllipse(t,s=!0){const e=t.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(e)}containsCurve(t){return t instanceof L3$$1?this.containsLine(t):t instanceof EllipseCurve$$1?this.containsEllipse(t):!(t instanceof BezierCurve$$1)&&super.containsCurve(t)}implicitFunction(){return t=>{return(this.matrixInverse.transformPoint(t).lengthXY()-1)*this.normalDir}}didp(t){const s=this.matrixInverse.transformPoint(t),e=s.lengthXY(),i=new ts3dutils.V3(s.x/e,s.y/e,0);return this.pLCNormalWCMatrix.transformVector(i)}containsPoint(t){const s=this.matrixInverse.transformPoint(t);return this.baseCurve.isValidT(EllipseCurve$$1.XYLCPointT(s,this.uMin,this.uMax))}uvP(t){ts3dutils.assert(1==arguments.length);const s=this.matrixInverse.transformPoint(t),e=EllipseCurve$$1.XYLCPointT(s,this.vMin,this.vMax);return new ts3dutils.V3(e,s.z,0)}isCurvesWithSurface(t){if(t instanceof ProjectedCurveSurface$$1&&t.dir.isParallelTo(this.dir)){const s=t.baseCurve.transform(ts3dutils.M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithCurve(s).map(s=>{const e=sign(this.normalP(s.p).cross(t.normalP(s.p)).dot(this.dir))||1;return new L3$$1(s.p,this.dir.times(e))})}if(t instanceof CylinderSurface$$1&&ts3dutils.eq0(this.getCenterLine().distanceToLine(t.getCenterLine())))throw new Error;return super.isCurvesWithSurface(t)}getCenterLine(){return new L3$$1(this.baseCurve.center,this.dir)}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){let t=this.baseCurve.f1.cross(this.dir);return t=t.times(-sign(t.dot(this.baseCurve.f2))),P3$$1.normalOnAnchor(t,this.baseCurve.center)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}}CylinderSurface$$1.UNIT=new CylinderSurface$$1(EllipseCurve$$1.UNIT,ts3dutils.V3.Z,void 0,void 0,0,1),CylinderSurface$$1.prototype.uStep=ts3dutils.TAU/32,CylinderSurface$$1.prototype.vStep=256;class EllipsoidSurface$$1 extends ParametricSurface$$1{constructor(t,s,e,i,r=0,n=PI,o=-PI/2,a=PI/2){super(r,n,o,a),this.center=t,this.f1=s,this.f2=e,this.f3=i,ts3dutils.assert(0<=r&&r<=PI),ts3dutils.assert(0<=n&&n<=PI),ts3dutils.assert(-PI/2<=o&&o<=PI/2),ts3dutils.assert(-PI/2<=a&&a<=PI/2),ts3dutils.assertVectors(t,s,e,i),this.matrix=ts3dutils.M4.forSys(s,e,i,t),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.matrixInverse)}static unitArea(t){return t.map(t=>{if(t.curve instanceof PICurve$$1){const s=t.curve.calcSegmentPoints(t.aT,t.bT,t.a,t.b,t.aT>t.bT,!0);let e=0;for(let t=0;t<s.length-1;t++){const i=s[t],r=s[t+1];e+=(abs(i.angleXY())+abs(r.angleXY()))/2*(r.z-i.z)}return e}if(t.curve instanceof EllipseCurve$$1){const s=s=>{const e=t.curve.at(s),i=t.curve.tangentAt(s);return abs(e.angleXY())*i.z};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}throw new Error}).sum()}static unitISTsWithLine(t,s){const e=s.dot(s),i=2*t.dot(s),r=t.dot(t)-1;return ts3dutils.pqFormula(i/e,r/e).filter(e=>ts3dutils.le(0,t.y+e*s.y))}static unitISCurvesWithPlane(t){const s=Math.abs(t.w);if(ts3dutils.lt(s,1)){const e=Math.sqrt(1-Math.pow(s,2)),i=t.normal1.y*t.w,r=abs(s*e);if(ts3dutils.le(i,-r)&&!ts3dutils.eq0(s))return[];if(ts3dutils.le(i,0)&&!t.normal1.isParallelTo(ts3dutils.V3.Y)){const s=t.normal1.isParallelTo(ts3dutils.V3.Y)?ts3dutils.V3.Z:t.normal1.cross(ts3dutils.V3.Y).toLength(e),r=s.cross(t.normal1),n=-i/r.y,o=max(0,Math.asin(n));return[new EllipseCurve$$1(t.anchor,s,r,o,PI-o)]}{const s=(t.normal1.isParallelTo(ts3dutils.V3.Y)?ts3dutils.V3.X:t.normal1.cross(ts3dutils.V3.Y)).toLength(e),r=s.cross(t.normal1),n=ts3dutils.eq0(r.y)?-1:-i/r.y,o=Math.acos(max(-1,n-ts3dutils.NLA_PRECISION));return[new EllipseCurve$$1(t.anchor,r.negated(),s,PI-o,PI),new EllipseCurve$$1(t.anchor,r,s.negated(),0,o)]}}return[]}static unitISCurvesWithEllipsoidSurface(t){if(t.isSphere()){const s=t.f1.length(),e=t.center.length();if(ts3dutils.le(1,e-s)||ts3dutils.le(e+s,1)||ts3dutils.le(e-s,-1))return[];{const i=2*function(t,s,e){const i=(t+s+e)/2;return sqrt(i*(i-t)*(i-s)*(i-e))}(1,s,e)/e,r=sign(1+Math.pow(e,2)-Math.pow(s,2))*sqrt(1-Math.pow(i,2)),n=new P3$$1(t.center.unit(),r);return EllipsoidSurface$$1.unitISCurvesWithPlane(n.flipped())}}throw new Error}static unitISCurvesWithCylinderSurface(t){if(new L3$$1(t.baseCurve.center,t.dir).containsPoint(ts3dutils.V3.O)){const s=t.baseCurve.transform(ts3dutils.M4.project(new P3$$1(t.dir,0))),e=s.f1.length(),i=s.f2.length();if(ts3dutils.lt(1,min(e,i)))return[];if(s.isCircular()){const i=Math.sqrt(1-Math.pow(min(1,e),2)),r=(t.dir.y<0?t.dir.negated():t.dir).times(i);return[new EllipseCurve$$1(r,s.f1,s.f2)]}}throw new Error}static sphere(t,s=ts3dutils.V3.O){return ts3dutils.assertNumbers(t),new EllipsoidSurface$$1(s,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,t,0),new ts3dutils.V3(0,0,t))}static forABC(t,s,e,i=ts3dutils.V3.O){return new EllipsoidSurface$$1(i,new ts3dutils.V3(t,0,0),new ts3dutils.V3(0,s,0),new ts3dutils.V3(0,0,e))}static calculateAreaSpheroid(t,s,e,i){ts3dutils.assertf(()=>t.isPerpendicularTo(s)),ts3dutils.assertf(()=>s.isPerpendicularTo(e)),ts3dutils.assertf(()=>e.isPerpendicularTo(t));const r=ts3dutils.M4.forSys(t,s,e).inversed(),n=t.length(),o=e.unit();return i.map(t=>{if(t.curve instanceof EllipseCurve$$1){const s=s=>{const e=t.curve.at(s),i=t.tangentAt(s),a=r.transformPoint(e);return a.angleXY()*n*Math.sqrt(1+Math.pow(a.z,2))*Math.sqrt(1+Math.pow(o.dot(i),2))};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}throw new Error}).sum()}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3,this.uMin,this.uMax,this.vMin,this.vMax]}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}edgeLoopCCW(t){return EllipsoidSurface$$1.unitArea(t.map(t=>t.transform(this.matrixInverse)))>0}like(t){return!!this.isCoplanarTo(t)&&this.matrix.determinant3()*t.matrix.determinant3()>0}rootPoints(){}toMesh(){return ParametricSurface$$1.prototype.toMesh.call(this)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}dpdu(){return(t,s)=>this.matrix.transformVector(new ts3dutils.V3(cos(s)*-sin(t),cos(s)*cos(t),0))}dpdv(){return(t,s)=>this.matrix.transformVector(new ts3dutils.V3(-sin(s)*cos(t),-sin(s)*sin(t),cos(s)))}isCurvesWithPCS(t){let s=ParametricSurface$$1.isCurvesParametricImplicitSurface(t,this,.1,.1/t.dir.length(),.05);return s=this.clipCurves(s)}isCurvesWithPCSSmart(t){const s=t.transform(this.matrixInverse),e=s.baseCurve.project(new P3$$1(s.dir,0)),i=e.isTsWithSurface(EllipsoidSurface$$1.UNIT),r=ts3dutils.getIntervals(i,e.tMin,e.tMax).filter(([t,s])=>e.at((t+s)/2).length()<1),n=[0,1].map(t=>i=>{const r=ts3dutils.snap(e.at(i).squared(),1),n=sqrt(1-r);return ts3dutils.eq0(n)?e.at(i):e.at(i).plus(s.dir.times(sign(t-.5)*n))}),o=[0,1].map(t=>i=>{const r=ts3dutils.snap(e.at(i).squared(),1),n=e.at(i).times(-1/sqrt(1-r)).dot(e.tangentAt(i));return e.tangentAt(i).plus(s.dir.times(sign(t-.5)*n))}),a=[];for(const[s,e]of r)for(const i of[0,1]){const r=t=>n[i](t).y,u=t=>o[i](t).y;ts3dutils.checkDerivate(r,u,s+.1,e-.1);const l=ts3dutils.getRoots(r,s+ts3dutils.NLA_PRECISION,e-ts3dutils.NLA_PRECISION,1/2048,u),c=ts3dutils.getIntervals(l,s,e).filter(([t,s])=>r((t+s)/2)>0);for(const[s,e]of c){let r=n[i](s),o=n[i](e);0===i&&([r,o]=[o,r]),ts3dutils.assert(EllipsoidSurface$$1.UNIT.containsPoint(r)),ts3dutils.assert(EllipsoidSurface$$1.UNIT.containsPoint(o)),a.push(PICurve$$1.forStartEnd(t,this,this.matrix.transformPoint(o),this.matrix.transformPoint(r),void 0))}}return t.clipCurves(a)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface$$1)return this.isCurvesWithCylinderSurface(t);if(t instanceof EllipsoidSurface$$1){const s=t.transform(this.matrixInverse),e=EllipsoidSurface$$1.unitISCurvesWithEllipsoidSurface(s).map(t=>t.transform(this.matrix));return t.clipCurves(e)}if(t instanceof ProjectedCurveSurface$$1)return this.isCurvesWithPCS(t);if(t instanceof ParametricSurface$$1){let s=ParametricSurface$$1.isCurvesParametricImplicitSurface(t,this,.1,.1,.05);return s=this.clipCurves(s),s=t.clipCurves(s)}throw new Error}isCurvesWithPlane(t){const s=t.transform(this.matrixInverse);return EllipsoidSurface$$1.unitISCurvesWithPlane(s).map(t=>t.transform(this.matrix))}isCurvesWithCylinderSurface(t){if(L3$$1.containsPoint(t.baseCurve.center,t.dir,this.center)){ts3dutils.assert(this.isSphere());const s=t.baseCurve.transform(ts3dutils.M4.project(t.baseCurve.getPlane(),t.dir));if(s.isCircular()){const t=this.f1.length(),e=s.f1.length();ts3dutils.eq(t,e),ts3dutils.assert(!1)}}return this.isCurvesWithPCS(t)}isTsForLine(t){ts3dutils.assertInst(L3$$1,t);const s=this.matrixInverse.transformPoint(t.anchor),e=this.matrixInverse.transformVector(t.dir1);return EllipsoidSurface$$1.unitISTsWithLine(s,e)}isCoplanarTo(t){if(this===t)return!0;if(!ts3dutils.hasConstructor(t,EllipsoidSurface$$1))return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&ts3dutils.eq(this.f1.length(),this.f2.length());const s=this.matrixInverse.times(t.matrix);return s.like3x3()&&s.isOrthogonal()}containsEllipse(t){const s=t.transform(this.matrixInverse),e=s.center.length(),i=Math.sqrt(1-Math.pow(e,2));return ts3dutils.lt(e,1)&&s.isCircular()&&s.f1.hasLength(i)}containsCurve(t){return t instanceof EllipseCurve$$1?this.containsEllipse(t):super.containsCurve(t)}transform(t){return ts3dutils.assert(t.isNoProj(),()=>t.sce),new EllipsoidSurface$$1(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3).times(t.isMirroring()?-1:1))}transform4(t){console.log("transform4");const s=t.times(this.matrix);console.log(s.toString());const e=ts3dutils.V(s.m[12],s.m[13],s.m[14]),i=this.pLCNormalWCMatrix.inversed().transformPoint(e),r=i.angleXY(),n=Math.asin(ts3dutils.clamp(i.z,-1,1)),o=s.transformPoint(e.unit()),a=s.transformPoint(e.unit().negated()),u=ts3dutils.V3.lerp(o,a,.5);return console.log(e.sce,r,n,o,a,"newCenter",u.sce),new EllipsoidSurface$$1(u,t.transformVector2(this.f1,this.center),t.transformVector2(this.f2,this.center),t.transformVector2(this.f3,this.center).times(t.isMirroring()?-1:1))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new EllipsoidSurface$$1(this.center,this.f1,this.f2,this.f3.negated(),this.uMin,this.uMax,-this.vMax,-this.vMin)}normalUVFunc(){return(t,s)=>{const{f1:e,f2:i,f3:r}=this;return i.cross(r).times(Math.cos(s)*Math.cos(t)).plus(r.cross(e).times(Math.cos(s)*Math.sin(t))).plus(e.cross(i).times(Math.sin(s))).unit()}}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(t)).unit()}normalUV(t,s){return this.pLCNormalWCMatrix.transformVector(ts3dutils.V3.sphere(t,s)).unit()}uvPFunc(){return t=>{const s=this.matrixInverse.transformPoint(t),e=abs(s.angleXY()),i=Math.asin(ts3dutils.clamp(s.z,-1,1));return ts3dutils.assert(isFinite(e)),ts3dutils.assert(isFinite(i)),new ts3dutils.V3(e,i,0)}}pUVFunc(){return(t,s)=>this.matrix.transformPoint(ts3dutils.V3.sphere(t,s))}isSphere(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&ts3dutils.eq(this.f2.length(),this.f3.length())&&ts3dutils.eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return ts3dutils.eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}mainAxes(){const{f1:t,f2:s,f3:e}=this;if(ts3dutils.eq0(t.dot(s))&&ts3dutils.eq0(s.dot(e))&&ts3dutils.eq0(e.dot(t)))return this;const{U:i,SIGMA:r}=this.matrix.svd3();ts3dutils.assert(r.isDiagonal()),ts3dutils.assert(i.isOrthogonal());const n=i.times(r),[o,a,u]=ts3dutils.arrayFromFunction(3,t=>new ts3dutils.V3(n.m[t],n.m[t+4],n.m[t+8]));return new EllipsoidSurface$$1(this.center,o,a,u)}containsPoint(t){return ts3dutils.eq0(this.implicitFunction()(t))}boundsFunction(){return(t,s)=>ts3dutils.between(t,0,PI)&&ts3dutils.between(s,-PI,PI)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,s){if(!this.containsPoint(s))return exports.PointVsFace.OUTSIDE;ts3dutils.assertVectors(s),ts3dutils.assert(Edge$$1.isLoop(t));const e=this.matrixInverse.transformPoint(s).xy(),i=new EllipseCurve$$1(this.center,this.f3,e.likeO()?this.f2:this.matrix.transformVector(e.unit()));return P3$$1.normalOnAnchor(this.f2.unit(),this.center).containsPoint(s)?t.some(t=>t.curve.containsPoint(s)&&ts3dutils.fuzzyBetween(t.curve.pointT(s),t.minT,t.maxT))?exports.PointVsFace.ON_EDGE:exports.PointVsFace.OUTSIDE:Surface$$1.loopContainsPointEllipse(t,s,i)}surfaceAreaApprox(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),r=1.6075;return 4*PI*Math.pow((Math.pow(s*e,r)+Math.pow(e*i,r)+Math.pow(i*s,r))/3,1/r)}surfaceArea(){const t=this.mainAxes(),s=t.f1.length(),e=t.f2.length(),i=t.f3.length(),[r,n,o]=[s,e,i].sort(ts3dutils.MINUS);function a(t,s){if(s<t){const e=1-Math.pow(s,2)/Math.pow(t,2),i=Math.sqrt(e);return 2*PI*Math.pow(t,2)*(1+(1-e)/Math.sqrt(i)*Math.atanh(i))}{const e=Math.sqrt(1-Math.pow(t,2)/Math.pow(s,2));return 2*PI*Math.pow(t,2)*(1+s/t/e*Math.asin(e))}}if(ts3dutils.eq(o,n))return a(o,r);if(ts3dutils.eq(n,r))return a(n,o);if(ts3dutils.eq(r,o))return a(r,n);const u=Math.acos(r/o),l=Math.pow(o,2)*(Math.pow(n,2)-Math.pow(r,2))/(Math.pow(n,2)*(Math.pow(o,2)-Math.pow(r,2))),c=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-l*Math.pow(Math.sin(t),2),-.5),0,u),h=ts3dutils.gaussLegendreQuadrature24(t=>Math.pow(1-l*Math.pow(Math.sin(t),2),.5),0,u);return(2*PI*Math.pow(r,2)+2*PI*o*n/Math.sin(u))*(h*Math.pow(Math.sin(u),2)+c*Math.pow(Math.cos(u),2))}getSeamPlane(){const t=P3$$1.forAnchorAndPlaneVectors(this.center,this.f1,this.f3);return t.normal1.dot(this.f2)<0?t:t.flipped()}getExtremePoints(){return getExtremePointsHelper$$1.call(this,new EllipseCurve$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Z,-PI/2,PI/2))}pointFoot(t,s,e){if(console.log(t.sce),void 0===s||void 0===e){let i=this.matrixInverse.transformPoint(t).unit();i.y<0&&(i=i.negated()),({x:s,y:e}=EllipsoidSurface$$1.UNIT.uvP(i))}const i=this.dpdu(),r=this.dpdv(),[n,o]=ts3dutils.newtonIterate(([s,e])=>{const n=this.pUV(s,e);console.log([n,n.plus(i(s,e)),n,n.plus(r(s,e))].map(ts3dutils.toSource).join()+",");const o=this.pUV(s,e).to(t);return[o.dot(i(s,e)),o.dot(r(s,e))]},[s,e],8,void 0,.1);return new ts3dutils.V3(n,o,0)}implicitFunction(){return t=>{return(this.matrixInverse.transformPoint(t).length()-1)*this.normalDir}}didp(t){const s=this.matrixInverse.transformPoint(t);return this.pLCNormalWCMatrix.transformVector(s.unit())}static unitTransform4(t){1!==t.m[15]&&(t=t.divScalar(t.m[15]));const s=new ts3dutils.M4(1,0,0,0,0,1,0,0,0,0,1,0,-t.m[12],-t.m[13],-t.m[14],1),e=new ts3dutils.V3(t.m[12],t.m[13],t.m[14]),i=t.m[15],r=Math.pow(i,2)-e.squared();if(ts3dutils.lt(r,0))throw new Error("vanishing plane intersects unit sphere");const n=e.div(-r),o=(e.times(i*e.length()/(e.squared()*-r)),i/-r),a=1/sqrt(r),u=ts3dutils.M4.forSys(e.unit(),e.getPerpendicular().unit());return ts3dutils.M4.product(t,s,ts3dutils.M4.translate(n),u,ts3dutils.M4.scale(o,a,a),u.transposed())}}EllipsoidSurface$$1.UNIT=new EllipsoidSurface$$1(ts3dutils.V3.O,ts3dutils.V3.X,ts3dutils.V3.Y,ts3dutils.V3.Z),EllipsoidSurface$$1.prototype.uStep=PI/32,EllipsoidSurface$$1.prototype.vStep=PI/32;class PlaneSurface$$1 extends ParametricSurface$$1{constructor(t,s=t.normal1.getPerpendicular().unit(),e=t.normal1.cross(s).unit(),i=-100,r=100,n=-100,o=100){super(i,r,n,o),this.plane=t,this.right=s,this.up=e,ts3dutils.assertInst(P3$$1,t),ts3dutils.assert(this.right.cross(this.up).like(this.plane.normal1)),this.matrix=ts3dutils.M4.forSys(s,e,t.normal1,t.anchor)}toSource(t=(t=>t)){return ts3dutils.callsce.call(void 0,"new PlaneSurface",...this.getConstructorParameters())}static throughPoints(t,s,e){return new PlaneSurface$$1(P3$$1.throughPoints(t,s,e))}static forAnchorAndPlaneVectors(t,s,e,i,r,n,o){return new PlaneSurface$$1(P3$$1.forAnchorAndPlaneVectors(t,s,e),s,e,i,r,n,o)}isCoplanarTo(t){return ts3dutils.hasConstructor(t,PlaneSurface$$1)&&this.plane.isCoplanarToPlane(t.plane)}isTsForLine(t){return t.isTsWithPlane(this.plane)}like(t){return ts3dutils.hasConstructor(t,PlaneSurface$$1)&&this.plane.like(t.plane)}pUV(t,s){return this.matrix.transformPoint(new ts3dutils.V3(t,s,0))}implicitFunction(){return t=>this.plane.distanceToPointSigned(t)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){const s=this.plane.intersectionWithPlane(t);return s?[s]:[]}edgeLoopCCW(t){return ts3dutils.assert(Edge$$1.isLoop(t),"isLoop"),ts3dutils.isCCW(t.flatMap(t=>t.points()),this.plane.normal1)}loopContainsPoint(t,s){const e=this.right.plus(this.up.times(.123)).unit(),i=new L3$$1(s,e),r=e.cross(this.plane.normal1);return Surface$$1.loopContainsPointGeneral(t,s,i,r)}uvPFunc(){const t=this.matrix.inversed();return function(s){return t.transformPoint(s)}}pointFoot(t){return this.uvP(t)}normalP(t){return this.plane.normal1}containsPoint(t){return this.plane.containsPoint(t)}containsCurve(t){return t instanceof ImplicitCurve$$1?super.containsCurve(t):this.plane.containsCurve(t)}transform(t){return new PlaneSurface$$1(this.plane.transform(t))}transform4(t){return new PlaneSurface$$1(this.plane.transform(t))}flipped(){return new PlaneSurface$$1(this.plane.flipped(),this.right,this.up.negated())}getConstructorParameters(){return[this.plane,this.right,this.up,this.uMin,this.uMax,this.vMin,this.vMax]}dpdu(){return()=>this.right}dpdv(){return()=>this.up}didp(t){return this.plane.normal1}normalUV(){return this.plane.normal1}}PlaneSurface$$1.prototype.uStep=1e6,PlaneSurface$$1.prototype.vStep=1e6;class PointProjectedSurface$$1 extends ParametricSurface$$1{constructor(t,s,e,i=1,r=t.tMin,n=t.tMax,o=0,a=16){super(r,n,o,a),this.curve=t,this.apex=s,this.curvePlane=e,this.normalDir=i,ts3dutils.assertInst(Curve$$1,t),ts3dutils.assert(!(t instanceof L3$$1),"use PlaneSurface instead"),ts3dutils.assert(!(t instanceof EllipseCurve$$1),"use ConicSurface instead"),ts3dutils.assert(!(t instanceof ImplicitCurve$$1),"this just seems like a terrible idea"),ts3dutils.assert(new PlaneSurface$$1(e).containsCurve(t)),ts3dutils.assertVectors(s),ts3dutils.assert(0<=o),this.planeProjectionMatrix=ts3dutils.M4.projectPlanePoint(s,e),this.uStep=t.tIncrement}pointFoot(t,s,e){void 0!==s&&void 0!==e||(void 0===s&&(s=t.like(this.apex)?0:this.curve.closestTToPoint(this.planeProjectionMatrix.transformPoint(t))*this.normalDir),void 0===e&&(e=ts3dutils.V3.inverseLerp(this.apex,this.curve.at(s),t)));const{0:i,1:r}=ts3dutils.newtonIterate(([s,e])=>{const i=this.pST(s,e).to(t);return[this.dpds()(s,e).dot(i),this.dpdt()(s).dot(i)]},[s,e]);return new ts3dutils.V3(i,r,0)}getConstructorParameters(){return[this.curve,this.apex,this.curvePlane,this.normalDir,this.sMin,this.sMax,this.tMin,this.tMax]}static unitISLineTs(t,s){const{x:e,y:i,z:r}=t,{x:n,y:o,z:a}=s,u=n*n+o*o-a*a,l=2*(e*n+i*o-r*a),c=e*e+i*i-r*r;return ts3dutils.pqFormula(l/u,c/u).filter(t=>0<r+t*a)}equals(t){return this==t||ts3dutils.hasConstructor(t,PointProjectedSurface$$1)&&this.curve.equals(t.curve)&&this.apex.equals(this.apex)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}loopContainsPoint(t,s){ts3dutils.assertVectors(s);const e=this.apex.like(s)?new L3$$1(s,this.apex.to(this.curve.at(this.curve.tMin)).unit()):L3$$1.throughPoints(s,this.apex),i=e.dir1.cross(this.curvePlane.normal1);return Surface$$1.loopContainsPointGeneral(t,s,e,i)}isTsForLine(t){const s=this.planeProjectionMatrix.transformPoint(t.anchor),e=this.planeProjectionMatrix.transformPoint(t.anchor.plus(t.dir1));return s.like(e)?[]:this.curve.isInfosWithLine(s,s.to(e),void 0,void 0,t.tMin,t.tMax).map(t=>t.tOther)}isCoplanarTo(t){return this===t||!!(t instanceof PointProjectedSurface$$1&&this.apex.like(t.apex))&&this.containsCurve(t.curve)}containsLine(t){if(this.curvePlane.isParallelToLine(t))return!1;if(!t.containsPoint(this.apex))return!1;const s=this.curvePlane.intersectionWithLine(t);return this.curve.containsPoint(s)}containsCurve(t){if(t instanceof L3$$1)return this.containsLine(t);if(t instanceof ImplicitCurve$$1)return super.containsCurve(t);{const s=t.transform(this.planeProjectionMatrix);return this.curve.isColinearTo(s)}}transform(t){return new PointProjectedSurface$$1(this.curve.transform(t),t.transformPoint(this.apex),this.curvePlane.transform(t),(t.isMirroring()?-1:1)*this.normalDir,this.sMin,this.sMax,this.tMin,this.tMax)}flipped(){return new PointProjectedSurface$$1(this.curve,this.apex,this.curvePlane,-this.normalDir,-this.sMax,-this.sMin,this.tMin,this.tMax)}normalSTFunc(){const t=this.dpdt();return(s,e)=>this.curve.tangentAt(s*this.normalDir).times(this.normalDir).cross(t(s)).unit()}pSTFunc(){return(t,s)=>this.apex.lerp(this.curve.at(t*this.normalDir),s)}dpds(){return(t,s)=>this.curve.tangentAt(t*this.normalDir).times(s*this.normalDir)}dpdt(){return t=>this.apex.to(this.curve.at(t*this.normalDir))}containsPoint(t){return this.apex.like(t)||this.curve.containsPoint(this.planeProjectionMatrix.transformPoint(t))}stP(t){const s=t.like(this.apex)?0:this.curve.pointT(this.planeProjectionMatrix.transformPoint(t)),e=ts3dutils.V3.inverseLerp(this.apex,this.curve.at(s),t);return new ts3dutils.V3(s*this.normalDir,e,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):ImplicitSurface$$1.is(t)?ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/this.curvePlane.distanceToPoint(this.apex),.02):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){return t.containsPoint(this.apex)?t.isParallelToPlane(this.curvePlane)?[]:this.curve.isTsWithPlane(t).map(t=>L3$$1.throughPoints(this.apex,this.curve.at(t))):[this.curve.transform(ts3dutils.M4.projectPlanePoint(this.apex,t))]}}PointProjectedSurface$$1.prototype.vStep=256;class NURBSSurface$$1 extends ParametricSurface$$1{constructor(t,s,e,i,r,n=s[i],o=s[s.length-i-1],a=e[r],u=e[e.length-r-1]){super(n,o,a,u),this.points=t,this.knotsU=s,this.knotsV=e,this.degreeU=i,this.degreeV=r;const l=s.length-1-i,c=e.length-1-r;ts3dutils.assert(l*c==t.length),ts3dutils.assert(i<=r,"degreeU <= degreeV"),ts3dutils.assert(-1==s.firstUnsorted(ts3dutils.MINUS),"knot values must be in ascending order"),ts3dutils.assert(-1==e.firstUnsorted(ts3dutils.MINUS),"knot values must be in ascending order")}getConstructorParameters(){return[this.points,this.knotsU,this.knotsV,this.degreeU,this.degreeV,this.uMin,this.uMax,this.vMin,this.vMax]}transform(t){return this.transform4(t)}transform4(t){return new NURBSSurface$$1(this.points.map(s=>t.timesVector(s)),this.knotsU,this.knotsV,this.degreeU,this.degreeV,this.uMin,this.uMax,this.vMin,this.vMax)}pUV(t,s){return this.isoparametricU(t).at(s)}dpdu(){return(t,s)=>this.isoparametricV(s).tangentAt(t)}dpdv(){return(t,s)=>this.isoparametricU(t).tangentAt(s)}normalUV(t,s){const e=this.dpdu()(t,s).cross(this.dpdv()(t,s));return e.likeO()?ts3dutils.V3.X:e.unit()}isoparametricU(t){const s=this.knotsU.length-1-this.degreeU,e=this.knotsV.length-1-this.degreeV;return new NURBS$$1(ts3dutils.arrayFromFunction(e,e=>deBoor(this.points.slice(e*s,(e+1)*s),this.degreeU,this.knotsU,t)),this.degreeV,this.knotsV,this.vMin,this.vMax)}isoparametricV(t){const s=this.knotsU.length-1-this.degreeU;return new NURBS$$1(ts3dutils.arrayFromFunction(s,e=>deBoor(this.points.sliceStep(e,this.points.length,s,1),this.degreeV,this.knotsV,t)),this.degreeU,this.knotsU,this.uMin,this.uMax)}debugInfo(){const t=this.knotsU.length-1-this.degreeU,s=this.knotsV.length-1-this.degreeV,e=[];for(let i=0;i<t;i++)for(let r=0;r<s;r++){const n=r*t+i;if(i<t-1){const s=r*t+i+1;e.push(this.points[n].p3(),this.points[s].p3())}if(r<s-1){const s=(r+1)*t+i;e.push(this.points[n].p3(),this.points[s].p3())}}return{points:this.points.map(t=>t.p3()),lines:e}}flipped(){const t=this.knotsU.length-1-this.degreeU;return new NURBSSurface$$1(ts3dutils.arrayFromFunction(this.points.length,s=>{const e=s%t;return this.points[s-e+(t-e-1)]}),this.knotsU.map(t=>-t).reverse(),this.knotsV,this.degreeU,this.degreeV,-this.uMax,-this.uMin,this.vMin,this.vMax)}}function getInterval(t,s,e){for(let i=t;i<s.length-1-t;i++)if(e>=s[i]&&e<=s[i+1])return i;throw new Error(e+" "+s)}function deBoor(t,s,e,i){const r=getInterval(s,e,i),n=ts3dutils.Vector.pack(t,new Float64Array(4*t.length));for(let t=1;t<=s;t++)for(let o=r;o>r-s-1+t;o--){const r=(i-e[o])/(e[o+s+1-t]-e[o]);for(let t=0;t<4;t++)n[4*o+t]=(1-r)*n[4*(o-1)+t]+r*n[4*o+t]}return new ts3dutils.Vector(n.slice(4*r,4*r+4))}NURBSSurface$$1.prototype.uStep=1/8,NURBSSurface$$1.prototype.vStep=1/8;const ZDirVolumeVisitor$$1={[ConicSurface$$1.name](t){console.log(this);const s=this.dpdu(),e=this.dpdv(),i=t.map(t=>{const i=t.curve;if(i instanceof EllipseCurve$$1||i instanceof HyperbolaCurve$$1||i instanceof ParabolaCurve$$1){const r=t=>{const r=i.at(t),n=i.tangentAt(t),o=this.uvP(r),a=-ts3dutils.M4.forSys(s(o.x,o.y),e(o.x)).inversed().transformVector(n).x,u=Math.pow(o.y,3)/3*(this.pUV(o.x,1).z-this.center.z)+Math.pow(o.y,2)/2*this.center.z;return s(o.x,u).cross(e(o.x)).z*a};return ts3dutils.glqInSteps(r,t.aT,t.bT,1)}if(i instanceof L3$$1)return 0;throw new Error}).sum(),r=t.map(t=>{const i=t.curve;if(i instanceof EllipseCurve$$1||i instanceof HyperbolaCurve$$1||i instanceof ParabolaCurve$$1){return glqV3$$1(t=>{const r=i.at(t),n=i.tangentAt(t),o=this.uvP(r),a=this.pUV(o.x,1).minus(this.center),u=ts3dutils.V3.add(a.times(.25*Math.pow(o.y,4)*a.z+1/3*Math.pow(o.y,3)*this.center.z),this.center.times(1/3*Math.pow(o.y,3)*a.z+.5*Math.pow(o.y,2)*this.center.z)).times(s(o.x,1).cross(e(o.x)).z),l=-ts3dutils.M4.forSys(s(o.x,o.y),e(o.x)).inversed().transformVector(n).x;return u.times(l)},t.aT,t.bT)}if(i instanceof L3$$1)return ts3dutils.V3.O;throw new Error});return{volume:i,centroid:ts3dutils.V3.add(...r).schur(new ts3dutils.V3(1,1,.5)).div(i)}},[PlaneSurface$$1.name](t){const s=this.right,e=this.up,i=this.plane.anchor;return ts3dutils.assert(s.hasLength(1)),ts3dutils.assert(e.hasLength(1)),ts3dutils.assert(s.isPerpendicularTo(e)),mergeVolumeAndCentroidZX2Parts(t.map(t=>{const r=t.curve;if(r instanceof L3$$1){function n(t,s,e){const i=s.minus(t),r=e.minus(t),n=i.cross(r);return[ts3dutils.V3.add(t,s,e).div(3).z*n.z/2,ts3dutils.V3.add(t.times(2*t.z+s.z+e.z),s.times(t.z+2*s.z+e.z),e.times(t.z+s.z+2*e.z)).times(n.z)]}const e=t.a,i=t.b,r=e.dot(s),o=i.dot(s),a=this.pUV(r,0),u=this.pUV(o,0),[l,c]=n(e,i,a),[h,d]=n(u,a,i);return[l+h,c.plus(d).div(24)]}if(r instanceof ImplicitCurve$$1)throw new Error;{const n=t=>{const n=r.at(t),o=n.dot(s),a=n.dot(e),u=a*i.z+o*a*s.z+.5*Math.pow(a,2)*e.z,l=-r.tangentAt(t).dot(s);return[u*l,...ts3dutils.V3.add(i.times(u),s.times(i.z*o*a+s.z*Math.pow(o,2)*a+.5*o*Math.pow(a,2)*e.z),e.times(.5*i.z*Math.pow(a,2)+.5*s.z*o*Math.pow(a,2)+1/3*Math.pow(a,3)*e.z)).times(l)]},[o,a,u,l]=glqArray$$1(n,t.aT,t.bT,4);return[o*this.plane.normal1.z,new ts3dutils.V3(a,u,l).times(this.plane.normal1.z)]}}))},[ParametricSurface$$1.name](t){const s=this.dpdu(),e=this.dpdv();return mergeVolumeAndCentroidZX2Parts(t.map(t=>{const i=t.curve;if(i instanceof ImplicitCurve$$1)throw new Error;{const r=t=>{const r=i.at(t),n=i.tangentAt(t),o=this.uvP(r),a=ts3dutils.glqInSteps(t=>{const i=this.pUV(o.x,t),r=s(o.x,t).cross(e(o.x,t));return i.z*r.z},0,o.y,1),u=-ts3dutils.M4.forSys(s(o.x,o.y),e(o.x,o.y)).inversed().transformVector(n).x;return[a*u,...glqV3$$1(t=>{const i=this.pUV(o.x,t),r=s(o.x,t).cross(e(o.x,t));return i.times(i.z*r.z)},0,o.y).times(u).toArray()]},[n,o,a,u]=glqArray$$1(r,t.aT,t.bT,4);return[n,new ts3dutils.V3(o,a,u)]}}))},[ProjectedCurveSurface$$1.name](t){if(ts3dutils.V3.Z.cross(this.dir).likeO())return{volume:0,centroid:ts3dutils.V3.O};const s=this.dir.toLength(Math.sign(this.dir.z)||1),e=ts3dutils.V3.Z.cross(s).unit(),i=s.rejectedFrom(ts3dutils.V3.Z).unit();return mergeVolumeAndCentroidZX2Parts(t.map(t=>{if(t.curve instanceof L3$$1)return[0,ts3dutils.V3.O];if(t.curve instanceof ImplicitCurve$$1)return[0,ts3dutils.V3.O];{const r=r=>{const n=t.curve.at(r),o=t.curve.tangentAt(r),a=n.rejectedFrom1(s),u=n.z*a.to(n).dot(i)/2+a.z*a.to(n).dot(i)/2,l=ts3dutils.V3.add(n.xy(),a,n).times(n.z*a.to(n).dot(i)/2/3),c=ts3dutils.V3.add(n.xy(),a,a.xy()).times(a.z*a.to(n).dot(i)/2/3),h=o.dot(e);return[u*h,...l.plus(c).times(h).schur(ts3dutils.V(1,1,2))]},[n,o,a,u]=glqArray$$1(r,t.aT,t.bT,4);return[n,new ts3dutils.V3(o,a,u)]}}))},[RotatedCurveSurface$$1.name](t){const s=this.dpdu(),e=this.dpdv(),i=t.map(t=>{const i=t.curve;return ts3dutils.gaussLegendreQuadrature24(t=>{const r=i.at(t),n=i.tangentAt(t),o=this.uvP(r),a=this.matrixInverse.transformPoint(r),u=this instanceof RotatedCurveSurface$$1?this.curve.tangentAt(o.y):ts3dutils.V(-a.z,0,a.lengthXY()),l=a.lengthXY(),c=a.z,h=u.x,d=u.z,p=this.matrix.X.z*l,f=this.matrix.Y.z*l,m=this.matrix.Z.z*c+this.matrix.O.z,$=(this.matrix.X.x*this.matrix.Y.y-this.matrix.X.y*this.matrix.Y.x)*l*h,g=(this.matrix.Y.x*this.matrix.X.y-this.matrix.Y.y*this.matrix.X.x)*l*h,v=(this.matrix.X.x*this.matrix.X.y-this.matrix.X.y*this.matrix.X.x)*l*h,P=(this.matrix.Y.x*this.matrix.Y.y-this.matrix.Y.y*this.matrix.Y.x)*l*h,x=(this.matrix.Y.x*this.matrix.Z.y-this.matrix.Y.y*this.matrix.Z.x)*l*d,C=(this.matrix.X.x*this.matrix.Z.y-this.matrix.X.y*this.matrix.Z.x)*l*d,M=ts3dutils.M4.forSys(s(o.x,o.y),e(o.x,o.y)).inversed().transformVector(n).y;return(t=>(6*(m*(-$+g)+p*x-f*C)*t+3*(3*f*$-f*g+p*(v-P)+4*m*C)*cos(t)+3*(3*p*g-p*$-f*(v-P)+4*m*x)*sin(t)+3*(p*C-f*x+m*(v-P))*cos(2*t)+3*(p*x+f*C+m*($+g))*sin(2*t)+(p*(v-P)-f*($+g))*cos(3*t)+(p*($+g)+f*(v-P))*sin(3*t))/12)(o.x)*M},t.aT,t.bT)}).sum(),r=t.map(t=>{return glqV3$$1(i=>{const r=t.curve,n=r.at(i),o=r.tangentAt(i),a=this.uvP(n),u=glqV3$$1(t=>{const i=this.pUV(t,a.y),r=s(t,a.y).cross(e(t,a.y));return i.times(i.z*r.z)},0,a.x),l=ts3dutils.M4.forSys(s(a.x,a.y),e(a.x,a.y)).inversed().transformVector(o).y;return u.times(l)},t.aT,t.bT)});return{volume:i,centroid:ts3dutils.V3.add(...r).schur(new ts3dutils.V3(1,1,.5)).div(i)}}};function glqV3$$1(t,s,e){return ts3dutils.gaussLegendre24Xs.reduce((i,r,n)=>{const o=s+(r+1)/2*(e-s);return i.plus(t(o).times(ts3dutils.gaussLegendre24Weights[n]))},ts3dutils.V3.O).times((e-s)/2)}function glqArray$$1(t,s,e,i=3){const r=new Array(i).fill(0);for(let n=0;n<24;n++){const o=t(s+(ts3dutils.gaussLegendre24Xs[n]+1)/2*(e-s));for(let t=0;t<i;t++)r[t]+=o[t]*ts3dutils.gaussLegendre24Weights[n]}for(let t=0;t<i;t++)r[t]*=(e-s)/2;return r}function mergeVolumeAndCentroidZX2Parts(t){const s=t.reduce((t,[s])=>t+s,0);return{volume:s,centroid:ts3dutils.V3.add(...t.map(([,t])=>t)).schur(new ts3dutils.V3(1,1,.5)).div(s)}}ZDirVolumeVisitor$$1[EllipsoidSurface$$1.name]=ZDirVolumeVisitor$$1[RotatedCurveSurface$$1.name];const CalculateAreaVisitor$$1={[ConicSurface$$1.name](t){const s=this.dpdu(),e=this.dpdv();return t.map(t=>{if(t.curve instanceof EllipseCurve$$1||t.curve instanceof HyperbolaCurve$$1||t.curve instanceof ParabolaCurve$$1){const i=i=>{const r=t.curve.at(i),n=t.tangentAt(i),o=this.uvP(r),a=-ts3dutils.M4.forSys(s(o.x,o.y),e(o.x)).inversed().transformVector(n).x;return s(o.x,Math.pow(o.y,2)/2).cross(e(o.x)).length()*a};return ts3dutils.glqInSteps(i,t.aT,t.bT,1)}if(t.curve instanceof L3$$1)return 0;throw new Error}).sum()*this.normalDir},[PlaneSurface$$1.name](t){let s=0;const e=this.right,i=this.up;for(const n of t){let t;const o=n.curve;if(o instanceof L3$$1)t=(n.a.dot(i)+n.b.dot(i))/2*n.b.to(n.a).dot(e);else if(o instanceof EllipseCurve$$1){const{f1:s,f2:a,center:u}=o,l=i.dot(s),c=i.dot(a),h=i.dot(u),d=e.dot(s),p=e.dot(a);function r(t){return.25*(2*(-c*d+l*p)*t+4*h*d*cos(t)+4*h*p*sin(t)+(l*d-c*p)*cos(2*t)+(c*d+l*p)*sin(2*t))}t=-(r(n.bT)-r(n.aT))}else{if(o instanceof ImplicitCurve$$1)throw new Error("implement for implicitCurve");{const s=i;ts3dutils.assertf(()=>s.hasLength(1));const r=t=>{const s=o.at(t),r=o.tangentAt(t);return e.dot(r)*i.dot(s)};t=ts3dutils.glqInSteps(r,n.aT,n.bT,3)}}s+=t}return ts3dutils.assert(isFinite(s)),s},[RotatedCurveSurface$$1.name](t,s=!0){const e=this.matrix.X,i=this.matrix.Y,r=this.matrix.Z,n=ts3dutils.eq(e.length(),i.length())&&e.isPerpendicularTo(i)&&i.isPerpendicularTo(r)&&r.isPerpendicularTo(e);return t.map((t,s)=>{console.log("edge",s,t.sce);const e=t.curve;if(t.curve instanceof ImplicitCurve$$1)throw new Error;if(n){const s=t=>{const s=e.at(t),i=e.tangentAt(t),r=this.matrixInverse.transformPoint(s),{x:n,y:o}=this.uvP(s);return n*this.matrix.transformVector(r.xy()).length()*this.dpdv()(n,o).unit().dot(i)};return ts3dutils.glqInSteps(s,t.aT,t.bT,1)}{const s=this.dpdu(),i=this.dpdv(),r=t=>{const r=e.at(t),n=e.tangentAt(t),o=this.uvP(r),a=ts3dutils.M4.forSys(s(o.x,o.y),i(o.x,o.y)).inversed().transformVector(n).y;return ts3dutils.glqInSteps(t=>s(t,o.y).cross(i(t,o.y)).length(),0,o.x,1)*a};return ts3dutils.glqInSteps(r,t.aT,t.bT,1)}}).sum()},[ProjectedCurveSurface$$1.name](t){const s=this.dir.unit(),e=t.map(t=>{if(t.curve instanceof L3$$1)return 0;if(t.curve instanceof ImplicitCurve$$1){const{points:e,tangents:i}=t.curve,r=t.minT,n=t.maxT;let o=0;const a=ceil(r+ts3dutils.NLA_PRECISION),u=floor(n-ts3dutils.NLA_PRECISION);for(let t=a;t<=u;t++){const r=e[t],n=i[t],a=this.normalP(r).cross(s).unit().dot(n);o+=r.dot(s)*a}const l=e=>{const i=t.curve.at(e),r=t.curve.tangentAt(e),n=this.normalP(i).cross(s).unit().dot(r);return i.dot(s)*n};return o+=l(r)*(a-r-.5),(o+=l(n)*(n-u-.5))*sign(t.deltaT())}{const e=e=>{const i=t.curve.at(e),r=t.tangentAt(e).rejected1Length(s);return i.dot(s)*r},i=ts3dutils.glqInSteps(e,t.aT,t.bT,1),r=Math.sign(this.normalP(t.a).cross(this.dir).dot(t.curve.tangentAt(t.aT)));return ts3dutils.assert(0!==r),i*r}}).sum();return console.log("totalArea",e),e}};function projectCurve$$1(t,s,e){if(t instanceof L3$$1){const i=s.cross(t.dir1).toLength(e?-1:1);return new PlaneSurface$$1(P3$$1.normalOnAnchor(i,t.anchor))}if(t instanceof EllipseCurve$$1){const i=e?s:s.negated();return new CylinderSurface$$1(t,i.unit(),void 0,void 0)}if(t instanceof BezierCurve$$1||t instanceof XiEtaCurve$$1){const i=s.times(e?1:-1);return new ProjectedCurveSurface$$1(t,i,void 0,void 0,e?0:-1,e?1:0)}throw new Error}function projectPointCurve$$1(t,s=t.tMin,e=t.tMax,i,r){if(t instanceof L3$$1){const r=t.anchor.to(i).rejectedFrom(t.dir1);return PlaneSurface$$1.forAnchorAndPlaneVectors(t.anchor,t.dir1,r.unit(),s,e,0,r.length())}if(t instanceof EllipseCurve$$1){const n=-1*(r?-1:1);return new ConicSurface$$1(i,t.f1.times(n),t.f2,i.to(t.center),s,e,0,1)}throw new Error("projectPointCurve not implemented for "+t.constructor.name)}function rotateCurve$$1(t,s=t.tMin,e=t.tMax,i,r){if(ts3dutils.assertf(()=>new PlaneSurface$$1(P3$$1.ZX).containsCurve(t)),t instanceof L3$$1){if(t.dir1.isParallelTo(ts3dutils.V3.Z)){if(ts3dutils.eq0(t.anchor.x))return;const n=new EllipseCurve$$1(ts3dutils.V3.O,t.anchor.xy(),t.anchor.xy().getPerpendicular(),0,i),o=(t.dir1.z>0?-1:1)*(r?-1:1),[a,u]=[t.at(s).z*o,t.at(e).z*o].sort(ts3dutils.MINUS);return new CylinderSurface$$1(n,ts3dutils.V3.Z.times(o),0,i,a,u)}if(t.at(s).xy().dot(t.dir1)*t.at(e).xy().dot(t.dir1)<0)throw new Error("line cannot cross the Z axis in the [tMin, tMax] interval, as conic surfaces cannot have an hourglass shape.");if(t.dir1.isPerpendicularTo(ts3dutils.V3.Z)){const i=(t.at(ts3dutils.lerp(s,e,.5)).dot(t.dir1)>0?1:-1)*(r?-1:1);return new PlaneSurface$$1(new P3$$1(ts3dutils.V3.Z.times(i),t.anchor.z*i))}{const n=t.at(s),o=t.at(e),a=n.z-n.x*(o.z-n.z)/(o.x-n.x),u=new ts3dutils.V3(0,0,a),l=-(n.x>o.x?-1:1)*(r?-1:1),c=new ConicSurface$$1(u,new ts3dutils.V3(t.dir1.lengthXY(),0,0),new ts3dutils.V3(0,t.dir1.lengthXY(),0),new ts3dutils.V3(0,0,(n.x>o.x?-1:1)*t.dir1.z),0,i,0,1);return l>0?c:c.flipped()}}if(t instanceof EllipseCurve$$1){const i=t.at(s),n=t.at(e),o=t.rightAngled(),a=o.f1.isPerpendicularTo(ts3dutils.V3.Z),u=o.f2.isPerpendicularTo(ts3dutils.V3.Z);if(L3$$1.Z.containsPoint(o.center)&&(a||u)){r=r==i.z>n.z;let t=o.f1.length(),s=o.f2.length();return o.f1.isParallelTo(ts3dutils.V3.Z)&&([t,s]=[s,t]),EllipsoidSurface$$1.forABC(t,(r?-1:1)*t,s,o.center)}return new RotatedCurveSurface$$1(t,ts3dutils.M4.IDENTITY,s,e)}throw new Error}CalculateAreaVisitor$$1[EllipsoidSurface$$1.name]=CalculateAreaVisitor$$1[RotatedCurveSurface$$1.name],function(t){function s(s,e=P3$$1.XY,i=ts3dutils.V3.Z,r="extrude"+getGlobalId$$1(),n,o){s=a(s),ts3dutils.assertf(()=>Edge$$1.isLoop(s));const u=new Map,l=new PlaneSurface$$1(e),c=ts3dutils.M4.translate(i),h=s.map(t=>t.transform(c,"top")),d=s.length,p=o&&o.extrudeBottom(l,s),f=new PlaneFace$$1(l,s,[],r+"Bottom",p),m=h.map(t=>t.flipped()).reverse(),$=new PlaneSurface$$1(e.flipped().translated(i)),g=o&&o.extrudeBottom($,m),v=new PlaneFace$$1($,m,[],r+"Top",g);s.forEach(s=>t.registerVertexName(u,s.name+"A",s.a)),m.forEach(s=>t.registerVertexName(u,s.name+"A",s.a));const P=ts3dutils.arrayFromFunction(d,t=>StraightEdge$$1.throughPoints(s[t].a,h[t].a,r+"Rib"+t)),x=s.map((t,e)=>{const n=r+"Wall"+e,a=(e+1)%d,u=[s[e].flipped(),P[e],h[e],P[a].flipped()],l=projectCurve$$1(t.curve,i,t.reversed),c=o&&o.extrudeWall(e,l,u);return Face$$1.create(l,u,void 0,n,c)});return x.push(f,v),n=n||ts3dutils.callsce("B2T.extrudeEdges",s,e,i,r),new BRep$$1(x,e.normal1.dot(i)>0,n,u)}function e(t=1,s="sphere"+getGlobalId$$1(),e=ts3dutils.TAU){const r=PCurveEdge$$1.create(new EllipseCurve$$1(ts3dutils.V3.O,new ts3dutils.V3(0,0,-t),new ts3dutils.V3(t,0,0)),new ts3dutils.V3(0,0,-t),new ts3dutils.V3(0,0,t),0,PI,void 0,new ts3dutils.V3(t,0,0),new ts3dutils.V3(-t,0,0)),n=ts3dutils.callsce("B2T.sphere",t,s,e);return i([StraightEdge$$1.throughPoints(r.b,r.a),r],e,s,n)}function i(t,s,e="rotateEdges"+getGlobalId$$1(),i,r){ts3dutils.assert(t.every(t=>new PlaneSurface$$1(P3$$1.ZX).containsCurve(t.curve))),ts3dutils.assert(!ts3dutils.eq(PI,s)||PI==s),ts3dutils.assertf(()=>ts3dutils.lt(0,s)&&ts3dutils.le(s,ts3dutils.TAU)),s=ts3dutils.snap(s,ts3dutils.TAU),ts3dutils.assertf(()=>Edge$$1.isLoop(t));const n=new PlaneSurface$$1(P3$$1.ZX.flipped()).edgeLoopCCW(t)?new PlaneSurface$$1(P3$$1.ZX.flipped()):new PlaneSurface$$1(P3$$1.ZX),o=!ts3dutils.eq(s,2*PI),a=t.map(t=>{const s=t.a,e=s.lengthXY();if(!ts3dutils.eq0(e))return new EllipseCurve$$1(ts3dutils.V(0,0,s.z),ts3dutils.V(e,0,0),ts3dutils.V(0,e,0))}),u=t.map((t,s)=>{const e=rotateCurve$$1(t.curve,t.minT,t.maxT,PI,t.deltaT()>0),i=ts3dutils.lerp(t.aT,t.bT,.5);return e&&ts3dutils.assert(t.tangentAt(i).cross(ts3dutils.V3.Y).dot(e.normalP(t.curve.at(i)))<0),e});let l,c=t;const h=[];for(let i=0;i<s;i+=PI){const n=0,o=min(s-i,PI),d=ts3dutils.M4.rotateZ(i+o);l=i+o==ts3dutils.TAU?t:t.map(t=>t.transform(d));const p=ts3dutils.arrayFromFunction(t.length,t=>{const s=c[t].a,r=s.lengthXY(),u=l[t].a;if(!ts3dutils.eq0(r)){const r=0===i?a[t]:a[t].rotateZ(i);return new PCurveEdge$$1(r,s,u,n,o,void 0,r.tangentAt(n),r.tangentAt(o),e+"rib"+t)}});for(let s=0;s<t.length;s++)if(u[s]){const n=c[s],o=(s+1)%t.length,a=[c[s].flipped(),!ts3dutils.eq0(n.a.x)&&p[s],l[s],!ts3dutils.eq0(n.b.x)&&p[o].flipped()].filter(t=>t),d=0===i?u[s]:u[s].rotateZ(i),f=r&&r.extrudeWall(s,d,a,void 0);h.push(Face$$1.create(d,a,void 0,e+"Wall"+s,f))}c=l}if(o){const i=Edge$$1.reversePath(l),o=r&&r.rotationStart(n,t,void 0),a=r&&r.rotationEnd(n.flipped().rotateZ(s),i,void 0);h.push(new PlaneFace$$1(n,t,void 0,e+"start",o),new PlaneFace$$1(n.flipped().rotateZ(s),i,void 0,e+"end",a))}const d=new PlaneSurface$$1(P3$$1.ZX).edgeLoopCCW(t);return new BRep$$1(h,d,i)}t.box=function(s=1,e=1,i=1,r="box"+getGlobalId$$1()){ts3dutils.assertNumbers(s,e,i),ts3dutils.assert("string"==typeof r);const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(0,e,0),new ts3dutils.V3(s,e,0),new ts3dutils.V3(s,0,0)],o=ts3dutils.callsce("B2T.box",s,e,i,r);return t.extrudeVertices(n,P3$$1.XY.flipped(),new ts3dutils.V3(0,0,i),r,o)},t.puckman=function(s,e,i,r="puckman"+getGlobalId$$1()){ts3dutils.assertf(()=>ts3dutils.lt(0,s)),ts3dutils.assertf(()=>ts3dutils.lt(0,e)&&ts3dutils.le(e,ts3dutils.TAU)),ts3dutils.assertf(()=>ts3dutils.lt(0,i));const n=StraightEdge$$1.chain([ts3dutils.V3.O,new ts3dutils.V3(s,0,0),new ts3dutils.V3(s,0,i),new ts3dutils.V3(0,0,i)],!0);return t.rotateEdges(n,e,r)},t.registerVertexName=function(t,s,e){Array.from(t.keys()).some(t=>t.like(e))||t.set(e,s)},t.extrudeEdges=s,t.cylinder=function(t=1,s=1,e=ts3dutils.TAU,r="cylinder"+getGlobalId$$1()){const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,0),new ts3dutils.V3(t,0,s),new ts3dutils.V3(0,0,s)];return i(StraightEdge$$1.chain(n,!0),e,r)},t.cone=function(t=1,s=1,e=ts3dutils.TAU,r="cone"+getGlobalId$$1()){const n=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,s),new ts3dutils.V3(0,0,s)];return i(StraightEdge$$1.chain(n,!0),e,r)},t.sphere=e,t.menger=function(s=2,e="menger"+getGlobalId$$1()){let i=t.box(1,1,1);if(0==s)return i;const r=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped();function n(t,s){if(i=i.and(r.transform(s)),t>1){const e=s.times(ts3dutils.M4.scale(1/3,1/3,1));for(let s=0;s<9;s++)4!=s&&n(t-1,e.times(ts3dutils.M4.translate(s%3,s/3|0,0)))}}return n(s,ts3dutils.M4.IDENTITY),n(s,ts3dutils.M4.YZX),n(s,ts3dutils.M4.ZXY),i},t.menger2=function(s=2,e="menger"+getGlobalId$$1()){if(0==s)return t.box(1,1,1);const i=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped(),r=[];!function t(s,e){if(r.push(...i.transform(e).faces),s>1){const i=e.times(ts3dutils.M4.scale(1/3,1/3,1));for(let e=0;e<9;e++)4!=e&&t(s-1,i.times(ts3dutils.M4.translate(e%3,e/3|0,0)))}}(s,ts3dutils.M4.IDENTITY);const n=new BRep$$1(r,!0);return t.box().and(n).and(n.transform(ts3dutils.M4.YZX)).and(n.transform(ts3dutils.M4.ZXY))},t.torus=function(s,e,i=ts3dutils.TAU,r="torus"+getGlobalId$$1()){ts3dutils.assertNumbers(s,e,i),ts3dutils.assertf(()=>e>s);const n=[EllipseCurve$$1.semicircle(s,new ts3dutils.V3(e,0,0)),EllipseCurve$$1.semicircle(-s,new ts3dutils.V3(e,0,0))].map(t=>PCurveEdge$$1.forCurveAndTs(t,0,Math.PI).rotateX(PI/2));return t.rotateEdges(n,i,r)},t.rotateEdges=i,t.quaffle=function(){const s=t.sphere(1).translate(0,1.7).flipped(),e=new BRep$$1(t.TETRAHEDRON_VERTICES.flatMap(t=>s.rotateAB(ts3dutils.V3.Y,t).faces),!1);return t.sphere().and(e)},t.extrudeFace=function(t,e){return new BRep$$1(s(t.contour,t.surface.plane,e).faces.slice(0,-2).concat(t,t.translate(e.x,e.y,e.z).flipped(),t.holes.flatMap(i=>s(i,t.surface.plane.flipped(),e).faces.slice(0,-2))),!1)},t.loadFonts=function(){return n("fonts/FiraSansMedium.woff").then(s=>t.defaultFont=s)};const r=new Map;function n(t){return new Promise(function(s,e){const i=r.get(t);i?s(i):opentype.load(t,function(i,n){i?e(i):(r.set(t,n),s(n))})})}function o(s,e,i=1,r=t.defaultFont){const n=[];r.getPath(s,0,0,e).commands.forEach(t=>{"M"==t.type&&n.push([]),n.last.push(t)});const o=n.map(t=>{const s=new opentype.Path;s.commands=t;const e=Edge$$1.reversePath(Edge$$1.pathFromSVG(s.toPathData(13))).map(t=>t.mirrorY());return ts3dutils.assert(Edge$$1.isLoop(e)),e}),a=Face$$1.assembleFacesFromLoops(o,new PlaneSurface$$1(P3$$1.XY),PlaneFace$$1),u=ts3dutils.callsce("B2T.text",s,e,i);return BRep$$1.join(a.map(s=>t.extrudeFace(s,ts3dutils.V(0,0,-i))),u)}function a(t){return t.flatMap(t=>{const s=t.curve;if(s instanceof EllipseCurve$$1&&s.tMin===-PI&&s.tMax===PI){return(t.minT<0&&t.maxT>0?t.split(0):[t]).map(t=>t.minT>=0?Edge$$1.create(new EllipseCurve$$1(s.center,s.f1,s.f2,max(0,s.tMin),s.tMax),t.a,t.b,t.aT,t.bT,void 0,t.aDir,t.bDir,t.name):Edge$$1.create(new EllipseCurve$$1(s.center,s.f1.negated(),s.f2.negated(),s.tMin+PI,min(PI,s.tMax+PI)),t.a,t.b,t.aT+PI,t.bT+PI,void 0,t.aDir,t.bDir,t.name))}return s instanceof BezierCurve$$1&&t.a.like(t.b)?t.split(ts3dutils.lerp(t.aT,t.bT,.5)):t})}t.loadFont=n,t.loadFontsAsync=function(s){t.defaultFont?s():opentype.load("fonts/FiraSansMedium.woff",function(e,i){if(e)throw new Error("Could not load font: "+e);t.defaultFont=i,s()})},t.text=o,t.minorityReport=function(){const s=t.sphere(),e=t.text("LEO CROW",64,128).scale(.1/32).translate(-.5,-.05,1.2).flipped(),i=t.sphere(.98);return s.and(e).plus(i)},t.whatever=function(){const t=d(),s=BRep$$1.join(t.faces.map((t,s)=>{const e=o(""+(s+1),.4,-2),i=t.contour.map(t=>t.a).reduce((t,s)=>t.plus(s),ts3dutils.V3.O).div(3),r=ts3dutils.M4.forSys(t.contour[0].aDir,i.cross(t.contour[0].aDir),i.unit(),i);return e.transform(r.times(ts3dutils.M4.translate(-e.getAABB().size().x/2,-.1,-.04)))})),i=e(.9);return t.and(i).and(s)},t.whatever3=function(){const s=t.torus(1,2);return t.box(5,5,2).translate(-2.5,-2.5).minus(s)},t.d20=function(){const t=d(),s=BRep$$1.join(t.faces.map((t,s)=>{const e=o(""+(s+1),.4,-2),i=t.contour.map(t=>t.a).reduce((t,s)=>t.plus(s),ts3dutils.V3.O).div(3),r=ts3dutils.M4.forSys(t.contour[0].aDir,i.cross(t.contour[0].aDir),i.unit(),i);return e.transform(r.times(ts3dutils.M4.translate(-e.getAABB().size().x/2,-.1,-.04)))})),i=e(.9);return t.and(i).and(s)},t.rotStep=function(t,s,e){const i="number"==typeof s?ts3dutils.arrayFromFunction(e,t=>(t+1)/e*s):s,r=i.length,n=!ts3dutils.eq(ts3dutils.TAU,i.last),o=[t,...i.map(s=>{if(ts3dutils.eq(ts3dutils.TAU,s))return t;const e=ts3dutils.M4.rotateZ(s);return t.map(t=>t.transform(e))})],a=ts3dutils.arrayFromFunction(r,s=>{const e=(s+1)%(r+1);return ts3dutils.arrayFromFunction(t.length,i=>{if(!ts3dutils.eq0(t[i].a.lengthXY()))return StraightEdge$$1.throughPoints(o[s][i].a,o[e][i].a)})}),u=[];let l;if(t.forEach((s,e)=>{const c=(e+1)%t.length;if(s instanceof StraightEdge$$1&&s.curve.dir1.isPerpendicularTo(ts3dutils.V3.Z)){const t=s.a.x>s.b.x,i=new PlaneSurface$$1(t?new P3$$1(ts3dutils.V3.Z,s.a.z):new P3$$1(ts3dutils.V3.Z.negated(),-s.a.z));if(n){const t=[];ts3dutils.eq0(s.a.x)||t.push(...ts3dutils.arrayFromFunction(r,t=>a[t][e])),t.push(o[r][e]),ts3dutils.eq0(s.b.x)||t.push(...ts3dutils.arrayFromFunction(r,t=>a[r-t-1][c].flipped())),t.push(s.flipped()),l=new PlaneFace$$1(i,t)}else{const n=t?ts3dutils.arrayFromFunction(r,t=>a[t][e]):ts3dutils.arrayFromFunction(r,t=>a[r-t-1][c].flipped());let o;t&&!ts3dutils.eq0(s.b.x)?o=ts3dutils.arrayFromFunction(r,t=>a[r-t-1][c].flipped()):t||ts3dutils.eq0(s.a.x)||(o=ts3dutils.arrayFromFunction(r,t=>a[t][e])),l=new PlaneFace$$1(i,n,o?[o]:[])}u.push(l)}else if(!(s instanceof StraightEdge$$1&&ts3dutils.eq0(s.a.lengthXY())&&ts3dutils.eq0(s.b.lengthXY())))for(let n=0;n<r;n++){const l=(n+1)%(r+1),h=[o[n][e].flipped(),a[n][e],o[l][e],a[n][c]&&a[n][c].flipped()].filter(t=>t);let d;if(s instanceof StraightEdge$$1)d=new PlaneSurface$$1(P3$$1.throughPoints(h[0].a,h[1].a,h[2].a));else{const s=t[e].getAABB().max.x,r=i[n],a=0==n?0:i[n-1],u=ts3dutils.V3.polar(s,a).to(ts3dutils.V3.polar(s,r));d=projectCurve$$1(o[n][e].curve,u,!1)}u.push(Face$$1.create(d,h))}}),n){const s=o[r].map(t=>t.flipped()).reverse(),e=new PlaneFace$$1(new PlaneSurface$$1(P3$$1.ZX.rotateZ(i.last)),s);u.push(new PlaneFace$$1(new PlaneSurface$$1(P3$$1.ZX.flipped()),t),e)}return new BRep$$1(u,new PlaneSurface$$1(P3$$1.ZX).edgeLoopCCW(t))},t.fixEdges=a,t.extrudeVertices=function(s,e,i,r,n){ts3dutils.assert(s.every(t=>t instanceof ts3dutils.V3),"baseVertices.every(v => v instanceof V3)"),ts3dutils.assertInst(P3$$1,e),ts3dutils.assertVectors(i),e.normal1.dot(i)>0&&(e=e.flipped());const o=StraightEdge$$1.chain(s,!0);return n=n||ts3dutils.callsce("B2T.extrudeVertices",s,e,i,r),t.extrudeEdges(o,e,i,r,n)},t.tetrahedron=function(t,s,e,i,r="tetra"+getGlobalId$$1()){ts3dutils.assertVectors(t,s,e,i);const n=P3$$1.throughPoints(t,s,e).distanceToPointSigned(i);if(ts3dutils.eq0(n))throw new Error("four points are coplanar");n>0&&([e,i]=[i,e]);const o=StraightEdge$$1.throughPoints(t,s),a=StraightEdge$$1.throughPoints(t,e),u=StraightEdge$$1.throughPoints(t,i),l=StraightEdge$$1.throughPoints(s,e),c=StraightEdge$$1.throughPoints(s,i),h=StraightEdge$$1.throughPoints(e,i),d=[new PlaneFace$$1(PlaneSurface$$1.throughPoints(t,s,e),[o,l,a.flipped()],[],r+"abc"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(t,i,s),[u,c.flipped(),o.flipped()],[],r+"adb"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(s,i,e),[c,h.flipped(),l.flipped()],[],r+"bdc"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(e,i,t),[h,u.flipped(),a],[],r+"cda")],p=ts3dutils.callsce("B2T.tetrahedron",t,s,e,i);return new BRep$$1(d,!1,p)};const u=1/ts3dutils.GOLDEN_RATIO,l=2-ts3dutils.GOLDEN_RATIO;t.TETRAHEDRON_VERTICES=[new ts3dutils.V3(1,0,-SQRT1_2),new ts3dutils.V3(-1,0,-SQRT1_2),new ts3dutils.V3(0,-1,SQRT1_2),new ts3dutils.V3(0,1,SQRT1_2)].map(t=>t.unit()),t.DODECAHEDRON_VERTICES=[new ts3dutils.V3(l,0,1),new ts3dutils.V3(-l,0,1),new ts3dutils.V3(-u,u,u),new ts3dutils.V3(0,1,l),new ts3dutils.V3(u,u,u),new ts3dutils.V3(u,-u,u),new ts3dutils.V3(0,-1,l),new ts3dutils.V3(-u,-u,u),new ts3dutils.V3(l,0,-1),new ts3dutils.V3(-l,0,-1),new ts3dutils.V3(-u,-u,-u),new ts3dutils.V3(0,-1,-l),new ts3dutils.V3(u,-u,-u),new ts3dutils.V3(u,u,-u),new ts3dutils.V3(0,1,-l),new ts3dutils.V3(-u,u,-u),new ts3dutils.V3(1,l,0),new ts3dutils.V3(-1,l,0),new ts3dutils.V3(-1,-l,0),new ts3dutils.V3(1,-l,0)].map(t=>t.unit()),t.DODECAHEDRON_FACE_VERTICES=[[4,3,2,1,0],[7,6,5,0,1],[12,11,10,9,8],[15,14,13,8,9],[14,3,4,16,13],[3,14,15,17,2],[11,6,7,18,10],[6,11,12,19,5],[4,0,5,19,16],[12,8,13,16,19],[15,9,10,18,17],[7,1,2,17,18]],t.OCTAHEDRON_VERTICES=[new ts3dutils.V3(1,0,0),new ts3dutils.V3(-1,0,0),new ts3dutils.V3(0,1,0),new ts3dutils.V3(0,-1,0),new ts3dutils.V3(0,0,1),new ts3dutils.V3(0,0,-1)],t.OCTAHEDRON_FACE_VERTICES=[[0,2,4],[2,1,4],[1,3,4],[3,0,4],[2,0,5],[1,2,5],[3,1,5],[0,3,5]];const{x:c,y:h}=new ts3dutils.V3(1,ts3dutils.GOLDEN_RATIO,0).unit();function d(){return p(t.ICOSAHEDRON_VERTICES,t.ICOSAHEDRON_FACE_VERTICES,"B2T.icosahedron()")}function p(t,s,e){const i=new Map,r=s.map(s=>{const e=PlaneSurface$$1.throughPoints(t[s[0]],t[s[1]],t[s[2]]),r=ts3dutils.arrayFromFunction(s.length,e=>{const r=(e+1)%s.length,n=s[e],o=s[r],a=min(n,o),u=max(n,o),l=a*t.length+u;let c=i.get(l);return!c&&i.set(l,c=StraightEdge$$1.throughPoints(t[a],t[u])),n<o?c:c.flipped()});return new PlaneFace$$1(e,r)});return new BRep$$1(r,!1,e)}t.ICOSAHEDRON_VERTICES=[new ts3dutils.V3(-c,h,0),new ts3dutils.V3(c,h,0),new ts3dutils.V3(-c,-h,0),new ts3dutils.V3(c,-h,0),new ts3dutils.V3(0,-c,h),new ts3dutils.V3(0,c,h),new ts3dutils.V3(0,-c,-h),new ts3dutils.V3(0,c,-h),new ts3dutils.V3(h,0,-c),new ts3dutils.V3(h,0,c),new ts3dutils.V3(-h,0,-c),new ts3dutils.V3(-h,0,c)],t.ICOSAHEDRON_FACE_VERTICES=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],t.dodecahedron=function(){return p(t.DODECAHEDRON_VERTICES,t.DODECAHEDRON_FACE_VERTICES,"B2T.dodecahedron()")},t.octahedron=function(){return p(t.OCTAHEDRON_VERTICES,t.OCTAHEDRON_FACE_VERTICES,"B2T.octahedron()")},t.icosahedron=d,t.pyramidEdges=function(t,s,e="pyramid"+getGlobalId$$1()){ts3dutils.assertInst(Edge$$1,...t),ts3dutils.assertVectors(s);const i=t.map(t=>StraightEdge$$1.throughPoints(s,t.a)),r=t.map((r,n)=>{const o=e+"Wall"+n,a=(n+1)%t.length,u=[i[n],r,i[a].flipped()],l=projectPointCurve$$1(r.curve,r.minT,r.maxT,s,r.deltaT()<0);return Face$$1.create(l,u,void 0,o)}),n=new PlaneSurface$$1(P3$$1.XY).flipped(),o=Face$$1.create(n,Edge$$1.reversePath(t));r.push(o);const a=ts3dutils.callsce("B2T.pyramidEdges",t,s,e);return new BRep$$1(r,!1,a)},t.fromBPT=function(t){const s=/.+/g,e=()=>s.exec(t)[0],i=()=>e().trim().split(/\s+/).map(t=>parseFloat(t)),r=parseInt(e()),n=ts3dutils.arrayFromFunction(r,()=>{const[t,s]=i(),e=Array.from({length:(t+1)*(s+1)},()=>ts3dutils.VV(...i(),1)),r=new NURBSSurface$$1(e,NURBS$$1.bezierKnots(t),NURBS$$1.bezierKnots(s),t,s,0,1,0,1);return r});return n}}(exports.B2T||(exports.B2T={}));class CustomPlane$$1 extends P3$$1{constructor(t,s,e,i="CustomPlane"+getGlobalId$$1(),r=chroma.random().gl(),n=-500,o=500,a=-500,u=500){const{normal1:l,w:c}=P3$$1.forAnchorAndPlaneVectors(t,s,e);super(l,c),this.up=e,this.right=s,this.uMin=n,this.uMax=o,this.vMin=a,this.vMax=u,this.name=i,this.color=r}get plane(){return this}toPlaneSurface(){return new PlaneSurface$$1(this,this.right,this.up)}toSource(){return ts3dutils.callsce("new CustomPlane",this.anchor,this.right,this.up,this.name,this.color,this.sMin,this.sMax,this.tMin,this.tMax)}static forPlane(t,s=tsgl.GL_COLOR_BLACK,e){const i=t.normal1.getPerpendicular().unit(),r=i.cross(t.normal1);return new CustomPlane$$1(t.anchor,r,i,e,s)}static fromPlaneSurface(t){return new CustomPlane$$1(t.plane.anchor,t.right,t.up,"genCustomPlane"+getGlobalId$$1())}distanceTo(t,s){return[new L3$$1(this.anchor.plus(this.right.times(this.uMin)),this.up),new L3$$1(this.anchor.plus(this.right.times(this.uMax)),this.up),new L3$$1(this.anchor.plus(this.up.times(this.vMin)),this.right),new L3$$1(this.anchor.plus(this.up.times(this.vMax)),this.right)].map((e,i)=>{const r=e.infoClosestToLine(t);return(isNaN(r.t)||i<2&&this.vMin<=r.t&&r.t<=this.vMax||i>=2&&this.uMin<=r.t&&r.t<=this.uMax)&&r.distance<=s?r.s:1/0}).min()}distanceTo2(t,s){return[new L3$$1(this.anchor.plus(this.right.times(this.uMin)),this.up),new L3$$1(this.anchor.plus(this.right.times(this.uMax)),this.up),new L3$$1(this.anchor.plus(this.up.times(this.vMin)),this.right),new L3$$1(this.anchor.plus(this.up.times(this.vMax)),this.right)].map((e,i)=>{const r=e.infoClosestToLine(t);return(isNaN(r.t)||i<2&&this.vMin<=r.t&&r.t<=this.vMax||i>=2&&this.uMin<=r.t&&r.t<=this.uMax)&&r.distance<=s?r.distance:1/0}).min()}}class Edge$$1 extends ts3dutils.Transformable{constructor(t,s,e,i,r,n,o){super(),this.curve=t,this.a=s,this.b=e,this.aT=i,this.bT=r,this.flippedOf=n,this.name=o,ts3dutils.assertNumbers(i,r),ts3dutils.assert(!ts3dutils.eq(i,r)),ts3dutils.assertVectors(s,e),ts3dutils.assertf(()=>t instanceof Curve$$1,t),ts3dutils.assertf(()=>!t.isValidT||t.isValidT(i)&&t.isValidT(r),i,r,t),ts3dutils.assertf(()=>t.at(i).like(s),()=>""+t.at(i)+s+" aT should have been "+t.pointT(s)),ts3dutils.assertf(()=>t.at(r).like(e),()=>""+t.at(r)+e+" bT should have been "+t.pointT(e)),ts3dutils.assertf(()=>ts3dutils.fuzzyBetween(i,t.tMin,t.tMax),i,t.tMin,t.tMax),ts3dutils.assertf(()=>ts3dutils.fuzzyBetween(r,t.tMin,t.tMax),r,t.tMin,t.tMax),this.aT=ts3dutils.clamp(i,t.tMin,t.tMax),this.bT=ts3dutils.clamp(r,t.tMin,t.tMax),this.reversed=this.aT>this.bT}get minT(){return Math.min(this.aT,this.bT)}get maxT(){return Math.max(this.aT,this.bT)}static forCurveAndTs(t,s=t.tMin,e=t.tMax){return Edge$$1.create(t,t.at(s),t.at(e),s,e,void 0,s<e?t.tangentAt(s):t.tangentAt(s).negated(),s<e?t.tangentAt(e):t.tangentAt(e).negated())}static create(t,s,e,i,r,n,o,a,u){return t instanceof L3$$1?new StraightEdge$$1(t,s,e,i,r,n,u):new PCurveEdge$$1(t,s,e,i,r,n,o,a,u)}static isLoop(t){return t.every((s,e)=>s.b.like(t[(e+1)%t.length].a))}static edgesIntersect(t,s){ts3dutils.assertNumbers(t.curve.hlol,s.curve.hlol),ts3dutils.assertInst(Edge$$1,t,s),t.curve.hlol<s.curve.hlol&&([s,t]=[t,s]);const e=t.curve.isInfosWithCurve(s.curve);return e.some(t=>isNaN(t.tThis)||isNaN(t.tOther))&&(console.log(t.sce),console.log(s.sce),ts3dutils.assert(!1)),e.some(({tThis:e,tOther:i})=>t.tValueInside(e)&&s.tValueInside(i))}static assertLoop(t){t.forEach((s,e)=>{const i=(e+1)%t.length;ts3dutils.assert(s.b.like(t[i].a),`edges[${e}].b != edges[${i}].a (${t[e].b.sce} != ${t[i].a.sce})`)})}static ngon(t=3,s=1){return StraightEdge$$1.chain(ts3dutils.arrayFromFunction(t,e=>ts3dutils.V3.polar(s,ts3dutils.TAU*e/t)))}static star(t=5,s=1,e=.5){const i=ts3dutils.arrayFromFunction(2*t,i=>ts3dutils.V3.polar(0==i%2?s:e,ts3dutils.TAU*i/t/2));return StraightEdge$$1.chain(i)}static reversePath(t,s=!0){return s?ts3dutils.arrayFromFunction(t.length,s=>t[t.length-1-s].flipped()):t}static rect(t=1,s=t){const e=[new ts3dutils.V3(0,0,0),new ts3dutils.V3(t,0,0),new ts3dutils.V3(t,s,0),new ts3dutils.V3(0,s,0)];return StraightEdge$$1.chain(e)}static reuleaux(t=3,s=1){ts3dutils.assert(3<=t),ts3dutils.assert(1==t%2);const e=ts3dutils.arrayFromFunction(t,e=>ts3dutils.V3.polar(s,ts3dutils.TAU*e/t));return ts3dutils.arrayFromFunction(t,s=>{const i=(s+floor(t/2))%t,r=(s+ceil(t/2))%t,n=e[i],o=e[r],a=e[s],u=a.to(n),l=new EllipseCurve$$1(a,u,ts3dutils.V3.Z.cross(u));return Edge$$1.create(l,n,o,0,l.pointT(o),void 0,ts3dutils.V3.Z.cross(u),ts3dutils.V3.Z.cross(a.to(o)))})}static round(t,s){if(ts3dutils.eq0(s))return t;const e=t.map((e,i)=>{const r=(i+1)%t.length,n=t[r];if(!e.b.like(n.a))return;const o=e.bDir.angleTo(n.aDir),a=e.curve,u=n.curve;if(a instanceof L3$$1&&u instanceof L3$$1){const t=a.dir1.cross(u.dir1);if(ts3dutils.eq0(o))return;const e=t.cross(a.dir1),i=t.cross(u.dir1),r=a.transform(ts3dutils.M4.translate(e.toLength(s))),n=u.transform(ts3dutils.M4.translate(i.toLength(s))),l=r.isInfoWithLine(n);if(!l)throw new Error("tangential curves");const c=l.plus(e.toLength(-s)),h=l.plus(i.toLength(-s)),d=e.toLength(-s),p=new EllipseCurve$$1(l,d,t.cross(d).toLength(s));return Edge$$1.create(p,c,h,0,p.pointT(h),void 0,a.dir1,u.dir1)}return Edge$$1.arbitraryCorner(e,n,s)});return t.flatMap((s,i)=>{const r=(i+t.length-1)%t.length,n=e[r],o=e[i];if(!n&&!o)return s;const[a,u,l]=n?[s.curve.pointT(n.b),n.b,n.bDir]:[s.aT,s.a,s.aDir],[c,h,d]=o?[s.curve.pointT(o.a),o.a,o.aDir]:[s.bT,s.b,s.bDir],p=Edge$$1.create(s.curve,u,h,a,c,void 0,l,d);return o?[p,o]:p})}static arbitraryCorner(t,s,e){const i=t.curve,r=s.curve;const n=t.bT-e*sign(t.deltaT())/t.bDir.length(),o=s.aT+e*sign(s.deltaT())/s.aDir.length(),[a,u]=ts3dutils.newtonIterate(function([t,s]){const n=i.at(t),o=r.at(s),a=i.tangentAt(t),u=r.tangentAt(s),l=a.cross(u),c=l.cross(a).unit(),h=l.cross(u).unit(),d=c.cross(h);l.likeO()&&ts3dutils.assert(!1);const p=n.to(o);ts3dutils.eq0(p.dot(l))||ts3dutils.assert(!1);const f=p.cross(h).dot(d)/d.squared(),m=p.cross(c).dot(d)/d.squared(),$=n.plus(c.times(f)),g=o.plus(h.times(m));return ts3dutils.assert($.like(g)),[abs(f)-e,abs(m)-e]},[n,o]),l=t.curve.at(a),c=s.curve.at(u),h=i.tangentAt(a),d=r.tangentAt(u),p=h.cross(d),f=p.cross(h).unit().toLength(-e),m=l.minus(f),$=new EllipseCurve$$1(m,f,p.cross(f).toLength(e));return Edge$$1.create($,l,c,0,$.pointT(c),void 0,i.tangentAt(a),r.tangentAt(u))}static pathFromSVG(t){let s=void 0;const e=new svgPathdata.SVGPathData(t).toAbs().normalizeHVZ().sanitize(ts3dutils.NLA_PRECISION).annotateArcs().commands,i=[];for(const t of e){ts3dutils.assert("x"in t&&"y"in t);const e=new ts3dutils.V3(t.x,t.y,0);switch(t.type){case svgPathdata.SVGPathData.LINE_TO:i.push(StraightEdge$$1.throughPoints(s,e));break;case svgPathdata.SVGPathData.CURVE_TO:{const r=new ts3dutils.V3(t.x1,t.y1,0),n=new ts3dutils.V3(t.x2,t.y2,0),o=new BezierCurve$$1(s,r,n,e,0,1),a=new PCurveEdge$$1(o,s,e,0,1,void 0,o.tangentAt(0),o.tangentAt(1));i.push(a);break}case svgPathdata.SVGPathData.QUAD_TO:{const r=new ts3dutils.V3(t.x1,t.y1,0),n=ParabolaCurve$$1.quadratic(s,r,e).rightAngled(),o=new PCurveEdge$$1(n,s,e,n.tMin,n.tMax,void 0,n.tangentAt(n.tMin),n.tangentAt(n.tMax));i.push(o);break}case svgPathdata.SVGPathData.ARC:{const r=t.phi1*ts3dutils.DEG,n=t.phi2*ts3dutils.DEG,[o,a]=[r,n].sort(ts3dutils.MINUS),u=ts3dutils.arrayRange(-3,4,1).map(t=>t*PI).filter(t=>o<=t&&t<=a),l=ts3dutils.V(t.cX,t.cY),c=ts3dutils.V3.polar(t.rX,t.xRot*ts3dutils.DEG),h=ts3dutils.V3.polar(t.rY,t.xRot*ts3dutils.DEG+Math.PI/2),d=ts3dutils.getIntervals(u,o,a).map(([t,i])=>{const o=i-t,a=ts3dutils.mod(t,ts3dutils.TAU),u=a+o;ts3dutils.assert(a>=0==u>=0);const d=a>PI||u>PI,p=d?a-PI:a,f=d?u-PI:u,m=new EllipseCurve$$1(l,d?c.negated():c,d?h.negated():h),$=r==t?s:n==t?e:m.at(p),g=r==i?s:n==i?e:m.at(f);return new PCurveEdge$$1(m,$,g,p,f,void 0,m.tangentAt(p),m.tangentAt(f))});i.push(...t.phiDelta>0?d:Edge$$1.reversePath(d));break}}s=e}return i}toString(){return ts3dutils.callsce("new "+this.constructor.name,this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir)}split(t){const s=this.curve.at(t),e=this.tangentAt(t);return[Edge$$1.create(this.curve,this.a,s,this.aT,t,void 0,this.aDir,e,this.name+"left"),Edge$$1.create(this.curve,s,this.b,t,this.bT,void 0,e,this.bDir,this.name+"left")]}colinearToLine(t){return this.curve instanceof L3$$1&&this.curve.isColinearTo(t)}tValueInside(t){return this.aT<this.bT?ts3dutils.lt(this.aT,t)&&ts3dutils.lt(t,this.bT):ts3dutils.lt(this.bT,t)&&ts3dutils.lt(t,this.aT)}isValidT(t){return this.aT<this.bT?ts3dutils.le(this.aT,t)&&ts3dutils.le(t,this.bT):ts3dutils.le(this.bT,t)&&ts3dutils.le(t,this.aT)}clampedT(t){return this.aT<this.bT?ts3dutils.clamp(t,this.aT,this.bT):ts3dutils.clamp(t,this.bT,this.aT)}equals(t){return this===t||this.constructor==t.constructor&&this.a.equals(t.a)&&this.b.equals(t.b)&&this.curve.equals(t.curve)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.a.hashCode())+this.b.hashCode())+this.curve.hashCode())}like(t){return this===t||t instanceof Edge$$1&&this.curve.isColinearTo(t.curve)&&this.a.like(t.a)&&this.b.like(t.b)}isCanon(){return!this.reversed}getCanon(){return this.reversed?this.flipped():this}overlaps(t,s){ts3dutils.assert(this.curve.isColinearTo(t.curve));const e=this.curve.containsPoint(t.a)&&this.curve.pointT(t.a),i=this.curve.containsPoint(t.b)&&this.curve.pointT(t.b);return!1===e&&!1===i?!s&&t.overlaps(this,!0):!(ts3dutils.le(t.maxT,this.minT)||ts3dutils.le(this.maxT,t.minT))}getAABB(){const t=[1/0,1/0,1/0],s=[-1/0,-1/0,-1/0];this.curve.roots().forEach((e,i)=>{e.forEach(e=>{ts3dutils.lt(this.minT,e)&&ts3dutils.lt(e,this.maxT)&&(t[i]=Math.min(t[i],this.curve.at(e).e(i)),s[i]=Math.max(s[i],this.curve.at(e).e(i)))})});const e=new ts3dutils.AABB(ts3dutils.V(t),ts3dutils.V(s));return e.addPoint(this.a),e.addPoint(this.b),e}length(t=1){return this.curve.arcLength(this.minT,this.maxT,t)}deltaT(){return this.bT-this.aT}deltaTSign(){return sign(this.bT-this.aT)}atAvgT(){return this.curve.at((this.minT+this.maxT)/2)}static loopsEqual(t,s){return t.length==s.length&&ts3dutils.arrayRange(0,t.length,1).some(e=>t.every((i,r)=>i.equals(s[(e+r)%t.length])))}}class PCurveEdge$$1 extends Edge$$1{constructor(t,s,e,i,r,n,o,a,u){super(t,s,e,i,r,n,u),this.flippedOf=n,this.aDir=o,this.bDir=a,ts3dutils.assertVectors(o,a),ts3dutils.assertf(()=>!o.likeO(),t),ts3dutils.assertf(()=>!a.likeO(),t),t instanceof PICurve$$1||(ts3dutils.assertf(()=>t.tangentAt(i).likeOrReversed(o),""+i+t.tangentAt(i).sce+" "+o.sce),ts3dutils.assertf(()=>t.tangentAt(r).likeOrReversed(a),""+r+t.tangentAt(r).sce+" "+a.sce)),ts3dutils.assert(this.reversed===this.aDir.dot(t.tangentAt(i))<0,i+" "+r+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(i)),ts3dutils.assert(this.reversed===this.bDir.dot(t.tangentAt(r))<0,i+" "+r+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(i))}static forCurveAndTs(t,s,e,i){return new PCurveEdge$$1(t,t.at(s),t.at(e),s,e,void 0,s<e?t.tangentAt(s):t.tangentAt(s).negated(),s<e?t.tangentAt(e):t.tangentAt(e).negated(),i)}toSource(){return ts3dutils.callsce("new PCurveEdge",this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir,this.name)}getVerticesNo0(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!1)}pointsCount(){return this.points().length}points(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!0)}edgeISTsWithSurface(t){return this.curve.isTsWithSurface(t).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}edgeISTsWithPlane(t){return this.curve.isTsWithPlane(t).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(t){return this.reversed?this.curve.tangentAt(t).negated():this.curve.tangentAt(t)}flipped(){return this.flippedOf||(this.flippedOf=new PCurveEdge$$1(this.curve,this.b,this.a,this.bT,this.aT,this,this.bDir.negated(),this.aDir.negated(),this.name))}transform(t,s){return new PCurveEdge$$1(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT,this.bT,void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+s)}transform4(t,s){const e=t.transformPoint(this.a),i=t.transformPoint(this.b),r=this.curve.transform4(t);return new PCurveEdge$$1(r,e,i,ts3dutils.snap(r.pointT(e),this.aT),ts3dutils.snap(r.pointT(i),this.bT),void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+s)}isCoEdge(t){return this===t||this===t.flippedOf||this.curve.isColinearTo(t.curve)&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}}class StraightEdge$$1 extends Edge$$1{constructor(t,s,e,i,r,n,o){super(t,s,e,i,r,n,o),this.flippedOf=n,ts3dutils.assertInst(L3$$1,t),!n||ts3dutils.assertInst(StraightEdge$$1,n),!o||ts3dutils.assertf(()=>"string"==typeof o,o),ts3dutils.assert(!s.like(e),"!a.like(b)"+s+e),this.tangent=this.aT<this.bT?this.curve.dir1:this.curve.dir1.negated()}get aDir(){return this.tangent}get bDir(){return this.tangent}static throughPoints(t,s,e){return new StraightEdge$$1(L3$$1.throughPoints(t,s,0,t.to(s).length()),t,s,0,t.to(s).length(),void 0,e)}static chain(t,s=!0){const e=t.length;return ts3dutils.arrayFromFunction(s?e:e-1,s=>StraightEdge$$1.throughPoints(t[s],t[(s+1)%e]))}toSource(){return ts3dutils.callsce("new StraightEdge",this.curve,this.a,this.b,this.aT,this.bT)}getVerticesNo0(){return[this.b]}pointsCount(){return 2}points(){return[this.a,this.b]}edgeISTsWithPlane(t){const s=ts3dutils.snap2(this.curve.isTWithPlane(t),this.aT,this.bT);return this.minT<=s&&s<=this.maxT?[s]:[]}edgeISTsWithSurface(t){return t instanceof PlaneSurface$$1?this.edgeISTsWithPlane(t.plane):t.isTsForLine(this.curve).map(t=>ts3dutils.snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(){return this.tangent}flipped(){return this.flippedOf||(this.flippedOf=new StraightEdge$$1(this.curve,this.b,this.a,this.bT,this.aT,this,this.name))}transform(t,s){const e=t.transformVector2(this.curve.dir1,this.curve.anchor).length(),i=this.curve.transform(t),r=t.transformPoint(this.a),n=t.transformPoint(this.b);return new StraightEdge$$1(i,r,n,t.isNoProj()?this.aT*e:i.pointT(r),t.isNoProj()?this.bT*e:i.pointT(n),void 0,""+this.name+s)}transform4(t,s){const e=t.transformVector2(this.curve.dir1,this.curve.anchor).length(),i=this.curve.transform4(t),r=t.transformPoint(this.a),n=t.transformPoint(this.b);return new StraightEdge$$1(i,r,n,t.isNoProj()?this.aT*e:i.pointT(r),t.isNoProj()?this.bT*e:i.pointT(n),void 0,""+this.name+s)}isCoEdge(t){return this===t||this===t.flippedOf||t.constructor===StraightEdge$$1&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}getEdgeT(t){ts3dutils.assertVectors(t);let s=t.minus(this.curve.anchor).dot(this.curve.dir1);if(ts3dutils.eq0(this.curve.at(s).distanceTo(t)))return s=ts3dutils.snap2(s,this.aT,this.bT),this.minT<=s&&s<=this.maxT?s:void 0}}class FaceInfoFactory{static makeStatic(t){return new class extends FaceInfoFactory{constructor(){super()}info(s,e,i){return t}}}info(t,s,e){throw new Error("no default implementation")}extrudeBottom(t,s,e=[]){return this.info(t,s,e)}extrudeTop(t,s,e=[]){return this.info(t,s,e)}extrudeWall(t,s,e,i=[]){return this.info(s,e,i)}rotationWall(t,s,e,i=[]){return this.info(s,e,i)}rotationStart(t,s,e=[]){return this.info(t,s,e)}rotationEnd(t,s,e=[]){return this.info(t,s,e)}newSubFace(t,s,e,i=[]){return t.info}transform(t,s,e,i,r,n=[]){return t.info}}class Face$$1 extends ts3dutils.Transformable{constructor(t,s,e=[],i,r){super(),this.surface=t,this.contour=s,this.holes=e,this.name=i,this.info=r,this.aabb=void 0,Edge$$1.assertLoop(s),ts3dutils.assert(s.every(t=>t instanceof Edge$$1),()=>"contour.every(f => f instanceof Edge)"+s),e&&e.forEach(t=>Edge$$1.assertLoop(t)),e&&e.forEach(s=>ts3dutils.assert(!t.edgeLoopCCW(s))),ts3dutils.assert(!e||e.constructor==Array,e&&e.toString()),this.allEdges=Array.prototype.concat.apply(this.contour,this.holes)}static assembleFacesFromLoops(t,s,e){const i=[],r=[];return t.forEach(t=>(function t(e,i){if(0==i.length)i.push(e);else{const r=i.find(t=>BRep$$1.loop1ContainsLoop2(t.loop,t.ccw,e.loop,e.ccw,s));if(r)t(e,r.subloops);else{for(let t=i.length;--t>=0;){const r=i[t];BRep$$1.loop1ContainsLoop2(e.loop,e.ccw,r.loop,r.ccw,s)&&(e.subloops.push(r),i.splice(t,1))}i.push(e)}}})({loop:t,ccw:s.edgeLoopCCW(t),subloops:[]},r)),r.forEach(t=>(function t(r){i.push(new e(s,r.ccw?r.loop:Edge$$1.reversePath(r.loop),r.subloops.map(t=>t.ccw?Edge$$1.reversePath(t.loop):t.loop))),r.subloops.forEach(s=>s.subloops.forEach(s=>t(s)))})(t)),i}static create(t,s,e,i,r){return t instanceof PlaneSurface$$1?new PlaneFace$$1(t,s,e,i,r):new RotationFace$$1(t,s,e,i,r)}intersectFace(t,s,e,i,r,n,o){function a(t,s){return o.has(new javasetmap_ts.Pair(t,s))}function u(t,s){return o.add(new javasetmap_ts.Pair(t,s))}function l(o,l,c){if(!l&&!c){let s=h.surface.normalP(o.a).cross(t.surface.normalP(o.a));if(s.likeO()){const e=ts3dutils.lerp(o.aT,o.bT,1/ts3dutils.GOLDEN_RATIO),i=o.curve.at(e);s=h.surface.normalP(i).cross(t.surface.normalP(i))}if(s.likeO()){const s=o.a,e=P3$$1.normalOnAnchor(o.aDir,s),r=h.surface.normalP(s),n=r.dot(t.surface.normalP(s))>0,a=e.normal1.cross(r),u=h.surface.isCurvesWithPlane(e)[0],l=u.pointT(s),c=sign(a.dot(u.tangentAt(l))),d=t.surface.isCurvesWithPlane(e)[0],p=d.pointT(s),f=sign(a.dot(u.tangentAt(p))),m=u.diff(l,EPS$$1*c).dot(r),$=d.diff(p,EPS$$1*f).dot(r);$<m&&ts3dutils.mapPush(i,t,n?o.flipped():o),r.dot(t.surface.normalP(s))<0==$<m&&ts3dutils.mapPush(i,h,o.flipped());const g=u.diff(l,EPS$$1*c).dot(r),v=d.diff(p,EPS$$1*f).dot(r);v<g&&ts3dutils.mapPush(i,t,n?o:o.flipped()),n!=v<g&&ts3dutils.mapPush(i,h,o)}else s.dot(o.aDir)<0&&(o=o.flipped()),ts3dutils.mapPush(i,h,o),ts3dutils.mapPush(i,t,o.flipped());return!0}function d(t,s,e,r,n,u,l,c,h){if(t&&!s){if(a(t.getCanon(),r))return!1;const s=r.surface;n.edgeFaces.get(t.getCanon()).forEach(t=>{const s=fff$$1(t,r.surface),e=s==INSIDE$$1||!l&&s==COPLANAR_SAME$$1,n=t.edge.tangentAt(t.edge.curve.pointT(o.a)).like(o.aDir)?o:o.flipped();console.log(o.sce),ts3dutils.assert(t.edge.tangentAt(t.edge.curve.pointT(n.a)).like(n.aDir)),e&&ts3dutils.mapPush(i,t.face,n)});const e=s.normalP(o.a),u=e.cross(o.aDir),c=splitsVolumeEnclosingFacesP$$1(n,t.getCanon(),o.a,u,e);let h,d;(h=c==INSIDE$$1||l&&c==COPLANAR_SAME$$1)&&ts3dutils.mapPush(i,r,o);const p=splitsVolumeEnclosingFacesP$$1(n,t.getCanon(),o.a,u.negated(),e);if((d=p==INSIDE$$1||l&&p==COPLANAR_SAME$$1)&&ts3dutils.mapPush(i,r,o.flipped()),h||d||c==COPLANAR_SAME$$1&&p==INSIDE$$1||p==COPLANAR_SAME$$1&&c==INSIDE$$1)return!0}return!1}const p=d(l,c,0,t,s,0,!1),f=d(c,l,0,h,e,0,!0);if(p||f)return!0;if(l&&c){if(a(l.getCanon(),c.getCanon()))return!1;function m(t,s,e,r,n,a,u,l){for(const u of e.edgeFaces.get(t.getCanon())){const e=splitsVolumeEnclosingFaces$$1(r,s.getCanon(),u.inside,u.normalAtCanonA),l=e==INSIDE$$1||n&&e==COPLANAR_SAME$$1,c=u.edge.aDir.like(o.aDir)?o:o.flipped();if(l){ts3dutils.mapPush(i,u.face,c);const s=t.getCanon().curve.pointT(o.a);ts3dutils.eq(s,t.aT)||ts3dutils.eq(s,t.bT)||splitsVolumeEnclosingCone2$$1(r,o.a,o.curve,o.aT,-Math.sign(o.deltaT()))==INSIDE$$1&&ts3dutils.mapPush(a,t.getCanon(),{p:o.a,edgeT:s});const e=t.getCanon().curve.pointT(o.b);ts3dutils.eq(e,t.aT)||ts3dutils.eq(e,t.bT)||splitsVolumeEnclosingCone2$$1(r,o.b,o.curve,o.bT,Math.sign(o.deltaT()))==INSIDE$$1&&ts3dutils.mapPush(a,t.getCanon(),{p:o.b,edgeT:e})}}}return u(l.getCanon(),c.getCanon()),m(l,c,s,e,!0,r),m(c,l,e,s,!1,n),!1}return!1}function c(t,i,o){if(t&&!i&&(t.colinear||t.edgeT==t.edge.aT||t.edgeT==t.edge.bT||(ts3dutils.mapPush(r,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))),i&&!t&&(i.colinear||i.edgeT==i.edge.aT||i.edgeT==i.edge.bT||(ts3dutils.mapPush(n,i.edge.getCanon(),i),ts3dutils.assert(i.edge.isValidT(i.edgeT)))),t&&i){function a(t,s,e,i,r,n,o,a,l,c){if(!t.colinear&&t.edgeT!=t.edge.aT&&t.edgeT!=t.edge.bT)if(u(t.edge.getCanon(),s.edge.getCanon()),t.p.like(s.edge.a)||t.p.like(s.edge.b)){const e=t.p.like(s.edge.a)?s.edge.a:s.edge.b,i=splitsVolumeEnclosingCone2$$1(a,e,t.edge.curve,t.edgeT,1),r=splitsVolumeEnclosingCone2$$1(a,e,t.edge.curve,t.edgeT,-1);INSIDE$$1!=i&&INSIDE$$1!=r||(ts3dutils.mapPush(c,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))}else{const e=splitsVolumeEnclosingFacesP2$$1(a,s.edge.getCanon(),t.p,t.edge.curve,t.edgeT,1,r.normalP(t.p)),i=splitsVolumeEnclosingFacesP2$$1(a,s.edge.getCanon(),t.p,t.edge.curve,t.edgeT,-1,r.normalP(t.p));(INSIDE$$1==e||l&&COPLANAR_SAME$$1==e||INSIDE$$1==i||l&&COPLANAR_SAME$$1==i)&&(ts3dutils.mapPush(c,t.edge.getCanon(),t),ts3dutils.assert(t.edge.isValidT(t.edgeT)))}}ts3dutils.assert(t.colinear||i.colinear||ts3dutils.eq(t.t,i.t)),a(t,i,0,0,d,0,0,e,!0,r),a(i,t,0,0,p,0,0,s,!1,n)}}ts3dutils.assertInst(Face$$1,t);const h=this,d=h.surface,p=t.surface;if(!this.getAABB().touchesAABBfuzzy(t.getAABB()))return;if(d.isCoplanarTo(p))return;const f=d.isCurvesWithSurface(p);if(0!=f.length){for(const t of f)ts3dutils.assert(d.containsCurve(t)),ts3dutils.assert(p.containsCurve(t));for(let s=0;s<f.length;s++){const e=f[s],i=h.edgeISPsWithSurface(e,t.surface),r=t.edgeISPsWithSurface(e,h.surface);function m(t,s){return 0==t.length?isFinite(e.tMin)&&s.containsPoint2(e.at(e.tMin))==exports.PointVsFace.INSIDE:t[0].insideDir.dot(e.tangentAt(t[0].t))<0}ts3dutils.assertf(()=>0==i.length||!ts3dutils.eq0(i[0].insideDir.dot(e.tangentAt(i[0].t))),()=>i[0].insideDir.dot(e.tangentAt(i[0].t))),ts3dutils.assertf(()=>0==r.length||!ts3dutils.eq0(r[0].insideDir.dot(e.tangentAt(r[0].t))),()=>r[0].insideDir.dot(e.tangentAt(r[0].t)));let n,o,a=m(i,h),u=m(r,t);if(0==i.length&&!a||0==r.length&&!u)continue;let d,p,$,g,v=0,P=0,x=a&&u?e.at(e.tMin):void 0,C=e.tMin;for(;v<i.length||P<r.length;){ts3dutils.assert(v<=i.length),ts3dutils.assert(P<=r.length);const t=i[v],s=r[P];if(ts3dutils.assert(t||s),P==r.length||v<i.length&&ts3dutils.lt(t.t,s.t)?(d=t,a=!a,t.used=!0,n=t.colinear?t:void 0,v++):v==i.length||ts3dutils.gt(t.t,s.t)?(d=s,s.used=!0,u=!u,o=s.colinear?s:void 0,P++):(d=t,t.used=!0,s.used=!0,a=!a,u=!u,n=t.colinear?t:void 0,o=s.colinear?s:void 0,v++,P++),!x||a&&u)a&&u&&(x=d.p,p=d.insideDir,C=d.t,$=t&&t.used?t:void 0,g=s&&s.used?s:void 0);else{if(p=e.tangentAt(C),ts3dutils.eq(C,d.t)){x=void 0;continue}ts3dutils.assert(ts3dutils.lt(C,d.t)),C>d.t&&(p=p.negated());let i=e.tangentAt(d.t);C>d.t&&(i=i.negated());const r=Edge$$1.create(e,x,d.p,C,d.t,void 0,p,i,"genseg"+getGlobalId$$1());x=void 0,l(r,n&&n.edge,o&&o.edge)&&(c($||n,g||o),c(t&&t.used&&t||n,s&&s.used&&s||o))}}if(a&&u&&C!==e.tMax){const t=e.tMax;p=e.tangentAt(C),C>t&&(p=p.negated());let s=e.tangentAt(t);C>t&&(s=s.negated());const i=Edge$$1.create(e,x,e.at(t),C,t,void 0,p,s,"genseg"+getGlobalId$$1());l(i,n&&n.edge,o&&o.edge)&&c($||n,g||o)}}h.getAllEdges().forEach(s=>{o.add(new javasetmap_ts.Pair(s.getCanon(),t))}),t.getAllEdges().forEach(t=>{o.add(new javasetmap_ts.Pair(t.getCanon(),h))})}}edgeISPsWithSurface(t,s){const e=this.surface,i=this.holes.concat([this.contour]),r=[];for(const n of i){const i=n.map(s=>s.curve.isColinearTo(t));for(let o=0;o<n.length;o++){const a=n[o],u=(o+1)%n.length,l=n[u];if(i[o]){if(t.containsPoint(a.a)){const s=(o-1+n.length)%n.length,u=n[s],l=t.pointT(a.a),c=a.aDir.cross(e.normalP(a.a));!i[s]&&dotCurve2$$1(u.curve,u.bT,c,-sign(u.deltaT()))>0&&r.push({p:u.b,insideDir:a.aDir.negated(),t:l,edge:u,edgeT:u.bT,colinear:!1}),r.push({p:a.a,insideDir:a.aDir,t:l,edge:a,edgeT:a.aT,colinear:!0})}if(t.containsPoint(a.b)){const s=t.pointT(a.b),n=a.bDir.cross(e.normalP(a.b));!i[u]&&dotCurve2$$1(l.curve,l.aT,n,sign(l.deltaT()))>0&&r.push({p:a.b,insideDir:a.bDir,t:s,edge:l,edgeT:l.aT,colinear:!1}),r.push({p:a.b,insideDir:a.bDir.negated(),t:s,edge:a,edgeT:a.bT,colinear:!0})}}else{const n=a.edgeISTsWithSurface(s);for(const s of n){const n=a.curve.at(s);if(!t.containsPoint(n))continue;const o=t.pointT(n);ts3dutils.assert(!isNaN(o));const l=a.tangentAt(s).cross(e.normalP(n)).negated(),c=t.tangentAt(o);if(s==a.bT){if(!i[u]){if(!ts3dutils.eq(o,t.tMax)){const s=this.pointsToInside3(a.b,t,o,1);ts3dutils.assert(s!=exports.PointVsFace.ON_EDGE),exports.PointVsFace.INSIDE==s&&r.push({p:a.b,insideDir:c,t:o,edge:a,edgeT:a.bT,colinear:!1})}if(!ts3dutils.eq(o,t.tMin)){const s=this.pointsToInside3(a.b,t,o,-1);ts3dutils.assert(s!=exports.PointVsFace.ON_EDGE),exports.PointVsFace.INSIDE==s&&r.push({p:a.b,insideDir:c.negated(),t:o,edge:a,edgeT:a.bT,colinear:!1})}}}else if(s!=a.aT)if(ts3dutils.eq0(l.dot(c))){const e=sign(c.dot(a.curve.tangentAt(s))),i=1e-4;for(const u of[-1,1]){if(-1==u*e&&s==a.minT||1==u*e&&s==a.maxT||-1==u&&o==t.tMin||1==u&&o==t.tMax)continue;t.at(o).to(t.at(o+u*i)).dot(l)-a.curve.at(s).to(a.curve.at(s+u*e*i)).dot(l)>0&&r.push({p:n,insideDir:c.times(u),t:o,edge:a,edgeT:s,colinear:!1})}}else r.push({p:n,insideDir:l,t:o,edge:a,edgeT:s,colinear:!1})}}}}return r.sort((s,e)=>s.t-e.t||s.insideDir.dot(t.tangentAt(s.t))),r}transform(t){const s=t.isMirroring(),e=Edge$$1.reversePath(this.contour.map(s=>s.transform(t)),s),i=this.holes.map(e=>Edge$$1.reversePath(e.map(s=>s.transform(t)),s));return new this.constructor(this.surface.transform(t),e,i,this.name,this.info)}transform4(t){const s=t.isMirroring(),e=Edge$$1.reversePath(this.contour.map(s=>s.transform4(t)),s),i=this.holes.map(e=>Edge$$1.reversePath(e.map(s=>s.transform4(t)),s));return new this.constructor(this.surface.transform4(t),e,i,this.name,this.info)}flipped(){const t=this.contour.map(t=>t.flipped()).reverse(),s=this.holes.map(t=>t.map(t=>t.flipped()).reverse());return new this.constructor(this.surface.flipped(),t,s,this.name,this.info)}toString(){return"new "+this.constructor.name+"("+this.surface+", ["+this.contour.map(t=>"\n\t"+t).join()+"]"+this.holes.map(t=>"\n\t\thole: "+t.join())+")"}toSource(){return"new "+this.constructor.name+"("+this.surface.toSource()+", ["+this.contour.map(t=>"\n\t"+t.toSource()+",").join("")+"], ["+this.holes.map(t=>"["+t.map(t=>"\n\t"+t.toSource()+",").join("")+"]").join(",")+"])"}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.holes.length==t.holes.length&&Edge$$1.loopsEqual(this.contour,t.contour)&&this.holes.every(s=>t.holes.some(t=>Edge$$1.loopsEqual(s,t)))}hashCode(){function t(t){let s=0;for(const e of t)s=31*s+e|0;return s}function s(s){return t(s.map(t=>t.hashCode()).sort(ts3dutils.MINUS))}let e=0;return e=31*(e=31*(e=31*e+t(this.holes.map(t=>s(t)).sort(ts3dutils.MINUS))|0)+s(this.contour)|0)+this.surface.hashCode()|0}likeFace(t){function s(t,s){return t.length==s.length&&ts3dutils.arrayRange(0,t.length,1).some(e=>t.every((i,r)=>i.like(s[(e+r)%t.length])))}return ts3dutils.assertInst(Face$$1,t),this.surface.like(t.surface)&&this.holes.length==t.holes.length&&s(this.contour,t.contour)&&this.holes.every(e=>t.holes.some(t=>s(e,t)))}getAllEdges(){return this.allEdges}addEdgeLines(t){ts3dutils.assert(!1,"buggy, fix");const s=this.contour.flatMap(t=>t.getVerticesNo0()),e=t.vertices.length;for(let i=0;i<s.length;i++)t.vertices.push(s[i]),t.LINES.push(e+i,e+(i+1)%s.length)}containsPoint(t){return ts3dutils.assertVectors(t),this.surface.loopContainsPoint(this.contour,t)!=exports.PointVsFace.OUTSIDE&&!this.holes.some(s=>this.surface.loopContainsPoint(s,t)!=exports.PointVsFace.OUTSIDE)}containsPoint2(t){ts3dutils.assertVectors(t);const s=this.surface.loopContainsPoint(this.contour,t);if(s!=exports.PointVsFace.INSIDE)return s;for(const s of this.holes){const e=this.surface.loopContainsPoint(s,t);if(e!=exports.PointVsFace.OUTSIDE)return e==exports.PointVsFace.ON_EDGE?exports.PointVsFace.ON_EDGE:exports.PointVsFace.OUTSIDE}return exports.PointVsFace.INSIDE}intersectsLine(t){if(ts3dutils.assertInst(L3$$1,t),!this.getAABB().intersectsLine(t))return NaN;const s=this.surface.isTsForLine(t).filter(s=>this.containsPoint(t.at(s))).withMax(t=>-t);return void 0!=s?s:NaN}toMesh(){const t=(new tsgl.Mesh).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES").addVertexBuffer("normals","ts_Normal");return this.addToMesh(t),t}zDirVolume(){return this.surface.zDirVolume(this.getAllEdges())}calcArea(){return this.surface.calculateArea(this.getAllEdges())}getLoops(){return[this.contour,...this.holes]}getAABB(){return this.aabb||(this.aabb=ts3dutils.AABB.forAABBs(this.contour.map(t=>t.getAABB())))}pointsToInside3(t,s,e,i){const r=this.surface.normalP(t),n=s.tangentAt(e).times(i),o=r.cross(n),a=s.at(e).to(s.at(e+1e-6*i)).dot(o);let u,l=1/0,c=!1;for(const e of this.getAllEdges()){const i=e.a.like(t),h=e.b.like(t);if(ts3dutils.assert(i==e.a.like(t)),ts3dutils.assert(h==e.b.like(t)),!i&&!h)continue;const d=i?e.aDir:e.bDir.negated(),p=n.angleRelativeNormal(d,r);if(ts3dutils.eq0(p)){if(s.isColinearTo(e.curve))return exports.PointVsFace.ON_EDGE;const t=i?e.aT:e.bT,r=(i?1:-1)*sign(e.deltaT()),n=e.curve.diff(t,1e-6*r).dot(o)-a;n>0&&(!c||n<l)&&(c=!0,l=n,u=i?exports.PointVsFace.OUTSIDE:exports.PointVsFace.INSIDE)}else if(!c){const t=(p+ts3dutils.TAU)%ts3dutils.TAU;t<l&&(l=t,u=i?exports.PointVsFace.OUTSIDE:exports.PointVsFace.INSIDE)}}if(void 0==u)throw new Error;return u}pointsToInside2(t,s){return this.pointsToInside3(t,L3$$1.anchorDirection(t,s),0,1)}}class PlaneFace$$1 extends Face$$1{constructor(t,s,e,i,r){ts3dutils.assert(t instanceof P3$$1||t instanceof PlaneSurface$$1),super(t instanceof P3$$1?new PlaneSurface$$1(t):t,s,e,i,r)}static forVertices(t,s,...e){const i=t instanceof P3$$1?new PlaneSurface$$1(t):t;ts3dutils.assert(ts3dutils.isCCW(s,i.plane.normal1),"isCCW(vs, planeSurface.plane.normal1)");const r=StraightEdge$$1.chain(s);e.forEach(t=>ts3dutils.assert(ts3dutils.doubleSignedArea(t,i.plane.normal1)>=0,"doubleSignedArea(vs, planeSurface.plane.normal1) >= 0"));const n=e.map(t=>StraightEdge$$1.chain(t));return new PlaneFace$$1(t,r,n)}addToMesh(t){const s=t.vertices.length,e=this.surface.plane.normal1,i=this.contour.flatMap(t=>t.getVerticesNo0());for(let e=0;e<i.length;e++)t.LINES.push(s+e,s+(e+1)%i.length);const r=[];this.holes.forEach(t=>{r.push(i.length),i.push(...t.flatMap(t=>t.getVerticesNo0()))});const n=triangulateVertices$$1(e,i,r).map(t=>t+s);Array.prototype.push.apply(t.vertices,i),Array.prototype.push.apply(t.TRIANGLES,n),Array.prototype.push.apply(t.normals,ts3dutils.arrayFromFunction(i.length,()=>e))}intersectsLine(t){ts3dutils.assertInst(L3$$1,t);const s=t.isTWithPlane(this.surface.plane);return Number.isFinite(s)&&this.containsPoint(t.at(s))?s:NaN}withHole(t){return new PlaneFace$$1(this.surface,this.contour,[t])}pointsToInside(t,s){return this.containsPoint2(t.plus(s.times(8*ts3dutils.NLA_PRECISION)))}edgeISPsWithPlane(t,s){ts3dutils.assert(this.surface.plane.containsLine(t)),ts3dutils.assert(s.containsLine(t));const e=this.surface.plane,i=[];return[this.contour].concat(this.holes).forEach(r=>{const n=r.map(s=>s.colinearToLine(t)&&-sign(s.aDir.dot(t.dir1))),o=t.dir1.cross(e.normal1);r.forEach((e,r,a)=>{const u=(r+1)%a.length,l=a[u],c=n[r];if(c){const s=t.pointT(e.a),r=t.pointT(e.b);i.push({p:e.a,insideDir:e.aDir,t:s,edge:e,edgeT:e.aT,colinear:!0},{p:e.b,insideDir:e.bDir.negated(),t:r,edge:e,edgeT:e.bT,colinear:!0}),c*(n[u]||dotCurve2$$1(l.curve,l.aT,o,l.deltaTSign()))<0&&i.push({p:l.a,insideDir:e.bDir,t:r,edge:l,edgeT:l.aT,colinear:!1})}else{const r=e.edgeISTsWithPlane(s);ts3dutils.assert(r.every(t=>s.containsPoint(e.curve.at(t))),r);for(const a of r)if(a==e.bT){dotCurve2$$1(e.curve,e.bT,o,-e.deltaTSign())*(n[u]||dotCurve2$$1(l.curve,l.aT,o,l.deltaTSign()))<0&&i.push({p:e.b,insideDir:s.normal1.negated(),t:t.pointT(e.b),edge:e,edgeT:e.bT,colinear:!1})}else if(a!=e.aT){const r=e.curve.at(a);ts3dutils.assert(s.containsPoint(r),e.toString(),r,a,s.distanceToPoint(r)),ts3dutils.assert(t.containsPoint(r),e.toString(),r,a,t.distanceToPoint(r));const n=s.normal1.negated();i.push({p:r,insideDir:n,t:t.pointT(r),edge:e,edgeT:a,colinear:!1})}}})}),i.sort((s,e)=>s.t-e.t||s.insideDir.dot(t.dir1)),i}}class RotationFace$$1 extends Face$$1{constructor(t,s,e,i,r){super(t,s,e,i,r)}static loopDoesNotCrossPlane(t,s){let e=0;function i(t){return 0!=e?!e||e*t<0:(e=t,!1)}for(const e of t){const t=e.edgeISTsWithPlane(s);if(0==t.length){if(!(e.curve instanceof L3$$1)&&i(s.distanceToPointSigned(e.a)))return!1}else for(const r of t){if(e.aT!=r&&i(dotCurve2$$1(e.curve,r,s.normal1,-e.deltaTSign())))return!1;if(e.bT!=r&&i(dotCurve2$$1(e.curve,r,s.normal1,e.deltaTSign())))return!1}}return!0}getAABB(){return this.aabb?this.aabb:(this.aabb=ts3dutils.AABB.forAABBs(this.contour.map(t=>t.getAABB())),this.aabb.addPoints(this.surface.getExtremePoints().filter(t=>this.containsPoint(t))),this.aabb)}unrollLoop(t){const s=[],e=this.surface.uvPFunc(),i=t.map(t=>t.getVerticesNo0()),r=i.findIndex(t=>!ts3dutils.eq(e(t[0]).x,Math.PI));ts3dutils.assert(-1!=r);for(let n=0;n<t.length;n++){const o=(n+r)%t.length;for(let t=0;t<i[o].length;t++){const r=i[o][t],n=e(r);s.push(n)}}return t.forEach(t=>{t.getVerticesNo0().forEach(t=>{s.push(e(t))})}),console.log("vs\n",s.join("\n"),s.length),s}unrollEllipsoidLoops(t){const s=[],e=[],i=[],r=this.surface,n=r.uvPFunc(),o=r instanceof EllipsoidSurface$$1?t=>t.like(r.center.plus(r.f3))||t.like(r.center.minus(r.f3)):t=>t.like(this.surface.center);for(const a of t){i.push(s.length);for(let t=0;t<a.length;t++){const i=(t+1)%a.length,u=a[t].getVerticesNo0();if(e.push(...u),s.push(...u.map(t=>n(t))),o(a[i].a)){const n=r.matrixInverse.transformVector(a[t].bDir),o=r.matrixInverse.transformVector(a[i].aDir),u=Math.atan2(-n.y,-n.x),l=Math.atan2(o.y,o.x),c=s.pop();s.push(new ts3dutils.V3(u,c.y,0),new ts3dutils.V3(l,c.y,0)),e.push(e.last)}s.forEach(({u:t,v:s})=>{ts3dutils.assert(isFinite(t)),ts3dutils.assert(isFinite(s))})}}let a;if(this.surface instanceof EllipsoidSurface$$1)a=e.map(t=>r.normalP(t));else{const t=r.normalUVFunc();a=s.map(({u:s,v:e})=>t(s,e))}return ts3dutils.assert(e.length==e.length),{verticesUV:s,vertices:e,normals:a,loopStarts:i}}unrollCylinderLoops(t){const s=t.map(t=>t.flatMap(t=>t.getVerticesNo0())),e=this.surface,i=s.concatenated(),r=s.reduce((t,s)=>(t.push(t.last+s.length),t),[0]),n=e.uvPFunc(),o=i.map(t=>n(t)),a=e.normalUVFunc();return{verticesUV:o,vertices:i,normals:o.map(({u:t,v:s})=>a(t,s)),loopStarts:r}}addToMesh(t,s=this.surface.uStep,e=this.surface.vStep){ts3dutils.assertf(()=>s>0&&e>0,s,e,"Surface: "+this.surface);const i=[],r=(t,i)=>this.surface.pUVFunc()(t*s,i*e),n=(t,i)=>this.surface.normalUVFunc()(t*s,i*e),o=this.getLoops(),{vertices:a,verticesUV:u,normals:l,loopStarts:c}=this.surface instanceof EllipsoidSurface$$1||this.surface instanceof ConicSurface$$1?this.unrollEllipsoidLoops(o):this.unrollCylinderLoops(o);c.push(a.length);const h=u.map(({u:t,v:i})=>new ts3dutils.V3(t/s,i/e,0));for(let s=0;s<o.length;s++){const e=c[s],i=c[s+1]-e,r=t.vertices.length+c[s];for(let s=0;s<i;s++)t.LINES.push(r+s,r+(s+1)%i)}ts3dutils.disableConsole();let d=1/0,p=-1/0,f=1/0,m=-1/0;h.forEach(([t,s])=>{ts3dutils.assert(isFinite(t)),ts3dutils.assert(isFinite(s)),d=min(d,t),p=max(p,t),f=min(f,s),m=max(m,s)}),ParametricSurface$$1.is(this.surface);const $=floor(d+ts3dutils.NLA_PRECISION),g=floor(f+ts3dutils.NLA_PRECISION),v=ceil(p-ts3dutils.NLA_PRECISION)-$,P=ceil(m-ts3dutils.NLA_PRECISION)-g;if(console.log(s,e,v,P),1==v&&1==P){const t=triangulateVertices$$1(ts3dutils.V3.Z,h,c.slice(1,1+this.holes.length));i.push(...t)}else{const t=new Array(v*P);function x(s,e,i){ts3dutils.assert(e<v&&i<P,`${e}, ${i}, ${v}, ${P}`),console.log("complete part",s,e,i),ts3dutils.assert(s.length);const r=e+$,n=i+g;for(const t of s)ts3dutils.assert(ts3dutils.le(r,h[t].x)&&ts3dutils.le(h[t].x,r+1),`${t} ${h[t].str} ${r} ${r}`),ts3dutils.assert(ts3dutils.le(n,h[t].y)&&ts3dutils.le(h[t].y,n+1));const o=i*v+e;(t[o]||(t[o]=[])).push(s)}for(let t=0;t<o.length;t++){let s,e=void 0,i=-1,r=-1,n=-1,o=-1,a=0;const u=c[t],l=c[t+1]-u;for(let t=0;t<l;t++){const c=u+t,d=h[c],p=u+(t+1)%l,f=h[p],m=d.to(f);ts3dutils.assert(d);const M=m.x,V=m.y;let w=c,S=d,T=0,I=400;for(;--I;){const t=floor(S.u+(ts3dutils.eq0(M)?-sign(V):sign(M))*ts3dutils.NLA_PRECISION)-$,u=floor(S.v+(ts3dutils.eq0(V)?sign(M):sign(V))*ts3dutils.NLA_PRECISION)-g;ts3dutils.assert(t<v&&u<P,`${t}, ${u}, ${v}, ${P}`);const l=ceil(sign(M)*S.u+ts3dutils.NLA_PRECISION)-sign(M)*S.u,c=ceil(sign(V)*S.v+ts3dutils.NLA_PRECISION)-sign(V)*S.v,h=T+l/abs(M),m=T+c/abs(V);if(n==t&&o==u||(e&&(s?(a++,x(e,n,o)):(s=e,i=n,r=o)),e=[w]),n=t,o=u,T=min(h,m),ts3dutils.ge(T,1)){e.push(p);break}{const t=d.lerp(f,T),s=C(t.x,t.y);e.push(s),S=t,w=s}}ts3dutils.assert(I,"whileLimit")}0==a&&ts3dutils.assert(!1,"found a hole, try increasing resolution"),i==n&&r==o?(e.pop(),x(e.concat(s),n,o)):(x(s,i,r),x(e,n,o)),console.log("firstPart",s)}console.log("calculated parts",t);const s=new Array((v+1)*(P+1));function C(t,s){return h.push(new ts3dutils.V3(t,s,0)),l.push(n(t,s)),a.push(r(t,s))-1}function M(t,e){const i=e*(v+1)+t;return s[i]||(s[i]=C(t+$,e+g))}for(let s=0;s<v;s++){let e=!1;for(let r=0;r<P;r++){const n=$+s,o=g+r,a=t[r*v+s];if(a){function V(t){const s=h[t],e=s.x-n,i=s.y-o;return ts3dutils.assert(-ts3dutils.NLA_PRECISION<e&&e<1+ts3dutils.NLA_PRECISION&&-ts3dutils.NLA_PRECISION<i&&i<1+ts3dutils.NLA_PRECISION,"oob u1 v1 "+e+" "+i+" "+t+" "+s.str+"IF THIS FAILS check canonSeamU is correct"),i<e?e+i:4-e-i}for(;a.length;){const t=[],n=a[0];ts3dutils.assert(n.length>0);let o=n;do{t.push(...o);const i=V(o.last),n=a.indexWithMax(t=>-ts3dutils.mod(V(t[0])-i,4)),u=a.removeIndex(n);let l=i;const c=V(u[0])>l?V(u[0]):V(u[0])+4;let h=ceil(l+ts3dutils.NLA_PRECISION),d=ts3dutils.eq0((l+ts3dutils.NLA_PRECISION)%1-ts3dutils.NLA_PRECISION);for(;ts3dutils.lt(h,c);){switch(h%4){case 0:t.push(M(s,r));break;case 1:e=e!=d,t.push(M(s+1,r));break;case 2:t.push(M(s+1,r+1));break;case 3:e=e!=d,t.push(M(s,r+1))}d=!0,h++}e=e!=(d&&h%2==1&&ts3dutils.eq(h,c)),l=h,o=u}while(o!=n);if(3==t.length)i.push(...t);else{const s=triangulateVertices$$1(ts3dutils.V3.Z,t.map(t=>h[t]),[]).map(s=>t[s]);i.push(...s)}}}else e&&tsgl.pushQuad(i,!1,M(s,r),M(s+1,r),M(s,r+1),M(s+1,r+1))}}}Array.prototype.push.apply(t.TRIANGLES,i.map(s=>s+t.vertices.length)),Array.prototype.push.apply(t.vertices,a),Array.prototype.push.apply(t.normals,l),ts3dutils.enableConsole()}addToMesh2(t){const s=[];let e=1/0,i=-1/0;const r=this.surface.pUVFunc(),n=this.surface.normalUVFunc(),o=this.holes.concat([this.contour]).map(t=>this.unrollLoop(t));o.forEach(t=>{t.forEach(({x:t,y:r})=>{const n=s.binaryIndexOf(t,(t,s)=>ts3dutils.snap(t.value-s,0));n<0&&s.splice(-n-1,0,{value:t,left:[],right:[]}),e=min(e,r),i=max(i,r)})}),console.log("zzzs",e,i,o[0].toSource().replace(/\), /g,",\n"));o.forEach(t=>{t.forEach((t,e,i)=>{let r=i[(e+1)%i.length],n=r.x-t.x;if(ts3dutils.eq0(n))return;n<0&&([t,r]=[r,t],n=-n);const o=s.binaryIndexOf(t.x,(t,s)=>ts3dutils.snap(t.value-s,0)),a=s.binaryIndexOf(r.x,(t,s)=>ts3dutils.snap(t.value-s,0));s[o].right.binaryInsert(t.y);for(let e=(o+1)%s.length;e!=a;e=(e+1)%s.length){const i=(s[e].value-t.x)/n,o=r.y*i+t.y*(1-i);s[e].left.binaryInsert(o),s[e].right.binaryInsert(o)}s[a].left.binaryInsert(r.y)})});const a=[],u=[],l=[];for(let t=0;t<s.length;t++){const e=s[t],i=s[(t+1)%s.length];ts3dutils.assert(e.right.length==i.left.length);for(let t=0;t<e.right.length;t++)a.push(r(e.value,e.right[t]),r(i.value,i.left[t])),l.push(n(e.value,e.right[t]),n(i.value,i.left[t]))}const c=a.length,h=(i-e)/8,d=ts3dutils.arrayFromFunction(7,t=>e+(1+t)*h);console.log("detailsZs",d);for(let t=0;t<s.length;t++){const e=s[t].value;for(let t=0;t<d.length;t++)a.push(r(e,d[t])),l.push(n(e,d[t]))}let p=0;const f=s.length-1;for(let t=0;t<f;t++){const e=(t+1)%s.length;let i=!1,r=0;const n=s[t],o=s[(t+1)%s.length];for(let s=0;s<d.length+1;s++){const a=d[s]||1e5;i?n.right[r]<a||o.left[r]<a?(tsgl.pushQuad(u,!0,c+t*d.length+s-1,c+e*d.length+s-1,p+2*r,p+2*r+1),i=!1,r++,(n.right[r]<a||o.left[r]<a)&&s--):tsgl.pushQuad(u,!0,c+t*d.length+s,c+t*d.length+s-1,c+e*d.length+s,c+e*d.length+s-1):n.right[r]<a&&o.left[r]<a&&(n.right[r+1]<a||o.left[r+1]<a?(tsgl.pushQuad(u,!0,p+2*r,p+2*(r+1),p+2*r+1,p+2*(r+1)+1),r+=2,(n.right[r]<a||o.left[r]<a)&&s--):(tsgl.pushQuad(u,!0,p+2*r,p+2*r+1,c+t*d.length+s,c+e*d.length+s),i=!0,r++))}p+=2*n.right.length}const m=u.map(s=>s+t.vertices.length);Array.prototype.push.apply(t.vertices,a),Array.prototype.push.apply(t.TRIANGLES,m),Array.prototype.push.apply(t.normals,l)}}const EPS$$1=1e-5;let globalId=0;function getGlobalId$$1(){return globalId++}function addLikeSurfaceFaces$$1(t,s,e){for(let i=0;i<t.length;i++){const r=t[i];let n=!1,o=!1;for(let t=0;t<r.length;t++){const i=r[t];i==s&&(n=!0),i==e&&(o=!0)}if(n!=o)return void r.push(n?e:s);if(n)return}t.push([s,e])}function assembleFaceFromLooseEdges$$1(t,s,e){const i=new Set;const r=[];let n,o=void 0;for(;n=t.find(t=>!i.has(t));){o=n;const e=[];let a=0;do{i.add(o),e.push(o);const r=t.filter(t=>o.b.like(t.a)),n=s.normalP(o.b),a=r.indexWithMax(t=>o.bDir.angleRelativeNormal(t.aDir,n));o=r[a]}while(n!=o&&a++<200);ts3dutils.assert(201!=a),r.push(e)}const a=BRep$$1.assembleFacesFromLoops(r,s,e);return ts3dutils.assertf(()=>1==a.length),a[0]}function calcNextEdgeIndex$$1(t,s,e){let i=-20,r=!1,n=Number.MAX_SAFE_INTEGER;const o=t.bDir.cross(e),a=sign(t.deltaT()),u=t.curve.diff(t.bT,1e-4*-a).dot(o);for(let a=s.length;a--;){const l=s[a],c=(t.bDir.negated().angleRelativeNormal(l.aDir,e)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION;if(ts3dutils.eq0(c)){if(t.curve.isColinearTo(l.curve))continue;const s=sign(l.deltaT()),e=l.curve.diff(l.aT,1e-4*s).dot(o)-u;e<0&&(!r||e>i)&&(r=!0,i=e,n=a)}else r||ts3dutils.gt(c,i)&&(i=c,n=a)}return n==Number.MAX_SAFE_INTEGER?0:n}class BRep$$1 extends ts3dutils.Transformable{constructor(t,s,e,i){super(),this.faces=t,ts3dutils.assertInst(Face$$1,...t),this.infiniteVolume=s,ts3dutils.assert(!this.infiniteVolume||!0===this.infiniteVolume),this.generator=e,this.vertexNames=i,this.edgeFaces=void 0}static loop1ContainsLoop2(t,s,e,i,r){for(const s of e){const e=r.loopContainsPoint(t,s.a);if(exports.PointVsFace.ON_EDGE!=e)return exports.PointVsFace.INSIDE==e}for(const s of e){const e=s.curve.at(.2*s.aT+.8*s.bT),i=r.loopContainsPoint(t,e);if(exports.PointVsFace.ON_EDGE!=i)return exports.PointVsFace.INSIDE==i}if(s!=i)return i;throw new Error(t.sce+e.sce)}static assembleFacesFromLoops(t,s,e,i){const r=[],n=[];return t.forEach(t=>(function t(e,i){if(0==i.length)i.push(e);else{const r=i.find(t=>BRep$$1.loop1ContainsLoop2(t.loop,t.ccw,e.loop,e.ccw,s));if(r)t(e,r.subloops);else{for(let t=i.length;--t>=0;){const r=i[t];BRep$$1.loop1ContainsLoop2(e.loop,e.ccw,r.loop,r.ccw,s)&&(e.subloops.push(r),i.splice(t,1))}i.push(e)}}})({loop:t,ccw:s.edgeLoopCCW(t),subloops:[]},n)),n.forEach(t=>(function t(n){if(n.ccw)if(n.subloops.every(t=>!t.ccw)){const o=n.subloops.map(t=>t.loop),a=i&&i.newSubFace(e,s,n.loop,o),u=new e.constructor(s,n.loop,o,"genface"+getGlobalId$$1(),a);r.push(u),n.subloops.forEach(s=>s.subloops.forEach(s=>s.ccw&&t(s)))}else n.subloops.forEach(s=>s.ccw&&t(s))})(t)),r}static join(t,s){return new BRep$$1(t.flatMap(t=>t.faces),!1,s)}containsPoint(t,s=!1){const e=[ts3dutils.V(-.3920414696448526,-.12936136783391444,-.9108068525164064),ts3dutils.V(.6520650903544943,-.07151288645511984,-.7547827667692488),ts3dutils.V(.9433494201061395,-.2402757256238473,-.22882186797013926),ts3dutils.V(.13678704228501923,-.04480387361087783,.9895867410047372),ts3dutils.V(.0662057922721913,-.5865836917435423,.8071780259955845),ts3dutils.V(-.7322576567870621,-.12953393611526787,.6685953061989045),ts3dutils.V(.6579719127258273,-.012300218400456116,.7529420075219719),ts3dutils.V(-.5576497966736425,.8006695748324647,.2189861552871446)];t:for(const i of e){const e=new L3$$1(t,i);let r=this.infiniteVolume;for(const t of this.faces){ts3dutils.assert(!t.surface.containsCurve(e));const i=t.surface.isTsForLine(e);for(const n of i){const i=e.at(n),o=t.containsPoint2(i);if(!s&&ts3dutils.assert(!ts3dutils.eq0(n)),n>0){if(o==exports.PointVsFace.ON_EDGE)continue t;o==exports.PointVsFace.INSIDE&&(r=!r)}}}return r}return!1}withMergedFaces(){const t=[];for(let s=0;s<this.faces.length;s++){let e=!1;for(let i=0;i<s;i++)if(this.faces[s].surface.isCoplanarTo(this.faces[i].surface)){const r=t.find(t=>t.includes(this.faces[i]));r&&(r.push(this.faces[s]),e=!0)}!e&&t.push([this.faces[s]])}if(console.log("likeSurfaceFaces",t),t.every(t=>1==t.length))return this;const s=[];let e=0;for(const i of t)if(console.log(i),1==i.length)s.push(i[0]);else{const t=i.flatMap(t=>t.getAllEdges());for(let s=t.length;s-- >0;)for(let i=0;i<s;i++)if(console.log("blugh",e),ts3dutils.assert(s>=0&&i>=0&&e++<500,s+" "+i+" "+e),t[s].isCoEdge(t[i])){t.splice(s,1),t.splice(i,1),s--;break}const r=assembleFaceFromLooseEdges$$1(t,i[0].surface,i[0]);s.push(r)}return new BRep$$1(s,this.infiniteVolume,this.generator&&this.generator+".withMergedFaces()",this.vertexNames)}calculateVolume(){return this.faces.map(t=>t.zDirVolume().volume).sum()}toMesh(){const t=(new tsgl.Mesh).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");t.faceIndexes=new Map;for(const s of this.faces){const e=t.TRIANGLES.length;s.addToMesh(t),t.faceIndexes.set(s,{start:e,count:t.TRIANGLES.length-e})}return t}minus(t,s){const e=this.generator&&t.generator&&this.generator+".minus("+t.generator+")";return this.intersection(t.flipped(),!0,!0,e,s)}plus(t,s){const e=this.generator&&t.generator&&this.generator+".plus("+t.generator+")";return this.flipped().intersection(t.flipped(),!0,!0,e,s).flipped()}and(t,s){const e=this.generator&&t.generator&&this.generator+".and("+t.generator+")";return this.intersection(t,!0,!0,e,s)}xor(t,s){const e=this.generator&&t.generator&&this.generator+".xor("+t.generator+")";return new BRep$$1(this.minus(t,s).faces.concat(t.minus(this,s).faces),this.infiniteVolume!=t.infiniteVolume,e)}equals(t){return this.faces.length==t.faces.length&&this.faces.every(s=>t.faces.some(t=>s.equals(t)))}like(t){return this.faces.length==t.faces.length&&this.faces.every(s=>t.faces.some(t=>s.likeFace(t)))}toString(){return`new BRep([\n${this.faces.join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}getConstructorParameters(){return[this.faces,this.infiniteVolume]}toSource(t=!0){return t&&this.generator||`new BRep([\n${this.faces.map(ts3dutils.SCE).join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}reconstituteFaces(t,s,e,i,r){const n=new Map,o=[];for(const u of t){const t=u.getAllEdges().filter(t=>!s.get(t)),l=u.getAllEdges().mapFilter(t=>s.get(t)).concatenated(),c=e.get(u)||[];if(c.length||l.length){n.set(u,"partial");const s=[];function a(){return c.find(t=>!e.has(t))||l.find(t=>!e.has(t))||t.find(t=>!e.has(t))}const e=new Set;let h;for(;h=a();){const i=h,r=[];let n=0;do{e.add(h),r.push(h);const s=t.filter(t=>h.b.like(t.a)),n=l.filter(t=>h.b.like(t.a)),o=c.filter(t=>h.b.like(t.a)),a=s.concat(n,o);if(0==a.length)break;ts3dutils.assert(0<a.length,()=>u.sce);const d=u.surface.normalP(h.b),p=calcNextEdgeIndex$$1(h,a,d);if(h=a[p],e.has(h))break;ts3dutils.assert(h),ts3dutils.assert(h!=i)}while(++n<400);400==n&&ts3dutils.assert(!1,"too many"),r.length>1&&h==i&&s.push(r)}const d=BRep$$1.assembleFacesFromLoops(s,u.surface,u,r);i.push(...d);const p=d.flatMap(t=>t.getAllEdges());o.push(...t.filter(t=>p.includes(t)))}}for(;0!=o.length;){const t=o.pop();this.edgeFaces.get(t.getCanon()).forEach(t=>{n.has(t.face)||(n.set(t.face,"inside"),o.push.apply(o,t.face.getAllEdges()))})}i.push(...t.filter(t=>"inside"==n.get(t)))}static getLooseEdgeSegments(t,s){const e=new javasetmap_ts.JavaMap;for(const[r,n]of t){if(0==n.length)continue;const t=s.get(r);n.sort((t,s)=>ts3dutils.snap0(t.edgeT-s.edgeT)||0);let o,a=r.a,u=r.aDir,l=r.aT;function i(s,i,n){for(let s=0;s<t.length;s++){const i=t[s];ts3dutils.mapPush(e,i.reversed?r.flipped():r,i.reversed?n.flipped():n)}}for(let t=0;t<n.length;t++){const s=n[t],e=r.tangentAt(s.edgeT);if(!ts3dutils.eq(s.edgeT,l)){i(0,0,Edge$$1.create(r.curve,a,s.p,l,s.edgeT,void 0,u,e,"looseSegment"+getGlobalId$$1()))}a=s.p,l=s.edgeT,o=s,u=e}if(o&&!ts3dutils.eq(l,r.bT)){i(0,0,Edge$$1.create(r.curve,a,r.b,l,r.bT,void 0,u,r.bDir,"looseSegment"+getGlobalId$$1()))}}return e}getIntersectionEdges(t){const s=new Map,e=new javasetmap_ts.JavaMap,i=new javasetmap_ts.JavaMap,r=new javasetmap_ts.JavaSet;return this.faces.forEach(n=>{t.faces.forEach(o=>{n.intersectFace(o,this,t,s,e,i,r)})}),Array.from(s.values()).concatenated()}shellCount(){const t=new Set;let s,e=0;for(;s=this.faces.find(s=>!t.has(s));){e++;const i=[s];for(;s=i.pop();)for(const e of s.getAllEdges())for(const{face:r}of this.edgeFaces.get(e.getCanon()))s===r||t.has(r)||(t.add(r),i.push(r))}return e}getAABB(){return ts3dutils.AABB.forAABBs(this.faces.map(t=>t.getAABB()))}assertSanity(){if(ts3dutils.NLA_DEBUG){this.buildAdjacencies();for(const[t,s]of this.edgeFaces)ts3dutils.assert(s.length%2==0,()=>t+s.sce)}}buildAdjacencies(){if(this.edgeFaces)return this;this.edgeFaces=new javasetmap_ts.JavaMap;for(const t of this.faces)for(const s of t.getAllEdges()){const e=s.getCanon(),i=t.surface.normalP(e.a),r=i.cross(e==s?s.aDir:s.bDir);ts3dutils.mapPush(this.edgeFaces,e,{face:t,edge:s,normalAtCanonA:i,reversed:e!=s,inside:r,angle:0})}for(const[t,s]of this.edgeFaces){const e=s.find(t=>t.reversed);e?(s.forEach(s=>{s!=e&&(s.angle=e.inside.angleRelativeNormal(s.inside,t.aDir.unit()),s.angle<0&&(s.angle+=2*Math.PI))}),s.sort((t,s)=>ts3dutils.snap(t.angle-s.angle,0))):console.warn("invalid brep")}return this}intersection(t,s,e,i,r){this.assertSanity(),t.assertSanity(),this.buildAdjacencies(),t.buildAdjacencies();const n=new Map,o=new javasetmap_ts.JavaMap,a=new javasetmap_ts.JavaMap,u=new javasetmap_ts.JavaSet;for(const s of this.faces)for(const e of t.faces)s.intersectFace(e,this,t,n,o,a,u);for(const t of o.keys())ts3dutils.assert(this.edgeFaces.get(t));for(const s of a.keys())ts3dutils.assert(t.edgeFaces.get(s));const l=[];if(0==n.size&&0==o.size&&0==a.size){const s=t.containsPoint(this.faces[0].contour[0].a,!0)!==t.infiniteVolume,e=!s&&this.containsPoint(t.faces[0].contour[0].a)!==this.infiniteVolume;if(s||e){const[e,i]=s?[this,t]:[t,this];return e.infiniteVolume?i.infiniteVolume?i:BRep$$1.join([e,i]):i.infiniteVolume?BRep$$1.EMPTY:e}return this.infiniteVolume?t.infiniteVolume?BRep$$1.join([this,t]):BRep$$1.EMPTY:t.infiniteVolume?this:BRep$$1.EMPTY}if(s){const t=BRep$$1.getLooseEdgeSegments(o,this.edgeFaces);this.faces.map(s=>[s,Array.from(t.entries()).flatMap(([t,e])=>s.getAllEdges().some(s=>s.equals(t))?e:[])]);this.reconstituteFaces(this.faces,t,n,l,r)}if(e){const s=BRep$$1.getLooseEdgeSegments(a,t.edgeFaces);t.faces.map(t=>[t,Array.from(s.entries()).flatMap(([s,e])=>t.getAllEdges().some(t=>t.equals(s))?e:[])]);t.reconstituteFaces(t.faces,s,n,l,r)}return new BRep$$1(l,this.infiniteVolume&&t.infiniteVolume,i)}transform(t,s){let e;return this.vertexNames&&(e=new Map,this.vertexNames.forEach((i,r)=>e.set(t.transformPoint(r),i+s))),new BRep$$1(this.faces.map(s=>s.transform(t)),this.infiniteVolume,this.generator&&s&&this.generator+s,e)}transform4(t,s){let e;return this.vertexNames&&(e=new Map,this.vertexNames.forEach((i,r)=>e.set(t.transformPoint(r),i+s))),new BRep$$1(this.faces.map(s=>s.transform4(t)),this.infiniteVolume,this.generator&&s&&this.generator+s,e)}flipped(){return new BRep$$1(this.faces.map(t=>t.flipped()),!this.infiniteVolume,this.generator&&this.generator+".flipped()",this.vertexNames)}}function dotCurve$$1(t,s,e){let i=t.dot(s);return ts3dutils.eq0(i)&&(i=t.dot(e)),ts3dutils.assert(!ts3dutils.eq0(i)),i}function dotCurve2$$1(t,s,e,i){ts3dutils.assert(1==i||-1==i,i);const r=t.tangentAt(s).dot(e);if(!ts3dutils.eq0(r))return i*r;if(t.ddt){const i=t.ddt(s).dot(e);if(!ts3dutils.eq0(i))return i}const n=t.at(s).to(t.at(s+4*i*ts3dutils.NLA_PRECISION)).dot(e);return ts3dutils.assert(!(t instanceof L3$$1)),n}BRep$$1.EMPTY=new BRep$$1([],!1,"BRep.EMPTY",new Map).buildAdjacencies(),BRep$$1.R3=new BRep$$1([],!0,"BRep.R3",new Map).buildAdjacencies();const INSIDE$$1=0,OUTSIDE$$1=1,COPLANAR_SAME$$1=2,COPLANAR_OPPOSITE$$1=3,ALONG_EDGE_OR_PLANE$$1=4;function splitsVolumeEnclosingFaces$$1(t,s,e,i){ts3dutils.assert(4==arguments.length),ts3dutils.assert(s==s.getCanon());const r=t.edgeFaces.get(s);ts3dutils.assertf(()=>r.length%2==0),ts3dutils.assertf(()=>t.edgeFaces);const n=r[0],o=s.aDir.unit(),a=(n.inside.angleRelativeNormal(e,o)+2*Math.PI+ts3dutils.NLA_PRECISION)%(2*Math.PI)-ts3dutils.NLA_PRECISION,u=r.findIndex(t=>ts3dutils.lt(a,t.angle)),l=r[-1==u?r.length-1:u-1];if(ts3dutils.eq(l.angle,a)){return l.normalAtCanonA.dot(i)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}return l.reversed?INSIDE$$1:OUTSIDE$$1}function splitsVolumeEnclosingFacesP$$1(t,s,e,i,r){ts3dutils.assert(5==arguments.length),ts3dutils.assert(s==s.getCanon()),ts3dutils.assertf(()=>t.edgeFaces);const n=t.edgeFaces.get(s);ts3dutils.assertf(()=>n.length%2==0);const o=s.tangentAt(s.curve.pointT(e)).unit(),a=t=>{const s=t.edge.getCanon()==t.edge?o:o.negated(),r=t.face.surface.normalP(e).cross(s);return-((i.angleRelativeNormal(r,o)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION)},u=n.withMax(a);if(ts3dutils.eq0(a(u))){return u.face.surface.normalP(e).dot(r)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}return u.reversed?OUTSIDE$$1:INSIDE$$1}function splitsVolumeEnclosingFacesP2$$1(t,s,e,i,r,n,o){ts3dutils.assert(s==s.getCanon()),ts3dutils.assertf(()=>t.edgeFaces);const a=t.edgeFaces.get(s);ts3dutils.assertf(()=>a.length%2==0);const u=s.tangentAt(s.curve.pointT(e)).unit();let l=i.tangentAt(r).times(n);l.isParallelTo(u)&&(l=(l=i.diff(r,1e-4*n/i.tangentAt(r).length()).rejectedFrom(u)).div(l.length()));let c=20,h=!1,d=OUTSIDE$$1;for(const t of a){const s=t.edge.getCanon()==t.edge?u:u.negated(),a=t.face.surface.normalP(e).cross(s),p=(l.angleRelativeNormal(a,u)+ts3dutils.TAU+ts3dutils.NLA_PRECISION)%ts3dutils.TAU-ts3dutils.NLA_PRECISION;if(ts3dutils.eq0(p)){const s=t.face.surface.normalP(e);if(t.face.surface.containsCurve(i)){return s.dot(o)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}const a=P3$$1.normalOnAnchor(u,e),p=t.face.surface.isCurvesWithPlane(a)[0],f=p.pointT(e),m=sign(p.tangentAt(f).dot(l)),$=1e-4,g=(p.at(f).to(p.at(f+n*m*$)).dot(s)-i.at(r).to(i.at(r+n*$)).dot(s))*(t.reversed?-1:1);g>0&&(!h||g<c)&&(h=!0,c=g,d=t.reversed?OUTSIDE$$1:INSIDE$$1)}else h||p<c&&(c=p,d=t.reversed?OUTSIDE$$1:INSIDE$$1)}return d}function splitsVolumeEnclosingCone$$1(t,s,e){const i=P3$$1.forAnchorAndPlaneVectors(s,e,e.getPerpendicular()),r=[];for(let n=0;n<t.faces.length;n++){const o=t.faces[n];if(ts3dutils.assertf(()=>o instanceof PlaneFace$$1),o.getAllEdges().some(t=>t.a.like(s)))if(i.isParallelToPlane(o.surface.plane)){if(o.pointsToInside(s,e)!=exports.PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE$$1}else{const t=L3$$1.fromPlanes(i,o.surface.plane),n=o.edgeISPsWithPlane(t,i);let a=0;for(;a<n.length;){const o=n[a++],u=n[a++],l=o.p.like(s);if(l||u.p.like(s)){const s=l?t.dir1:t.dir1.negated(),n=(e.angleRelativeNormal(s,i.normal1)+2*Math.PI+ts3dutils.NLA_PRECISION/2)%(2*Math.PI);r.push({angle:n,out:l})}}}}return r.sort((t,s)=>t.angle-s.angle),ts3dutils.eq0(r[0].angle)?ALONG_EDGE_OR_PLANE$$1:r[0].out?OUTSIDE$$1:INSIDE$$1}function splitsVolumeEnclosingCone2$$1(t,s,e,i,r){ts3dutils.assert(e.containsPoint(s));const n=t.faces.filter(t=>t.getAllEdges().some(t=>t.a.like(s)));for(let t=0;t<n.length;t++){const o=n[t];if(o.surface.containsCurve(e)&&o.pointsToInside3(s,e,i,r)!=exports.PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE$$1}return t.containsPoint(e.at(i+1e-6*r),!0)?INSIDE$$1:OUTSIDE$$1}function fff$$1(t,s){const e=t.edge.reversed?t.edge.b:t.edge.a,i=s.normalP(e),r=ts3dutils.snap0(t.inside.dot(i));if(0!==r)return 0<r?OUTSIDE$$1:INSIDE$$1;if(s.isCoplanarTo(t.face.surface))return 0<t.normalAtCanonA.dot(i)?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1;throw new Error}function triangulateVertices$$1(t,s,e){const i=t.maxAbsDim(),r=sign(t.e(i)),n=new Float64Array(2*s.length);let o=s.length;for(;o--;)switch(i){case 0:n[2*o]=s[o].y*r,n[2*o+1]=s[o].z;break;case 1:n[2*o]=s[o].z*r,n[2*o+1]=s[o].x;break;case 2:n[2*o]=s[o].x*r,n[2*o+1]=s[o].y}return earcut(n,e)}function intersectionUnitCircleLine$$1(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=sqrt(t*t+s*s-e*e);return{x1:(t*e+s*i)/(t*t+s*s),x2:(t*e-s*i)/(t*t+s*s),y1:(s*e-t*i)/(t*t+s*s),y2:(s*e+t*i)/(t*t+s*s)}}function intersectionUnitCircleLine2$$1(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=ts3dutils.snap0(t*t+s*s-e*e);if(i<0)return[];if(0==i)return[[t*e/(t*t+s*s),s*e/(t*t+s*s)]];{const r=sqrt(i);return[[(t*e+s*r)/(t*t+s*s),(s*e-t*r)/(t*t+s*s)],[(t*e-s*r)/(t*t+s*s),(s*e+t*r)/(t*t+s*s)]]}}function intersectionCircleLine$$1(t,s,e,i){ts3dutils.assertNumbers(t,s,e,i);const r=sqrt(i*i*(t*t+s*s)-e*e);return{x1:(t*e+s*r)/(t*t+s*s),x2:(t*e-s*r)/(t*t+s*s),y1:(s*e-t*r)/(t*t+s*s),y2:(s*e+t*r)/(t*t+s*s)}}function intersectionUnitHyperbolaLine$$1(t,s,e){ts3dutils.assertNumbers(t,s,e);const i=t*t,r=s*s,n=e*e,o=2*sqrt(r*n+r*r-i*r),a=sqrt(4*n*r-4*(r-i)*(n-i));return{x1:(-2*t*e+o)/2/(r-i),x2:(-2*t*e-o)/2/(r-i),y1:(2*s*e-a)/2/(r-i),y2:(2*s*e+a)/2/(r-i)}}function curvePointPP$$1(t,s,e,i){const r=ts3dutils.NLA_PRECISION/4;let n,o,a,u,l,c=e,h=t.pointFoot(c),d=s.pointFoot(c),p=16;do{if(n=t.pUV(h.x,h.y),o=s.pUV(d.x,d.y),ts3dutils.eq0(n.distanceTo(o),r))break;a=t.normalUV(h.x,h.y),u=s.normalUV(d.x,d.y),l=a.cross(u),c=ts3dutils.V3.add(u.cross(l).times(n.dot(a)),l.cross(a).times(o.dot(u)),l.times(l.dot(c))).div(l.squared()),h=t.pointFoot(c,h.x,h.y),d=s.pointFoot(c,d.x,d.y)}while(--p);if(ts3dutils.eq0(n.distanceTo(o),r))return{p:c,st1:h,st2:d}}function followAlgorithmPP$$1(t,s,e,i,r=uvInAABB2$$1.bind(void 0,t),n=uvInAABB2$$1.bind(void 0,s)){const o=[],a=[],u=[],l=[];let c=e,h=t.uvP(c),d=s.uvP(c);ts3dutils.assert(t.pUV(h.x,h.y).like(c)),ts3dutils.assert(h.like(t.pointFoot(c,h.x,h.y))),ts3dutils.assert(d.like(s.pointFoot(c,d.x,d.y))),ts3dutils.assert(s.pUV(d.x,d.y).like(c));for(let e=0;e<1e3;e++){({p:c,st1:h,st2:d}=curvePointPP$$1(t,s,c)),ts3dutils.assert(t.containsPoint(c),c,t),ts3dutils.assert(s.containsPoint(c));const p=t.normalUV(h.x,h.y),f=s.normalUV(d.x,d.y),m=p.cross(f).toLength(i);if(a.push(m),o.push(c),u.push(h),l.push(d),e>4&&(!r(h.x,h.y)||!n(d.x,d.y)))break;c=c.plus(m)}return{points:o,tangents:a,st1s:u,st2s:l}}function followAlgorithm2d$$1(t,s,e=.5,i,r,n,o){ts3dutils.assertNumbers(e,t(0,0)),ts3dutils.assertVectors(s),o||(o=new ts3dutils.V3(-t.y(s.x,s.y),t.x(s.x,s.y),0).toLength(e)),ts3dutils.assertVectors(o);const a=[],u=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))",t(s.x,s.y));let l=0,c=s,h=o,d=!1;do{a.push(c),u.push(h);const o=c.plus(h);ts3dutils.assert(o);const p=curvePointMF$$1(t,o),f=t.x(p.x,p.y),m=t.y(p.x,p.y),$=new ts3dutils.V3(-m,f,0).toLength(e);if(ts3dutils.assert(!c.equals(p)),h.dot($)<0){const s=ts3dutils.newtonIterate2d(t.x,t.y,c.x,c.y);if(ts3dutils.eq0(t(s.x,s.y))&&s.distanceTo(c)<abs(e)){a.push(s),u.push(c.to(s));break}throw new Error}if(n&&c.equals(n))break;if(d){if(c.distanceTo(s)>abs(e)){a.pop(),u.pop(),ts3dutils.assert(a.last.distanceTo(s)<=abs(e));break}}else l>4&&c.distanceTo(s)<=abs(e)&&(d=!0);if(l>1&&!uvInAABB2$$1(i,c.x,c.y)){const s=figureOutBorderPoint(i,c,t);a.pop(),u.pop(),a.last.distanceTo(s)<abs(e)/2&&(a.pop(),u.pop());const r=new ts3dutils.V3(-t.y(s.x,s.y),t.x(s.x,s.y),0).toLength(e);a.push(s),u.push(r);break}if(l>4&&!r(c.x,c.y))break;ts3dutils.assert(ts3dutils.eq0(t(p.x,p.y),2*ts3dutils.NLA_PRECISION),c,p,o,t(p.x,p.y)),h=$,c=p}while(++l<1e3);return ts3dutils.assert(l<1e3),{points:a,tangents:u}}function figureOutBorderPoint(t,s,e){if(s.x<t.uMin||t.uMax<s.x){const i=t.uMax<s.x?t.uMax:t.uMin,r=ts3dutils.newtonIterateWithDerivative(t=>e(i,t),s.y,4,t=>e.y(i,t));if(uvInAABB2$$1(t,i,r))return new ts3dutils.V3(i,r,0)}if(s.y<t.vMin||t.vMax<s.y){const i=t.vMax<s.y?t.vMax:t.vMin,r=ts3dutils.newtonIterateWithDerivative(t=>e(t,i),s.x,4,t=>e.x(t,i));return ts3dutils.assert(uvInAABB2$$1(t,r,i)),new ts3dutils.V3(r,i,0)}throw new Error(s+" "+t)}function followAlgorithm2dAdjustable$$1(t,s,e=.5,i,r=s){ts3dutils.assertNumbers(e,t(0,0)),ts3dutils.assertVectors(s);const n=[],o=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let a=s,u=a,l=0;do{const s=t.x(a.x,a.y),e=t.y(a.x,a.y),i=t.xx(a.x,a.y),r=t.yy(a.x,a.y),l=t.xy(a.x,a.y),c=abs((Math.pow(e,2)*i-2*s*e*l+Math.pow(s,2)*r)/Math.pow(Math.pow(s,2)+Math.pow(e,2),2)),h=new ts3dutils.V3(s,e,0).times(c),d=1/16/h.length(),p=new ts3dutils.V3(-e,s,0).unit(),f=a.plus(p.times(d).plus(h.times(Math.pow(d,2)/2)));n.push(a),o.push(p),u=a;const m=curvePointMF$$1(t,f);m.equals(a)&&ts3dutils.assertNever(),console.log(a.to(m).length()),a=m,ts3dutils.assert(ts3dutils.eq0(t(a.x,a.y)))}while(l++<1e3&&(l<4||u.distanceTo(r)>e)&&i(a.x,a.y));ts3dutils.assert(1e3!=l);const c=l<4||u.distanceTo(r)>e?a:r,h=new ts3dutils.V3(-t.y(c.x,c.y),t.x(c.x,c.y),0).toLength(e);return n.push(c),o.push(h),{points:n,tangents:o}}function intersectionICurveICurve$$1(t,s,e,i,r,n){ts3dutils.assertNumbers(r,t(0,0),n(0,0)),ts3dutils.assertVectors(s,e),ts3dutils.assert(!i||i instanceof ts3dutils.V3);const o=[];ts3dutils.assert(ts3dutils.eq0(t(s.x,s.y))),r=r||.5;let a=s,u=a,l=0;for(;l++<1e3&&(l<4||a.distanceTo(e)>1.1*r);){const s=t(a.x,a.y),e=(t(a.x+1e-5,a.y)-s)/1e-5,i=(t(a.x,a.y+1e-5)-s)/1e-5;let n=new ts3dutils.V3(-i,e,0).toLength(r);a.minus(u).dot(n)<0&&(n=n.negated()),u=a,a=curvePointMF$$1(t,a.plus(n)),o.push(a)}return o}function intersectionICurveICurve2$$1(t,s,e){let i,r=s[0],n=e(r.x,r.y);const o=[];for(let a=0;a<s.length;a++)i=n,(n=e((r=s[a]).x,r.y))*i<=0&&o.push(ts3dutils.newtonIterate2d(t,e,r.x,r.y));return o}function cassini$$1(t,s){return(e,i)=>(e*e+i*i)*(e*e+i*i)-2*s*s*(e*e-i*i)-(Math.pow(t,4)-Math.pow(s,4))}!function(t){t.forNerdamer=function(t,s=["x","y"]){const e=nerdamer(t),i=nerdamer.diff(e,s[0]),r=nerdamer.diff(e,s[1]),n=e.buildFunction(s);return n.x=i.buildFunction(s),n.y=r.buildFunction(s),n.xx=nerdamer.diff(i,s[0]).buildFunction(s),n.xy=nerdamer.diff(i,s[1]).buildFunction(s),n.yy=nerdamer.diff(r,s[1]).buildFunction(s),n},t.nerdamerToR2_R=function(t,s=["x","y"]){return t.buildFunction(s)},t.forFFxFy=function(t,s,e){return t.x=s,t.y=e,t}}(exports.MathFunctionR2R||(exports.MathFunctionR2R={}));const cas2$$1=cassini$$1(.9,1.02);function arrayLerp$$1(t,s,e){return 0==e%1?s[e]:t(s[Math.floor(e)],s[Math.ceil(e)],e%1)}function doNotSerialize$$1(t,s){(t.__SERIALIZATION_BLACKLIST||(t.__SERIALIZATION_BLACKLIST={}))[s]="no"}class ClassSerializer$$1{constructor(){this.CLASS_NAMES=new Map,this.NAME_CLASSES=new Map,this.addClass("Object",Object)}addClass(t,s){if(this.NAME_CLASSES.has(t))throw new Error(t);return this.NAME_CLASSES.set(t,s),this.CLASS_NAMES.set(s,t),this}addNamespace(t,s){return Object.keys(t).forEach(e=>{const i=t[e];"function"==typeof i&&i.name&&this.addClass((s?s+".":"")+e,i)}),this}setUpdater(t){return this.updater=t,this}serialize(t){return JSON.stringify(this.serializeObj(t))}serializeObj(t){const s=t=>{if(void 0!==t&&t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor));else if(Array.isArray(t))if(i.has(t))r.has(t)||(r.set(t,n.length),n.push(t));else{i.add(t);for(let e=0;e<t.length;e++)s(t[e])}else if(void 0!==t&&"object"==typeof t)if(i.has(t))r.has(t)||(r.set(t,n.length),n.push(t));else{if(ts3dutils.assert(!t.__noxTarget||!i.has(t.__noxTarget)),ts3dutils.assert(!t.__noxProxy||!i.has(t.__noxProxy)),i.add(t),!t.getConstructorParameters)for(const e of Object.keys(t).sort())"__noxProxy"!=e&&"__noxTarget"!=e&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[e]||s(t[e]));s(Object.getPrototypeOf(t))}},e=(t,s,i)=>{if("string"==typeof t||"number"==typeof t||"boolean"==typeof t||null===t)return t;if(void 0===t)return{"#REF":-1};if(t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor))return{"#REF":this.CLASS_NAMES.get(t.constructor)};let n;if(s&&!i&&void 0!==(n=r.get(t)))return{"#REF":n};if(Array.isArray(t))return t.map(t=>e(t,s));if("object"==typeof t){if(t.getConstructorParameters)return{"#CONSTRUCTOR":this.CLASS_NAMES.get(t.constructor),"#ARGS":e(t.getConstructorParameters(),!1)};const i={};Object.prototype!==Object.getPrototypeOf(t)&&(i["#PROTO"]=e(Object.getPrototypeOf(t),s));for(const r of Object.keys(t))"__noxProxy"!=r&&"__noxTarget"!=r&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[r]||(i[r]=e(t[r],s)));return i}throw new Error("?"+typeof t+t.toString())},i=new Set,r=new Map;let n=[];return r.set(t,0),n.push(t),s(t),n=n.map(t=>e(t,!0,!0))}unserialize(t){let s=0;const e=(t,n)=>{if(++s>100)throw new Error;if(t&&t.constructor===Array){n(t);for(let s=0;s<t.length;s++)e(t[s],e=>t[s]=e)}else if("object"==typeof t&&void 0!=t)if("#CONSTRUCTOR"in t){const s=t["#CONSTRUCTOR"],i=this.NAME_CLASSES.get(s);ts3dutils.assert(i,s+" Missing ");let r=void 0;e(t["#ARGS"],t=>r=t),n(new i(...r))}else if("#REF"in t){const s=t["#REF"];"string"==typeof s?n(this.NAME_CLASSES.get(s).prototype):"number"==typeof s&&(-1==s?n(void 0):r[s]?n(r[s]):e(i[s],t=>n(r[s]=t)))}else{let s;"#PROTO"in t?e(t["#PROTO"],t=>{s=Object.create(t),n(s)}):n(s=t);const i=Object.keys(t);for(let r=0;r<i.length;r++)"#PROTO"!=i[r]&&e(t[i[r]],t=>s[i[r]]=t);Object.defineProperty(s,"loadID",{value:getGlobalId$$1(),enumerable:!1,writable:!1}),this.updater&&this.updater(s)}else n(t);s--},i=JSON.parse(t),r=new Array(i.length);return e({"#REF":0},()=>{}),r[0]}}const fragmentShaderLighting="\n\tprecision highp float;\n\tuniform vec4 color;\n\tuniform vec3 camPos;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tvec3 normal1 = normalize(normal);\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\n\t\tvec3 lightDir = normalize(vPosition.xyz - lightPos);\n        vec3 reflectionDirection = reflect(lightDir, normal1);\n        vec3 eyeDirection = normalize(camPos.xyz-vPosition.xyz);\n        float uMaterialShininess = 256.0;\n\t\tfloat specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n\t\tfloat lightIntensity = 0.6 + 0.2 * max(0.0, -dot(lightDir, normal1)) + 0.2*specularLightWeighting;\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\n\t}\n",vertexShaderLighting="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tuniform mat4 ts_ModelViewMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        vPosition = ts_ModelViewMatrix * ts_Vertex;\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\n\t}\n",vertexShaderWaves="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tuniform mat4 ts_ModelViewMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\n\t\tfloat offset = mod  (((ts_Vertex.x + ts_Vertex.y + ts_Vertex.z) * 31.0), 20.0) - 10.0;\n\t\tvec4 modPos = ts_Vertex + vec4(normal * offset, 0);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * modPos;\n        vPosition = ts_ModelViewMatrix * modPos;\n\t}\n",vertexShaderBasic="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t}\n",vertexShaderColor="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tattribute vec4 ts_Color;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t\tfragColor = ts_Color;\n\t}\n",vertexShaderArc="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float step, offset;\n\tuniform float radius, width;\n\tvoid main() {\n\t\tfloat r = radius;\n\t\tfloat t = offset + ts_Vertex.x * step;\n\t\tfloat pRadius = r - ts_Vertex.y * width;\n\t\tvec4 p = vec4(pRadius * cos(t), pRadius * sin(t), 0, 1);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\n}\n",vertexShaderConic3d="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec3 center, f1, f2;\n\tuniform int mode;\n\tfloat sinh(float x) { return (exp(x) - exp(-x)) / 2.0; }\n\tfloat cosh(float x) { return (exp(x) + exp(-x)) / 2.0; }\n\tvoid main() {\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\n\n\t\tvec3 normal = normalize(cross(f1, f2));\n\n\t\tvec3 p, tangent;\n\t\tif (0 == mode) { // ellipse\n\t\t\tp = center + f1 * cos(t) + f2 * sin(t);\n\t\t\ttangent = f1 * -sin(t) + f2 * cos(t);\n\t\t}\n\t\tif (1 == mode) { // parabola\n\t\t\tp = center + f1 * t + f2 * t * t;\n\t\t\ttangent = f1 + 2.0 * f2 * t;\n\t\t}\n\t\tif (2 == mode) { // hyperbola\n\t\t\tp = center + f1 * cosh(t) + f2 * sinh(t);\n\t\t\ttangent = f1 * sinh(t) + f2 * cosh(t);\n\t\t}\n\t\tvec3 outDir = normalize(cross(normal, tangent));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + normal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderNURBS="#version 300 es\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tin vec4 ts_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec4 points[32];\n\tuniform int pointCount, degree;\n\tuniform float knots[40];\n\tuniform vec3 normal;\n\tconst int MIN_DEGREE = 1;\n\tconst int MAX_DEGREE = 6;\n\t\n\tint tInterval(float t) {\n\t\tfor (int s = degree; s < 40 - 1 - degree; s++) {\n\t\t\tif (t >= knots[s] && t <= knots[s + 1]) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec4 stepp(int k, int i, vec4 dkMinus1iMinus1, vec4 dkMinus1i) {\n\t    return dkMinus1i - dkMinus1iMinus1 * float(k) / (knots[i + degree - k] - knots[i - 1]);\n\t}\n\t\n\tvoid main() {\n\t\t// ts_Vertex.x is in [0, 1]\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\n\t\t\n\t\tint s = tInterval(t);\n\t\t\n\t\tvec4 v[MAX_DEGREE + 1];\n\t\tfor (int i = 0; i < degree + 1; i++) {\n\t\t    v[i] = points[s - degree + i];\n\t\t}\n\t\t\n\t\tvec4 pTangent4, ddt4 = vec4(0, 0, 1, 0);\n\t\tfor (int level = 0; level < degree; level++) {\n\t\t\tif (level == degree - 2) {\n\t\t\t\t// see https://www.globalspec.com/reference/61012/203279/10-8-derivatives\n\t\t\t\tvec4 a = v[degree];\n\t\t\t\tvec4 b = v[degree - 1];\n\t\t\t\tvec4 c = v[degree - 2];\n\t\t\t\tddt4 = stepp(degree, s + 1, stepp(degree - 1, s + 1, a, b), stepp(degree - 1, s, b, c));\n\t\t\t}\n\t\t\tif (level == degree - 1) {\n\t\t\t\tvec4 a = v[degree];\n\t\t\t\tvec4 b = v[degree - 1];\n\t\t\t\tpTangent4 = (b - a) * (float(degree) / (knots[s] - knots[s + 1]));\n\t\t\t}\n\t\t\tfor (int i = degree; i > level; i--) {\n\t\t\t\tfloat alpha = (t - knots[i + s - degree]) / (knots[i + s - level] - knots[i + s - degree]);\n\n\t\t\t\t// interpolate each component\n                v[i] = (1.0 - alpha) * v[i - 1] + alpha * v[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec4 p4 = v[degree];\n\t\t\n\t\tvec3 p = p4.xyz / p4.w;\n\t\tvec3 pTangent = ((pTangent4.xyz * p4.w) - (p4.xyz * pTangent4.w)) / (p4.w * p4.w);\n\t\tvec3 ddt = (\n\t\t    p4.xyz * (-p4.w * ddt4.w + 2.0 * pow(pTangent4.w, 2.0))\n\t\t    + pTangent4.xyz * (-2.0 * p4.w * pTangent4.w) \n\t\t    + ddt4.xyz * pow(p4.w, 2.0)\n        ) / pow(p4.w, 3.0);\n\t\t\n\t\tvec3 outDir = normalize(cross(ddt, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n    }\n",vertexShaderBezier="\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float width, startT, endT;\n\tuniform vec3 p0, p1, p2, p3;\n\tvoid main() {\n\t\t// ts_Vertex.x is in [0, 1]\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 pPos = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 pNormal = normalize(vec3(pTangent.y, -pTangent.x, 0));\n\t\tvec4 p = vec4(pPos - ts_Vertex.y * width * pNormal, 1);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\n\t}\n",vertexShaderBezier3d="\n    precision highp float;\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\n\tuniform float scale, startT, endT;\n\tuniform vec3 ps[4];\n\tuniform vec3 p0, p1, p2, p3, normal;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\t// ts_Vertex.y is in [0, 1]\n\t\tvec3 p5 = ps[0];\n\t\tfloat t = startT * (1.0 - ts_Vertex.x) + endT * ts_Vertex.x, s = 1.0 - t;\n\t\tfloat c0 = s * s * s, \n\t\t      c1 = 3.0 * s * s * t, \n\t\t      c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 p = (p0 * c0 + p1 * c1) + (p2 * c2 + p3 * c3);\n\t\tfloat c01 = 3.0 * s * s, \n\t\t      c12 = 6.0 * s * t, \n\t\t      c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 outDir = normalize(cross(normal, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderGeneric="\n\tuniform float scale;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tvoid main() {\n\t\tvec3 normal = normalize(ts_NormalMatrix * ts_Normal);\n\t\tvec4 vertexPos = ts_Vertex + vec4(normal * scale, 0);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vertexPos;\n\t}\n",vertexShaderRing="\n\t#define M_PI 3.1415926535897932384626433832795\n\tuniform float step;\n\tuniform float innerRadius, outerRadius;\n\tattribute float index;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(index, index, index, 1);\n\t\tfloat id = atan(ts_Vertex.x, ts_Vertex.y) / M_PI  * 32.0;\n\t\tfloat radius = mod(id, 2.0) < 1.0 ? outerRadius : innerRadius;\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(radius * cos(index * step), radius * sin(index * step), 0, 1);\n\t}\n",fragmentShaderColor="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = color;\n\t}\n",fragmentShaderColor3="#version 300 es\n\tprecision highp float;\n\tuniform vec4 color;\n\tout vec4 fragColor;\n\tvoid main() {\n\t\tfragColor = color;\n\t}\n",fragmentShaderVaryingColor="\n\tprecision highp float;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_FragColor = fragColor;\n\t}\n",fragmentShaderColorHighlight="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tfloat diagonal = (gl_FragCoord.x + 2.0 * gl_FragCoord.y);\n\t\tif (mod(diagonal, 50.0) > 40.0) { // mod(diagonal, 2.0) > 1.0\n\t\t\tdiscard;\n\t\t\t//gl_FragColor = color + vec4(0.2,0.2,0.2,0);\n\t\t} else {\n\t\t\tgl_FragColor = color - vec4(0.2,0.2,0.2,0);\n\t\t}\n\t}\n",vertexShaderTexture="\n\tvarying vec2 texturePos;\n\tattribute vec4 ts_Vertex;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tvoid main() {\n\t\ttexturePos = ts_Vertex.xy;\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t}\n",fragmentShaderTextureColor="\n\tprecision highp float;\n\tvarying vec2 texturePos;\n\tuniform vec4 color;\n\tuniform sampler2D texture;\n\tvoid main() {\n\t\tgl_FragColor = texture2D(texture, texturePos) * color;\n\t}\n";function parseGetParams$$1(t){const s={};return t.split("&").forEach(function(t){const e=t.indexOf("=");-1==e?s[t]=t:s[t.substr(0,e)]=decodeURI(t.substr(e+1))}),s}const COLORS$$1={RD_FILL:chroma("#9EDBF9"),RD_STROKE:chroma("#77B0E0"),TS_FILL:chroma("#D19FE3"),TS_STROKE:chroma("#A76BC2"),PP_FILL:chroma("#F3B6CF"),PP_STROKE:chroma("#EB81B4")};class BRepGLContext$$1{constructor(t){this.cachedMeshes=new WeakMap,this.shaders=initShaders$$1(t),initMeshes$$1(this.meshes={},t)}static create(t){return ts3dutils.addOwnProperties(t,BRepGLContext$$1.prototype),ts3dutils.addOwnProperties(t,new BRepGLContext$$1(t)),t}drawPoint(t,s=tsgl.GL_COLOR_BLACK,e=5){this.pushMatrix(),this.translate(t),this.scale(e/2,e/2,e/2),this.shaders.singleColor.uniforms({color:s}).draw(this.meshes.sphere1),this.popMatrix()}drawEdge(t,s=tsgl.GL_COLOR_BLACK,e=2){CURVE_PAINTERS$$1[t.curve.constructor.name](this,t.curve,s,t.minT,t.maxT,e)}drawCurve(t,s=tsgl.GL_COLOR_BLACK,e=2,i,r){CURVE_PAINTERS$$1[t.constructor.name](this,t,s,i,r,e)}drawVector(t,s,e=tsgl.GL_COLOR_BLACK,i=1){if(t.likeO())return;this.pushMatrix();const r=4*i;if(r>t.length())return;const n=t.getPerpendicular().unit();this.multMatrix(ts3dutils.M4.forSys(t.unit(),n,t.cross(n).unit(),s)),this.scale(t.length()-r,i/2,i/2),this.shaders.singleColor.uniforms({color:e}).draw(this.meshes.vectorShaft),this.scale(1/(t.length()-r),1,1),this.translate(t.length()-r,0,0),this.scale(r/2,1,1),this.shaders.singleColor.draw(this.meshes.vectorHead),this.popMatrix()}drawVectors(t,s){this.drawVector(ts3dutils.V3.X,ts3dutils.V3.O,chroma("red").gl(),s),this.drawVector(ts3dutils.V3.Y,ts3dutils.V3.O,chroma("green").gl(),s),this.drawVector(ts3dutils.V3.Z,ts3dutils.V3.O,chroma("blue").gl(),s),t.forEach(t=>this.drawVector(t.v,t.anchor,t.color,s))}drawPlane(t,s,e=!1){this.pushMatrix(),this.multMatrix(ts3dutils.M4.forSys(t.right,t.up,t.normal1)),this.translate(t.uMin,t.vMin,t.w),this.scale(t.uMax-t.uMin,t.vMax-t.vMin,1);const i=e?this.meshes.xyDottedLinePlane:this.meshes.xyLinePlane;this.shaders.singleColor.uniforms({color:s}).draw(i,this.LINES),this.popMatrix()}drawBox(t,s){this.pushMatrix(),this.multMatrix(t),s?this.shaders.singleColor.uniforms({color:s}).draw(this.meshes.cube,this.LINES):this.shaders.multiColor.draw(this.meshes.cube,this.LINES),this.popMatrix()}}function conicPainter(t,s,e,i,r,n,o=2){s.shaders.ellipse3d.uniforms({f1:e.f1,f2:e.f2,center:e.center,color:i,startT:r,endT:n,scale:o,mode:t}).draw(s.meshes.pipe)}const CURVE_PAINTERS$$1={[EllipseCurve$$1.name]:conicPainter.bind(void 0,0),[ParabolaCurve$$1.name]:conicPainter.bind(void 0,1),[HyperbolaCurve$$1.name]:conicPainter.bind(void 0,2),[ImplicitCurve$$1.name](t,s,e,i,r,n=2){let o=t.cachedMeshes.get(s);o||(o=(new tsgl.Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal"),s.addToMesh(o,4),o.compile(),t.cachedMeshes.set(s,o));const a=ceil(i),u=floor(r);if(a<=u){const l=24;if(t.shaders.generic3d.uniforms({color:e,scale:n}).draw(o,t.TRIANGLES,a*l,(floor(r)-a)*l),i%1!=0){const r=s.at(i);t.pushMatrix();const u=ts3dutils.M4.forSys(r.to(s.points[a]),o.normals[4*a].toLength(n),o.normals[4*a+1].toLength(n),r);t.multMatrix(u),t.shaders.singleColor.uniforms({color:e}).draw(t.meshes.pipeSegmentForICurve),console.log(t.meshes.pipeSegmentForICurve),t.popMatrix()}if(r%1!=0){const i=s.at(r);t.pushMatrix();const a=ts3dutils.M4.forSys(s.points[u].to(i),o.normals[4*u].toLength(n),o.normals[4*u+1].toLength(n),s.points[u]);t.multMatrix(a),t.shaders.singleColor.uniforms({color:e}).draw(t.meshes.pipeSegmentForICurve),t.popMatrix()}}else{const o=s.at(i),a=s.at(r);t.pushMatrix();const u=o.to(a),l=u.getPerpendicular().toLength(n),c=u.cross(l).toLength(n),h=ts3dutils.M4.forSys(u,l,c,o);t.multMatrix(h),t.shaders.singleColor.uniforms({color:e}).draw(t.meshes.pipeSegmentForICurve),t.popMatrix()}},[BezierCurve$$1.name](t,s,e,i,r,n=2,o=ts3dutils.V3.Z){t.shaders.bezier3d.uniforms({p0:s.p0,p1:s.p1,p2:s.p2,p3:s.p3,color:e,startT:i,endT:r,scale:n,normal:o}).draw(t.meshes.pipe)},[NURBS$$1.name](t,s,e,i,r,n=2,o=ts3dutils.V3.Z){t.shaders.nurbs.uniforms({"points[0]":ts3dutils.Vector.pack(s.points),degree:s.degree,"knots[0]":s.knots,color:e,startT:i,endT:r,scale:n,normal:o}).draw(t.meshes.pipe)},[L3$$1.name](t,s,e,i,r,n=2,o=ts3dutils.V3.Z){t.pushMatrix();const a=s.at(i),u=s.at(r).minus(a),l=u.getPerpendicular().unit(),c=ts3dutils.M4.forSys(u,l,u.cross(l).unit(),a);t.multMatrix(c),t.scale(1,n,n),t.shaders.singleColor.uniforms({color:e}).draw(t.meshes.pipe),t.popMatrix()}};function initMeshes$$1(t,s){s.makeCurrent(),t.cube=(()=>{const t=exports.B2T.box().toMesh().addVertexBuffer("colors","ts_Color");return t.colors=t.vertices.map(t=>[t.x,t.y,t.z,1].map(t=>.9*t)),t.compile(),t})(),t.sphere1=tsgl.Mesh.sphere(2),t.segment=tsgl.Mesh.plane({startY:-.5,height:1,detailX:128}),t.text=tsgl.Mesh.plane(),t.vector=tsgl.Mesh.rotation([ts3dutils.V3.O,ts3dutils.V(0,.05,0),ts3dutils.V(.8,.05),ts3dutils.V(.8,.1),ts3dutils.V(1,0)],L3$$1.X,ts3dutils.TAU,16,!0),t.vectorShaft=tsgl.Mesh.rotation([ts3dutils.V3.O,ts3dutils.V3.Y,ts3dutils.V3.XY],L3$$1.X,ts3dutils.TAU,8,!0),t.vectorHead=tsgl.Mesh.rotation([ts3dutils.V3.Y,ts3dutils.V(0,2,0),ts3dutils.V(2,0,0)],L3$$1.X,ts3dutils.TAU,8,!0),t.pipe=tsgl.Mesh.rotation(ts3dutils.arrayFromFunction(512,(t,s)=>new ts3dutils.V3(t/(s-1),-.5,0)),L3$$1.X,ts3dutils.TAU,8,!0),t.xyLinePlane=tsgl.Mesh.plane(),t.xyDottedLinePlane=makeDottedLinePlane(),t.pipeSegmentForICurve=tsgl.Mesh.offsetVertices(ts3dutils.M4.rotateY(90*ts3dutils.DEG).transformedPoints(ts3dutils.arrayFromFunction(4,t=>ts3dutils.V3.polar(1,ts3dutils.TAU*t/4))),ts3dutils.V3.X,!0)}function initShaders$$1(t){return t.makeCurrent(),{singleColor:tsgl.Shader.create(vertexShaderBasic,fragmentShaderColor),multiColor:tsgl.Shader.create(vertexShaderColor,fragmentShaderVaryingColor),singleColorHighlight:tsgl.Shader.create(vertexShaderBasic,fragmentShaderColorHighlight),textureColor:tsgl.Shader.create(vertexShaderTexture,fragmentShaderTextureColor),arc:tsgl.Shader.create(vertexShaderRing,fragmentShaderColor),arc2:tsgl.Shader.create(vertexShaderArc,fragmentShaderColor),ellipse3d:tsgl.Shader.create(vertexShaderConic3d,fragmentShaderColor),generic3d:tsgl.Shader.create(vertexShaderGeneric,fragmentShaderColor),bezier3d:tsgl.Shader.create(vertexShaderBezier3d,fragmentShaderColor),nurbs:tsgl.Shader.create(vertexShaderNURBS,fragmentShaderColor3),bezier:tsgl.Shader.create(vertexShaderBezier,fragmentShaderColor),lighting:tsgl.Shader.create(vertexShaderLighting,fragmentShaderLighting),waves:tsgl.Shader.create(vertexShaderWaves,fragmentShaderLighting)}}function makeDottedLinePlane(t=128){const s=(new tsgl.Mesh).addIndexBuffer("LINES"),e=ts3dutils.arrayFromFunction(t,s=>new ts3dutils.V3(s/t,0,0));return s.vertices.push(...e),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.Y,ts3dutils.V3.O,ts3dutils.V3.O,ts3dutils.V3.X).transformedPoints(e)),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.X.negated(),ts3dutils.V3.O,ts3dutils.V3.O,new ts3dutils.V3(1,1,0)).transformedPoints(e)),s.vertices.push(...ts3dutils.M4.forSys(ts3dutils.V3.Y.negated(),ts3dutils.V3.O,ts3dutils.V3.O,ts3dutils.V3.Y).transformedPoints(e)),s.LINES=ts3dutils.arrayFromFunction(4*t,s=>s-(s>=2*t?1:0)),s.compile(),s}function initNavigationEvents$$1(t,s,e){const i=t.canvas;let r=ts3dutils.V3.O;i.addEventListener("mousemove",i=>{const n=ts3dutils.V(i.pageX,i.pageY),o=r.to(n);if(4&i.buttons){const i=ts3dutils.V(2*-o.x/t.canvas.width,2*o.y/t.canvas.height),r=t.projectionMatrix.inversed().transformVector(i);s.pos=s.pos.plus(r),s.focus=s.focus.plus(r),setupCamera$$1(s,t),e()}if(2&i.buttons){const i=-o.x/6*ts3dutils.DEG,r=-o.y/6*ts3dutils.DEG;let n=ts3dutils.M4.rotateLine(s.focus,s.up,i);const a=s.up.cross(s.pos.minus(s.focus));n=n.times(ts3dutils.M4.rotateLine(s.focus,a,r)),s.pos=n.transformPoint(s.pos),s.up=n.transformVector(s.up),setupCamera$$1(s,t),e()}r=n}),i.addEventListener("wheel",i=>{const r=2*-sign(i.deltaY);s.zoomFactor*=pow(.9,-r);const n=getPosOnTarget$$1(i),o=ts3dutils.V(2*n.x/t.canvas.offsetWidth-1,2*-n.y/t.canvas.offsetHeight+1,0),a=o.times(1-1/pow(.9,-r)),u=t.projectionMatrix.inversed(),l=u.transformVector(a);s.pos=s.pos.plus(l),s.focus=s.focus.plus(l);const c=u.transformPoint(o),h=ts3dutils.M4.rotateLine(c,s.pos.to(s.focus),10*-sign(i.deltaX)*ts3dutils.DEG);s.up=h.transformVector(s.up),s.pos=h.transformPoint(s.pos),s.focus=h.transformPoint(s.focus),setupCamera$$1(s,t),e(),i.preventDefault()})}function getMouseLine$$1(t,s){const e=ts3dutils.V(2*t.x/s.canvas.width-1,2*-t.y/s.canvas.height+1,0),i=ts3dutils.V(2*t.x/s.canvas.width-1,2*-t.y/s.canvas.height+1,1),r=s.projectionMatrix.inversed(),n=r.transformPoint(e),o=r.transformPoint(i).minus(n);return L3$$1.anchorDirection(n,o)}function getPosOnTarget$$1(t){const s=t.target.getBoundingClientRect();return{x:t.clientX-s.left,y:t.clientY-s.top}}function setupCamera$$1(t,s,e=!1){const{pos:i,focus:r,up:n,zoomFactor:o}=t;s.matrixMode(s.PROJECTION),s.loadIdentity();const a=s.canvas.width/2/o,u=s.canvas.height/2/o;s.ortho(-a,a,-u,u,-1e4,1e4),s.lookAt(i,r,n),s.matrixMode(s.MODELVIEW),!e&&cameraChangeListeners$$1.forEach(s=>s(t))}CURVE_PAINTERS$$1[PICurve$$1.name]=CURVE_PAINTERS$$1[ImplicitCurve$$1.name],CURVE_PAINTERS$$1[PPCurve$$1.name]=CURVE_PAINTERS$$1[ImplicitCurve$$1.name];const cameraChangeListeners$$1=[],SHADERS_TYPE_VAR$$1=!1;exports.Curve=Curve$$1,exports.breakDownPPCurves=breakDownPPCurves$$1,exports.AABB2=AABB2$$1,exports.uvInAABB2=uvInAABB2$$1,exports.curvePoint=curvePoint$$1,exports.curvePointMF=curvePointMF$$1,exports.XiEtaCurve=XiEtaCurve$$1,exports.parabola4Projection=parabola4Projection$$1,exports.ImplicitCurve=ImplicitCurve$$1,exports.surfaceIsICurveIsInfosWithLine=surfaceIsICurveIsInfosWithLine$$1,exports.BezierCurve=BezierCurve$$1,exports.HyperbolaCurve=HyperbolaCurve$$1,exports.L3=L3$$1,exports.PICurve=PICurve$$1,exports.PPCurve=PPCurve$$1,exports.ParabolaCurve=ParabolaCurve$$1,exports.EllipseCurve=EllipseCurve$$1,exports.NURBS=NURBS$$1,exports.P3=P3$$1,exports.Surface=Surface$$1,exports.ImplicitSurface=ImplicitSurface$$1,exports.ParametricSurface=ParametricSurface$$1,exports.ConicSurface=ConicSurface$$1,exports.ProjectedCurveSurface=ProjectedCurveSurface$$1,exports.RotatedCurveSurface=RotatedCurveSurface$$1,exports.getExtremePointsHelper=getExtremePointsHelper$$1,exports.CylinderSurface=CylinderSurface$$1,exports.EllipsoidSurface=EllipsoidSurface$$1,exports.PlaneSurface=PlaneSurface$$1,exports.PointProjectedSurface=PointProjectedSurface$$1,exports.NURBSSurface=NURBSSurface$$1,exports.ZDirVolumeVisitor=ZDirVolumeVisitor$$1,exports.glqV3=glqV3$$1,exports.glqArray=glqArray$$1,exports.CalculateAreaVisitor=CalculateAreaVisitor$$1,exports.projectCurve=projectCurve$$1,exports.projectPointCurve=projectPointCurve$$1,exports.rotateCurve=rotateCurve$$1,exports.CustomPlane=CustomPlane$$1,exports.Edge=Edge$$1,exports.PCurveEdge=PCurveEdge$$1,exports.StraightEdge=StraightEdge$$1,exports.FaceInfoFactory=FaceInfoFactory,exports.Face=Face$$1,exports.PlaneFace=PlaneFace$$1,exports.RotationFace=RotationFace$$1,exports.EPS=EPS$$1,exports.getGlobalId=getGlobalId$$1,exports.addLikeSurfaceFaces=addLikeSurfaceFaces$$1,exports.assembleFaceFromLooseEdges=assembleFaceFromLooseEdges$$1,exports.calcNextEdgeIndex=calcNextEdgeIndex$$1,exports.BRep=BRep$$1,exports.dotCurve=dotCurve$$1,exports.dotCurve2=dotCurve2$$1,exports.INSIDE=INSIDE$$1,exports.OUTSIDE=OUTSIDE$$1,exports.COPLANAR_SAME=COPLANAR_SAME$$1,exports.COPLANAR_OPPOSITE=COPLANAR_OPPOSITE$$1,exports.ALONG_EDGE_OR_PLANE=ALONG_EDGE_OR_PLANE$$1,exports.splitsVolumeEnclosingFaces=splitsVolumeEnclosingFaces$$1,exports.splitsVolumeEnclosingFacesP=splitsVolumeEnclosingFacesP$$1,exports.splitsVolumeEnclosingFacesP2=splitsVolumeEnclosingFacesP2$$1,exports.splitsVolumeEnclosingCone=splitsVolumeEnclosingCone$$1,exports.splitsVolumeEnclosingCone2=splitsVolumeEnclosingCone2$$1,exports.fff=fff$$1,exports.triangulateVertices=triangulateVertices$$1,exports.intersectionUnitCircleLine=intersectionUnitCircleLine$$1,exports.intersectionUnitCircleLine2=intersectionUnitCircleLine2$$1,exports.intersectionCircleLine=intersectionCircleLine$$1,exports.intersectionUnitHyperbolaLine=intersectionUnitHyperbolaLine$$1,exports.curvePointPP=curvePointPP$$1,exports.followAlgorithmPP=followAlgorithmPP$$1,exports.followAlgorithm2d=followAlgorithm2d$$1,exports.followAlgorithm2dAdjustable=followAlgorithm2dAdjustable$$1,exports.intersectionICurveICurve=intersectionICurveICurve$$1,exports.intersectionICurveICurve2=intersectionICurveICurve2$$1,exports.cassini=cassini$$1,exports.cas2=cas2$$1,exports.arrayLerp=arrayLerp$$1,exports.doNotSerialize=doNotSerialize$$1,exports.ClassSerializer=ClassSerializer$$1,exports.parseGetParams=parseGetParams$$1,exports.COLORS=COLORS$$1,exports.BRepGLContext=BRepGLContext$$1,exports.CURVE_PAINTERS=CURVE_PAINTERS$$1,exports.initMeshes=initMeshes$$1,exports.initShaders=initShaders$$1,exports.initNavigationEvents=initNavigationEvents$$1,exports.getMouseLine=getMouseLine$$1,exports.getPosOnTarget=getPosOnTarget$$1,exports.setupCamera=setupCamera$$1,exports.cameraChangeListeners=cameraChangeListeners$$1,exports.SHADERS_TYPE_VAR=!1;