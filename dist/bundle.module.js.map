{"version":3,"file":"bundle.module.js","sources":["../out/math.js","../out/curve/Curve.js","../out/curve/XiEtaCurve.js","../out/curve/ImplicitCurve.js","../out/curve/BezierCurve.js","../out/curve/HyperbolaCurve.js","../out/curve/L3.js","../out/curve/PICurve.js","../out/curve/PPCurve.js","../out/curve/ParabolaCurve.js","../out/curve/EllipseCurve.js","../out/curve/NURBS.js","../out/P3.js","../out/surface/Surface.js","../out/surface/ParametricSurface.js","../out/surface/ConicSurface.js","../out/surface/ProjectedCurveSurface.js","../out/surface/RotatedCurveSurface.js","../out/surface/CylinderSurface.js","../out/surface/EllipsoidSurface.js","../out/surface/PlaneSurface.js","../out/surface/PointProjectedSurface.js","../out/surface/NURBSSurface.js","../out/surface/ZDirVolumeVisitor.js","../out/surface/CalculateAreaVisitor.js","../out/BRepGenerators.js","../out/CustomPlane.js","../out/Edge.js","../out/FaceInfo.js","../out/Face.js","../out/BRep.js","../out/ClassSerializer.js","../out/shaders.js","../out/BREPGLContext.js"],"sourcesContent":["export const { abs, acos, acosh, asin, asinh, atan, atanh, atan2, ceil, cbrt, expm1, clz32, cos, cosh, exp, floor, fround, hypot, imul, log, log1p, log2, log10, max, min, pow, random, round, sign, sin, sinh, sqrt, tan, tanh, trunc, E, LN10, LN2, LOG10E, LOG2E, PI, SQRT1_2, SQRT2, } = Math;\r\n//# sourceMappingURL=math.js.map","import { AABB, arrayFromFunction, assert, assertNumbers, callsce, clamp, eq, eq0, fuzzyUniquesF, getIntervals, glqInSteps, hasConstructor, le, newtonIterate1d, newtonIterate2dWithDerivatives, newtonIterateWithDerivative, NLA_PRECISION, Transformable, V, V3, } from 'ts3dutils';\r\nimport { curvePointPP, EllipsoidSurface, followAlgorithm2d, followAlgorithmPP, P3, PlaneSurface, PPCurve, ProjectedCurveSurface, } from '../index';\r\nimport { abs, ceil, floor } from '../math';\r\nlet insideIsInfosWithCurve = false;\r\nexport class Curve extends Transformable {\r\n    constructor(tMin, tMax) {\r\n        super();\r\n        this.tMin = tMin;\r\n        this.tMax = tMax;\r\n        assertNumbers(tMin, tMax);\r\n        assert('number' == typeof tMin && !isNaN(tMin));\r\n        assert('number' == typeof tMax && !isNaN(tMax));\r\n        assert(tMin < tMax, 'tMin < tMax ' + tMin + ' < ' + tMax);\r\n    }\r\n    static integrate(curve, startT, endT, steps) {\r\n        const step = (endT - startT) / steps;\r\n        let length = 0;\r\n        let p = curve.at(startT);\r\n        let i = 0, t = startT + step;\r\n        for (; i < steps; i++, t += step) {\r\n            const next = curve.at(t);\r\n            length += p.distanceTo(next);\r\n            p = next;\r\n        }\r\n        return length;\r\n    }\r\n    static ispsRecursive(curve1, tMin, tMax, curve2, sMin, sMax) {\r\n        // the recursive function finds good approximates for the intersection points\r\n        // curve1 function uses newton iteration to improve the result as much as possible\r\n        function handleStartTS(startT, startS) {\r\n            if (!result.some(info => eq(info.tThis, startT) && eq(info.tOther, startS))) {\r\n                const f1 = (t, s) => curve1.tangentAt(t).dot(curve1.at(t).minus(curve2.at(s)));\r\n                const f2 = (t, s) => curve2.tangentAt(s).dot(curve1.at(t).minus(curve2.at(s)));\r\n                // f = (b1, b2, t1, t2) = b1.tangentAt(t1).dot(b1.at(t1).minus(b2.at(t2)))\r\n                const dfdt1 = (b1, b2, t1, t2) => b1.ddt(t1).dot(b1.at(t1).minus(b2.at(t2))) + b1.tangentAt(t1).squared();\r\n                const dfdt2 = (b1, b2, t1, t2) => -b1.tangentAt(t1).dot(b2.tangentAt(t2));\r\n                const ni = newtonIterate2dWithDerivatives(f1, f2, startT, startS, 16, dfdt1.bind(undefined, curve1, curve2), dfdt2.bind(undefined, curve1, curve2), (t, s) => -dfdt2(curve2, curve1, s, t), (t, s) => -dfdt1(curve2, curve1, s, t));\r\n                assert(isFinite(ni.x));\r\n                assert(isFinite(ni.y));\r\n                if (ni == undefined)\r\n                    console.log(startT, startS, curve1.sce, curve2.sce);\r\n                result.push({ tThis: ni.x, tOther: ni.y, p: curve1.at(ni.x) });\r\n            }\r\n        }\r\n        // returns whether an intersection was immediately found (i.e. without further recursion)\r\n        function findRecursive(tMin, tMax, sMin, sMax, curve1AABB, curve2AABB, depth = 0) {\r\n            const EPS = NLA_PRECISION;\r\n            if (curve1AABB.touchesAABBfuzzy(curve2AABB)) {\r\n                const tMid = (tMin + tMax) / 2;\r\n                const sMid = (sMin + sMax) / 2;\r\n                if (Math.abs(tMax - tMin) < EPS || Math.abs(sMax - sMin) < EPS) {\r\n                    handleStartTS(tMid, sMid);\r\n                    return true;\r\n                }\r\n                else {\r\n                    const curve1AABBleft = curve1.getAABB(tMin, tMid);\r\n                    const curve2AABBleft = curve2.getAABB(sMin, sMid);\r\n                    let curve1AABBright, curve2AABBright;\r\n                    // if one of the following calls immediately finds an intersection, we don't want to call the others\r\n                    // as that will lead to the same intersection being output multiple times\r\n                    findRecursive(tMin, tMid, sMin, sMid, curve1AABBleft, curve2AABBleft, depth + 1) ||\r\n                        findRecursive(tMin, tMid, sMid, sMax, curve1AABBleft, (curve2AABBright = curve2.getAABB(sMid, sMax)), depth + 1) ||\r\n                        findRecursive(tMid, tMax, sMin, sMid, (curve1AABBright = curve1.getAABB(tMid, tMax)), curve2AABBleft, depth + 1) ||\r\n                        findRecursive(tMid, tMax, sMid, sMax, curve1AABBright, curve2AABBright, depth + 1);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        const result = [];\r\n        findRecursive(tMin, tMax, sMin, sMax, curve1.getAABB(tMin, tMax), curve2.getAABB(sMin, sMax));\r\n        return fuzzyUniquesF(result, info => info.tThis);\r\n    }\r\n    /**\r\n     * Searches a 2d area for (an) implicit curve(s).\r\n     * @param implicitCurve\r\n     * @param bounds Defines area to search.\r\n     * @param uStep Granularity of search in s-direction.\r\n     * @param vStep Granularity of search in t-direction.\r\n     * @param stepSize step size to take along the curve\r\n     * @return\r\n     */\r\n    static breakDownIC(implicitCurve, bounds, uStep, vStep, stepSize, validUV) {\r\n        //undefined == didu && (didu = (u, v) => (implicitCurve(u + EPS, v) - implicitCurve(u, v)) / EPS)\r\n        //undefined == didv && (didv = (u, v) => (implicitCurve(u, v + EPS) - implicitCurve(u, v)) / EPS)\r\n        const { uMin, uMax, vMin, vMax } = bounds;\r\n        const deltaS = uMax - uMin, deltaT = vMax - vMin;\r\n        const sRes = ceil(deltaS / uStep), tRes = ceil(deltaT / vStep);\r\n        const grid = new Array(sRes * tRes).fill(0);\r\n        // const printGrid = () =>\r\n        // \tconsole.log(\r\n        // \t\tarrayFromFunction(tRes, i =>\r\n        // \t\t\tgrid\r\n        // \t\t\t\t.slice(sRes * i, sRes * (i + 1))\r\n        // \t\t\t\t.map(v => (v ? 'X' : '_'))\r\n        // \t\t\t\t.join(''),\r\n        // \t\t).join('\\n'),\r\n        // \t)\r\n        const get = (i, j) => grid[j * sRes + i];\r\n        const set = (i, j) => 0 <= i && i < sRes && 0 <= j && j < tRes && (grid[j * sRes + i] = 1);\r\n        const result = [];\r\n        const logTable = [];\r\n        for (let i = 0; i < sRes; i++) {\r\n            search: for (let j = 0; j < tRes; j++) {\r\n                if (get(i, j))\r\n                    continue;\r\n                set(i, j);\r\n                let u = uMin + (i + 0.5) * uStep, v = vMin + (j + 0.5) * vStep;\r\n                const startS = u, startT = v;\r\n                // basically curvePoint\r\n                for (let k = 0; k < 8; k++) {\r\n                    const fp = implicitCurve(u, v);\r\n                    const dfpdx = implicitCurve.x(u, v), dfpdy = implicitCurve.y(u, v);\r\n                    if (0 === Math.pow(dfpdx, 2) + Math.pow(dfpdy, 2)) {\r\n                        // top of a hill, keep looking\r\n                        continue search;\r\n                    }\r\n                    const scale = fp / (Math.pow(dfpdx, 2) + Math.pow(dfpdy, 2));\r\n                    u -= scale * dfpdx;\r\n                    v -= scale * dfpdy;\r\n                }\r\n                const li = floor((u - uMin) / uStep), lj = floor((v - vMin) / vStep);\r\n                logTable.push({\r\n                    i,\r\n                    j,\r\n                    li,\r\n                    lj,\r\n                    startS,\r\n                    startT,\r\n                    u,\r\n                    v,\r\n                    'bounds(u, v)': uvInAABB2(bounds, u, v),\r\n                    'ic(s,t)': implicitCurve(u, v),\r\n                });\r\n                if (!(i == li && j == lj) && get(li, lj)) {\r\n                    continue search;\r\n                }\r\n                set(li, lj);\r\n                // u, v are now good starting coordinates to use follow algorithm\r\n                if (uvInAABB2(bounds, u, v) && validUV(u, v) && eq0(implicitCurve(u, v))) {\r\n                    const subResult = mkcurves(implicitCurve, u, v, stepSize, bounds, validUV);\r\n                    for (const curveData of subResult) {\r\n                        assert(curveData.points.length > 2);\r\n                        for (const { x, y } of curveData.points) {\r\n                            const lif = (x - uMin) / uStep, ljf = (y - vMin) / vStep;\r\n                            set((lif - 0.5) | 0, (ljf - 0.5) | 0);\r\n                            set((lif - 0.5) | 0, (ljf + 0.5) | 0);\r\n                            set((lif + 0.5) | 0, (ljf - 0.5) | 0);\r\n                            set((lif + 0.5) | 0, (ljf + 0.5) | 0);\r\n                        }\r\n                    }\r\n                    //printGrid()\r\n                    result.push(...subResult);\r\n                }\r\n            }\r\n        }\r\n        // console.table(logTable)\r\n        for (const { points } of result) {\r\n            for (let i = 0; i < points.length - 1; i++) {\r\n                assert(!points[i].equals(points[i + 1]));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    toString() {\r\n        return this.toSource();\r\n    }\r\n    toSource(rounder = x => x) {\r\n        return callsce.call(undefined, 'new ' + this.constructor.name, ...this.getConstructorParameters(), this.tMin, this.tMax);\r\n    }\r\n    withBounds(tMin = this.tMin, tMax = this.tMax) {\r\n        //assert(this.tMin <= tMin && tMin <= this.tMax)\r\n        //assert(this.tMin <= tMax && tMax <= this.tMax)\r\n        return new this.constructor(...this.getConstructorParameters(), tMin, tMax);\r\n    }\r\n    /**\r\n     * The point on the line that is closest to the given point.\r\n     */\r\n    closestPointToPoint(p) {\r\n        return this.at(this.closestTToPoint(p));\r\n    }\r\n    isValidT(t) {\r\n        return le(this.tMin, t) && le(t, this.tMax);\r\n    }\r\n    diff(t, eps) {\r\n        return this.at(t).to(this.at(t + eps));\r\n    }\r\n    // TODO: tmin/tmax first\r\n    closestTToPoint(p, tStart, tMin = this.tMin, tMax = this.tMax) {\r\n        // this.at(t) has minimal distance to p when this.tangentAt(t) is perpendicular to\r\n        // the vector between this.at(t) and p. This is the case iff the dot product of the two is 0.\r\n        // f = (this.at(t) - p) . (this.tangentAt(t)\r\n        // df = this.tangentAt(t) . this.tangentAt(t) + (this.at(t) - p) . this.ddt(t)\r\n        //    = this.tangentAt(t)² + (this.at(t) - p) . this.ddt(t)\r\n        const f = (t) => this.at(t)\r\n            .minus(p)\r\n            .dot(this.tangentAt(t)); // 5th degree polynomial\r\n        const df = (t) => this.tangentAt(t).squared() +\r\n            this.at(t)\r\n                .minus(p)\r\n                .dot(this.ddt(t));\r\n        //checkDerivate(f, df, tMin, tMax)\r\n        const STEPS = 32;\r\n        if (undefined === tStart) {\r\n            tStart = arrayFromFunction(STEPS, i => tMin + (tMax - tMin) * i / (STEPS - 1)).withMax(t => -this.at(t).distanceTo(p));\r\n        }\r\n        return newtonIterateWithDerivative(f, tStart, 16, df);\r\n    }\r\n    /**\r\n     * So different edges on the same curve do not have different vertices, they are always generated\r\n     * on fixed points this.at(k * this.tIncrement), with k taking integer values\r\n     *\r\n     */\r\n    calcSegmentPoints(aT, bT, a, b, reversed, includeFirst) {\r\n        assert(this.tIncrement, 'tIncrement not defined on ' + this);\r\n        const inc = this.tIncrement;\r\n        const result = [];\r\n        if (includeFirst)\r\n            result.push(a);\r\n        assert(reversed != aT < bT);\r\n        if (aT < bT) {\r\n            const start = Math.ceil((aT + NLA_PRECISION) / inc);\r\n            const end = Math.floor((bT - NLA_PRECISION) / inc);\r\n            for (let i = start; i <= end; i++) {\r\n                result.push(this.at(i * inc));\r\n            }\r\n        }\r\n        else {\r\n            const start = Math.floor((aT - NLA_PRECISION) / inc);\r\n            const end = Math.ceil((bT + NLA_PRECISION) / inc);\r\n            for (let i = start; i >= end; i--) {\r\n                result.push(this.at(i * inc));\r\n            }\r\n        }\r\n        result.push(b);\r\n        return result;\r\n    }\r\n    calcSegmentTs(aT, bT, reversed, includeFirst) {\r\n        assert(this.tIncrement, 'tIncrement not defined on ' + this);\r\n        const inc = this.tIncrement;\r\n        const result = [];\r\n        if (includeFirst)\r\n            result.push(aT);\r\n        assert(reversed != aT < bT);\r\n        if (aT < bT) {\r\n            const start = Math.ceil((aT + NLA_PRECISION) / inc);\r\n            const end = Math.floor((bT - NLA_PRECISION) / inc);\r\n            for (let i = start; i <= end; i++) {\r\n                result.push(i * inc);\r\n            }\r\n        }\r\n        else {\r\n            const start = Math.floor((aT - NLA_PRECISION) / inc);\r\n            const end = Math.ceil((bT + NLA_PRECISION) / inc);\r\n            for (let i = start; i >= end; i--) {\r\n                result.push(i * inc);\r\n            }\r\n        }\r\n        result.push(bT);\r\n        return result;\r\n    }\r\n    /**\r\n     *\r\n     * @param p\r\n     * @param tStart Defines interval with tEnd in which a start value for t will be searched.\r\n     * Result is not necessarily in this interval.\r\n     * @param tEnd\r\n     */\r\n    distanceToPoint(p, tStart, tEnd) {\r\n        const closestT = this.closestTToPoint(p, tStart, tEnd);\r\n        return this.at(closestT).distanceTo(p);\r\n    }\r\n    asSegmentDistanceToPoint(p, tStart, tEnd) {\r\n        let t = this.closestTToPoint(p, tStart, tEnd);\r\n        t = clamp(t, tStart, tEnd);\r\n        return this.at(t).distanceTo(p);\r\n    }\r\n    /**\r\n     * Behavior when curves are colinear: self intersections\r\n     */\r\n    isInfosWithCurve(curve) {\r\n        if (insideIsInfosWithCurve) {\r\n            return Curve.ispsRecursive(this, this.tMin, this.tMax, curve, curve.tMin, curve.tMax);\r\n        }\r\n        else {\r\n            try {\r\n                insideIsInfosWithCurve = true;\r\n                const infos = curve.isInfosWithCurve(this);\r\n                return infos.map(info => {\r\n                    assert(info);\r\n                    const { tThis, tOther, p } = info;\r\n                    return { tOther: tThis, tThis: tOther, p };\r\n                });\r\n            }\r\n            finally {\r\n                insideIsInfosWithCurve = false;\r\n            }\r\n        }\r\n    }\r\n    isTsWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isTsWithPlane(surface.plane);\r\n        }\r\n        if (surface instanceof ProjectedCurveSurface) {\r\n            const projPlane = new P3(surface.dir.unit(), 0);\r\n            const projThis = this.project(projPlane);\r\n            const projEllipse = surface.baseCurve.project(projPlane);\r\n            return projEllipse.isInfosWithCurve(projThis).map(info => info.tOther);\r\n        }\r\n        if (surface instanceof EllipsoidSurface) {\r\n            const thisOC = this.transform(surface.matrixInverse);\r\n            if (!thisOC.getAABB().touchesAABBfuzzy(new AABB(V3.XYZ.negated(), V3.XYZ))) {\r\n                return [];\r\n            }\r\n            const f = (t) => thisOC.at(t).length() - 1;\r\n            const df = (t) => thisOC\r\n                .at(t)\r\n                .unit()\r\n                .dot(thisOC.tangentAt(t));\r\n            const stepSize = 1 / (1 << 11);\r\n            const result = [];\r\n            for (let startT = this.tMin; startT <= this.tMax; startT += stepSize) {\r\n                const dt = stepSize * thisOC.tangentAt(startT).length();\r\n                if (abs(f(startT)) <= dt) {\r\n                    //const t = newtonIterate1d(f, startT, 16)\r\n                    let t = newtonIterateWithDerivative(f, startT, 16, df);\r\n                    if (!eq0(f(t)) || eq0(df(t))) {\r\n                        t = newtonIterate1d(df, startT, 16);\r\n                        //if (f(a) * f(b) < 0) {\r\n                        //    t = bisect(f, a, b, 16)\r\n                        //} else if (df(a) * df(b) < 0) {\r\n                        //    t = bisect(df, a, b, 16)\r\n                        //}\r\n                    }\r\n                    if (eq0(f(t)) && !result.some(r => eq(r, t))) {\r\n                        result.push(t);\r\n                    }\r\n                }\r\n            }\r\n            return result.filter(t => surface.containsPoint(this.at(t)));\r\n        }\r\n        throw new Error();\r\n    }\r\n    arcLength(startT, endT, steps = 1) {\r\n        assert(startT < endT, 'startT < endT');\r\n        return glqInSteps(t => this.tangentAt(t).length(), startT, endT, steps);\r\n    }\r\n    equals(obj) {\r\n        if (this === obj)\r\n            return true;\r\n        return (hasConstructor(obj, this.constructor) &&\r\n            this.getConstructorParameters().equals(obj.getConstructorParameters()));\r\n    }\r\n    hashCode() {\r\n        return this.getConstructorParameters().hashCode();\r\n    }\r\n    getAABB(tMin = this.tMin, tMax = this.tMax) {\r\n        tMin = isFinite(tMin) ? tMin : this.tMin;\r\n        tMax = isFinite(tMax) ? tMax : this.tMax;\r\n        const tMinAt = this.at(tMin), tMaxAt = this.at(tMax);\r\n        const roots = this.roots();\r\n        const mins = new Array(3), maxs = new Array(3);\r\n        for (let dim = 0; dim < 3; dim++) {\r\n            const tRoots = roots[dim];\r\n            mins[dim] = Math.min(tMinAt.e(dim), tMaxAt.e(dim));\r\n            maxs[dim] = Math.max(tMinAt.e(dim), tMaxAt.e(dim));\r\n            for (const tRoot of tRoots) {\r\n                if (tMin < tRoot && tRoot < tMax) {\r\n                    mins[dim] = Math.min(mins[dim], this.at(tRoot).e(dim));\r\n                    maxs[dim] = Math.max(maxs[dim], this.at(tRoot).e(dim));\r\n                }\r\n            }\r\n        }\r\n        return new AABB(V3.fromArray(mins), V3.fromArray(maxs));\r\n    }\r\n    reversed() {\r\n        throw new Error();\r\n    }\r\n    clipPlane(plane) {\r\n        const ists = this.isTsWithPlane(plane).filter(ist => this.tMin <= ist && ist <= this.tMax);\r\n        return getIntervals(ists, this.tMin, this.tMax).mapFilter(([a, b]) => {\r\n            const midT = (a + b) / 2;\r\n            return !eq(a, b) && plane.distanceToPointSigned(this.at(midT)) < 0 && this.withBounds(a, b);\r\n        });\r\n    }\r\n}\r\nCurve.hlol = 0;\r\nfunction mkcurves(implicitCurve, sStart, tStart, stepSize, bounds, validUV) {\r\n    const start = V(sStart, tStart);\r\n    assert(stepSize > 0);\r\n    // checkDerivate(s => implicitCurve(s, 0), s => didu(s, 0), -1, 1, 0)\r\n    // checkDerivate(t => implicitCurve(0, t), t => didv(0, t), -1, 1, 0)\r\n    const { points, tangents } = followAlgorithm2d(implicitCurve, start, stepSize, bounds, validUV);\r\n    if (points.length > 4 && points[0].distanceTo(points.last) <= abs(stepSize)) {\r\n        // this is a loop: split it\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            assert(!points[i].equals(points[i + 1]));\r\n        }\r\n        const half = floor(points.length / 2);\r\n        const points1 = points.slice(0, half), points2 = points.slice(half - 1, points.length);\r\n        const tangents1 = tangents.slice(0, half), tangents2 = tangents.slice(half - 1, tangents.length);\r\n        //tangents2[tangents2.length - 1] = tangents1[0]\r\n        //points2[tangents2.length - 1] = points1[0]\r\n        for (let i = 0; i < points1.length - 1; i++) {\r\n            assert(!points1[i].equals(points1[i + 1]));\r\n        }\r\n        for (let i = 0; i < points2.length - 1; i++) {\r\n            assert(!points2[i].equals(points2[i + 1]));\r\n        }\r\n        return [{ points: points1, tangents: tangents1 }, { points: points2, tangents: tangents2 }];\r\n    }\r\n    else {\r\n        // not a loop: check in the other direction\r\n        const { points: reversePoints, tangents: reverseTangents } = followAlgorithm2d(implicitCurve, start, -stepSize, bounds, validUV);\r\n        const result = followAlgorithm2d(implicitCurve, reversePoints.last, stepSize, bounds, validUV, undefined, reverseTangents.last.negated());\r\n        assert(result.points.length > 2);\r\n        return [result];\r\n    }\r\n}\r\nexport function breakDownPPCurves(ps1, ps2, uStep, vStep, stepSize) {\r\n    const { uMin, uMax, vMin, vMax } = ps1;\r\n    const bounds = uvInAABB2.bind(undefined, ps1);\r\n    const bounds2 = uvInAABB2.bind(undefined, ps2);\r\n    const deltaU = uMax - uMin, deltaV = vMax - vMin;\r\n    const sRes = ceil(deltaU / uStep), tRes = ceil(deltaV / vStep);\r\n    const grid = new Array(sRes * tRes).fill(0);\r\n    //const printGrid = () => console.log(arrayFromFunction(tRes, i => grid.slice(sRes * i, sRes * (i + 1)).map(v => v ? 'X' : '_').join('')).join('\\n'))\r\n    const at = (i, j) => grid[j * sRes + i];\r\n    const set = (i, j) => 0 <= i && i < sRes && 0 <= j && j < tRes && (grid[j * sRes + i] = 1);\r\n    const result = [];\r\n    const logTable = [];\r\n    for (let i = 0; i < sRes; i++) {\r\n        search: for (let j = 0; j < tRes; j++) {\r\n            if (at(i, j))\r\n                continue;\r\n            set(i, j);\r\n            const startU = uMin + (i + 0.5) * uStep, startV = vMin + (j + 0.5) * vStep;\r\n            // assume point is valid, currently (TODO)\r\n            const curvePointPPResult = curvePointPP(ps1, ps2, ps1.pUV(startU, startV));\r\n            if (undefined === curvePointPPResult) {\r\n                continue search;\r\n            }\r\n            const { p: startP, st1: { x: u, y: v }, st2: { x: u2, y: v2 }, } = curvePointPPResult;\r\n            const li = floor((u - uMin) / uStep), lj = floor((v - vMin) / vStep);\r\n            logTable.push({\r\n                i,\r\n                j,\r\n                li,\r\n                lj,\r\n                startU,\r\n                startV,\r\n                u,\r\n                v,\r\n                'bounds(u, v)': bounds(u, v),\r\n            });\r\n            if (!(i == li && j == lj) && at(li, lj)) {\r\n                continue search;\r\n            }\r\n            set(li, lj);\r\n            // u, v are now good starting coordinates to use follow algorithm\r\n            if (bounds(u, v) && bounds2(u2, v2)) {\r\n                console.log(V(u, v).sce);\r\n                const subResult = mkPPCurves(ps1, ps2, startP, stepSize, bounds, bounds2);\r\n                for (const curveData of subResult) {\r\n                    assert(curveData.st1s.length > 2);\r\n                    for (const { x, y } of curveData.st1s) {\r\n                        const lif = (x - uMin) / uStep, ljf = (y - vMin) / vStep;\r\n                        set((lif - 0.5) | 0, (ljf - 0.5) | 0);\r\n                        set((lif - 0.5) | 0, (ljf + 0.5) | 0);\r\n                        set((lif + 0.5) | 0, (ljf - 0.5) | 0);\r\n                        set((lif + 0.5) | 0, (ljf + 0.5) | 0);\r\n                    }\r\n                }\r\n                //printGrid()\r\n                result.push(...subResult);\r\n            }\r\n        }\r\n    }\r\n    console.table(logTable);\r\n    for (const { points } of result) {\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            assert(!points[i].equals(points[i + 1]));\r\n        }\r\n    }\r\n    return result.map(({ points, tangents, st1s }) => {\r\n        return new PPCurve(points, tangents, ps1, ps2, st1s, undefined, stepSize, 1);\r\n    });\r\n}\r\nfunction mkPPCurves(ps1, ps2, startPoint, stepSize, bounds1, bounds2) {\r\n    // checkDerivate(s => implicitCurve(s, 0), s => didu(s, 0), -1, 1, 0)\r\n    // checkDerivate(t => implicitCurve(0, t), t => didv(0, t), -1, 1, 0)\r\n    const { points, tangents, st1s } = followAlgorithmPP(ps1, ps2, startPoint, stepSize, bounds1, bounds2);\r\n    if (points[0].distanceTo(points.last) < stepSize && points.length > 2) {\r\n        // this is a loop: split it\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            assert(!points[i].equals(points[i + 1]));\r\n        }\r\n        const half = floor(points.length / 2);\r\n        const points1 = points.slice(0, half), points2 = points.slice(half - 1, points.length);\r\n        const tangents1 = tangents.slice(0, half), tangents2 = tangents.slice(half - 1, tangents.length);\r\n        const st1s1 = st1s.slice(0, half), st1s2 = st1s.slice(half - 1, tangents.length);\r\n        tangents2[tangents2.length - 1] = tangents1[0];\r\n        points2[tangents2.length - 1] = points1[0];\r\n        st1s2[tangents2.length - 1] = st1s1[0];\r\n        for (let i = 0; i < points1.length - 1; i++) {\r\n            assert(!points1[i].equals(points1[i + 1]));\r\n        }\r\n        for (let i = 0; i < points2.length - 1; i++) {\r\n            assert(!points2[i].equals(points2[i + 1]));\r\n        }\r\n        return [\r\n            { points: points1, tangents: tangents1, st1s: st1s1 },\r\n            { points: points2, tangents: tangents2, st1s: st1s2 },\r\n        ];\r\n    }\r\n    else {\r\n        // not a loop: check in the other direction\r\n        const { points: reversePoints } = followAlgorithmPP(ps1, ps2, startPoint, -stepSize, bounds1, bounds2);\r\n        const result = followAlgorithmPP(ps1, ps2, reversePoints.last, stepSize, bounds1, bounds2);\r\n        assert(result.points.length > 2);\r\n        return [result];\r\n    }\r\n}\r\nexport function AABB2(uMin, uMax, vMin, vMax) {\r\n    return { uMin, uMax, vMin, vMax };\r\n}\r\nexport function uvInAABB2(aabb2, u, v) {\r\n    return aabb2.uMin <= u && u <= aabb2.uMax && aabb2.vMin <= v && v <= aabb2.vMax;\r\n}\r\nexport function curvePoint(implicitCurve, startPoint, didu, didv) {\r\n    let p = startPoint;\r\n    for (let i = 0; i < 8; i++) {\r\n        const fp = implicitCurve(p.x, p.y);\r\n        const dfpdx = didu(p.x, p.y), dfpdy = didv(p.x, p.y);\r\n        const scale = fp / (dfpdx * dfpdx + dfpdy * dfpdy);\r\n        p = p.minus(new V3(scale * dfpdx, scale * dfpdy, 0));\r\n    }\r\n    return p;\r\n}\r\nexport function curvePointMF(mf, startPoint, steps = 8, eps = 1 / (1 << 30)) {\r\n    let p = startPoint;\r\n    for (let i = 0; i < steps; i++) {\r\n        const fp = mf(p.x, p.y);\r\n        const dfpdx = mf.x(p.x, p.y), dfpdy = mf.y(p.x, p.y);\r\n        const scale = fp / (dfpdx * dfpdx + dfpdy * dfpdy);\r\n        p = p.minus(new V3(scale * dfpdx, scale * dfpdy, 0));\r\n        if (abs(fp) <= eps)\r\n            break;\r\n    }\r\n    return p;\r\n}\r\n//# sourceMappingURL=Curve.js.map","import { arrayFromFunction, assertInst, assertNumbers, assertVectors, eq0, hasConstructor, M4, NLA_PRECISION, snap0, solveCubicReal2, TAU, V, V3, DEG, } from 'ts3dutils';\r\nimport { pushQuad } from 'tsgl';\r\nimport { BezierCurve, ConicSurface, Curve, EllipseCurve, EllipsoidSurface, HyperbolaCurve, L3, P3, ParabolaCurve, PlaneSurface, ProjectedCurveSurface, } from '../index';\r\nimport { abs, acos, acosh, sign, sqrt } from '../math';\r\nexport class XiEtaCurve extends Curve {\r\n    constructor(center, f1, f2, tMin, tMax) {\r\n        super(tMin, tMax);\r\n        this.center = center;\r\n        this.f1 = f1;\r\n        this.f2 = f2;\r\n        this.tMin = tMin;\r\n        this.tMax = tMax;\r\n        assertVectors(center, f1, f2);\r\n        this.normal = f1.cross(f2);\r\n        if (!this.normal.likeO()) {\r\n            this.normal = this.normal.unit();\r\n            this.matrix = M4.forSys(f1, f2, this.normal, center);\r\n            this.matrixInverse = this.matrix.inversed();\r\n        }\r\n        else {\r\n            this.matrix = M4.forSys(f1, f2, f1.unit(), center);\r\n            const f1p = f1.getPerpendicular();\r\n            // prettier-ignore\r\n            this.matrixInverse = new M4(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1).times(M4.forSys(f1, f1p, f1.cross(f1p), center).inversed());\r\n        }\r\n    }\r\n    /**\r\n     * Intersection of the unit curve with the line ax + by = c.\r\n     */\r\n    static intersectionUnitLine(a, b, c, tMin, tMax) {\r\n        throw new Error('abstract');\r\n    }\r\n    /**\r\n     * Returns a new EllipseCurve representing an ellipse parallel to the XY-plane\r\n     * with semi-major/minor axes parallel t the X and Y axes.\r\n     *\r\n     * @param a length of the axis parallel to X axis.\r\n     * @param b length of the axis parallel to Y axis.\r\n     * @param center center of the ellipse.\r\n     */\r\n    static forAB(a, b, center = V3.O) {\r\n        return new this(center, V(a, 0, 0), V(0, b, 0));\r\n    }\r\n    static XYLCValid(pLC) {\r\n        throw new Error('abstract');\r\n    }\r\n    static XYLCPointT(pLC, tMin, tMax) {\r\n        throw new Error('abstract');\r\n    }\r\n    static unitIsInfosWithLine(anchorLC, dirLC, anchorWC, dirWC, tMin, tMax) {\r\n        throw new Error('abstract');\r\n    }\r\n    addToMesh(mesh, res = 4, radius = 0, pointStep = 1) {\r\n        const baseNormals = arrayFromFunction(res, i => V3.polar(1, TAU * i / res));\r\n        const baseVertices = arrayFromFunction(res, i => V3.polar(radius, TAU * i / res));\r\n        const inc = this.tIncrement;\r\n        const start = Math.ceil((this.tMin + NLA_PRECISION) / inc);\r\n        const end = Math.floor((this.tMax - NLA_PRECISION) / inc);\r\n        for (let i = start; i <= end; i += pointStep) {\r\n            const t = i * inc;\r\n            const start = mesh.vertices.length;\r\n            if (0 !== i) {\r\n                for (let j = 0; j < res; j++) {\r\n                    pushQuad(mesh.TRIANGLES, true, start - res + j, start + j, start - res + (j + 1) % res, start + (j + 1) % res);\r\n                }\r\n            }\r\n            const point = this.at(t), tangent = this.tangentAt(t);\r\n            const matrix = M4.forSys(this.normal, tangent.cross(this.normal), tangent, point);\r\n            mesh.normals.push(...matrix.transformedVectors(baseNormals));\r\n            mesh.vertices.push(...matrix.transformedPoints(baseVertices));\r\n        }\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.center, this.f1, this.f2];\r\n    }\r\n    isInfosWithCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.isInfosWithLine(curve.anchor, curve.dir1, this.tMin, this.tMax, curve.tMin, curve.tMax);\r\n        }\r\n        if (curve instanceof BezierCurve) {\r\n            return this.isInfosWithBezier(curve);\r\n        }\r\n        if (curve instanceof XiEtaCurve) {\r\n            if (!this.normal.isParallelTo(curve.normal)) {\r\n                return this.isTsWithPlane(curve.getPlane()).mapFilter(tThis => {\r\n                    const p = this.at(tThis);\r\n                    if (curve.containsPoint(p)) {\r\n                        return { tThis, tOther: curve.pointT(p), p };\r\n                    }\r\n                    return undefined;\r\n                });\r\n            }\r\n        }\r\n        return super.isInfosWithCurve(curve);\r\n    }\r\n    transform(m4) {\r\n        return new this.constructor(m4.transformPoint(this.center), m4.transformVector(this.f1), m4.transformVector(this.f2), this.tMin, this.tMax);\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (undefined != obj &&\r\n                this.constructor == obj.constructor &&\r\n                this.center.equals(obj.center) &&\r\n                this.f1.equals(obj.f1) &&\r\n                this.f2.equals(obj.f2)));\r\n    }\r\n    hashCode() {\r\n        let hashCode = 0;\r\n        hashCode = hashCode * 31 + this.center.hashCode();\r\n        hashCode = hashCode * 31 + this.f1.hashCode();\r\n        hashCode = hashCode * 31 + this.f2.hashCode();\r\n        return hashCode | 0;\r\n    }\r\n    likeCurve(curve) {\r\n        return (hasConstructor(curve, this.constructor) &&\r\n            this.center.like(curve.center) &&\r\n            this.f1.like(curve.f1) &&\r\n            this.f2.like(curve.f2));\r\n    }\r\n    normalP(t) {\r\n        return this.tangentAt(t).cross(this.normal);\r\n    }\r\n    getPlane() {\r\n        return P3.normalOnAnchor(this.normal, this.center);\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        assertInst(P3, planeWC);\r\n        /*\r\n         this: x = center + f1 * cos t + f2 * sin t  (1)\r\n         plane:\r\n         n := plane.normal1\r\n         n DOT x == plane.w           (2)\r\n         plane defined by f1/f2\r\n         x = center + f1 * xi + f2 * eta         (3)\r\n         intersection plane and planef1/f2:\r\n         insert (3) into (2):\r\n         n DOT center + n DOT f1 * xi + n DOT f2 * eta = plane.w | -n DOT center\r\n         n DOT f1 * xi + n DOT f2 * eta = plane.w - n DOT center (4)\r\n         points on ellipse have additional condition\r\n         eta * eta + xi * xi = 1 (5)\r\n         g1 := n DOT f1\r\n         g2 := n DOT f2\r\n         g3 := w - n DOT center\r\n         solve system (5)/(6)\r\n         g1 * xi + g2 * eta = g3 (6)\r\n         */\r\n        if (planeWC.normal1.isParallelTo(this.normal)) {\r\n            return [];\r\n        }\r\n        const n = planeWC.normal1, w = planeWC.w, center = this.center, f1 = this.f1, f2 = this.f2, g1 = n.dot(f1), g2 = n.dot(f2), g3 = w - n.dot(center);\r\n        return this.constructor.intersectionUnitLine(g1, g2, g3, this.tMin, this.tMax);\r\n    }\r\n    pointT(p) {\r\n        assertVectors(p);\r\n        const pLC = this.matrixInverse.transformPoint(p);\r\n        return this.constructor.XYLCPointT(pLC);\r\n    }\r\n    containsPoint(p) {\r\n        const pLC = this.matrixInverse.transformPoint(p);\r\n        return eq0(pLC.z) && this.isValidT(this.constructor.XYLCPointT(pLC, this.tMin, this.tMax));\r\n    }\r\n    isInfosWithLine(anchorWC, dirWC, tMin = this.tMin, tMax = this.tMax, lineMin = -100000, lineMax = 100000) {\r\n        const anchorLC = this.matrixInverse.transformPoint(anchorWC);\r\n        const dirLC = this.matrixInverse.transformVector(dirWC);\r\n        if (eq0(dirLC.z)) {\r\n            // local line parallel to XY-plane\r\n            if (eq0(anchorLC.z)) {\r\n                // local line lies in XY-plane\r\n                return this.constructor.unitIsInfosWithLine(anchorLC, dirLC, anchorWC, dirWC, tMin, tMax);\r\n            }\r\n        }\r\n        else {\r\n            // if the line intersects the XY-plane in a single point, there can be an intersection there\r\n            // find point, then check if distance from circle = 1\r\n            const otherTAtZ0 = anchorLC.z / dirLC.z;\r\n            const isp = dirLC.times(otherTAtZ0).plus(anchorLC);\r\n            if (this.constructor.XYLCValid(isp)) {\r\n                // point lies on unit circle\r\n                return [\r\n                    {\r\n                        tThis: this.constructor.XYLCPointT(isp),\r\n                        tOther: otherTAtZ0,\r\n                        p: anchorWC.plus(dirWC.times(otherTAtZ0)),\r\n                    },\r\n                ];\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n    isTsWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isTsWithPlane(surface.plane);\r\n        }\r\n        else if (surface instanceof EllipsoidSurface) {\r\n            const isEllipses = surface.isCurvesWithPlane(this.getPlane());\r\n            return isEllipses\r\n                .flatMap(isEllipse => this.isInfosWithCurve(isEllipse))\r\n                .filter(info => surface.containsPoint(info.p))\r\n                .map(info => info.tThis);\r\n        }\r\n        else if (surface instanceof ProjectedCurveSurface || surface instanceof ConicSurface) {\r\n            return surface\r\n                .isCurvesWithPlane(this.getPlane())\r\n                .flatMap(curve => this.isInfosWithCurve(curve))\r\n                .map(info => info.tThis);\r\n        }\r\n        else {\r\n            throw new Error();\r\n        }\r\n    }\r\n    isInfosWithBezier(bezierWC) {\r\n        const bezierLC = bezierWC.transform(this.matrixInverse);\r\n        if (new PlaneSurface(P3.XY).containsCurve(bezierLC)) {\r\n            return this.isInfosWithBezier2D(bezierWC);\r\n        }\r\n        else {\r\n            const infos = bezierLC.isTsWithPlane(P3.XY).mapFilter(tOther => {\r\n                const pLC = bezierLC.at(tOther);\r\n                if (this.constructor.XYLCValid(pLC)) {\r\n                    return { tOther: tOther, p: bezierWC.at(tOther), tThis: this.constructor.XYLCPointT(pLC) };\r\n                }\r\n                return undefined;\r\n            });\r\n            return infos;\r\n        }\r\n    }\r\n    isInfosWithBezier2D(bezierWC, sMin = bezierWC.tMin, sMax = bezierWC.tMax) {\r\n        return Curve.ispsRecursive(this, this.tMin, this.tMax, bezierWC, sMin, sMax);\r\n    }\r\n    isOrthogonal() {\r\n        return this.f1.isPerpendicularTo(this.f2);\r\n    }\r\n    at2(xi, eta) {\r\n        assertNumbers(xi, eta);\r\n        // center + f1 xi + f2 eta\r\n        return this.center.plus(this.f1.times(xi)).plus(this.f2.times(eta));\r\n    }\r\n    debugInfo() {\r\n        return {\r\n            points: [this.center, this.at2(0.5, 0), this.at2(0, 1 / 3), this.at2(0, 2 / 3)],\r\n            lines: [this.center, this.at2(0, 1), this.center, this.at2(1, 0)],\r\n        };\r\n    }\r\n}\r\n/**\r\n * Transforms the unit 4d parabola P(t) = t² (0, 1, 0, 0) + t (1, 0, 0, 0) + (0, 0, 0, 1) using m and projects the\r\n * result into 3d. This is used for the transform4 implementation of conics. The parabola my not cross the vanishing\r\n * plane of m in the interval [tMin, tMax], as that would result in discontinuities.\r\n */\r\nexport function parabola4Projection(m, tMin, tMax) {\r\n    return HyperbolaCurve.XY.rotateZ(45 * DEG);\r\n    console.log(m.str);\r\n    console.log();\r\n    const w2 = m.m[13];\r\n    const w1 = m.m[12];\r\n    const wc = m.m[15];\r\n    // if the 4d parabola crosses the vanishing plane, it will lead to multiple/infinite hyperbolas, both of which we\r\n    // want to avoid. Hence, we must check that the entire interval [tMin, tMax] is on one side of the vanishing plane.\r\n    // Checking tMax, tMin and the extremas is enough.\r\n    const extremas = solveCubicReal2(0, w2, w1, wc);\r\n    const wx0 = (x) => (Number.isFinite(x) ? snap0(Math.pow(x, 2) * w2 + x * w1 + wc) : sign(w2) * Infinity);\r\n    if (wx0(tMin) * wx0(tMax) < 0 || extremas.some(x => wx0(x) * (wx0(tMin) + wx0(tMax)) < 0)) {\r\n        console.log(m.str);\r\n        throw new Error('The entire interval must be on one side of the vanishing plane. P=' + P3.vanishingPlane(m).toSource());\r\n    }\r\n    if (eq0(wc)) {\r\n        // the following matrix maps a curve C onto itself, with the parameter being inverted:\r\n        // C2(t) = C(-1/t). This makes C(0) a real value, which i necessary for the projection calculation.\r\n        // the sign inversion is so the tangent direction does not change.\r\n        // prettier-ignore\r\n        const mm = new M4(-1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);\r\n        if (!eq0(w2)) {\r\n            return parabola4Projection(m.times(mm), -1 / tMin, -1 / tMax);\r\n        }\r\n        // wc == w2 == 0 => degenerates to a line:\r\n        // C(t) = (t² f2 + t f1 + c) / (t w1)\r\n        // C(t) = (t f2 + f1 + c) / (t w2 + w1)\r\n        // substitute t = (1/s - w1) / w2\r\n        // C(s) = f2 / w2 + s (f1 - f2 w1 / w2), which is a line\r\n        // we can multiply the direction vector by w2 to avoid divisions:\r\n        // C(t) = f2 / w2 + s (f1 w2 - f2 w1)\r\n        const f1 = m.col(0);\r\n        const f2 = m.col(1);\r\n        return L3.anchorDirection(f2.p3(), f1\r\n            .V3()\r\n            .times(f2.w)\r\n            .minus(f2.V3().times(f1.w)));\r\n    }\r\n    {\r\n        // ensure that the bottom-right value = 1. this does not change the 3d result.\r\n        m.m[15] !== 1 && (m = m.divScalar(m.m[15]));\r\n        const w2 = m.m[13];\r\n        const w1 = m.m[12];\r\n        const wc = m.m[15];\r\n        // we want to split m into X * P, such that X is a transformation with no projective component (first three\r\n        // values of the bottom row = 0), which can be handled by the usual .transform() method, and P which has only a\r\n        // projective component (only the row differs from the identity matrix). This simplifies the following\r\n        // calculation. X * P = x => X * P * P^-1 = m * P^-1 => X = m * P^-1 prettier-ignore\r\n        const Pinv = new M4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -m.m[12], -m.m[13], -m.m[14], 1);\r\n        const X = m.times(Pinv);\r\n        // P'(t) = 0 is true for t = 0 and t1. The center is in between P(0) and P(t1), or P(t1) / 2, as P(0) = O\r\n        const delta = 4 * w2 * wc - Math.pow(w1, 2);\r\n        const center = new V3(-w1 * wc / delta, 2 * Math.pow(wc, 2) / delta, 0);\r\n        // f2 is parallel to P'(0), i.e. horizontal. Solve Py(t2) = Cy = Py(t1) / 2 for t2 and simplify\r\n        // f2x = Px(t2) - Cx = Px(t2) - Px(t1) / 2 to get the x-component of f2:\r\n        const f2x = 1 / sqrt(abs(delta)) / wc;\r\n        const f2 = new V3(f2x, 0, 0);\r\n        let result;\r\n        if (eq0(delta)) {\r\n            result = new ParabolaCurve(V3.O, V3.X, V3.Y, tMin, tMax);\r\n        }\r\n        else if (0 < delta) {\r\n            const tMapInv = (t) => {\r\n                const wt = Math.pow(t, 2) * w2 + t * w1 + wc;\r\n                const xi = 1 - delta / 2 / Math.pow(wc, 2) * (Number.isFinite(t) ? Math.pow(t, 2) / wt : 1 / w2);\r\n                const eta = (t * 2 * Math.pow(wc, 2) - Math.pow(t, 2) * delta) / wt / 2 / Math.pow(wc, 2) - 2 * w1 * wc / delta;\r\n                const xx = acos(xi);\r\n                const p = Number.isFinite(t) ? new V3(t, Math.pow(t, 2), 0).div(wt) : new V3(0, 1 / w2, 0);\r\n                const pLC = M4.forSys(center.negated(), f2, V3.Z, center)\r\n                    .inversed()\r\n                    .transformPoint(p);\r\n                const angle = pLC.angleXY();\r\n                if (t > 0 && pLC.y < 0) {\r\n                    return angle + TAU;\r\n                }\r\n                else if (t < 0 && pLC.y > 0) {\r\n                    return angle - TAU;\r\n                }\r\n                return angle;\r\n            };\r\n            result = EllipseCurve.andFixTs(center, center.negated(), f2, tMapInv(tMin), tMapInv(tMax));\r\n        }\r\n        else {\r\n            const tMapInv = (t) => sign(t) *\r\n                acosh(1 - delta / 2 / Math.pow(wc, 2) * (Number.isFinite(t) ? Math.pow(t, 2) / (Math.pow(t, 2) * w2 + t * w1 + wc) : 1 / w2));\r\n            result = new HyperbolaCurve(center, center.negated(), f2, tMapInv(tMin), tMapInv(tMax));\r\n        }\r\n        return result.transform(X);\r\n    }\r\n}\r\n//# sourceMappingURL=XiEtaCurve.js.map","import { arrayFromFunction, arrayRange, assert, assertVectors, bisect, clamp, eq, eq0, M4, TAU, V3, } from 'ts3dutils';\r\nimport { pushQuad } from 'tsgl';\r\nimport { Curve, L3, PICurve } from '../index';\r\nimport { ceil, floor, max, min } from '../math';\r\nexport class ImplicitCurve extends Curve {\r\n    constructor(points, tangents, dir = 1, generator, tMin = 1 == dir ? 0 : -(points.length - 1), tMax = 1 == dir ? points.length - 1 : 0) {\r\n        super(tMin, tMax);\r\n        this.points = points;\r\n        this.tangents = tangents;\r\n        this.dir = dir;\r\n        this.generator = generator;\r\n        assert(points.length > 2);\r\n        assert(0 <= tMin && tMin <= points.length - 1, tMin, points.length);\r\n        assert(0 <= tMax && tMax <= points.length - 1, tMax, points.length);\r\n    }\r\n    likeCurve(curve) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    toSource(rounder = x => x) {\r\n        return this.generator || super.toSource(rounder);\r\n    }\r\n    containsPoint(p) {\r\n        assertVectors(p);\r\n        return !isNaN(this.pointT(p));\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (Object.getPrototypeOf(obj) == PICurve.prototype &&\r\n                this.points[0].equals(obj.points[0]) &&\r\n                this.tangents[0].equals(obj.tangents[0])));\r\n    }\r\n    hashCode() {\r\n        return [this.points[0], this.tangents[0]].hashCode();\r\n    }\r\n    tangentP(pWC) {\r\n        assertVectors(pWC);\r\n        assert(this.containsPoint(pWC), 'this.containsPoint(pWC)' + this.containsPoint(pWC));\r\n        const t = this.pointT(pWC);\r\n        return this.tangentAt(t);\r\n    }\r\n    tangentAt(t) {\r\n        t = clamp(t, this.tMin, this.tMax);\r\n        return V3.lerp(this.tangents[floor(t)], this.tangents[ceil(t)], t % 1);\r\n    }\r\n    at(t) {\r\n        assert(isFinite(t));\r\n        return V3.lerp(this.points[floor(t)], this.points[ceil(t)], t % 1);\r\n    }\r\n    getConstructorParameters() {\r\n        throw new Error();\r\n    }\r\n    roots() {\r\n        const allTs = arrayRange(0, this.points.length);\r\n        return [allTs, allTs, allTs];\r\n    }\r\n    /**\r\n     * @param mesh\r\n     * @param res\r\n     * @param radius default to 0. Use the shader to achieve dynamic scaling.\r\n     * @param pointStep\r\n     */\r\n    addToMesh(mesh, res = 4, radius = 0, pointStep = 1) {\r\n        const baseNormals = arrayFromFunction(res, i => V3.polar(1, TAU * i / res));\r\n        const baseVertices = arrayFromFunction(res, i => V3.polar(radius, TAU * i / res));\r\n        let prevTangent = V3.Z, prevMatrix = M4.IDENTITY;\r\n        for (let i = 0; i < this.points.length; i += pointStep) {\r\n            const start = mesh.vertices.length;\r\n            if (0 !== i) {\r\n                for (let j = 0; j < res; j++) {\r\n                    pushQuad(mesh.TRIANGLES, true, start - res + j, start + j, start - res + (j + 1) % res, start + (j + 1) % res);\r\n                }\r\n            }\r\n            const point = this.points[i], tangent = this.tangents[i];\r\n            const tangentMatrix = M4.rotateAB(prevTangent, tangent).times(prevMatrix);\r\n            mesh.normals.push(...tangentMatrix.transformedVectors(baseNormals));\r\n            const baseMatrix = M4.translate(point).times(tangentMatrix);\r\n            mesh.vertices.push(...baseMatrix.transformedPoints(baseVertices));\r\n            prevTangent = tangent;\r\n            prevMatrix = tangentMatrix;\r\n        }\r\n    }\r\n    rootsApprox() {\r\n        const roots = [[], [], []];\r\n        const points = this.points;\r\n        let lastDiff = points[1].minus(points[0]);\r\n        for (let i = 2; i < points.length; i++) {\r\n            const diff = points[i].minus(points[i - 1]);\r\n            for (let dim = 0; dim < 3; dim++) {\r\n                if (Math.sign(lastDiff.e(dim)) != Math.sign(diff.e(dim))) {\r\n                    roots[dim].push(i);\r\n                }\r\n            }\r\n            lastDiff = diff;\r\n        }\r\n        return roots;\r\n    }\r\n    pointT(pWC) {\r\n        const startT = arrayRange(floor(this.tMin), ceil(this.tMax), 1).withMax(t => -pWC.distanceTo(this.points[t]));\r\n        if (undefined === startT)\r\n            throw new Error();\r\n        if (this.points[startT].like(pWC))\r\n            return startT;\r\n        const a = max(0, startT - 1), b = min(this.points.length - 1, startT + 1);\r\n        const tangent = this.tangentAt(startT);\r\n        const f = (t) => this.at(t)\r\n            .to(pWC)\r\n            .dot(tangent);\r\n        // const df = (t: number) => -this.tangentAt(clamp(t, 0, this.points.length - 1)).dot(tangent)\r\n        //checkDerivate(f, df, 0, this.points.length - 2, 3)\r\n        const t = bisect(f, a, b, 32);\r\n        if (!isFinite(t) || !eq0(this.at(t).distanceTo(pWC))) {\r\n            return NaN;\r\n        }\r\n        return t;\r\n    }\r\n}\r\nImplicitCurve.prototype.tIncrement = 1;\r\n/**\r\n * isInfosWithLine for an ImplicitCurve defined as the intersection of two surfaces.\r\n */\r\nexport function surfaceIsICurveIsInfosWithLine(surface1, surface2, anchorWC, dirWC, tMin, tMax, lineMin, lineMax) {\r\n    const line = new L3(anchorWC, dirWC.unit());\r\n    const psTs = surface1.isTsForLine(line);\r\n    const isTs = surface2.isTsForLine(line);\r\n    const commonTs = psTs.filter(psT => isTs.some(isT => eq(psT, isT)));\r\n    const commonTInfos = commonTs.map(t => ({ tThis: 0, tOther: t / dirWC.length(), p: line.at(t) }));\r\n    const result = commonTInfos.filter(info => this.containsPoint(info.p));\r\n    result.forEach(info => (info.tThis = this.pointT(info.p)));\r\n}\r\n//# sourceMappingURL=ImplicitCurve.js.map","import { arrayFromFunction, assert, assertf, assertInst, assertNever, assertNumbers, assertVectors, between, combinations, eq, eq0, fuzzyUniques, hasConstructor, lerp, MINUS, newtonIterate1d, newtonIterate2dWithDerivatives, NLA_PRECISION, solveCubicReal2, V, V3, } from 'ts3dutils';\r\nimport { Curve, CylinderSurface, EllipseCurve, L3, P3, } from '../index';\r\nimport { abs, cos, PI, sin } from '../math';\r\n/**\r\n * Bezier curve with degree 3.\r\n */\r\nexport class BezierCurve extends Curve {\r\n    constructor(p0, p1, p2, p3, tMin = -0.1, tMax = 1.1) {\r\n        super(tMin, tMax);\r\n        assertVectors(p0, p1, p2, p3);\r\n        assert(isFinite(tMin) && isFinite(tMax));\r\n        //assert(!L3.throughPoints(p0, p3).containsPoint(p1) || !L3.throughPoints(p0, p3).containsPoint(p2))\r\n        this.p0 = p0;\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        this.p3 = p3;\r\n    }\r\n    get points() {\r\n        return [this.p0, this.p1, this.p2, this.p3];\r\n    }\r\n    /**\r\n     * Returns a curve with curve.at(x) == V(x, ax³ + bx² + cx + d, 0)\r\n     */\r\n    static graphXY(a, b, c, d, tMin, tMax) {\r\n        // d = p0y\r\n        // c = -3 p0y + 3 p1y => p1y = c/3 + p0y\r\n        // b = 3 p0y - 6 p1y + 3 p2y => p2y = b/3 - p0y + 2 p1y\r\n        // a = -p0y + 3 p1y -3 p2y + p3y => p3y = a + p0y - 3 p1y + 3 p2y\r\n        const p0y = d;\r\n        const p1y = c / 3 + p0y;\r\n        const p2y = b / 3 - p0y + 2 * p1y;\r\n        const p3y = a + p0y - 3 * p1y + 3 * p2y;\r\n        return new BezierCurve(V(0, p0y), V(1 / 3, p1y), V(2 / 3, p2y), V(1, p3y), tMin, tMax);\r\n    }\r\n    static quadratic(a, b, c, tMin = 0, tMax = 1) {\r\n        const line = L3.throughPoints(a, c);\r\n        if (line.containsPoint(b)) {\r\n            return line;\r\n        }\r\n        else {\r\n            // p1 = 1/3 a + 2/3 b\r\n            // p2 = 1/3 c + 2/3 b\r\n            return new BezierCurve(a, b\r\n                .times(2)\r\n                .plus(a)\r\n                .div(3), b\r\n                .times(2)\r\n                .plus(c)\r\n                .div(3), c, tMin, tMax);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a bezier curve which approximates a CCW unit circle arc starting at V3.X of angle phi\r\n     * phi <= PI / 2 is recommended\r\n     *\r\n     * Formula from here: https://pomax.github.io/bezierinfo/#circles_cubic\r\n     */\r\n    static approximateUnitArc(phi) {\r\n        const f = 4 / 3 * Math.tan(phi / 4);\r\n        return new BezierCurve(V3.X, new V3(1, f, 0), new V3(cos(phi) + f * sin(phi), sin(phi) - f * cos(phi), 0), V3.sphere(phi, 0), 0, 1);\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.p0, this.p1, this.p2, this.p3];\r\n    }\r\n    at(t) {\r\n        // = s^3 p0 + 3 s^2 t p1 + 3 s t^2 p2 + t^3 p3\r\n        assertNumbers(t);\r\n        const p0 = this.p0, p1 = this.p1, p2 = this.p2, p3 = this.p3;\r\n        const s = 1 - t, c0 = s * s * s, c1 = 3 * s * s * t, c2 = 3 * s * t * t, c3 = t * t * t;\r\n        return new V3(p0.x * c0 + p1.x * c1 + p2.x * c2 + p3.x * c3, p0.y * c0 + p1.y * c1 + p2.y * c2 + p3.y * c3, p0.z * c0 + p1.z * c1 + p2.z * c2 + p3.z * c3);\r\n    }\r\n    /**\r\n     * s := (1 - t)\r\n     * at(t) := s³ p0 + 3 s² t p1 + 3 s t² p2 + t³ p3\r\n     * tangent(t) := 3 s² (p1 - p0) + 6 s t (p2 - p1) + 3 t² (p3 - p2)\r\n     *            := 3 (1 - t)² (p1 - p0) + 6 (1 - t) t (p2 - p1) + 3 t² (p3 - p2)\r\n     *            := 3 (1 - 2 t + t²) (p1 - p0) + 6 (t - t²) (p2 - p1) + 3 t² (p3 - p2)\r\n     *            := (3 (p3 - p2) - 6 (p2 - p1) + 3 (p1 - p0)) t²*\r\n     *                + (-6 (p1 - p0) + (p2 - p1)) t\r\n     *                + 3 (p1 - p0)\r\n     */\r\n    tangentAt(t) {\r\n        assertNumbers(t);\r\n        const p0 = this.p0, p1 = this.p1, p2 = this.p2, p3 = this.p3;\r\n        const s = 1 - t, c01 = 3 * s * s, c12 = 6 * s * t, c23 = 3 * t * t;\r\n        return new V3((p1.x - p0.x) * c01 + (p2.x - p1.x) * c12 + (p3.x - p2.x) * c23, (p1.y - p0.y) * c01 + (p2.y - p1.y) * c12 + (p3.y - p2.y) * c23, (p1.z - p0.z) * c01 + (p2.z - p1.z) * c12 + (p3.z - p2.z) * c23);\r\n    }\r\n    ddt(t) {\r\n        assertNumbers(t);\r\n        const p0 = this.p0, p1 = this.p1, p2 = this.p2, p3 = this.p3;\r\n        const c012 = 6 * (1 - t), c123 = 6 * t;\r\n        return new V3((p2.x - 2 * p1.x + p0.x) * c012 + (p3.x - 2 * p2.x + p1.x) * c123, (p2.y - 2 * p1.y + p0.y) * c012 + (p3.y - 2 * p2.y + p1.y) * c123, (p2.z - 2 * p1.z + p0.z) * c012 + (p3.z - 2 * p2.z + p1.z) * c123);\r\n    }\r\n    normalP(t) {\r\n        const tangent = this.tangentAt(t);\r\n        const rot = tangent.cross(this.ddt(t));\r\n        return rot.cross(tangent);\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        assertInst(P3, planeWC);\r\n        /*\r\n         We are solving for t:\r\n         n := plane.normal1\r\n         this.at(t) DOT n == plane.w // according to plane definition\r\n         (a t³ + b t² + c t + d) DOT n == plane.w // bezier curve as cubic equation\r\n         (a DOT n) t³ + (b DOT n) t³ + (c DOT n) t + d DOT n - plane.w == 0 // multiply out DOT n, minus plane.w\r\n         */\r\n        const { p0, p1, p2, p3 } = this;\r\n        const n = planeWC.normal1;\r\n        const a = p1\r\n            .minus(p2)\r\n            .times(3)\r\n            .minus(p0)\r\n            .plus(p3);\r\n        const b = p0\r\n            .plus(p2)\r\n            .times(3)\r\n            .minus(p1.times(6));\r\n        const c = p1.minus(p0).times(3);\r\n        const d = p0;\r\n        return solveCubicReal2(a.dot(n), b.dot(n), c.dot(n), d.dot(n) - planeWC.w).filter(t => between(t, this.tMin, this.tMax));\r\n    }\r\n    isTsWithSurface(surfaceWC) {\r\n        if (surfaceWC instanceof CylinderSurface) {\r\n            const projPlane = new P3(surfaceWC.dir.unit(), 0);\r\n            const projThis = this.project(projPlane);\r\n            const projEllipse = surfaceWC.baseCurve.project(projPlane);\r\n            return projEllipse.isInfosWithBezier2D(projThis).map(info => info.tOther);\r\n        }\r\n        return super.isTsWithSurface(surfaceWC);\r\n    }\r\n    likeCurve(curve) {\r\n        return (this == curve ||\r\n            (hasConstructor(curve, BezierCurve) &&\r\n                this.p0.like(curve.p0) &&\r\n                this.p1.like(curve.p1) &&\r\n                this.p2.like(curve.p2) &&\r\n                this.p3.like(curve.p3)));\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (hasConstructor(obj, BezierCurve) &&\r\n                this.p0.equals(obj.p0) &&\r\n                this.p1.equals(obj.p1) &&\r\n                this.p2.equals(obj.p2) &&\r\n                this.p3.equals(obj.p3)));\r\n    }\r\n    hashCode() {\r\n        let hashCode = 0;\r\n        hashCode = hashCode * 31 + this.p0.hashCode();\r\n        hashCode = hashCode * 31 + this.p1.hashCode();\r\n        hashCode = hashCode * 31 + this.p2.hashCode();\r\n        hashCode = hashCode * 31 + this.p3.hashCode();\r\n        return hashCode | 0;\r\n    }\r\n    /**\r\n     * Checks if this curve is colinear to the passed curve, i.e.\r\n     * for every t:number there exists a s:number with this.at(t) = curve.at(s)\r\n     */\r\n    isColinearTo(curve) {\r\n        if (this === curve || this.likeCurve(curve))\r\n            return true;\r\n        if (!(curve instanceof BezierCurve))\r\n            return false;\r\n        // first, find out where/if curve.p0 and curve.p3 are on this\r\n        // then split this at curve.p0 --> curve.p3 to compare points p1 and p2\r\n        let curveP0T, curveP3T;\r\n        // assign in if condition to exploit short-circuit\r\n        if (isNaN((curveP0T = this.pointT(curve.p0))) || isNaN((curveP3T = this.pointT(curve.p3)))) {\r\n            return false;\r\n        }\r\n        let thisSplit;\r\n        if (eq(1, curveP0T)) {\r\n            // this.split(curveP0T).right is degenerate in this case, so we need to handle it separately\r\n            // this.split(curveP3T): 0 --> curveP3T --> 1\r\n            // .right: curveP3T --> 1\r\n            // .reversed(): 1 --> curveP3T\r\n            thisSplit = this.split(curveP3T)[1].reversed();\r\n        }\r\n        else {\r\n            // curveP3T describes the point on this\r\n            // adjust it so it describes the same point on this.split(curveP0T).right\r\n            // this:                       0           p0t        p3t      1\r\n            //                             |            |          |       |\r\n            // this.split(curveP0T).right:              0        p3tad     1\r\n            const curveP3Tadjusted = (curveP3T - curveP0T) / (1 - curveP0T);\r\n            thisSplit = this.split(curveP0T)[1].split(curveP3Tadjusted)[0];\r\n        }\r\n        return curve.likeCurve(thisSplit);\r\n    }\r\n    selectPart(t0, t1) {\r\n        const t1Adjusted = (t1 - t0) / (1 - t0);\r\n        return this.split(t0)[1].split(t1Adjusted)[0];\r\n    }\r\n    reversed() {\r\n        return new BezierCurve(this.p3, this.p2, this.p1, this.p0, 1 - this.tMax, 1 - this.tMin);\r\n    }\r\n    getCoefficients() {\r\n        const { p0, p1, p2, p3 } = this;\r\n        // calculate cubic equation coefficients\r\n        // a t³ + b t² + c t + d = 0\r\n        // multiplying out the cubic Bézier curve equation gives:\r\n        // a = -p0 + 3 p1 - 3 p2 + p3\r\n        // b = 3 p0 - 6 p1 + 3 p2\r\n        // c = -3 p0 + 3 p1\r\n        // d = p0 - p\r\n        const a = p1\r\n            .minus(p2)\r\n            .times(3)\r\n            .minus(p0)\r\n            .plus(p3);\r\n        const b = p0\r\n            .plus(p2)\r\n            .times(3)\r\n            .minus(p1.times(6));\r\n        const c = p1.minus(p0).times(3);\r\n        const d = p0;\r\n        return [a, b, c, d];\r\n    }\r\n    tangentCoefficients() {\r\n        const { p0, p1, p2, p3 } = this;\r\n        const p01 = p1.minus(p0), p12 = p2.minus(p1), p23 = p3.minus(p2);\r\n        const a = p01\r\n            .plus(p23)\r\n            .times(3)\r\n            .minus(p12.times(6));\r\n        const b = p12.minus(p01).times(6);\r\n        const c = p01.times(3);\r\n        return [V3.O, a, b, c];\r\n    }\r\n    pointT2(p, tMin = this.tMin, tMax = this.tMax) {\r\n        const t = this.closestTToPoint(p, undefined, tMin, tMax);\r\n        assert(this.at(t).like(p));\r\n        return t;\r\n    }\r\n    pointT(p) {\r\n        const { p0, p1, p2, p3 } = this;\r\n        // calculate cubic equation coefficients\r\n        // a t³ + b t² + c t + d = 0\r\n        // multiplying out the cubic Bézier curve equation gives:\r\n        // a = -p0 + 3 p1 - 3 p2 + p3\r\n        // b = 3 p0 - 6 p1 + 3 p2\r\n        // c = -3 p0 + 3 p1\r\n        // d = p0 - p\r\n        const a = p1\r\n            .minus(p2)\r\n            .times(3)\r\n            .minus(p0)\r\n            .plus(p3);\r\n        const b = p0\r\n            .plus(p2)\r\n            .times(3)\r\n            .minus(p1.times(6));\r\n        const c = p1.minus(p0).times(3);\r\n        const d = p0.minus(p);\r\n        // a t³ + b t² + c t + d = 0 is 3 cubic equations, some of which can be degenerate\r\n        const maxDim = NLA_PRECISION < a.maxAbsElement()\r\n            ? a.maxAbsDim()\r\n            : NLA_PRECISION < b.maxAbsElement()\r\n                ? b.maxAbsDim()\r\n                : NLA_PRECISION < c.maxAbsElement()\r\n                    ? c.maxAbsDim()\r\n                    : assertNever();\r\n        const results = solveCubicReal2(a.e(maxDim), b.e(maxDim), c.e(maxDim), d.e(maxDim)).filter(t => this.at(t).like(p));\r\n        if (0 == results.length)\r\n            return NaN;\r\n        if (1 == results.length)\r\n            return results[0];\r\n        throw new Error('multiple intersection ' + this.toString() + p.sce);\r\n    }\r\n    pointT3(p) {\r\n        const { p0, p1, p2, p3 } = this;\r\n        // calculate cubic equation coefficients\r\n        // a t³ + b t² + c t + d = 0\r\n        // multiplying out the cubic Bézier curve equation gives:\r\n        // a = -p0 + 3 p1 - 3 p2 + p3\r\n        // b = 3 p0 - 6 p1 + 3 p2\r\n        // c = -3 p0 + 3 p1\r\n        // d = p0 - p\r\n        const a = p1\r\n            .minus(p2)\r\n            .times(3)\r\n            .minus(p0)\r\n            .plus(p3)\r\n            .els();\r\n        const b = p0\r\n            .plus(p2)\r\n            .times(3)\r\n            .minus(p1.times(6))\r\n            .els();\r\n        const c = p1\r\n            .minus(p0)\r\n            .times(3)\r\n            .els();\r\n        const d = p0.minus(p).els();\r\n        let results = undefined;\r\n        // assume passed point is on curve and that curve does not self-intersect,\r\n        // i.e. there is exactly one correct result for t\r\n        // try to find a single result in the x-dimension, if multiple are found,\r\n        // filter them by checking the other dimensions\r\n        for (let dim = 0; dim < 3; dim++) {\r\n            if (eq0(a[dim]) && eq0(b[dim]) && eq0(c[dim])) {\r\n                // for case x:\r\n                // ax == bx == cx == 0 => x(t) = dx\r\n                // x value is constant\r\n                // if x == 0 for all t, this does not limit the result, otherwise, there is no result, i.e\r\n                // the passed point is not on the curve\r\n                if (!eq0(d[dim]))\r\n                    return NaN;\r\n            }\r\n            else {\r\n                const newResults = solveCubicReal2(a[dim], b[dim], c[dim], d[dim]);\r\n                if (0 == newResults.length)\r\n                    return NaN;\r\n                if (1 == newResults.length)\r\n                    return newResults[0];\r\n                if (results) {\r\n                    results = results.filter(t => newResults.some(t2 => eq(t, t2)));\r\n                    if (0 == results.length)\r\n                        return NaN;\r\n                    if (1 == results.length)\r\n                        return results[0];\r\n                }\r\n                else {\r\n                    results = newResults;\r\n                }\r\n            }\r\n        }\r\n        throw new Error('multiple intersection ' + results + this.toString() + p.sce);\r\n    }\r\n    transform(m4) {\r\n        // perspective projection turn bezier curve into rational spline\r\n        assert(m4.isNoProj(), m4.str);\r\n        return new BezierCurve(m4.transformPoint(this.p0), m4.transformPoint(this.p1), m4.transformPoint(this.p2), m4.transformPoint(this.p3), this.tMin, this.tMax);\r\n    }\r\n    isClosed() {\r\n        return this.p0.like(this.p3);\r\n    }\r\n    isQuadratic() {\r\n        return this.p0.lerp(this.p1, 1.5).like(this.p3.lerp(this.p2, 1.5));\r\n    }\r\n    debugInfo() {\r\n        return {\r\n            lines: [0, 1, 1, 2, 2, 3].map(i => this.points[i]),\r\n            points: this.points,\r\n        };\r\n    }\r\n    split(t) {\r\n        // do de Casteljau's algorithm at t, the resulting points are the points needed to create 2 new curves\r\n        const s = 1 - t;\r\n        const { p0, p1, p2, p3 } = this;\r\n        /*\r\n        p3 // n3\r\n        b01 = s p0 + t p1\r\n        b11 = s p1 + t p2\r\n        b21 = s p2 + t p3 // n2\r\n        b02 = s b01 + t b11\r\n        b12 = s b11 + t b21 // n1\r\n        b03 = s b02 + t b12 // n0\r\n\r\n        c01 =\r\n        */\r\n        const b01 = p0.times(s).plus(p1.times(t)), b11 = p1.times(s).plus(p2.times(t)), b21 = p2.times(s).plus(p3.times(t));\r\n        const b02 = b01.times(s).plus(b11.times(t)), b12 = b11.times(s).plus(b21.times(t));\r\n        const b03 = b02.times(s).plus(b12.times(t));\r\n        return [new BezierCurve(p0, b01, b02, b03), new BezierCurve(b03, b12, b21, p3)];\r\n    }\r\n    containsPoint(p) {\r\n        return isFinite(this.pointT(p));\r\n    }\r\n    roots() {\r\n        /**\r\n         *            := (3 (p3 - p2) - 6 (p2 - p1) + 3 (p1 - p0)) t²*\r\n         *                + (-6 (p1 - p0) + 6 (p2 - p1)) t\r\n         *                + 3 (p1 - p0)\r\n         *                */\r\n        const { p0, p1, p2, p3 } = this;\r\n        const p01 = p1.minus(p0), p12 = p2.minus(p1), p23 = p3.minus(p2);\r\n        const a = p01\r\n            .plus(p23)\r\n            .times(3)\r\n            .minus(p12.times(6));\r\n        const b = p12.minus(p01).times(6);\r\n        const c = p01.times(3);\r\n        return arrayFromFunction(3, dim => solveCubicReal2(0, a.e(dim), b.e(dim), c.e(dim)));\r\n    }\r\n    isInfosWithLine(anchorWC, dirWC, tMin, tMax, lineMin = -100000, lineMax = 100000) {\r\n        // const dirLength = dirWC.length()\r\n        // // TODO: no:\r\n        // let result = Curve.ispsRecursive(this, this.tMin, this.tMax, new L3(anchorWC, dirWC.unit()), lineMin, lineMax)\r\n        // result = fuzzyUniquesF(result, info => info.tOther)\r\n        // result.forEach(info => (info.tOther /= dirLength))\r\n        // return result\r\n        // looking for this.at(t) == line.at(s)\r\n        // this.at(t).x == anchorWC.x + dirWC.x * s\r\n        // (this.at(t).x - anchorWC.x) / dirWC.x == s (analogue for y and z) (1x, 1y, 1z)\r\n        // (1x) - (1y):\r\n        // (this.at(t).x - anchorWC.x) / dirWC.x - (this.at(t).y - anchorWC.y) / dirWC.y == 0\r\n        // (this.at(t).x - anchorWC.x) * dirWC.y - (this.at(t).y - anchorWC.y) * dirWC.x == 0 (2)\r\n        // cubic equation params (see #pointT):\r\n        const { p0, p1, p2, p3 } = this;\r\n        const a = p1\r\n            .minus(p2)\r\n            .times(3)\r\n            .minus(p0)\r\n            .plus(p3);\r\n        const v1 = V3.UNITS[a.minAbsDim()];\r\n        const testPlane = P3.forAnchorAndPlaneVectors(anchorWC, dirWC, v1.isParallelTo(dirWC) ? a : v1);\r\n        return this.isTsWithPlane(testPlane)\r\n            .map(tThis => {\r\n            const p = this.at(tThis);\r\n            return { tThis, tOther: L3.pointT(anchorWC, dirWC, p), p };\r\n        })\r\n            .filter(info => L3.containsPoint(anchorWC, dirWC, info.p));\r\n    }\r\n    closestPointToLine(line, tMin, tMax) {\r\n        // (this(t)-line(s)) * line.dir == 0 (1)\r\n        // (this(t)-line(s)) * this.tangentAt(t) == 0 (2)\r\n        // this(t) * line.dir - line(s) * line.dir == 0\r\n        // this(t) * line.dir - line.anchor * line.dir - s line.dir * line.dir == 0\r\n        // this(t) * line.dir - line.anchor * line.dir == s (3)\r\n        // insert (3) in (2)\r\n        // (this(t)-line(this(t) * line.dir - line.anchor * line.dir)) * this.tangentAt(t) == 0 (4)\r\n        // (4) is a 5th degree polynomial, solve numerically\r\n        tMin = isFinite(tMin) ? tMin : this.tMin;\r\n        tMax = isFinite(tMax) ? tMax : this.tMax;\r\n        const anchorDotDir1 = line.anchor.dot(line.dir1);\r\n        const f = (t) => {\r\n            const atT = this.at(t);\r\n            return atT.minus(line.at(atT.dot(line.dir1) - anchorDotDir1)).dot(this.tangentAt(t));\r\n        };\r\n        const STEPS = 32;\r\n        const startT = arrayFromFunction(STEPS, i => tMin + (tMax - tMin) * i / STEPS).withMax(t => -f(t));\r\n        return newtonIterate1d(f, startT, 8);\r\n    }\r\n    /**\r\n     *\r\n     * @param bezier\r\n     * @param tMin\r\n     * @param tMax\r\n     * @param sMin\r\n     * @param {number=} sMax\r\n     * @returns\r\n     */\r\n    isInfosWithBezier3(bezier, tMin, tMax, sMin, sMax) {\r\n        const handleStartTS = (startT, startS) => {\r\n            if (!result.some(info => eq(info.tThis, startT) && eq(info.tOther, startS))) {\r\n                const f1 = (t, s) => this.tangentAt(t).dot(this.at(t).minus(bezier.at(s)));\r\n                const f2 = (t, s) => bezier.tangentAt(s).dot(this.at(t).minus(bezier.at(s)));\r\n                // f = (b1, b2, t1, t2) = b1.tangentAt(t1).dot(b1.at(t1).minus(b2.at(t2)))\r\n                const fdt1 = (b1, b2, t1, t2) => b1.ddt(t1).dot(b1.at(t1).minus(b2.at(t2))) + b1.tangentAt(t1).squared();\r\n                const fdt2 = (b1, b2, t1, t2) => -b1.tangentAt(t1).dot(b2.tangentAt(t2));\r\n                const ni = newtonIterate2dWithDerivatives(f1, f2, startT, startS, 16, fdt1.bind(undefined, this, bezier), fdt2.bind(undefined, this, bezier), (t, s) => -fdt2(bezier, this, s, t), (t, s) => -fdt1(bezier, this, s, t));\r\n                result.push({ tThis: ni.x, tOther: ni.y, p: this.at(ni.x) });\r\n            }\r\n        };\r\n        tMin = undefined !== tMin ? tMin : this.tMin;\r\n        tMax = undefined !== tMax ? tMax : this.tMax;\r\n        sMin = undefined !== sMin ? sMin : bezier.tMin;\r\n        sMax = undefined !== sMax ? sMax : bezier.tMax;\r\n        // stack of indices:\r\n        const indices = [tMin, tMax, sMin, sMax];\r\n        const result = [];\r\n        while (indices.length) {\r\n            const i = indices.length - 4;\r\n            const tMin = indices[i], tMax = indices[i + 1], sMin = indices[i + 2], sMax = indices[i + 3];\r\n            indices.length -= 4;\r\n            const thisAABB = this.getAABB(tMin, tMax);\r\n            const otherAABB = bezier.getAABB(sMin, sMax);\r\n            // console.log(tMin, tMax, sMin, sMax, thisAABB.sce, otherAABB.sce)\r\n            if (thisAABB && otherAABB && thisAABB.intersectsAABB2d(otherAABB)) {\r\n                const tMid = (tMin + tMax) / 2;\r\n                const sMid = (sMin + sMax) / 2;\r\n                const EPS = 0.00001;\r\n                if (tMax - tMin < EPS || sMax - sMin < EPS) {\r\n                    console.log(tMin, tMax, sMin, sMax);\r\n                    console.log(thisAABB.sce);\r\n                    console.log(otherAABB.sce);\r\n                    console.log(tMid, sMid);\r\n                    handleStartTS(tMid, sMid);\r\n                }\r\n                else {\r\n                    indices.push(tMin, tMid, sMin, sMid, tMin, tMid, sMid, sMax, tMid, tMax, sMin, sMid, tMid, tMax, sMid, sMax);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    isInfosWithBezier(bezier, tMin, tMax, sMin, sMax) {\r\n        tMin = undefined !== tMin ? tMin : this.tMin;\r\n        tMax = undefined !== tMax ? tMax : this.tMax;\r\n        sMin = undefined !== sMin ? sMin : bezier.tMin;\r\n        sMax = undefined !== sMax ? sMax : bezier.tMax;\r\n        assertf(() => tMin < tMax);\r\n        assertf(() => sMin < sMax);\r\n        const result = [];\r\n        const likeCurves = this.likeCurve(bezier), colinearCurves = this.isColinearTo(bezier);\r\n        if (likeCurves || colinearCurves) {\r\n            if (!likeCurves) {\r\n                // only colinear\r\n                // recalculate sMin and sMax so they are valid on this, from then on we can ignore bezier\r\n                sMin = this.pointT(bezier.at(sMin));\r\n                sMax = this.pointT(bezier.at(sMax));\r\n            }\r\n            tMin = Math.min(tMin, sMin);\r\n            tMax = Math.max(tMax, sMax);\r\n            const splits = fuzzyUniques(this.roots()\r\n                .concatenated()\r\n                .filter(isFinite)\r\n                .concat([tMin, tMax])).sort(MINUS);\r\n            //const aabbs = arrayFromFunction(splits.length - 1, i => this.getAABB(splits[i], splits[i + 1]))\r\n            Array.from(combinations(splits.length - 1)).forEach(({ i, j }) => {\r\n                // adjacent curves can't intersect\r\n                if (Math.abs(i - j) > 2) {\r\n                    // console.log(splits[i], splits[i + 1], splits[j], splits[j + 1], aabbs[i], aabbs[j])\r\n                    //findRecursive(splits[i], splits[i + 1], splits[j], splits[j + 1], aabbs[i], aabbs[j])\r\n                    result.push(...Curve.ispsRecursive(this, splits[i], splits[i + 1], bezier, splits[j], splits[j + 1]));\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return Curve.ispsRecursive(this, tMin, tMax, bezier, sMin, sMax);\r\n        }\r\n        return result;\r\n    }\r\n    selfIntersectionsInfo() {\r\n        return this.isInfosWithBezier(this);\r\n    }\r\n    isInfosWithCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.isInfosWithLine(curve.anchor, curve.dir1, curve.tMin, curve.tMax);\r\n        }\r\n        if (curve instanceof BezierCurve) {\r\n            return this.isInfosWithBezier(curve);\r\n        }\r\n        return curve.isInfosWithCurve(this).map(({ tThis, tOther, p }) => ({ tThis: tOther, tOther: tThis, p }));\r\n    }\r\n    /**\r\n     * Approximate this bezier curve with a number of circular segments. This curve is recursively split in half until\r\n     * segments are close enough (relative error < REL_ERR in two test points) to an arc which goes through the start,\r\n     * end and mid points of the segment.\r\n     * @returns each EllipseCurve is circular and their tMin and tMax respectively define their start and end points.\r\n     * @param t0 Start parameter of segment which should be approximated.\r\n     * @param t1 End parameter of segment which should be approximated.\r\n     * @param REL_ERROR max allowable relative error.\r\n     * @param result Resulting circle arcs are stored in this array. Mainly used by the recursion.\r\n     */\r\n    circleApprox(t0 = this.tMin, t1 = this.tMax, REL_ERROR = 1 / 1024, result = []) {\r\n        const a = this.at(t0), b = this.at(t1), tMid = (t0 + t1) / 2, pMid = this.at(tMid), abLine = L3.throughPoints(a, b);\r\n        if (!abLine.containsPoint(pMid) && between(abLine.pointT(pMid), 0, abLine.pointT(b))) {\r\n            const arc = EllipseCurve.circleThroughPoints(a, pMid, b), arcRadius = arc.f1.length(), pTest1 = this.at(lerp(t0, t1, 0.25)), pTest2 = this.at(lerp(t0, t1, 0.75));\r\n            if (abs(arc.center.distanceTo(pTest1) / arcRadius - 1) <= REL_ERROR &&\r\n                abs(arc.center.distanceTo(pTest2) / arcRadius - 1) <= REL_ERROR) {\r\n                result.push(arc);\r\n                return result;\r\n            }\r\n        }\r\n        this.circleApprox(t0, tMid, REL_ERROR, result);\r\n        this.circleApprox(tMid, t1, REL_ERROR, result);\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * https://en.wikipedia.org/wiki/Cubic_function#/media/File:Graph_of_cubic_polynomial.svg\r\n */\r\nBezierCurve.EX2D = BezierCurve.graphXY(2, -3, -3, 2);\r\nBezierCurve.EX3D = new BezierCurve(V3.O, V(-0.1, -1, 1), V(1.1, 1, 1), V3.X);\r\nBezierCurve.QUARTER_CIRCLE = BezierCurve.approximateUnitArc(PI / 2);\r\nBezierCurve.prototype.hlol = Curve.hlol++;\r\nBezierCurve.prototype.tIncrement = 1 / 80;\r\n//# sourceMappingURL=BezierCurve.js.map","import { arrayFromFunction, assertNumbers, eq, eq0, hasConstructor, le, M4, snap0, V3 } from 'ts3dutils';\r\nimport { intersectionUnitHyperbolaLine, parabola4Projection, XiEtaCurve, } from '../index';\r\nimport { abs, cosh, min, PI, sign, sqrt } from '../math';\r\n/**\r\n * x² - y² = 1\r\n * C(t) = center + f1 * cosh(t) + f2 * sinh(t)\r\n */\r\nexport class HyperbolaCurve extends XiEtaCurve {\r\n    constructor(center, f1, f2, tMin = -7, tMax = 7) {\r\n        super(center, f1, f2, tMin, tMax);\r\n    }\r\n    static XYLCValid(pLC) {\r\n        return pLC.x > 0 && eq(1, pLC.x * pLC.x - pLC.y * pLC.y);\r\n    }\r\n    static XYLCPointT(pLC) {\r\n        return Math.asinh(pLC.y);\r\n    }\r\n    /**\r\n     * http://www.wolframalpha.com/input/?i=x%C2%BRep-y%C2%BRep%3D1,ax%2Bby%3Dc\r\n     * Minor empiric test shows asinh(eta) consistently gets more accurate results than atanh(eta/xi)\r\n     */\r\n    static intersectionUnitLine(a, b, c) {\r\n        if (eq0(b)) {\r\n            const sqrtVal = snap0(Math.pow(c, 2) / Math.pow(a, 2) - 1);\r\n            if (sqrtVal < 0 || c * a < 0) {\r\n                return [];\r\n            }\r\n            else if (sqrtVal == 0) {\r\n                return [0];\r\n            }\r\n            const eta1 = Math.sqrt(sqrtVal);\r\n            return [-Math.asinh(eta1), Math.asinh(eta1)];\r\n        }\r\n        else if (eq(abs(a), abs(b))) {\r\n            if (le(c * a, 0)) {\r\n                return [];\r\n            }\r\n            const eta = sign(a * b) * (Math.pow(c, 2) - Math.pow(a, 2)) / 2 / a / c;\r\n            return [Math.asinh(eta)];\r\n        }\r\n        else {\r\n            const sqrtVal = snap0(Math.pow(b, 2) * (-(Math.pow(a, 2)) + Math.pow(b, 2) + Math.pow(c, 2)));\r\n            if (sqrtVal < 0) {\r\n                return [];\r\n            }\r\n            const xi1 = (a * c - Math.sqrt(sqrtVal)) / (Math.pow(a, 2) - Math.pow(b, 2));\r\n            const xi2 = (a * c + Math.sqrt(sqrtVal)) / (Math.pow(a, 2) - Math.pow(b, 2));\r\n            const eta1 = (Math.pow(b, 2) * c - a * Math.sqrt(sqrtVal)) / (b * (Math.pow(b, 2) - Math.pow(a, 2)));\r\n            const eta2 = (Math.pow(b, 2) * c + a * Math.sqrt(sqrtVal)) / (b * (Math.pow(b, 2) - Math.pow(a, 2)));\r\n            return [xi1 > 0 && Math.asinh(eta1), xi2 > 0 && Math.asinh(eta2)].filter((x) => x !== false);\r\n        }\r\n    }\r\n    at(t) {\r\n        assertNumbers(t);\r\n        // = center + f1 cosh t + f2 sinh t\r\n        return this.center.plus(this.f1.times(Math.cosh(t))).plus(this.f2.times(Math.sinh(t)));\r\n    }\r\n    toString() {\r\n        return `${this.center} + ${this.f1} * cosh(t) + ${this.f2} * sinh(t)`;\r\n    }\r\n    tangentAt(t) {\r\n        assertNumbers(t);\r\n        // = f1 sinh t + f2 cosh t\r\n        return this.f1.times(Math.sinh(t)).plus(this.f2.times(Math.cosh(t)));\r\n    }\r\n    tangentAt2(xi, eta) {\r\n        assertNumbers(xi, eta);\r\n        // = f1 eta + f2 xi\r\n        return this.f1.times(eta).plus(this.f2.times(xi));\r\n    }\r\n    ddt(t) {\r\n        assertNumbers(t);\r\n        return this.f1.times(Math.cosh(t)).plus(this.f2.times(Math.sinh(t)));\r\n    }\r\n    isColinearTo(curve) {\r\n        if (!hasConstructor(curve, HyperbolaCurve))\r\n            return false;\r\n        if (!curve.center || !this.center.like(curve.center)) {\r\n            return false;\r\n        }\r\n        if (this === curve) {\r\n            return true;\r\n        }\r\n        const { f1: f1, f2: f2 } = this.rightAngled(), { f1: c1, f2: c2 } = curve.rightAngled();\r\n        return eq(f1.squared(), Math.abs(f1.dot(c1))) && eq(f2.squared(), Math.abs(f2.dot(c2)));\r\n    }\r\n    reversed() {\r\n        return new HyperbolaCurve(this.center, this.f1, this.f2.negated(), -this.tMax, -this.tMin);\r\n    }\r\n    rightAngled() {\r\n        const f1 = this.f1, f2 = this.f2, a = f1.dot(f2), b = f2.squared() + f1.squared();\r\n        if (eq0(a)) {\r\n            return this;\r\n        }\r\n        const g1 = 2 * a, g2 = b + Math.sqrt(b * b - 4 * a * a);\r\n        const { x1: xi, y1: eta } = intersectionUnitHyperbolaLine(g1, g2, 0);\r\n        return new HyperbolaCurve(this.center, f1.times(xi).plus(f2.times(eta)), f1.times(eta).plus(f2.times(xi)));\r\n    }\r\n    eccentricity() {\r\n        const mainAxes = this.rightAngled();\r\n        const f1length = mainAxes.f1.length(), f2length = mainAxes.f1.length();\r\n        const [a, b] = f1length > f2length ? [f1length, f2length] : [f2length, f1length];\r\n        return Math.sqrt(1 + b * b / a / a);\r\n    }\r\n    roots() {\r\n        // tangent(t) = f1 sinh t + f2 cosh t = 0\r\n        // tangentAt2(xi, eta) = f1 eta + f2 xi = V3.O\r\n        // xi² - eta² = 1 (by def for hyperbola)\r\n        return arrayFromFunction(3, dim => {\r\n            const a = this.f2.e(dim), b = this.f1.e(dim);\r\n            return HyperbolaCurve.intersectionUnitLine(a, b, 0);\r\n        });\r\n    }\r\n    transform4(m4) {\r\n        const tMap = (t) => sign(t) * min(10, sqrt(-(1 - cosh(t)) / (1 + cosh(t))));\r\n        // prettier-ignore\r\n        const parabolaToUnitHyperbola = new M4(0, 1, 0, 1, 2, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 1);\r\n        return parabola4Projection(M4.product(m4, this.matrix, parabolaToUnitHyperbola), tMap(this.tMin), tMap(this.tMax));\r\n    }\r\n}\r\nHyperbolaCurve.XY = new HyperbolaCurve(V3.O, V3.X, V3.Y);\r\nHyperbolaCurve.prototype.tIncrement = PI / 16;\r\n//# sourceMappingURL=HyperbolaCurve.js.map","import { assert, assertf, assertInst, assertNumbers, assertVectors, clamp, eq, eq0, hasConstructor, le, lt, V3, VV, } from 'ts3dutils';\r\nimport { Curve, P3 } from '../index';\r\n/**\r\n * A 3-dimensional line. Defined by an anchor and a normalized direction vector.\r\n */\r\nexport class L3 extends Curve {\r\n    constructor(anchor, // line anchor\r\n    dir1, // normalized line dir\r\n    tMin = -4096, tMax = 4096) {\r\n        super(tMin, tMax);\r\n        this.anchor = anchor;\r\n        this.dir1 = dir1;\r\n        assertVectors(anchor, dir1);\r\n        assert(dir1.hasLength(1), 'dir must be unit' + dir1);\r\n        assertf(() => !Number.isNaN(anchor.x));\r\n    }\r\n    isTsWithSurface(surface) {\r\n        return surface.isTsForLine(this);\r\n    }\r\n    static throughPoints(anchor, b, tMin = 0, tMax) {\r\n        const dir = b.minus(anchor);\r\n        return new L3(anchor, dir.unit(), tMin, undefined !== tMax ? tMax : dir.length());\r\n    }\r\n    static anchorDirection(anchor, dir, min = 0, max = dir.length()) {\r\n        const dir1 = dir.unit();\r\n        return new L3(anchor, dir1, 'number' == typeof min ? min : min.minus(anchor).dot(dir1), 'number' == typeof max ? max : max.minus(anchor).dot(dir1));\r\n    }\r\n    static pointT(anchor, dir, x) {\r\n        assertVectors(anchor, dir, x);\r\n        return x.minus(anchor).dot(dir) / dir.squared();\r\n    }\r\n    static at(anchor, dir, t) {\r\n        return anchor.plus(dir.times(t));\r\n    }\r\n    /**\r\n     * Create new line which is the intersection of two planes. Throws error if planes are parallel.\r\n     * @param plane1\r\n     * @param plane2\r\n     */\r\n    static fromPlanes(plane1, plane2) {\r\n        assertInst(P3, plane1, plane2);\r\n        const dir = plane1.normal1.cross(plane2.normal1);\r\n        const length = dir.length();\r\n        if (length < 1e-10) {\r\n            throw new Error('Parallel planes');\r\n        }\r\n        return plane1.intersectionWithPlane(plane2);\r\n    }\r\n    static containsPoint(anchor, dir, p) {\r\n        const closestT = L3.pointT(anchor, dir, p);\r\n        const distance = L3.at(anchor, dir, closestT).distanceTo(p);\r\n        return eq0(distance);\r\n    }\r\n    roots() {\r\n        return [[], [], []];\r\n    }\r\n    containsPoint(p) {\r\n        assertVectors(p);\r\n        const dist = this.distanceToPoint(p);\r\n        assertNumbers(dist);\r\n        return eq0(dist);\r\n    }\r\n    likeCurve(curve) {\r\n        return (this == curve || (hasConstructor(curve, L3) && this.anchor.like(curve.anchor) && this.dir1.like(curve.dir1)));\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (Object.getPrototypeOf(obj) == L3.prototype && this.anchor.equals(obj.anchor) && this.dir1.equals(obj.dir1)));\r\n    }\r\n    isColinearTo(obj) {\r\n        return obj instanceof L3 && this.containsPoint(obj.anchor) && eq(1, Math.abs(this.dir1.dot(obj.dir1)));\r\n    }\r\n    distanceToLine(line) {\r\n        assertInst(L3, line);\r\n        if (this.isParallelToLine(line)) {\r\n            return this.distanceToPoint(line.anchor);\r\n        }\r\n        const dirCross1 = this.dir1.cross(line.dir1).unit();\r\n        const anchorDiff = this.anchor.minus(line.anchor);\r\n        return Math.abs(anchorDiff.dot(dirCross1));\r\n    }\r\n    distanceToPoint(x) {\r\n        assertVectors(x);\r\n        // See http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\r\n        const t = x.minus(this.anchor).dot(this.dir1);\r\n        return this.at(t).distanceTo(x);\r\n        //return x.minus(this.anchor).cross(x.minus(this.anchor.plus(this.dir1))).length()\r\n    }\r\n    asSegmentDistanceToPoint(x, sStart, sEnd) {\r\n        let t = x.minus(this.anchor).dot(this.dir1);\r\n        t = clamp(t, sStart, sEnd);\r\n        return this.at(t)\r\n            .minus(x)\r\n            .length();\r\n    }\r\n    asSegmentDistanceToLine(line, sStart, sEnd) {\r\n        assertInst(L3, line);\r\n        const dirCross = this.dir1.cross(line.dir1);\r\n        const div = dirCross.squared();\r\n        if (eq0(div)) {\r\n            return undefined;\r\n        } // lines parallel\r\n        const anchorDiff = line.anchor.minus(this.anchor);\r\n        // check if distance is zero (see also L3.distanceToLine)\r\n        if (!eq0(anchorDiff.dot(dirCross.unit()))) {\r\n            return undefined;\r\n        }\r\n        let t = this.infoClosestToLine(line).t;\r\n        t = clamp(t, sStart, sEnd);\r\n        return this.at(clamp(t, sStart, sEnd));\r\n    }\r\n    at(t) {\r\n        assertNumbers(t);\r\n        return this.anchor.plus(this.dir1.times(t));\r\n    }\r\n    /**\r\n     * This function returns lambda for a given point x\r\n     *\r\n     * Every point x on this line is described by the equation\r\n     *      x = this.anchor + lambda * this.dir1 | - this.anchor\r\n     *      x - this.anchor = lambda * this.dir1 | DOT this.dir1\r\n     *      (x - this.anchor) DOT this.dir1 = lambda (dir1² is 1 as |dir1| == 1)\r\n     *\r\n     *  @param x\r\n     *  @returns\r\n     */\r\n    pointT(x) {\r\n        assertVectors(x);\r\n        const t = x.minus(this.anchor).dot(this.dir1);\r\n        return t;\r\n    }\r\n    /**\r\n     * Returns true if the line is parallel (this.dir = line.dir || this.dir = -line.dir) to the argument.\r\n     */\r\n    isParallelToLine(line) {\r\n        assertInst(L3, line);\r\n        // we know that 1 == this.dir1.length() == line.dir1.length(), we can check for parallelity simpler than\r\n        // isParallelTo()\r\n        return eq(1, Math.abs(this.dir1.dot(line.dir1)));\r\n    }\r\n    angleToLine(line) {\r\n        assertInst(L3, line);\r\n        return this.dir1.angleTo(line.dir1);\r\n    }\r\n    /**\r\n     *\r\n     * @param line\r\n     * @returns {boolean} If the distance between the lines is zero\r\n     */\r\n    intersectsLine(line) {\r\n        return eq0(this.distanceToLine(line));\r\n    }\r\n    isInfosWithCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.isInfosWithLine(curve.anchor, curve.dir1);\r\n        }\r\n        return super.isInfosWithCurve(curve);\r\n    }\r\n    isInfosWithLine(anchorWC, dirWC) {\r\n        const dirCross = this.dir1.cross(dirWC);\r\n        const div = dirCross.squared();\r\n        if (eq0(div)) {\r\n            // lines are parallel\r\n            return [];\r\n        }\r\n        const anchorDiff = anchorWC.minus(this.anchor);\r\n        if (eq0(anchorDiff.dot(dirCross))) {\r\n            const tThis = anchorDiff.cross(dirWC).dot(dirCross) / div;\r\n            const tOther = anchorDiff.cross(this.dir1).dot(dirCross) / div;\r\n            const p = this.at(tThis);\r\n            return [{ tThis: tThis, tOther: tOther, p: p }];\r\n        }\r\n        return [];\r\n    }\r\n    isInfoWithLine(line) {\r\n        // todo infos?\r\n        assertInst(L3, line);\r\n        const dirCross = this.dir1.cross(line.dir1);\r\n        const div = dirCross.squared();\r\n        if (eq0(div)) {\r\n            return undefined;\r\n        } // lines parallel\r\n        const anchorDiff = line.anchor.minus(this.anchor);\r\n        // check if distance is zero (see also L3.distanceToLine)\r\n        if (!eq0(anchorDiff.dot(dirCross.unit()))) {\r\n            return undefined;\r\n        }\r\n        const t = anchorDiff.cross(line.dir1).dot(dirCross) / div;\r\n        return this.at(t);\r\n    }\r\n    /**\r\n     * returns s and t with this.at(s) == line.at(t)\r\n     */\r\n    intersectionLineST(line) {\r\n        // the two points on two lines the closest two each other are the ones whose\r\n        // connecting\r\n        // TODO Where does this come from?\r\n        // TODO: return value when no IS?\r\n        assertInst(L3, line);\r\n        const dirCross = this.dir1.cross(line.dir1);\r\n        const div = dirCross.squared();\r\n        const anchorDiff = line.anchor.minus(this.anchor);\r\n        const s = anchorDiff.cross(this.dir1).dot(dirCross) / div;\r\n        const t = anchorDiff.cross(line.dir1).dot(dirCross) / div;\r\n        return { s: s, t: t };\r\n        // console.log(segmentIntersectsRay, a, b, \"ab\", ab, \"p\", p, \"dir\", dir, s > 0 && t / div >= 0 && t / div <= 1,\r\n        // \"s\", s, \"t\", t, \"div\", div)\r\n    }\r\n    ddt() {\r\n        return V3.O;\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.anchor, this.dir1];\r\n    }\r\n    closestTToPoint(p) {\r\n        // similar logic as pointT; we project the vector (anchor -> p) onto dir1, then add anchor back to it\r\n        const nearestT = p.minus(this.anchor).dot(this.dir1);\r\n        return nearestT;\r\n    }\r\n    infoClosestToLine(line) {\r\n        /*\r\n         line = a + s*b\r\n         this = c + t*d\r\n\r\n         (this - line) * b = 0\r\n         (this - line) * d = 0\r\n\r\n         (a + s*b - c - t*d) * b = 0\r\n         (a + s*b - c - t*d) * d = 0\r\n\r\n         (a - c + s*b - t*d) * b = 0\r\n         (a - c + s*b - t*d) * d = 0\r\n\r\n         (a - c)*b + (s*b - t*d)*b = 0\r\n         (a - c)*d + (s*b - t*d)*d = 0\r\n\r\n         (a - c)*b + s*(b*b) - t*(d*b) = 0\r\n         (a - c)*d + s*(b*d) - t*(d*d) = 0\r\n\r\n         s = (t*(d*b) - (a - c)*b) / (b*b)\r\n         =>\r\n         (a - c)*d + (t*(d*b) - (a - c)*b) / (b*b)*(b*d) - t*(d*d) = 0 | * (b*b)\r\n         (a - c)*d * (b*b) + (t*(d*b) - (a - c)*b)*(b*d) - t*(d*d) * (b*b) = 0\r\n         (a - c)*d * (b*b) + t*(d*b)*(b*d) - (a - c)*b*(b*d) - t*(d*d) * (b*b) = 0\r\n         t = ((a - c)*b*(b*d) - (a - c)*d * (b*b)) / ((d*b)*(b*d) - (d*d) * (b*b))\r\n         */\r\n        if (this.isParallelToLine(line)) {\r\n            return { t: NaN, s: NaN, distance: this.distanceToLine(line) };\r\n        }\r\n        const a = line.anchor, b = line.dir1, c = this.anchor, d = this.dir1;\r\n        const bd = b.dot(d), bb = b.squared(), dd = d.squared(), ca = a.minus(c), divisor = bd * bd - dd * bb;\r\n        const t = (ca.dot(b) * bd - ca.dot(d) * bb) / divisor;\r\n        const s = (ca.dot(b) * dd - ca.dot(d) * bd) / divisor;\r\n        return {\r\n            t: t,\r\n            s: s,\r\n            closest: this.at(t),\r\n            closest2: line.at(s),\r\n            distance: this.at(t).distanceTo(line.at(s)),\r\n        };\r\n    }\r\n    intersectionWithPlane(plane) {\r\n        // plane: plane.normal1 * p = plane.w\r\n        // line: p=line.point + lambda * line.dir1\r\n        const lambda = (plane.w - plane.normal1.dot(this.anchor)) / plane.normal1.dot(this.dir1);\r\n        const point = this.anchor.plus(this.dir1.times(lambda));\r\n        return point;\r\n    }\r\n    tangentAt() {\r\n        return this.dir1;\r\n    }\r\n    isTWithPlane(plane) {\r\n        // plane: plane.normal1 * p = plane.w\r\n        // line: p=line.point + lambda * line.dir1\r\n        const div = plane.normal1.dot(this.dir1);\r\n        if (eq0(div))\r\n            return NaN;\r\n        const lambda = (plane.w - plane.normal1.dot(this.anchor)) / div;\r\n        return lambda;\r\n    }\r\n    reversed() {\r\n        return new L3(this.anchor, this.dir1.negated(), -this.tMax, -this.tMin);\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        const t = this.isTWithPlane(planeWC);\r\n        return isNaN(t) ? [] : [t];\r\n    }\r\n    flipped() {\r\n        return new L3(this.anchor, this.dir1.negated());\r\n    }\r\n    transform(m4) {\r\n        const newAnchor = m4.transformPoint(this.anchor);\r\n        const newDir = m4.transformVector(this.dir1);\r\n        return new L3(newAnchor, newDir.unit(), this.tMin * newDir.length(), this.tMax * newDir.length());\r\n    }\r\n    transform4(m4) {\r\n        const vanishingPlane = P3.vanishingPlane(m4);\r\n        if (!vanishingPlane)\r\n            return this.transform(m4);\r\n        const pMin = this.at(this.tMin);\r\n        const pMax = this.at(this.tMax);\r\n        if (le(vanishingPlane.distanceToPointSigned(pMin), 0) || le(vanishingPlane.distanceToPointSigned(pMax), 0)) {\r\n            throw new Error('line must be in front of vanishingPlane in [tMin, tMax]');\r\n        }\r\n        const anchor = lt(0, vanishingPlane.distanceToPointSigned(this.anchor))\r\n            ? this.anchor\r\n            : this.at((this.tMin + this.tMax) / 2);\r\n        const transformedAnchor = m4.timesVector(VV(anchor.x, anchor.y, anchor.z, 1));\r\n        const transformedVector = m4.timesVector(VV(this.dir1.x, this.dir1.y, this.dir1.z, 0));\r\n        const newDir = transformedVector\r\n            .times(transformedAnchor.w)\r\n            .minus(transformedAnchor.times(transformedVector.w))\r\n            .V3();\r\n        const newAnchor = transformedAnchor.p3();\r\n        return L3.anchorDirection(newAnchor, newDir, m4.transformPoint(pMin), m4.transformPoint(pMax));\r\n    }\r\n    hashCode() {\r\n        return this.anchor.hashCode() * 31 + this.dir1.hashCode();\r\n    }\r\n}\r\nL3.X = new L3(V3.O, V3.X);\r\nL3.Y = new L3(V3.O, V3.Y);\r\nL3.Z = new L3(V3.O, V3.Z);\r\nL3.prototype.hlol = Curve.hlol++;\r\nL3.prototype.tIncrement = 256;\r\n//# sourceMappingURL=L3.js.map","import { arrayRange, assert, assertVectors, bisect, callsce, clamp, fuzzyUniques, M4, newtonIterate2dWithDerivatives, V3, } from 'ts3dutils';\r\nimport { curvePoint, EllipsoidSurface, followAlgorithm2d, ImplicitCurve, ImplicitSurface, MathFunctionR2R, PlaneSurface, ProjectedCurveSurface, surfaceIsICurveIsInfosWithLine, } from '../index';\r\nimport { abs, ceil, floor, max, min } from '../math';\r\nexport class PICurve extends ImplicitCurve {\r\n    constructor(points, tangents, parametricSurface, implicitSurface, pmPoints, pmTangents, stepSize, dir = 1, generator, tMin, tMax) {\r\n        super(points, tangents, dir, generator, tMin, tMax);\r\n        this.parametricSurface = parametricSurface;\r\n        this.implicitSurface = implicitSurface;\r\n        this.pmPoints = pmPoints;\r\n        this.pmTangents = pmTangents;\r\n        this.stepSize = stepSize;\r\n        assert(Array.isArray(pmPoints));\r\n        assert(dir == 1);\r\n        assert(stepSize <= 1);\r\n        const pf = parametricSurface.pUVFunc();\r\n        const dpdu = parametricSurface.dpdu();\r\n        const dpdv = parametricSurface.dpdv();\r\n        const didp = implicitSurface.didp.bind(implicitSurface);\r\n        this.didu = (u, v) => didp(pf(u, v)).dot(dpdu(u, v));\r\n        this.didv = (u, v) => didp(pf(u, v)).dot(dpdv(u, v));\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            assert(!points[i].equals(points[i + 1]));\r\n            //assert(parametricSurface.pUV(pmPoints[i].x, pmPoints[i].y).equals(points[i]))\r\n        }\r\n        {\r\n            const ps = this.parametricSurface;\r\n            const is = implicitSurface;\r\n            const pFunc = ps.pUVFunc(), iFunc = is.implicitFunction();\r\n            const dpdu = ps.dpdu();\r\n            const dpdv = ps.dpdv();\r\n            const didp = is.didp.bind(is);\r\n            const mf = MathFunctionR2R.forFFxFy((x, y) => iFunc(pFunc(x, y)), (u, v) => didp(pFunc(u, v)).dot(dpdu(u, v)), (u, v) => didp(pFunc(u, v)).dot(dpdv(u, v)));\r\n            const { points } = followAlgorithm2d(mf, this.pmPoints[0], stepSize, ps, (u, v) => is.containsPoint(pFunc(u, v)), this.pmPoints.last, this.pmTangents[0]);\r\n            if (points.length !== this.points.length) {\r\n                followAlgorithm2d(mf, this.pmPoints[0], stepSize, ps, (u, v) => is.containsPoint(pFunc(u, v)), this.pmPoints.last, this.pmTangents[0]);\r\n            }\r\n            assert(points.length == this.points.length, points.length, this.points.length);\r\n        }\r\n    }\r\n    static forParametricStartEnd(ps, is, pmStart, pmEnd, stepSize = 0.02, startPMTangent, tMin, tMax) {\r\n        const pFunc = ps.pUVFunc(), iFunc = is.implicitFunction();\r\n        const dpdu = ps.dpdu();\r\n        const dpdv = ps.dpdv();\r\n        const didp = is.didp.bind(is);\r\n        const mf = MathFunctionR2R.forFFxFy((x, y) => iFunc(pFunc(x, y)), (u, v) => didp(pFunc(u, v)).dot(dpdu(u, v)), (u, v) => didp(pFunc(u, v)).dot(dpdv(u, v)));\r\n        const { points, tangents } = followAlgorithm2d(mf, pmStart, stepSize, ps, (u, v) => is.containsPoint(pFunc(u, v)), pmEnd, startPMTangent);\r\n        return PICurve.forParametricPointsTangents(ps, is, points, tangents, stepSize, 1, tMin, tMax);\r\n    }\r\n    static forStartEnd(ps, is, start, end, stepSize = 0.02, startTangent, min, max) {\r\n        const startPM = ps.uvP(start);\r\n        const dpdu = ps.dpdu()(startPM.x, startPM.y), dpdv = ps.dpdv()(startPM.x, startPM.y);\r\n        const startPMTangent = startTangent &&\r\n            M4.forSys(dpdu, dpdv)\r\n                .inversed()\r\n                .transformVector(startTangent);\r\n        // assert(dpdu.times(startPMTangent.x).plus(dpdv.times(startPMTangent.y)).like(startTangent))\r\n        const curve = PICurve.forParametricStartEnd(ps, is, startPM, ps.uvP(end), stepSize, startPMTangent);\r\n        return curve.withBounds(min && curve.pointT(min), max && curve.pointT(max));\r\n    }\r\n    static forParametricPointsTangents(ps, is, pmPoints, pmTangents, stepSize, dir = 1, tMin, tMax) {\r\n        const pFunc = ps.pUVFunc(), dpdu = ps.dpdu();\r\n        const dpdv = ps.dpdv();\r\n        const points = pmPoints.map(({ x, y }) => pFunc(x, y));\r\n        const tangents = pmPoints.map(({ x: u, y: v }, i) => {\r\n            const ds = dpdu(u, v);\r\n            const dt = dpdv(u, v);\r\n            return ds.times(pmTangents[i].x).plus(dt.times(pmTangents[i].y));\r\n            //const p = points[i]\r\n            //return cs.normalP(p).cross(ses.normalP(p))\r\n            //\t.toLength(ds.times(pmTangents[i].x).plus(dt.times(pmTangents[i].y)).length())\r\n        });\r\n        return new PICurve(points, tangents, ps, is, pmPoints, pmTangents, stepSize, dir, undefined, tMin, tMax);\r\n    }\r\n    getConstructorParameters() {\r\n        return [\r\n            this.points,\r\n            this.tangents,\r\n            this.parametricSurface,\r\n            this.implicitSurface,\r\n            this.pmPoints,\r\n            this.pmTangents,\r\n            this.stepSize,\r\n            this.dir,\r\n            this.generator,\r\n        ];\r\n    }\r\n    implicitCurve() {\r\n        const pF = this.parametricSurface.pUVFunc();\r\n        const iF = this.implicitSurface.implicitFunction();\r\n        return (u, v) => iF(pF(u, v));\r\n    }\r\n    isColinearTo(curve) {\r\n        if (curve instanceof PICurve) {\r\n            if (this.equals(curve)) {\r\n                return true;\r\n            }\r\n            if (this.parametricSurface.isCoplanarTo(curve.parametricSurface) &&\r\n                this.implicitSurface.isCoplanarTo(curve.implicitSurface)) {\r\n                // TODO\r\n            }\r\n            return false;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    containsPoint(p) {\r\n        assertVectors(p);\r\n        const t = this.pointT(p);\r\n        return !isNaN(t) && this.isValidT(t);\r\n    }\r\n    equals(obj) {\r\n        return (Object.getPrototypeOf(obj) == PICurve.prototype &&\r\n            this.parametricSurface.equals(obj.parametricSurface) &&\r\n            this.implicitSurface.equals(obj.implicitSurface) &&\r\n            this.points[0].equals(obj.points[0]) &&\r\n            this.tangents[0].equals(obj.tangents[0]) &&\r\n            this.dir === obj.dir);\r\n    }\r\n    hashCode() {\r\n        let hashCode = 0;\r\n        hashCode = hashCode * 31 + this.parametricSurface.hashCode();\r\n        hashCode = hashCode * 31 + this.implicitSurface.hashCode();\r\n        hashCode = hashCode * 31 + this.points[0].hashCode();\r\n        hashCode = hashCode * 31 + this.tangents[0].hashCode();\r\n        return hashCode | 0;\r\n    }\r\n    tangentP(point) {\r\n        assertVectors(point);\r\n        assert(this.containsPoint(point), 'this.containsPoint(point)');\r\n        const t = this.pointT(point);\r\n        return this.tangentAt(t);\r\n    }\r\n    tangentAt(t) {\r\n        assert(!isNaN(t));\r\n        if (0 === t % 1)\r\n            return this.tangents[t];\r\n        const uv = this.uvT(t);\r\n        const uvTangent = new V3(-this.didv(uv.x, uv.y), this.didu(uv.x, uv.y), 0).toLength(this.stepSize);\r\n        const du = this.parametricSurface.dpdu()(uv.x, uv.y);\r\n        const dv = this.parametricSurface.dpdv()(uv.x, uv.y);\r\n        return du.times(uvTangent.x).plus(dv.times(uvTangent.y));\r\n    }\r\n    at(t) {\r\n        assert(!isNaN(t));\r\n        if (0 === t % 1)\r\n            return this.points[t];\r\n        const startParams = V3.lerp(this.pmPoints[floor(t)], this.pmPoints[ceil(t)], t % 1);\r\n        return this.closestPointToParams(startParams);\r\n    }\r\n    uvT(t) {\r\n        assert(!isNaN(t));\r\n        if (0 === t % 1)\r\n            return this.pmPoints[t];\r\n        const startParams = V3.lerp(this.pmPoints[floor(t)], this.pmPoints[ceil(t)], t % 1);\r\n        return curvePoint(this.implicitCurve(), startParams, this.didu, this.didv);\r\n    }\r\n    closestTToPoint(p, tStart) {\r\n        // TODO\r\n        return 0;\r\n    }\r\n    closestPointToParams(startUV) {\r\n        const pointParams = curvePoint(this.implicitCurve(), startUV, this.didu, this.didv);\r\n        return this.parametricSurface.pUVFunc()(pointParams.x, pointParams.y);\r\n    }\r\n    isTsWithSurface(surface) {\r\n        if (surface instanceof EllipsoidSurface) {\r\n            const pS = this.parametricSurface, iS = this.implicitSurface;\r\n            if (pS instanceof ProjectedCurveSurface && iS instanceof EllipsoidSurface) {\r\n                const iscs = iS.isCurvesWithSurface(surface);\r\n                const points = iscs.flatMap(isc => isc.isTsWithSurface(pS).map(t => isc.at(t)));\r\n                const ts = fuzzyUniques(points.map(p => this.pointT(p)));\r\n                return ts.filter(t => !isNaN(t) && this.isValidT(t));\r\n            }\r\n        }\r\n        else if (ImplicitSurface.is(surface)) {\r\n            const result = [];\r\n            const iF = surface.implicitFunction();\r\n            let prevSignedDistance = iF(this.points[0]);\r\n            for (let i = 1; i < this.points.length; i++) {\r\n                const point = this.points[i];\r\n                const signedDistance = iF(point);\r\n                if (prevSignedDistance * signedDistance <= 0) {\r\n                    const pF = this.parametricSurface.pUVFunc();\r\n                    const dpdu = this.parametricSurface.dpdu();\r\n                    const dpdv = this.parametricSurface.dpdv();\r\n                    const startUV = this.pmPoints[abs(prevSignedDistance) < abs(signedDistance) ? i - 1 : i];\r\n                    const isUV = newtonIterate2dWithDerivatives(this.implicitCurve(), (u, v) => iF(pF(u, v)), startUV.x, startUV.y, 4, this.didu, this.didv, (u, v) => dpdu(u, v).dot(surface.didp(pF(u, v))), (u, v) => dpdv(u, v).dot(surface.didp(pF(u, v))));\r\n                    result.push(this.pointT(this.parametricSurface.pUV(isUV.x, isUV.y)));\r\n                }\r\n                prevSignedDistance = signedDistance;\r\n            }\r\n            return result;\r\n        }\r\n        throw new Error();\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        return this.isTsWithSurface(new PlaneSurface(planeWC));\r\n        // version which intersects the plane with the defining surfaces of this PICurve, but this causes\r\n        // issues when they are PICurves too:\r\n        // assertInst(P3, planeWC)\r\n        // const ps = this.parametricSurface,\r\n        // \tis = this.implicitSurface\r\n        // const pscs = ps.isCurvesWithPlane(planeWC)\r\n        // const iscs = is.isCurvesWithPlane(planeWC)\r\n        // const infos = iscs.flatMap(isc => pscs.flatMap(psc => isc.isInfosWithCurve(psc)))\r\n        // const ts = fuzzyUniques(infos.map(info => this.pointT(info.p)))\r\n        // return ts.filter(t => !isNaN(t) && this.isValidT(t))\r\n    }\r\n    pointT(p) {\r\n        assertVectors(p);\r\n        if (!this.parametricSurface.containsPoint(p) || !this.implicitSurface.containsPoint(p)) {\r\n            return NaN;\r\n        }\r\n        const pmPoint = this.parametricSurface.uvPFunc()(p);\r\n        const ps = this.points, pmps = this.pmPoints;\r\n        let t = 0, pmDistance = pmPoint.distanceTo(pmps[0]);\r\n        while (pmDistance > abs(this.stepSize) && t < ps.length - 1) {\r\n            // TODO -1?\r\n            //console.log(t, pmps[t].$, pmDistance)\r\n            t = min(pmps.length - 1, t + max(1, Math.round(pmDistance / abs(this.stepSize) / 2 / 2)));\r\n            pmDistance = pmPoint.distanceTo(pmps[t]);\r\n        }\r\n        // if (t < this.pmPoints.length - 1 && pmDistance > pmPoint.distanceTo(pmps[t + 1])) {\r\n        //     t++\r\n        // }\r\n        if (pmDistance > abs(this.stepSize) * 1.1) {\r\n            // p is not on this curve\r\n            return NaN;\r\n        }\r\n        if (t == ps.length - 1) {\r\n            t--;\r\n        }\r\n        if (ps[t].like(p))\r\n            return t;\r\n        if (ps[t + 1].like(p))\r\n            return t + 1;\r\n        const startT = arrayRange(floor(this.tMin), ceil(this.tMax), 1).withMax(t => -pmPoint.distanceTo(pmps[t]));\r\n        if (undefined === startT)\r\n            throw new Error();\r\n        if (ps[startT].like(p))\r\n            return startT;\r\n        //const [a, b] = 0 === startT\r\n        //    ? [0, 1]\r\n        //    : this.points.length - 1 === startT\r\n        //        ? [startT - 1, startT]\r\n        //        : pmPoint.distanceTo(pmps[startT - 1]) < pmPoint.distanceTo(pmps[startT + 1])\r\n        //            ? [startT - 1, startT]\r\n        //            : [startT, startT + 1]\r\n        const a = max(0, startT - 1), b = min(this.points.length - 1, startT + 1);\r\n        const tangent = this.tangentAt(startT);\r\n        const f = (t) => this.at(clamp(t, 0, this.points.length - 1))\r\n            .to(p)\r\n            .dot(tangent);\r\n        // const df = (t: number) => -this.tangentAt(clamp(t, 0, this.points.length - 1)).dot(tangent)\r\n        //checkDerivate(f, df, 0, this.points.length - 2, 3)\r\n        // 8 steps necessary because df can currently be way off\r\n        t = bisect(f, a, b, 32);\r\n        if (!isFinite(t) || this.at(t).distanceTo(p) > abs(this.stepSize)) {\r\n            return NaN;\r\n        }\r\n        return t;\r\n    }\r\n    transform(m4) {\r\n        const dirFactor = m4.isMirroring() ? -1 : 1;\r\n        return PICurve.forStartEnd(this.parametricSurface.transform(m4), this.implicitSurface.transform(m4), m4.transformPoint(this.points[0]), m4.transformPoint(this.points.last), this.stepSize * dirFactor, m4.transformVector(this.tangents[0]), m4.transformPoint(this.at(this.tMin)), m4.transformPoint(this.at(this.tMax)));\r\n        //return PICurve.forParametricStartEnd(\r\n        //\tthis.parametricSurface.transform(m4),\r\n        //\tthis.implicitSurface.transform(m4),\r\n        //\tthis.pmPoints[0],\r\n        //\tthis.pmPoints.last,\r\n        //\tthis.stepSize,\r\n        //\tthis.dir,\r\n        //\tthis.tMin,\r\n        //\tthis.tMax)\r\n        // TODO: pass transformed points?\r\n        //return new PICurve(\r\n        //\tm4.transformedPoints(this.points),\r\n        //\tm4.transformedVectors(this.tangents),\r\n        //    this.parametricSurface.transform(m4),\r\n        //   this.implicitSurface.transform(m4),\r\n        //   this.pmPoints,\r\n        //   this.pmTangents,\r\n        //this.stepSize,\r\n        //   this.dir,\r\n        //this.generator,\r\n        //this.tMin, this.tMax)\r\n    }\r\n    roots() {\r\n        const allTs = arrayRange(0, this.points.length);\r\n        return [allTs, allTs, allTs];\r\n    }\r\n    isInfosWithLine(anchorWC, dirWC, tMin, tMax, lineMin, lineMax) {\r\n        return surfaceIsICurveIsInfosWithLine.call(this, anchorWC, dirWC, tMin, tMax, lineMin, lineMax);\r\n    }\r\n    toSource(rounder = x => x) {\r\n        const result = callsce('PICurve.forParametricStartEnd', this.parametricSurface, this.implicitSurface, this.pmPoints[0], this.pmPoints.last, this.stepSize, this.pmTangents[0], this.tMin, this.tMax);\r\n        return result;\r\n    }\r\n}\r\nPICurve.prototype.tIncrement = 1;\r\n//# sourceMappingURL=PICurve.js.map","import { assert, assertVectors, callsce, newtonIterate, V3 } from 'ts3dutils';\r\nimport { curvePointPP, followAlgorithmPP, ImplicitCurve, ImplicitSurface, ParametricSurface, PlaneSurface, surfaceIsICurveIsInfosWithLine, } from '../index';\r\nimport { abs, ceil, floor } from '../math';\r\nexport class PPCurve extends ImplicitCurve {\r\n    constructor(points, tangents, parametricSurface1, parametricSurface2, st1s, pmTangents, stepSize, dir = 1, generator, tMin, tMax) {\r\n        super(points, tangents, dir, generator, tMin, tMax);\r\n        this.parametricSurface1 = parametricSurface1;\r\n        this.parametricSurface2 = parametricSurface2;\r\n        this.st1s = st1s;\r\n        this.pmTangents = pmTangents;\r\n        this.stepSize = stepSize;\r\n        assert(ParametricSurface.is(parametricSurface1));\r\n        assert(ParametricSurface.is(parametricSurface2));\r\n        assert(Array.isArray(st1s));\r\n        assert(dir == 1);\r\n        assert(stepSize <= 1);\r\n    }\r\n    at(t) {\r\n        assert(!isNaN(t));\r\n        if (0 === t % 1)\r\n            return this.points[t];\r\n        const startPoint = V3.lerp(this.points[floor(t)], this.points[ceil(t)], t % 1);\r\n        return curvePointPP(this.parametricSurface1, this.parametricSurface2, startPoint).p;\r\n    }\r\n    isColinearTo(curve) {\r\n        if (curve instanceof PPCurve) {\r\n            if (this.equals(curve)) {\r\n                return true;\r\n            }\r\n            if (this.parametricSurface1.isCoplanarTo(curve.parametricSurface1) &&\r\n                this.parametricSurface1.isCoplanarTo(curve.parametricSurface2)) {\r\n                // TODO\r\n            }\r\n            return false;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    containsPoint(p) {\r\n        assertVectors(p);\r\n        // TODO: wrong, as there could be another curve\r\n        return (this.parametricSurface1.containsPoint(p) &&\r\n            this.parametricSurface2.containsPoint(p) &&\r\n            !isNaN(this.pointT(p)));\r\n    }\r\n    rootPoints() {\r\n        const pF1 = this.parametricSurface1.pUVFunc();\r\n        const pF2 = this.parametricSurface2.pUVFunc();\r\n        const pN1 = this.parametricSurface1.normalUVFunc();\r\n        const pN2 = this.parametricSurface2.normalUVFunc();\r\n        const rootsApprox = this.rootsApprox();\r\n        const results = [[], [], []];\r\n        for (let dim = 0; dim < 3; dim++) {\r\n            for (let i = 0; i < rootsApprox[dim].length; i++) {\r\n                const lambda = rootsApprox[dim][i];\r\n                const p = this.at(lambda);\r\n                assert(this.parametricSurface1.containsPoint(p));\r\n                const pp1 = this.parametricSurface1.uvP(p);\r\n                const { x: u, y: v } = this.parametricSurface2.uvP(p);\r\n                const startValues = [pp1.x, pp1.y, u, v];\r\n                function f(vals) {\r\n                    const [u1, v1, u2, v2] = vals;\r\n                    const diff = pF1(u1, v1).minus(pF2(u2, v2));\r\n                    const n1 = pN1(u1, v1);\r\n                    const n2 = pN2(u2, v2);\r\n                    const tangent = n1.cross(n2);\r\n                    return [diff.x, diff.y, diff.z, tangent.e(dim)];\r\n                }\r\n                const pps = newtonIterate(f, startValues, 8);\r\n                // assert(pF1(pps[0], pps[1]).like(pF2(pps[2], pps[3])),\r\n                // \tpF1(pps[0], pps[1]).sce + pF2(pps[2], pps[3]).sce)\r\n                const result = pF1(pps[0], pps[1]);\r\n                results[dim].push(result);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    roots() {\r\n        return this.rootPoints().map(ps => ps.map(p => this.pointT(p)));\r\n    }\r\n    pointTangent(pWC) {\r\n        assertVectors(pWC);\r\n        assert(this.containsPoint(pWC), 'this.containsPoint(pWC)');\r\n        const n1 = this.parametricSurface1.normalP(pWC);\r\n        const n2 = this.parametricSurface2.normalP(pWC);\r\n        return n1.cross(n2);\r\n    }\r\n    transform(m4) {\r\n        return new PPCurve(m4.transformedPoints(this.points), m4.transformedVectors(this.tangents), this.parametricSurface1.transform(m4), this.parametricSurface2.transform(m4), this.st1s, undefined, this.stepSize, this.dir, undefined);\r\n    }\r\n    toSource() {\r\n        return callsce('PPCurve.forStartEnd', this.parametricSurface1, this.parametricSurface2, this.points[0], this.points.last, this.stepSize);\r\n    }\r\n    static forStartEnd(ps1, ps2, startPoint, end, stepSize = 0.02) {\r\n        const { points, tangents, st1s } = followAlgorithmPP(ps1, ps2, startPoint, stepSize);\r\n        return new PPCurve(points, tangents, ps1, ps2, st1s, undefined, stepSize, 1);\r\n    }\r\n    isInfosWithLine(anchorWC, dirWC, tMin, tMax, lineMin, lineMax) {\r\n        return surfaceIsICurveIsInfosWithLine.call(this, anchorWC, dirWC, tMin, tMax, lineMin, lineMax);\r\n    }\r\n    isTsWithSurface(surface) {\r\n        if (ImplicitSurface.is(surface)) {\r\n            const result = [];\r\n            const iF = surface.implicitFunction();\r\n            const pUV1 = this.parametricSurface1.pUVFunc();\r\n            const pUV2 = this.parametricSurface2.pUVFunc();\r\n            let prevSignedDistance = iF(this.points[0]);\r\n            for (let i = 1; i < this.points.length; i++) {\r\n                const point = this.points[i];\r\n                const signedDistance = iF(point);\r\n                if (prevSignedDistance * signedDistance <= 0) {\r\n                    const startIndex = abs(prevSignedDistance) < abs(signedDistance) ? i - 1 : i;\r\n                    const startPoint = this.points[startIndex];\r\n                    const startUV1 = this.st1s[startIndex];\r\n                    const startUV2 = this.parametricSurface2.uvP(startPoint);\r\n                    const isSTUV = newtonIterate(([u1, v1, u2, v2]) => {\r\n                        const ps1p = pUV1(u1, v1);\r\n                        const ps2p = pUV2(u2, v2);\r\n                        return [...ps1p.to(ps2p), iF(ps1p)];\r\n                    }, [startUV1.x, startUV1.y, startUV2.x, startUV2.y]);\r\n                    result.push(this.pointT(this.parametricSurface1.pUV(isSTUV[0], isSTUV[1])));\r\n                }\r\n                prevSignedDistance = signedDistance;\r\n            }\r\n            return result;\r\n        }\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        return this.isTsWithSurface(new PlaneSurface(planeWC));\r\n    }\r\n}\r\n//# sourceMappingURL=PPCurve.js.map","import { arrayFromFunction, assertNumbers, eq, eq0, hasConstructor, le, pqFormula, V3 } from 'ts3dutils';\r\nimport { BezierCurve, L3, XiEtaCurve } from '../index';\r\nimport { parabola4Projection } from './XiEtaCurve';\r\n/**\r\n * eta = xi²\r\n */\r\nexport class ParabolaCurve extends XiEtaCurve {\r\n    constructor(center, f1, f2, tMin = -10, tMax = 10) {\r\n        super(center, f1, f2, tMin, tMax);\r\n    }\r\n    static eccentricity() {\r\n        return 1;\r\n    }\r\n    static unitIsInfosWithLine(anchorLC, dirLC, anchorWC, dirWC) {\r\n        // para: x² = y\r\n        // line(t) = anchor + t dir\r\n        // (ax + t dx)² = ay + t dy\r\n        // ax² + t ax dx + t² dx² = ay + t dy\r\n        // t² dx² + t (ax dx + dy) + ay² + ay = 0\r\n        const pqDiv = Math.pow(dirLC.x, 2);\r\n        const lineTs = pqFormula((anchorLC.x * dirLC.x + dirLC.y) / pqDiv, (Math.pow(anchorLC.x, 2) + anchorLC.y) / pqDiv);\r\n        return lineTs.filter(tOther => le(0, anchorLC.y + tOther * dirLC.y)).map(tOther => ({\r\n            tThis: dirLC.x * tOther + anchorLC.x,\r\n            tOther: tOther,\r\n            p: L3.at(anchorWC, dirWC, tOther),\r\n        }));\r\n    }\r\n    static intersectionUnitLine(a, b, c) {\r\n        /*\r\n         solve system (5)/(6)\r\n         g1 * xi + g2 * eta = g3 (6)\r\n         g1 * xi + g2 * xi * xi = g3\r\n         xi² + xi * g1/g2 - g3/g2 = 0\r\n         */\r\n        return pqFormula(a / b, -c / b);\r\n    }\r\n    static XYLCValid(pLC) {\r\n        return eq(Math.pow(pLC.x, 2), pLC.y);\r\n    }\r\n    static XYLCPointT(pLC) {\r\n        return pLC.x;\r\n    }\r\n    static quadratic(a, b, c) {\r\n        // (1 - t)² a + 2 * t * (1 - t) b + t² c\r\n        // (1 -2t +t²)a + (2t -2t²) b + t² c\r\n        // = t²(a - 2b + c) + t (-2a + 2b) + a\r\n        // (2t - 2) a + (1 - 2t) b + 2t c = t(2a + 2b - 2c) - 2a + b\r\n        // 2 a + -2 b + 2 c\r\n        const f2 = a.plus(c).minus(b.times(2));\r\n        const f1 = b.minus(a).times(2);\r\n        const center = a;\r\n        return new ParabolaCurve(center, f1, f2, 0, 1);\r\n    }\r\n    at(t) {\r\n        // center + f1 t + f2 t²\r\n        return this.center.plus(this.f1.times(t)).plus(this.f2.times(t * t));\r\n    }\r\n    tangentAt(t) {\r\n        assertNumbers(t);\r\n        // f1 + f2 2 t\r\n        return this.f1.plus(this.f2.times(2 * t));\r\n    }\r\n    ddt(t) {\r\n        assertNumbers(t);\r\n        return this.f2.times(2);\r\n    }\r\n    tangentAt2(xi, eta) {\r\n        assertNumbers(xi, eta);\r\n        return this.f1.plus(this.f2.times(2 * eta));\r\n    }\r\n    reversed() {\r\n        return new this.constructor(this.center, this.f1.negated(), this.f2, -this.tMax, -this.tMin);\r\n    }\r\n    /**\r\n     * tangent: f1 + 2 * t * f2 = 0\r\n     * t = -f1 / 2 / f2 (for individual dimensions)\r\n     */\r\n    roots() {\r\n        const dimRoots = (dim) => (eq0(this.f2.e(dim)) ? [] : [-this.f1.e(dim) / 2 / this.f2.e(dim)]);\r\n        return arrayFromFunction(3, dimRoots);\r\n    }\r\n    isColinearTo(curve) {\r\n        if (!hasConstructor(curve, ParabolaCurve))\r\n            return false;\r\n        const thisRA = this.rightAngled(), curveRA = curve.rightAngled();\r\n        return thisRA.center.like(curveRA.center) && thisRA.f2.like(curveRA.f2) && thisRA.f1.likeOrReversed(curveRA.f1);\r\n    }\r\n    rightAngled() {\r\n        // looking for vertex of parabola\r\n        // this is the point where the tangent is perpendicular to the main axis (f2)\r\n        // tangent = f1 + f2 * 2 * t0\r\n        // f2 DOT (f1 + f2 * 2 * t0) == 0\r\n        // f1 DOT f2 + f2 DOT f2 * 2 * t0 == 0\r\n        // t0 == -(f1 DOT f2) / (f2 DOT f2 * 2)\r\n        const f1 = this.f1, f2 = this.f2;\r\n        const f1DOTf2 = f1.dot(f2);\r\n        if (eq0(f1DOTf2) && f1.hasLength(1)) {\r\n            return this;\r\n        }\r\n        const t0 = -f1DOTf2 / f2.squared() / 2;\r\n        // we need to rearange tMin/tMax\r\n        // tMin' = pointT(at(tMin)) =\r\n        const raCenter = this.at(t0);\r\n        const raF1 = this.tangentAt(t0), raF1Length = raF1.length(), raF11 = raF1.unit();\r\n        const repos = (t) => this.at(t)\r\n            .minus(raCenter)\r\n            .dot(raF11);\r\n        return new ParabolaCurve(raCenter, raF11, f2.div(Math.pow(raF1Length, 2)), repos(this.tMin), repos(this.tMax));\r\n    }\r\n    arcLength(startT, endT) {\r\n        let f1 = this.f1;\r\n        const f2 = this.f2;\r\n        const f1DOTf2 = f1.dot(f2);\r\n        let t0 = 0;\r\n        if (!eq0(f1DOTf2)) {\r\n            t0 = -f1DOTf2 / f2.squared() / 2;\r\n            f1 = f1.plus(f2.times(2 * t0));\r\n        }\r\n        const f1Length = f1.length();\r\n        const a = f2.length() / f1Length;\r\n        function F(x) {\r\n            return Math.asinh(a * 2 * x) / 4 / a + x * Math.sqrt(1 + a * a * 4 * x * x) / 2;\r\n        }\r\n        return f1Length * (F(endT - t0) - F(startT - t0));\r\n    }\r\n    transform4(m4) {\r\n        return parabola4Projection(this.matrix.transform(m4), this.tMin, this.tMax);\r\n    }\r\n    asBezier() {\r\n        return BezierCurve.quadratic(this.at(-1), new L3(this.at(-1), this.tangentAt(-1).unit()).isInfoWithLine(new L3(this.at(1), this.tangentAt(1).unit())), this.at(1));\r\n    }\r\n    /**\r\n     * Returns new ParabolaCurve that has its center point at this.at(t0)\r\n     * @param t0\r\n     */\r\n    recenter(t0) {\r\n        // this.at(t) = f2 t² + f1 t + center\r\n        // c2.at(t) = f2 (t + t0)² + f1 (t + t0) + center\r\n        // c2.at(t) = f2 (t² + 2 t0 t + t0²) + f1 (t + t0) + center\r\n        // c2.at(t) = f2 t² + (f1 + 2 f2 t0) t + center + f2 t0² + f1 t0\r\n        return new ParabolaCurve(this.at(t0), this.f1.plus(this.f2.times(2 * t0)), this.f2);\r\n    }\r\n}\r\nParabolaCurve.XY = new ParabolaCurve(V3.O, V3.X, V3.Y);\r\nParabolaCurve.YZ = new ParabolaCurve(V3.O, V3.Y, V3.Z);\r\nParabolaCurve.ZX = new ParabolaCurve(V3.O, V3.Z, V3.X);\r\nParabolaCurve.prototype.tIncrement = 1 / 32;\r\n//# sourceMappingURL=ParabolaCurve.js.map","import { arrayFromFunction, assert, assertf, assertNumbers, assertVectors, between, checkDerivate, eq, eq0, fuzzyBetween, hasConstructor, le, lerp, lt, M4, newtonIterate1d, newtonIterateSmart, pqFormula, TAU, V3, } from 'ts3dutils';\r\nimport { Curve, intersectionUnitCircleLine, intersectionUnitCircleLine2, L3, P3, XiEtaCurve, } from '../index';\r\nimport { atan2, cos, max, min, PI, sign, sqrt } from '../math';\r\nimport { parabola4Projection } from './XiEtaCurve';\r\nexport class EllipseCurve extends XiEtaCurve {\r\n    constructor(center, f1, f2, tMin = 0, tMax = PI) {\r\n        super(center, f1, f2, tMin, tMax);\r\n        assert(-PI <= this.tMin && this.tMin < PI);\r\n        assert(-PI < this.tMax && this.tMax <= PI);\r\n    }\r\n    static andFixTs(center, f1, f2, tMin = 0, tMax = PI) {\r\n        if (-PI <= tMin && tMax <= PI) {\r\n            return new EllipseCurve(center, f1, f2, tMin, tMax);\r\n        }\r\n        if (0 <= tMin && tMax <= TAU) {\r\n            return new EllipseCurve(center, f1.negated(), f2.negated(), tMin - PI, tMax - PI);\r\n        }\r\n        if (-TAU <= tMin && tMax <= 0) {\r\n            return new EllipseCurve(center, f1.negated(), f2.negated(), tMin + PI, tMax + PI);\r\n        }\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    static XYLCValid(pLC) {\r\n        const { x, y } = pLC;\r\n        return eq0(Math.pow(x, 2) + Math.pow(y, 2) - 1);\r\n    }\r\n    static XYLCPointT(pLC, tMin, tMax) {\r\n        assertNumbers(tMin, tMax);\r\n        const t = atan2(pLC.y, pLC.x);\r\n        const lowSplitter = lerp(tMin, tMax - TAU, 0.5);\r\n        if (t < lowSplitter) {\r\n            return t + TAU;\r\n        }\r\n        const highSplitter = lerp(tMax, tMin + TAU, 0.5);\r\n        if (t > highSplitter) {\r\n            return t - TAU;\r\n        }\r\n        return t;\r\n    }\r\n    static intersectionUnitLine(a, b, c, tMin, tMax) {\r\n        const isLC = intersectionUnitCircleLine2(a, b, c);\r\n        const result = [];\r\n        for (const [xi, eta] of isLC) {\r\n            const t = EllipseCurve.XYLCPointT(new V3(xi, eta, 0), tMin, tMax);\r\n            fuzzyBetween(t, tMin, tMax) && result.push(t);\r\n        }\r\n        return result;\r\n    }\r\n    static unitIsInfosWithLine(anchorLC, dirLC, anchorWC, dirWC, tMin, tMax) {\r\n        // ell: x² + y² = 1 = p²\r\n        // line(t) = anchor + t dir\r\n        // anchor² - 1 + 2 t dir anchor + t² dir² = 0\r\n        const pqDiv = dirLC.squared();\r\n        const lineTs = pqFormula(2 * dirLC.dot(anchorLC) / pqDiv, (anchorLC.squared() - 1) / pqDiv);\r\n        return lineTs.filter(tOther => le(0, anchorLC.y + tOther * dirLC.y)).map(tOther => ({\r\n            tThis: EllipseCurve.XYLCPointT(dirLC.times(tOther).plus(anchorLC), tMin, tMax),\r\n            tOther: tOther,\r\n            p: L3.at(anchorWC, dirWC, tOther),\r\n        }));\r\n    }\r\n    /**\r\n     * Returns a new EllipseCurve representing a circle parallel to the XY-plane.`\r\n     */\r\n    static semicircle(radius, center = V3.O, tMin, tMax) {\r\n        return new EllipseCurve(center, new V3(radius, 0, 0), new V3(0, radius, 0), tMin, tMax);\r\n    }\r\n    static circleForCenter2P(center, a, b, radius, tMin, tMax) {\r\n        const f1 = center.to(a);\r\n        const normal = f1.cross(center.to(b));\r\n        const f2 = normal.cross(f1).toLength(f1.length());\r\n        return new EllipseCurve(center, f1, f2, undefined !== tMin ? tMin : 0, undefined !== tMax ? tMax : f1.angleTo(center.to(b)));\r\n    }\r\n    split(tMin = this.tMin, tMax = this.tMax) {\r\n        const result = [];\r\n        tMin < 0 &&\r\n            result.push(new EllipseCurve(this.center, this.f1.negated(), this.f2.negated(), tMin + PI, min(0, tMax) + PI));\r\n        tMax > 0 && result.push(new EllipseCurve(this.center, this.f1, this.f2, max(0, tMin), tMax));\r\n        return result;\r\n    }\r\n    static forAB(a, b, center = V3.O) {\r\n        return super.forAB(a, b, center);\r\n    }\r\n    /**\r\n     * Create a circle curve which has a, b and c on it. a, b, c can't be on a straight line.\r\n     * tMin defaults to 0, tMax defaults to the value for c\r\n     */\r\n    static circleThroughPoints(a, b, c, tMin = 0, tMax) {\r\n        assertf(() => !L3.throughPoints(a, c).containsPoint(b));\r\n        const normal = a.to(b).cross(b.to(c));\r\n        const center = new L3(a.lerp(b, 0.5), normal.cross(a.to(b)).unit()).isInfoWithLine(new L3(b.lerp(c, 0.5), normal.cross(b.to(c)).unit()));\r\n        const f1 = center.to(a).negated();\r\n        return new EllipseCurve(center, f1, normal.unit().cross(f1), -PI, undefined === tMax ? f1.angleRelativeNormal(center.to(c), normal.unit()) : tMax);\r\n    }\r\n    getAreaInDir(right, up, tStart, tEnd) {\r\n        //assertf(() => tStart < tEnd)\r\n        assertf(() => right.isPerpendicularTo(this.normal));\r\n        assertf(() => up.isPerpendicularTo(this.normal));\r\n        //assertf(() => EllipseCurve.isValidT(tStart), tStart)\r\n        //assertf(() => EllipseCurve.isValidT(tEnd), tEnd)\r\n        const upLC = this.matrixInverse.transformVector(up);\r\n        const rightLC = upLC.cross(V3.Z);\r\n        const normTStart = tStart - rightLC.angleXY();\r\n        const normTEnd = tEnd - rightLC.angleXY();\r\n        const transformedOriginY = this.matrixInverse.getTranslation().dot(upLC.unit());\r\n        // integral of sqrt(1 - x²) from 0 to cos(t)\r\n        // Basically, we want\r\n        // INTEGRAL[cos(t); PI/2] sqrt(1 - x²) dx\r\n        // INTEGRAL[PI/2: cos(t)] -sqrt(1 - x²) dx\r\n        // = INTEGRAL[cos(0); cos(t)] -sqrt(1 - x²) dx\r\n        // = INTEGRAL[0; t] -sqrt(1 - cos²(t)) * -sin(t) dt\r\n        // = INTEGRAL[0; t] -sin(t) * -sin(t) dt\r\n        // = INTEGRAL[0; t] sin²(t) dt (partial integration / wolfram alpha)\r\n        // = (1/2 * (t - sin(t) * cos(t)))[0; t] (this form has the distinct advantage of being defined everywhere)\r\n        function fArea(t) {\r\n            return (t - Math.sin(t) * Math.cos(t)) / 2;\r\n        }\r\n        // for the centroid, we want\r\n        // cx = 1 / area * INTEGRAL[cos(t); PI/2] x * f(x) dx\r\n        // cx = 1 / area * INTEGRAL[cos(t); PI/2] x * sqrt(1 - x²) dx\r\n        // cx = 1 / area * INTEGRAL[cos(0); cos(t)] x * -sqrt(1 - x²) dx\r\n        // ...\r\n        // cx = 1 / area * INTEGRAL[0; t] cos(t) * sin²(t) dt // WA\r\n        // cx = 1 / area * (sin^3(t) / 3)[0; t]\r\n        function cxTimesArea(t) {\r\n            return Math.pow(Math.sin(t), 3) / 3;\r\n        }\r\n        // cy = 1 / area * INTEGRAL[cos(t); PI/2] f²(x) / 2 dx\r\n        // cy = 1 / area * INTEGRAL[cos(0); cos(t)] -(1 - x²) / 2 dx\r\n        // cy = 1 / area * INTEGRAL[0; t] (cos²(t) - 1) * -sin(t) / 2 dt\r\n        // cy = 1 / area * (cos (3 * t) - 9 * cos(t)) / 24 )[0; t]\r\n        function cyTimesArea(t) {\r\n            return (Math.cos(3 * t) - 9 * Math.cos(t)) / 24;\r\n        }\r\n        const restArea = -transformedOriginY * (-Math.cos(normTEnd) + Math.cos(normTStart));\r\n        const area = fArea(normTEnd) - fArea(normTStart) + restArea;\r\n        const cxt = (cxTimesArea(normTEnd) -\r\n            cxTimesArea(normTStart) +\r\n            -transformedOriginY * (-Math.cos(normTEnd) - Math.cos(normTStart)) / 2 * restArea) /\r\n            area;\r\n        const cyt = (cyTimesArea(normTEnd) - cyTimesArea(normTStart) - -transformedOriginY / 2 * restArea) / area;\r\n        const factor = this.matrix.xyAreaFactor(); // * upLC.length()\r\n        //console.log('fctor', factor, 'area', area, 'resultarea', area* factor)\r\n        assert(!eq0(factor));\r\n        return {\r\n            area: area * factor,\r\n            centroid: this.matrix.transformPoint(M4.rotateZ(rightLC.angleXY()).transformPoint(new V3(cxt, cyt, 0))),\r\n        };\r\n    }\r\n    at(t) {\r\n        assertNumbers(t);\r\n        //assert(this.isValidT(t))\r\n        // = center + f1 cos t + f2 sin t\r\n        return this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)));\r\n    }\r\n    tangentAt(t) {\r\n        assertNumbers(t);\r\n        //assert(this.isValidT(t))\r\n        // ) f2 cos(t) - f1 sin(t)\r\n        return this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)));\r\n    }\r\n    ddt(t) {\r\n        assertNumbers(t);\r\n        assert(this.isValidT(t));\r\n        return this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)));\r\n    }\r\n    tangentAt2(xi, eta) {\r\n        return this.f2.times(xi).minus(this.f1.times(eta));\r\n    }\r\n    isCircular() {\r\n        return eq(this.f1.length(), this.f2.length()) && this.f1.isPerpendicularTo(this.f2);\r\n    }\r\n    isColinearTo(curve) {\r\n        if (!hasConstructor(curve, EllipseCurve))\r\n            return false;\r\n        if (!this.center.like(curve.center)) {\r\n            return false;\r\n        }\r\n        if (this == curve) {\r\n            return true;\r\n        }\r\n        if (this.isCircular()) {\r\n            return (curve.isCircular() && eq(this.f1.length(), curve.f1.length()) && this.normal.isParallelTo(curve.normal));\r\n        }\r\n        else {\r\n            let { f1: f1, f2: f2 } = this.rightAngled(), { f1: c1, f2: c2 } = curve.rightAngled();\r\n            if (f1.length() > f2.length()) {\r\n                ;\r\n                [f1, f2] = [f2, f1];\r\n            }\r\n            if (c1.length() > c2.length()) {\r\n                ;\r\n                [c1, c2] = [c2, c1];\r\n            }\r\n            return eq(f1.squared(), Math.abs(f1.dot(c1))) && eq(f2.squared(), Math.abs(f2.dot(c2)));\r\n        }\r\n    }\r\n    pointT(pWC) {\r\n        assertVectors(pWC);\r\n        assert(this.containsPoint(pWC));\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const t = EllipseCurve.XYLCPointT(pLC, this.tMin, this.tMax);\r\n        assert(this.isValidT(t));\r\n        return t;\r\n    }\r\n    reversed() {\r\n        return new EllipseCurve(this.center, this.f1.negated(), this.f2, PI - this.tMax, PI - this.tMin);\r\n    }\r\n    eccentricity() {\r\n        const mainAxes = this.rightAngled();\r\n        const f1length = mainAxes.f1.length(), f2length = mainAxes.f1.length();\r\n        const [a, b] = f1length > f2length ? [f1length, f2length] : [f2length, f1length];\r\n        return Math.sqrt(1 - b * b / a / a);\r\n    }\r\n    circumference() {\r\n        return this.arcLength(-Math.PI, Math.PI);\r\n    }\r\n    arcLength(tStart = this.tMin, tEnd = this.tMax, steps = 2) {\r\n        assert(tStart < tEnd, 'startT < endT');\r\n        const f1Length = this.f1.length();\r\n        if (eq(f1Length, this.f2.length())) {\r\n            return f1Length * (tEnd - tStart);\r\n        }\r\n        return super.arcLength(tStart, tEnd, steps);\r\n    }\r\n    circumferenceApproximate() {\r\n        // approximate circumference by Ramanujan\r\n        // https://en.wikipedia.org/wiki/Ellipse#Circumference\r\n        const { f1, f2 } = this.rightAngled(), a = f1.length(), b = f2.length();\r\n        const h = Math.pow((a - b), 2) / Math.pow((a + b), 2);\r\n        return Math.PI * (a + b) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\r\n    }\r\n    /**\r\n     * Radii of the ellipse are described by\r\n     * q(phi) = f1 * cos(phi) + f2 * sin(phi)\r\n     * or q(xi, eta) = f1 * xi + f2 * eta (1) with the added condition\r\n     * xi² + eta² = 1 (2)\r\n     * we want to find the radius where the corresponding tangent is perpendicular\r\n     * tangent: q'(phi) = f1 * -sin(phi) + f2 * cos(phi)\r\n     * tangent: q'(xi, eta) = f1 * -eta + f2 * xi\r\n     * perpendicular when: q'(xi, eta) DOT q(xi, eta) = 0\r\n     * (f1 * -eta + f2 * xi) DOT (f1 * xi + f2 * eta) = 0\r\n     * DOT is distributive:\r\n     * f1² * (-eta * xi) + f1 * f2 * (-eta² + xi²) + f2² * (xi * eta) = 0\r\n     * (f2² - f1²) * (eta * xi) + f1 * f2 * (-eta² + xi²) = 0\r\n     * a * (xi² - eta²) + b * xi * eta = 0 (2)\r\n     * with a = f1 * f2, b = f2² - f1²\r\n     * => (xi/eta)² + xi/eta * b/a + 1 = 0 (divide by a * eta²)\r\n     * xi/eta = b/a/2 +- sqrt(b²/a²/4 - 1) | * 2*a*eta\r\n     * 2 * a * xi = eta * (b +- sqrt(b² - 4 * a²))\r\n     * g1 * xi - g2 * eta = 0 (3)\r\n     * with g1 = 2 * a, g2 = b +- sqrt(b² - 4 * a²)\r\n     * Solve (3), (2) with intersectionUnitCircleLine\r\n     */\r\n    rightAngled() {\r\n        const f1 = this.f1, f2 = this.f2, a = f1.dot(f2), b = f2.squared() - f1.squared();\r\n        if (eq0(a)) {\r\n            return this;\r\n        }\r\n        const g1 = 2 * a, g2 = b + Math.sqrt(b * b + 4 * a * a);\r\n        const { x1: xi, y1: eta } = intersectionUnitCircleLine(g1, g2, 0);\r\n        const f1RA = f1.times(xi).plus(f2.times(eta));\r\n        const f2RA = f1.times(-eta).plus(f2.times(xi));\r\n        return new EllipseCurve(this.center, f1RA, f2RA, -PI, PI);\r\n    }\r\n    isInfosWithEllipse(ellipse) {\r\n        if (this.normal.isParallelTo(ellipse.normal) && eq0(this.center.minus(ellipse.center).dot(ellipse.normal))) {\r\n            // ellipses are coplanar\r\n            const ellipseLCRA = ellipse.transform(this.matrixInverse).rightAngled();\r\n            const r1 = ellipseLCRA.f1.lengthXY(), r2 = ellipseLCRA.f2.lengthXY(), centerDist = ellipseLCRA.center.lengthXY();\r\n            const rMin = min(r1, r2), rMax = max(r1, r2);\r\n            if (lt(centerDist + rMax, 1) || // entirely inside unit circle\r\n                lt(1, centerDist - rMax) || // entirely outside unit circle\r\n                lt(1, rMin - centerDist) || // contains unit circle\r\n                (eq(1, r1) && eq(1, r2) && eq0(centerDist)) // also unit circle, return no IS\r\n            ) {\r\n                return [];\r\n            }\r\n            const f = (t) => ellipseLCRA.at(t).lengthXY() - 1;\r\n            const df = (t) => ellipseLCRA\r\n                .at(t)\r\n                .xy()\r\n                .dot(ellipseLCRA.tangentAt(t)) / ellipseLCRA.at(t).lengthXY();\r\n            checkDerivate(f, df, -PI, PI, 1);\r\n            const ellipseLCRATs = [];\r\n            for (let startT = -4 / 5 * PI; startT < PI; startT += PI / 4) {\r\n                let t = newtonIterateSmart(f, startT, 16, df, 1e-4);\r\n                le(t, -PI) && (t += TAU);\r\n                assert(!isNaN(t));\r\n                if (between(t, -PI, PI) && eq0(f(t)) && !ellipseLCRATs.some(r => eq(t, r))) {\r\n                    ellipseLCRATs.push(t);\r\n                }\r\n            }\r\n            const result = [];\r\n            for (const ellipseLCRAT of ellipseLCRATs) {\r\n                const p = this.matrix.transformPoint(ellipseLCRA.at(ellipseLCRAT));\r\n                if (this.containsPoint(p) && ellipse.containsPoint(p)) {\r\n                    result.push({ tThis: this.pointT(p), tOther: ellipse.pointT(p), p });\r\n                }\r\n            }\r\n            return result;\r\n            //const angle = ellipseLCRA.f1.angleXY()\r\n            //const aSqr = ellipseLCRA.f1.squared(), bSqr = ellipseLCRA.f2.squared()\r\n            //const a = Math.sqrt(aSqr), b = Math.sqrt(bSqr)\r\n            //const {x: centerX, y: centerY} = ellipseLCRA.center\r\n            //const rotCenterX = centerX * Math.cos(-angle) + centerY * -Math.sin(-angle)\r\n            //const rotCenterY = centerX * Math.sin(-angle) + centerY * Math.cos(-angle)\r\n            //const rotCenter = V(rotCenterX, rotCenterY)\r\n            //const f = t => {\r\n            //\tconst lex = Math.cos(t) - rotCenterX, ley = Math.sin(t) - rotCenterY\r\n            //\treturn lex * lex / aSqr + ley * ley / bSqr - 1\r\n            //}\r\n            //const f2 = (x, y) => (x * x + y * y - 1)\r\n            //const f3 = (x, y) => ((x - rotCenterX) * (x - rotCenterX) / aSqr + (y - rotCenterY) * (y - rotCenterY) /\r\n            // bSqr - 1) const results = [] const resetMatrix = this.matrix.times(M4.rotateZ(angle)) for (let startT =\r\n            // Math.PI / 4; startT < 2 * Math.PI; startT += Math.PI / 2) { const startP = EllipseCurve.XY.at(startT)\r\n            // const p = newtonIterate2d(f3, f2, startP.x, startP.y, 10) if (p && !results.some(r => r.like(p))) {\r\n            // results.push(p) } } const rotEl = new EllipseCurve(rotCenter, V(a, 0, 0), V(0, b, 0)) return\r\n            // results.map(pLC => { const p = resetMatrix.transformPoint(pLC) return {tThis: this.pointT(p, PI),\r\n            // tOther: ellipse.pointT(p, PI), p} })\r\n        }\r\n        else {\r\n            return this.isTsWithPlane(P3.normalOnAnchor(ellipse.normal.unit(), ellipse.center)).mapFilter(t => {\r\n                const p = this.at(t);\r\n                if (ellipse.containsPoint(p)) {\r\n                    return { tThis: t, tOther: ellipse.pointT(p), p };\r\n                }\r\n                return undefined;\r\n            });\r\n        }\r\n    }\r\n    isInfosWithCurve(curve) {\r\n        if (curve instanceof EllipseCurve) {\r\n            return this.isInfosWithEllipse(curve);\r\n        }\r\n        return super.isInfosWithCurve(curve);\r\n    }\r\n    transform4(m4) {\r\n        const tMap = (t) => sign(t) * sqrt((1 - cos(t)) / (1 + cos(t)));\r\n        // prettier-ignore\r\n        const parabolaToUnitEllipse = new M4(0, -1, 0, 1, 2, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1);\r\n        return parabola4Projection(M4.product(m4, this.matrix, parabolaToUnitEllipse), tMap(this.tMin), tMap(this.tMax));\r\n    }\r\n    roots() {\r\n        // tangent(t) = f2 cos t - f1 sin t\r\n        // solve for each dimension separately\r\n        // tangent(eta, xi) = f2 eta - f1 xi\r\n        return arrayFromFunction(3, dim => {\r\n            const a = this.f2.e(dim), b = -this.f1.e(dim);\r\n            return intersectionUnitCircleLine2(a, b, 0)\r\n                .map(([xi, eta]) => Math.atan2(eta, xi))\r\n                .filter(t => this.isValidT(t));\r\n        });\r\n    }\r\n    closestTToPoint(p, tStart) {\r\n        // (at(t) - p) * tangentAt(t) = 0\r\n        // (xi f1 + eta f2 + q) * (xi f2 - eta f1) = 0\r\n        // xi eta (f2^2-f1^2) + xi f2 q - eta² f1 f2 + xi² f1 f2 - eta f1 q = 0\r\n        //  (xi² - eta²) f1 f2 + xi eta (f2^2-f1^2) + xi f2 q - eta f1 q = 0\r\n        // atan2 of p is a good first approximation for the searched t\r\n        tStart = tStart || this.matrixInverse.transformPoint(p).angleXY();\r\n        const pRelCenter = p.minus(this.center);\r\n        const f = (t) => this.tangentAt(t).dot(this.f1\r\n            .times(Math.cos(t))\r\n            .plus(this.f2.times(Math.sin(t)))\r\n            .minus(pRelCenter));\r\n        return newtonIterate1d(f, tStart, 8);\r\n    }\r\n    area() {\r\n        // see\r\n        // https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Cross_product_parallelogram.svg/220px-Cross_product_parallelogram.svg.png\r\n        return Math.PI * this.f1.cross(this.f2).length();\r\n    }\r\n    angleToT(phi) {\r\n        // atan2(y, x) = phi\r\n        const phiDir = this.f1\r\n            .unit()\r\n            .times(Math.cos(phi))\r\n            .plus(this.f2\r\n            .rejectedFrom(this.f1)\r\n            .unit()\r\n            .times(Math.sin(phi)));\r\n        const dirLC = this.matrixInverse.transformVector(phiDir);\r\n        return dirLC.angleXY();\r\n    }\r\n}\r\nEllipseCurve.UNIT = new EllipseCurve(V3.O, V3.X, V3.Y);\r\nEllipseCurve.prototype.hlol = Curve.hlol++;\r\nEllipseCurve.prototype.tIncrement = 2 * Math.PI / (4 * 32);\r\n//# sourceMappingURL=EllipseCurve.js.map","import { arrayFromFunction, arraySamples, assert, between, DEG, eq, eq0, hasConstructor, le, lerp, M4, newtonIterateWithDerivative2, snap, snap0, V, V3, vArrGet, Vector, VV, MINUS } from 'ts3dutils';\r\nimport { BezierCurve, Curve, EllipseCurve, HyperbolaCurve, L3, P3, ParabolaCurve } from '../index';\r\nimport { abs, cos, cosh, PI, sin, sinh, sqrt, SQRT1_2 } from '../math';\r\nexport class NURBS extends Curve {\r\n    constructor(points, degree, knots = NURBS.openUniformKnots(points.length, degree), tMin = knots[degree], tMax = knots[knots.length - degree - 1]) {\r\n        super(tMin, tMax);\r\n        this.points = points;\r\n        this.degree = degree;\r\n        this.knots = knots;\r\n        const knotsLength = points.length + degree + 1;\r\n        assert(knots.length === knotsLength, 'bad knot vector length: expected ' +\r\n            knotsLength +\r\n            ' (degree = ' +\r\n            degree +\r\n            ' pcount = ' +\r\n            points.length +\r\n            '), but was ' +\r\n            knots.length);\r\n        assert(knots[degree] <= tMin);\r\n        assert(tMax <= knots[knots.length - degree - 1]);\r\n        for (let i = 0; i < points.length; i++) {\r\n            assert(points[i].dim() == 4);\r\n        }\r\n        assert(degree >= 1, 'degree must be at least 1 (linear)');\r\n        assert(degree % 1 == 0);\r\n        assert(-1 == knots.firstUnsorted(MINUS), 'knot values must be in ascending order');\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.points, this.degree, this.knots];\r\n    }\r\n    at4(t) {\r\n        assert(between(t, this.tMin, this.tMax), t);\r\n        const { points, degree, knots } = this;\r\n        // find s (the spline segment) for the [t] value provided\r\n        const s = this.tInterval(t);\r\n        const v = Vector.pack(points, new Float64Array((degree + 1) * 4), s - degree, 0, degree + 1);\r\n        for (let level = 0; level < degree; level++) {\r\n            // build level l of the pyramid\r\n            for (let i = degree; i > level; i--) {\r\n                const alpha = (t - knots[i + s - degree]) / (knots[i + s - level] - knots[i + s - degree]);\r\n                // interpolate each component\r\n                for (let dim = 0; dim < 4; dim++) {\r\n                    v[i * 4 + dim] = (1 - alpha) * v[(i - 1) * 4 + dim] + alpha * v[i * 4 + dim];\r\n                }\r\n            }\r\n        }\r\n        return new Vector(v.slice(degree * 4, (degree + 1) * 4));\r\n    }\r\n    at(t) {\r\n        return this.at4(t).p3();\r\n    }\r\n    /*\r\n    d(k, i, t) = a(i, k, t) * d(k - 1, i, t) + (1 - a(i, k, t)) * d(k - 1, i - 1, t)\r\n    a(i, k, t) = (t - knots[i]) / (knots[i + 1 + n - k] - knots[i])\r\n    a'(i, k, t) = 1 / (knots[i + 1 + n - k] - knots[i])\r\n\r\n    d/dt =  a(i, k, t) * d'(k - 1, i, t) + a'(i, k, t) * d(k - 1, i, t)\r\n    + (1 - a(i, k, t)) * d'(k - 1, i - 1, t) + a'(i, k, t) * d(k - 1, i - 1, t)\r\n*/\r\n    ptDtDdt4(t) {\r\n        const { points, degree, knots } = this;\r\n        // find s (the spline segment) for the [t] value provided\r\n        const s = this.tInterval(t);\r\n        const v = Vector.pack(points, new Float64Array((degree + 1) * 4), s - degree, 0, degree + 1);\r\n        let ddt = Vector.Zero(4), derivative;\r\n        for (let level = 0; level < degree; level++) {\r\n            if (level == degree - 2) {\r\n                // see https://www.globalspec.com/reference/61012/203279/10-8-derivatives\r\n                const a = new Vector(v.slice(degree * 4, (degree + 1) * 4));\r\n                const b = new Vector(v.slice((degree - 1) * 4, degree * 4));\r\n                const c = new Vector(v.slice((degree - 2) * 4, (degree - 1) * 4));\r\n                function step(k, i, dkMinus1iMinus1, dkMinus1i) {\r\n                    return dkMinus1i.minus(dkMinus1iMinus1).times(k / (knots[i + degree - k] - knots[i - 1]));\r\n                }\r\n                ddt = step(degree, s + 1, step(degree - 1, s + 1, a, b), step(degree - 1, s, b, c));\r\n            }\r\n            if (level == degree - 1) {\r\n                const a = new Vector(v.slice(degree * 4, (degree + 1) * 4));\r\n                const b = new Vector(v.slice((degree - 1) * 4, degree * 4));\r\n                derivative = b.minus(a).times(degree / (knots[s] - knots[s + 1]));\r\n            }\r\n            for (let i = degree; i > level; i--) {\r\n                const alpha = (t - knots[i + s - degree]) / (knots[i + s - level] - knots[i + s - degree]);\r\n                // interpolate each component\r\n                for (let dim = 0; dim < 4; dim++) {\r\n                    v[i * 4 + dim] = (1 - alpha) * v[(i - 1) * 4 + dim] + alpha * v[i * 4 + dim];\r\n                }\r\n            }\r\n        }\r\n        const p = new Vector(v.slice(degree * 4, degree * 4 + 4));\r\n        return [p, derivative, ddt];\r\n    }\r\n    tangentAt(t) {\r\n        // x(t) = xw(t) / w(t)\r\n        // quotient rule\r\n        const [p, derivative] = this.ptDtDdt4(t);\r\n        const expected = derivative\r\n            .times(p.w)\r\n            .minus(p.times(derivative.w))\r\n            .div(Math.pow(p.w, 2))\r\n            .V3();\r\n        return expected;\r\n    }\r\n    ddt(t) {\r\n        const [p, dt, ddt] = this.ptDtDdt4(t);\r\n        // =(-w(t) x(t) w''(t) - 2 w(t) w'(t) x'(t) + 2 x(t) w'(t)^2 + w(t)^2 x''(t))/w(t)^3\r\n        // =(x(t) ((-w(t)) w''(t) + 2 w'(t)^2) - x'(t) 2 w(t) w'(t) + x''(t) w(t)^2 )/w(t)^3\r\n        // prettier-ignore\r\n        return Vector.add(p.times(-p.w * ddt.w + 2 * Math.pow(dt.w, 2)), dt.times(-2 * p.w * dt.w), ddt.times(Math.pow(p.w, 2))).div(Math.pow(p.w, 3)).V3();\r\n    }\r\n    ptDtDdt(t) {\r\n        const [pt, dt4, ddt4] = this.ptDtDdt4(t);\r\n        return [\r\n            pt.p3(),\r\n            dt4\r\n                .times(pt.w)\r\n                .minus(pt.times(dt4.w))\r\n                .div(Math.pow(pt.w, 2))\r\n                .V3(),\r\n            // prettier-ignore\r\n            Vector.add(pt.times(-pt.w * ddt4.w + 2 * Math.pow(dt4.w, 2)), dt4.times(-2 * pt.w * dt4.w), ddt4.times(Math.pow(pt.w, 2))).div(Math.pow(pt.w, 3)).V3(),\r\n        ];\r\n    }\r\n    pointT(pWC) {\r\n        return this.closestTToPoint(pWC);\r\n    }\r\n    closestTToPoint(p, tStart, tMin = this.tMin, tMax = this.tMax) {\r\n        // this.at(t) has minimal distance to p when this.tangentAt(t) is perpendicular to\r\n        // the vector between this.at(t) and p. This is the case iff the dot product of the two is 0.\r\n        // f = (this.at(t) - p) . (this.tangentAt(t)\r\n        // df = this.tangentAt(t) . this.tangentAt(t) + (this.at(t) - p) . this.ddt(t)\r\n        //    = this.tangentAt(t)² + (this.at(t) - p) . this.ddt(t)\r\n        const f = (t) => {\r\n            const [pt, dt, ddt] = this.ptDtDdt(t);\r\n            return [pt.minus(p).dot(dt), dt.squared() + pt.minus(p).dot(ddt)];\r\n        };\r\n        //checkDerivate(f, df, tMin, tMax)\r\n        const STEPS = 32;\r\n        if (undefined === tStart) {\r\n            tStart = arraySamples(tMin, tMax, STEPS).withMax(t => -this.at(t).distanceTo(p));\r\n        }\r\n        const result = newtonIterateWithDerivative2(f, tStart, 8, this.tMin, this.tMax);\r\n        //assert(undefined !== result)\r\n        return result;\r\n    }\r\n    containsPoint(pWC) {\r\n        const tGuess = this.closestTToPoint(pWC);\r\n        return undefined === tGuess ? false : this.at(tGuess).like(pWC);\r\n    }\r\n    derivate() {\r\n        const k = this.degree;\r\n        const ps = arrayFromFunction(this.points.length - 1, i => this.points[i].to(this.points[i + 1]).times(k / (this.knots[i + k + 1] - this.knots[i + 1])));\r\n        return new NURBS(ps, this.degree - 1, this.knots.slice(1, -1), this.tMin, this.tMax);\r\n    }\r\n    /**\r\n     * Create a new NURBS of equal degree with the added knot [newKnot]. New NURBS will have one additional control\r\n     * point.\r\n     */\r\n    withKnot(newKnot, multiplicity = 1) {\r\n        assert(between(newKnot, this.tMin, this.tMax));\r\n        const k = this.tInterval(newKnot);\r\n        const { knots, points, degree } = this;\r\n        const insertPoints = arrayFromFunction(this.degree, j => {\r\n            const i = k - degree + 1 + j;\r\n            const aiNumerator = newKnot - knots[i];\r\n            // 0/0 defined as 0:\r\n            const ai = aiNumerator == 0 ? 0 : aiNumerator / (knots[i + degree] - knots[i]);\r\n            assert(between(ai, 0, 1));\r\n            return Vector.lerp(points[i - 1], points[i], ai);\r\n        });\r\n        const newPoints = points.slice();\r\n        newPoints.splice(k - degree + 1, degree - 1, ...insertPoints);\r\n        const newKnots = knots.slice();\r\n        newKnots.splice(k + 1, 0, newKnot);\r\n        return new NURBS(newPoints, degree, newKnots, this.tMin, this.tMax);\r\n    }\r\n    removeKnot(t) {\r\n        const { knots, points, degree } = this;\r\n        let k = this.tInterval(t), s = 0; // s = multiplicity of the knot\r\n        while (knots[k + 1] == t) {\r\n            k++;\r\n            s++;\r\n        }\r\n        if (s == 0)\r\n            throw new Error('There is no knot ' + t + '!');\r\n        // the points which were relevant when inserting were (k - p - 1) to (k - 1). (- 1) because the current k has\r\n        // been increased by one due to the insertion.\r\n        // p - 1 points were replaced by p points, hence we need to generate the original p - 1 point, + 1 to check if\r\n        // this transformation is valid.\r\n        const insertPoints = [points[k - degree - 1]];\r\n        const oldKnots = knots.slice();\r\n        oldKnots.splice(k, 1);\r\n        for (let i = k - degree; i <= k - s; i++) {\r\n            const alphaInv = (oldKnots[i + degree] - oldKnots[i]) / (t - oldKnots[i]);\r\n            const oldPoint = Vector.lerp(insertPoints.last, points[i], alphaInv);\r\n            insertPoints.push(oldPoint);\r\n        }\r\n        if (insertPoints.last.like(points[k + 1 - s])) {\r\n            const oldPoints = points.slice();\r\n            oldPoints.splice(k - degree - 1, degree - s + 3, ...insertPoints);\r\n            return new NURBS(oldPoints, degree, oldKnots);\r\n        }\r\n        return undefined;\r\n    }\r\n    static openUniformKnots(pointCount, degree, tMin = 0, tMax = 1) {\r\n        const knotsLength = pointCount + degree + 1;\r\n        return arrayFromFunction(knotsLength, i => {\r\n            if (i <= degree) {\r\n                return tMin;\r\n            }\r\n            else if (i >= knotsLength - degree - 1) {\r\n                return tMax;\r\n            }\r\n            else {\r\n                return lerp(tMin, tMax, (i - degree) / (knotsLength - degree * 2 - 1));\r\n            }\r\n        });\r\n    }\r\n    static bezierKnots(degree, tMin = 0, tMax = 1) {\r\n        const result = new Array((degree + 1) * 2);\r\n        for (let i = 0; i < degree + 1; i++) {\r\n            result[i] = tMin;\r\n            result[degree + 1 + i] = tMax;\r\n        }\r\n        return result;\r\n    }\r\n    static fromBezier(bezier) {\r\n        const bezier01 = bezier.selectPart(bezier.tMin, bezier.tMax);\r\n        return NURBS.Bezier(bezier01.points);\r\n    }\r\n    static Bezier(points, tMin = 0, tMax = 1) {\r\n        return new NURBS(points.map(p => (p instanceof V3 ? new Vector(new Float64Array([p.x, p.y, p.z, 1])) : p)), points.length - 1, arrayFromFunction(points.length * 2, i => (i < points.length ? 0 : 1)), tMin, tMax);\r\n    }\r\n    static fromHyperbola(hyperbola, tMin = hyperbola.tMin, tMax = hyperbola.tMax) {\r\n        const p0 = HyperbolaCurve.XY.at(tMin);\r\n        const p2 = HyperbolaCurve.XY.at(tMax);\r\n        const p1 = new V3((sinh(tMin) - sinh(tMax)) / sinh(tMin - tMax), (cosh(tMin) - cosh(tMax)) / sinh(tMin - tMax), 0);\r\n        // M: midpoint between p0 and p2\r\n        // X: intersection of line through p1 and M and unit hyperbola\r\n        // result.at(1/2) = X\r\n        // result.at(1/2) = (1/4 p0 + 1/2 p1 w + 1/4 p2) / (1/4 + 1/ 2 w + 1/4)\r\n        // result.at(1/2) = (1/2 p0 + p1 w + 1/2 p2) / (1 + w)\r\n        // result.at(1/2) = (M + p1 w) / (1 + w) = X\r\n        // => w * (p1 - X) = (X - M)\r\n        // as p1, X and M are all on the same line, we can solve this equation with only the x\r\n        const M = p0.lerp(p2, 0.5);\r\n        const Xx = 1 / sqrt(1 - Math.pow((M.y / M.x), 2));\r\n        const w = (Xx - M.x) / (p1.x - Xx);\r\n        return NURBS.fromV3s([p0, p1, p2], 2, undefined, [1, w, 1]).transform(hyperbola.matrix);\r\n    }\r\n    static fromParabola(parabola) {\r\n        return NURBS.fromBezier(parabola.asBezier());\r\n    }\r\n    static fromEllipse(ellipse) {\r\n        const unitSemiEllipse = new NURBS([\r\n            VV(1, 0, 0, 1),\r\n            VV(1, 1, 0, 1).times(SQRT1_2),\r\n            VV(0, 1, 0, 1),\r\n            VV(-1, 1, 0, 1).times(SQRT1_2),\r\n            VV(-1, 0, 0, 1),\r\n            VV(-1, -1, 0, 1).times(SQRT1_2),\r\n            VV(0, -1, 0, 1),\r\n        ], 2, [0, 0, 0, PI / 2, PI / 2, PI, PI, 3 * PI / 2, 3 * PI / 2, 2 * PI]);\r\n        return unitSemiEllipse.transform(ellipse.matrix);\r\n    }\r\n    /**\r\n     * Create a new NURBS from V3s, with optional weights.\r\n     * @param points\r\n     * @param degree\r\n     * @param knots\r\n     * @param weights\r\n     */\r\n    static fromV3s(points, degree, knots, weights = arrayFromFunction(points.length, () => 1)) {\r\n        assert(points.length == weights.length);\r\n        return new NURBS(points.map((p, i) => Vector.fromV3AndWeight(p, weights[i])), degree, knots);\r\n    }\r\n    isUniform(precision = 0) {\r\n        const intervals = arrayFromFunction(this.knots.length - 1, i => this.knots[i + 1] - this.knots[i]);\r\n        const [min, max] = minAndMax(intervals);\r\n        return eq(min, max, precision);\r\n    }\r\n    /**\r\n     * NURBS is a B spline if control points all have the same weight.\r\n     */\r\n    isBSpline(precision = 0) {\r\n        const [minWeight, maxWeight] = minAndMax(this.points.map(p => p.w));\r\n        return eq(minWeight, maxWeight, precision);\r\n    }\r\n    /**\r\n     * Whether this is a (rational) bezier curve.\r\n     */\r\n    isBezier(precision = 0) {\r\n        if (this.degree + 1 != this.points.length)\r\n            return false;\r\n        const [min0, max0] = minAndMax(this.knots, 0, this.degree + 1);\r\n        if (!eq(min0, max0, precision))\r\n            return false;\r\n        const [min1, max1] = minAndMax(this.knots, this.degree + 1);\r\n        if (!eq(min1, max1, precision))\r\n            return false;\r\n        return true;\r\n    }\r\n    /**\r\n     * Splits NURBS curve into rational bezier curves.\r\n     * See https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/subdivision.html\r\n     */\r\n    getSegments() {\r\n        const { knots, points, degree } = this;\r\n        const result = [];\r\n        const v = Vector.pack(points, new Float64Array(points.length * 4));\r\n        const vectorFromV = (i) => new Vector(v.slice(i * 4, (i + 1) * 4));\r\n        let k = degree + 1; // k = knot index we are duplicating\r\n        while (k < knots.length - degree - 1) {\r\n            const t = knots[k];\r\n            const prevKnot = knots[k - 1];\r\n            let s = 1; // s = multiplicity of the knot\r\n            while (knots[k + 1] == t) {\r\n                k++;\r\n                s++;\r\n            }\r\n            const newNURBSPoints = new Array(degree + 1);\r\n            // the first s + 1 points are identical to the current curve\r\n            for (let i = 0; i < s + 1; i++) {\r\n                newNURBSPoints[i] = vectorFromV(k - degree - s + i);\r\n            }\r\n            // we need to have multiplicity degree, so insert (degree - s) times\r\n            for (let level = 1; level <= degree - s; level++) {\r\n                for (let i = k - degree; i <= k - s - level; i++) {\r\n                    const alpha = (t - prevKnot) / (knots[i + degree + 1] - prevKnot);\r\n                    for (let dim = 0; dim < 4; dim++) {\r\n                        v[i * 4 + dim] = (1 - alpha) * v[i * 4 + dim] + alpha * v[(i + 1) * 4 + dim];\r\n                    }\r\n                }\r\n                newNURBSPoints[s + level] = vectorFromV(k - degree);\r\n            }\r\n            const newNURBSKnots = arrayFromFunction((degree + 1) * 2, i => (i < degree + 1 ? knots[k - s] : t));\r\n            result.push(new NURBS(newNURBSPoints, degree, newNURBSKnots));\r\n            k++;\r\n        }\r\n        // last curve\r\n        const newNURBSPoints = arrayFromFunction(degree + 1, i => vectorFromV(points.length - degree - 1 + i));\r\n        const newNURBSKnots = arrayFromFunction((degree + 1) * 2, i => (i < degree + 1 ? knots[k - 1] : knots[k]));\r\n        result.push(new NURBS(newNURBSPoints, degree, newNURBSKnots));\r\n        return result;\r\n    }\r\n    split(t) {\r\n        const { knots, points, degree } = this;\r\n        assert(le(this.tMin, t) && le(t, this.tMax));\r\n        let k = this.tInterval(t), s = 0; // s = multiplicity of the knot\r\n        while (knots[k + 1] == t) {\r\n            k++;\r\n            s++;\r\n        }\r\n        const vectorFromV = (i) => new Vector(v.slice(i * 4, (i + 1) * 4));\r\n        const leftPoints = new Array(k + 1 - s);\r\n        // the first k + s + 1 points are identical to the current curve\r\n        for (let i = 0; i < k + s - degree + 1; i++) {\r\n            leftPoints[i] = this.points[i];\r\n        }\r\n        const rightPointsLength = points.length - (k - degree);\r\n        const v = Vector.pack(points, new Float64Array(rightPointsLength * 4), k - degree);\r\n        // we need to have multiplicity degree, so insert (degree - s) times\r\n        for (let level = 1; level <= degree - s; level++) {\r\n            for (let i = k - degree; i <= k - s - level; i++) {\r\n                const alpha = (t - knots[i + level]) / (knots[i + degree + 1] - knots[i + level]);\r\n                const j = i - (k - degree);\r\n                for (let dim = 0; dim < 4; dim++) {\r\n                    v[j * 4 + dim] = (1 - alpha) * v[j * 4 + dim] + alpha * v[(j + 1) * 4 + dim];\r\n                }\r\n            }\r\n            leftPoints[k - degree + level] = vectorFromV(0);\r\n        }\r\n        const leftKnots = knots.slice(0, k + degree + 2 - s);\r\n        for (let i = 0; i < degree - s + 1; i++) {\r\n            leftKnots[k - s + 1 + i] = t;\r\n        }\r\n        const rightKnots = knots.slice(k - degree);\r\n        for (let i = 0; i < degree + 1; i++) {\r\n            rightKnots[i] = t;\r\n        }\r\n        const rightPoints = arrayFromFunction(rightPointsLength, i => vArrGet(v, 4, i));\r\n        return [new NURBS(leftPoints, degree, leftKnots), new NURBS(rightPoints, degree, rightKnots)];\r\n    }\r\n    simplify() {\r\n        assert(this.isBezier());\r\n        if (3 == this.degree && this.isBSpline()) {\r\n            return new BezierCurve(this.points[0].p3(), this.points[1].p3(), this.points[2].p3(), this.points[3].p3(), this.tMin, this.tMax);\r\n        }\r\n        else if (2 == this.degree) {\r\n            const [P0, P1, P2] = this.points;\r\n            const [p0, p1, p2] = this.points.map(p => p.p3());\r\n            const c = NURBS.simplifyUnit2(P0.w, P1.w, P2.w).transform(M4.forSys(p1.to(p0), p1.to(p2), undefined, p1));\r\n            const [tMin, tMax] = [c.pointT(p0), c.pointT(p2)].sort();\r\n            return c.withBounds(snap(tMin, c.tMin), snap(tMax, c.tMax));\r\n        }\r\n        else if (1 == this.degree) {\r\n            return L3.throughPoints(this.points[0].p3(), this.points[1].p3());\r\n        }\r\n        else {\r\n            return this;\r\n        }\r\n    }\r\n    static simplifyUnit2(w0, w1, w2) {\r\n        // see https://math.stackexchange.com/a/2794874/230980\r\n        const delta = w0 * w2 - Math.pow(w1, 2);\r\n        const cxy = w0 * w2 / 2 / delta;\r\n        const center = new V3(cxy, cxy, 0);\r\n        const k = (Math.pow(w1, 2) + delta - 2 * w1 * sqrt(abs(delta))) / 2 / delta;\r\n        const p = V3.X;\r\n        const q = new V3(k, cxy, 0);\r\n        // const q = new V3(cxy, k, 0)\r\n        if (eq0(delta)) {\r\n            return new ParabolaCurve(new V3(1 / 4, 1 / 4, 0), new V3(1, -1, 0), new V3(1, 1, 0), -0.5, 0.5);\r\n        }\r\n        else if (delta < 0) {\r\n            // hyperbola\r\n            return new HyperbolaCurve(center, center.to(p), center.to(q));\r\n        }\r\n        else {\r\n            // ellipse\r\n            return new EllipseCurve(center, center.to(p), center.to(q), 0);\r\n        }\r\n    }\r\n    elevateDegreeBezier() {\r\n        assert(this.isBezier());\r\n        const newPoints = new Array(this.points.length + 1);\r\n        newPoints[0] = this.points[0];\r\n        newPoints[this.points.length] = this.points[this.points.length - 1];\r\n        for (let i = 1; i < this.points.length; i++) {\r\n            newPoints[i] = Vector.lerp(this.points[i], this.points[i - 1], i / (this.degree + 1));\r\n        }\r\n        const newKnots = NURBS.bezierKnots(this.degree + 1, this.knots[0], this.knots[this.degree + 1]);\r\n        return new NURBS(newPoints, this.degree + 1, newKnots, this.tMin, this.tMax);\r\n    }\r\n    elevateDegree() {\r\n        const segmentsElevated = this.getSegments().map(b => b.elevateDegreeBezier());\r\n        // stitch together the segments\r\n        const newPoints = new Array(2 + segmentsElevated.length * this.degree);\r\n        newPoints[0] = segmentsElevated[0].points[0];\r\n        newPoints.last = segmentsElevated.last.points.last;\r\n        for (let i = 0; i < segmentsElevated.length; i++) {\r\n            for (let pi = 1; pi < segmentsElevated[i].points.length - 1; pi++) {\r\n                newPoints[i * (segmentsElevated[0].points.length - 2) + pi] = segmentsElevated[i].points[pi];\r\n            }\r\n        }\r\n        const newKnots = new Array(newPoints.length + this.degree + 2);\r\n        for (let i = 0; i < this.degree + 2; i++) {\r\n            newKnots[i] = this.knots[0];\r\n        }\r\n        for (let i = 0; i < segmentsElevated.length; i++) {\r\n            for (let pi = 1; pi < segmentsElevated[i].points.length - 1; pi++) {\r\n                newKnots[i * (segmentsElevated[0].points.length - 2) + pi + this.degree + 1] =\r\n                    segmentsElevated[i].knots.last;\r\n            }\r\n        }\r\n        newKnots[newKnots.length - 1] = this.knots.last;\r\n        newKnots[newKnots.length - 2] = this.knots.last;\r\n        let result = new NURBS(newPoints, this.degree + 1, newKnots, this.tMin, this.tMax);\r\n        for (let i = 0; i < segmentsElevated.length - 1; i++) {\r\n            let optimization;\r\n            while ((optimization = result.removeKnot(segmentsElevated[i].knots.last))) {\r\n                result = optimization;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    transform(m4) {\r\n        return this.transform4(m4);\r\n    }\r\n    transform4(m4) {\r\n        return new NURBS(this.points.map(p => m4.timesVector(p)), this.degree, this.knots, this.tMin, this.tMax);\r\n    }\r\n    /**\r\n     * Returns the index of the interval which contains the value t.\r\n     */\r\n    tInterval(t) {\r\n        const { degree, knots } = this;\r\n        for (let s = degree; s < knots.length - 1 - degree; s++) {\r\n            if (t >= knots[s] && t <= knots[s + 1]) {\r\n                return s;\r\n            }\r\n        }\r\n        throw new Error(t + ' ' + knots);\r\n    }\r\n    static UnitCircle(sections = 2, tMin = 0, tMax = PI) {\r\n        const dt = tMax - tMin;\r\n        const tStep = dt / sections;\r\n        const w = sin(PI / 2 - tStep / 2);\r\n        console.log(tStep / 2 / DEG);\r\n        // cos\r\n        const r = 1 / cos(tStep / 2);\r\n        const points = arrayFromFunction(sections * 2 + 1, i => {\r\n            const t = lerp(tMin, tMax, i / 2 / sections);\r\n            if (i % 2 == 0) {\r\n                // control point on circle\r\n                return VV(cos(t), sin(t), 0, 1);\r\n            }\r\n            else {\r\n                return VV(r * w * cos(t), r * w * sin(t), 0, w);\r\n            }\r\n        });\r\n        const knots = [];\r\n        knots.push(tMin, tMin, tMin);\r\n        for (let i = 0; i < sections - 1; i++) {\r\n            const knot = lerp(tMin, tMax, (i + 1) / sections);\r\n            knots.push(knot, knot);\r\n        }\r\n        knots.push(tMax, tMax, tMax);\r\n        return new NURBS(points, 2, knots);\r\n    }\r\n    debugInfo() {\r\n        return {\r\n            points: [\r\n                ...this.knots.slice(this.degree, -this.degree).map(t => this.at(t)),\r\n                ...this.points.map(p => p.p3()),\r\n            ],\r\n            lines: this.points.flatMap((p, i, ps) => (ps[i + 1] ? [p.p3(), ps[i + 1].p3()] : [])),\r\n        };\r\n    }\r\n    isTsWithPlane(planeWC) {\r\n        const { knots, degree, points } = this;\r\n        const controlPointTs = [\r\n            knots[degree],\r\n            ...points\r\n                .slice(1, -1)\r\n                .map((p, i) => this.closestTToPoint(p.p3(), undefined, knots[i + 3], knots[i + degree])),\r\n            knots[knots.length - degree - 1],\r\n        ];\r\n        const result = [];\r\n        for (let i = 0; i < this.points.length - 1; i++) {\r\n            const findClosest = (startT) => {\r\n                console.log('startT', startT);\r\n                // try {\r\n                const f = (t) => {\r\n                    const [p, dt] = this.ptDtDdt(t);\r\n                    return [planeWC.distanceToPointSigned(p), planeWC.normal1.dot(dt)];\r\n                };\r\n                let t = newtonIterateWithDerivative2(f, startT, 8, this.tMin, this.tMax);\r\n                let [distanceAtT, distanceDtAtT] = undefined === t ? [] : f(t);\r\n                if (t === undefined || !eq0(distanceAtT) || eq0(distanceDtAtT)) {\r\n                    t = newtonIterateWithDerivative2(t => {\r\n                        const [, dt, ddt] = this.ptDtDdt(t);\r\n                        return [planeWC.normal1.dot(dt), planeWC.normal1.dot(ddt)];\r\n                    }, startT, 8, this.tMin, this.tMax);\r\n                }\r\n                ;\r\n                [distanceAtT, distanceDtAtT] = undefined === t ? [] : f(t);\r\n                if (undefined !== t && eq0(distanceAtT) && !result.some(r => eq(r, t))) {\r\n                    result.push(t);\r\n                }\r\n            };\r\n            const a = this.points[i].p3();\r\n            const b = this.points[i + 1].p3();\r\n            const ad = snap0(planeWC.distanceToPointSigned(a));\r\n            const bd = snap0(planeWC.distanceToPointSigned(b));\r\n            if (ad * bd < 0) {\r\n                const startT = lerp(controlPointTs[i], controlPointTs[i + 1], ad / (ad - bd));\r\n                findClosest(startT);\r\n            }\r\n            else if (0 == bd) {\r\n                findClosest(this.closestTToPoint(b, controlPointTs[i + 1]));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    isInfosWithCurve(curveWC) {\r\n        if (curveWC instanceof L3) {\r\n            return this.isInfosWithLine(curveWC.anchor, curveWC.dir1);\r\n        }\r\n        return super.isInfosWithCurve(curveWC);\r\n    }\r\n    isInfosWithLine(anchor, dir) {\r\n        const thisPlane = P3.fromPoints(this.points.map(p => p.p3()));\r\n        const l = L3.anchorDirection(anchor, dir);\r\n        const maxDistanceToPlane = this.points.map(p => thisPlane.distanceToPoint(p.p3())).max();\r\n        const thisIsPlanar = eq0(maxDistanceToPlane);\r\n        if (thisIsPlanar && !thisPlane.containsLine(l)) {\r\n            const [t] = l.isTsWithPlane(thisPlane);\r\n            if (undefined === t)\r\n                return [];\r\n            const p = l.at(t);\r\n            return this.containsPoint(p) ? [{ tThis: this.pointT(p), tOther: L3.pointT(anchor, dir, p), p }] : [];\r\n        }\r\n        else {\r\n            const thisTs = this.isTsWithPlane(P3.normalOnAnchor(thisPlane.normal1.cross(dir), anchor));\r\n            const infos = thisTs.map(tThis => {\r\n                const p = this.at(tThis);\r\n                return { tThis, tOther: L3.pointT(anchor, dir, p), p };\r\n            });\r\n            return thisIsPlanar ? infos : infos.filter(info => L3.containsPoint(anchor, dir, info.p));\r\n        }\r\n    }\r\n    roots() {\r\n        console.log(this.tMin, this.tMax);\r\n        arraySamples(this.tMin, this.tMax, 30).forEach(t => {\r\n            console.log(t + ',' + this.tangentAt(t).z);\r\n        });\r\n        const result = [[], [], []];\r\n        for (let i = 0; i < this.points.length - 1; i++) {\r\n            const findClosest = (startT, d) => {\r\n                console.log('d', d, 'startT', startT);\r\n                // try {\r\n                const root = newtonIterateWithDerivative2(t => {\r\n                    const [, dt, ddt] = this.ptDtDdt(t);\r\n                    return [dt.e(d), ddt.e(d)];\r\n                }, startT, 8, this.tMin, this.tMax);\r\n                if (undefined !== root) {\r\n                    result[d].push(root);\r\n                }\r\n                console.log('d', d, 'startT', startT, 'root', root);\r\n            };\r\n            const a = this.points[i].p3();\r\n            const b = this.points[i + 1].p3();\r\n            const ab = a.to(b);\r\n            for (let d = 0; d < 3; d++) {\r\n                if (0 !== i && eq0(ab.e(d))) {\r\n                    const startT = lerp(this.knots[i], this.knots[i + this.degree + 2], 0.5);\r\n                    findClosest(startT, d);\r\n                }\r\n                else if (i < this.points.length - 2) {\r\n                    const bc = b.to(this.points[i + 2].p3());\r\n                    if (!eq0(bc.e(d)) && ab.e(d) * bc.e(d) < 0) {\r\n                        findClosest(this.closestTToPoint(b, this.guessTClosestToControlPoint(i + 1)), d);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(result);\r\n        return result;\r\n    }\r\n    //getAABB() {\r\n    //\treturn new AABB().addPoints(this.points.map(p => p.p3()))\r\n    //}\r\n    /**\r\n     * Rough approximation of t param for points closest to control point.\r\n     */\r\n    guessTClosestToControlPoint(pointIndex) {\r\n        return lerp(this.knots[pointIndex], this.knots[pointIndex + this.degree + 1], 0.5);\r\n    }\r\n    likeCurve(curve) {\r\n        return (this == curve ||\r\n            (hasConstructor(curve, NURBS) &&\r\n                this.degree === curve.degree &&\r\n                this.points.every((p, i) => p.like(curve.points[i])) &&\r\n                this.knots.every((k, i) => eq(k, curve.knots[i]))));\r\n    }\r\n    isColinearTo(curve) {\r\n        throw new Error(\"This doesn't even make sense.\");\r\n    }\r\n}\r\nNURBS.EX2D = NURBS.fromV3s([\r\n    V(51, 141),\r\n    V(11, 76),\r\n    V(29, 32),\r\n    V(46, 102),\r\n    V(74, 148),\r\n    V(189, 107),\r\n    V(56, 10),\r\n    V(206, 10),\r\n    V(211, 98),\r\n    V(195, 141),\r\n    V(139, 148),\r\n], 4);\r\nNURBS.EX3D = new NURBS([\r\n    VV(94, 0, -34, 1),\r\n    VV(69, 57, 45, 0.5),\r\n    VV(-20, 44, 91, 1),\r\n    VV(-89, -13, 47, 0.5),\r\n    VV(-56, -97, -7, 1),\r\n    VV(34, -83, -54, 0.5),\r\n    VV(112, -53, 16, 1),\r\n    VV(79, 30, 70, 0.5),\r\n    VV(-2, -9, 141, 1),\r\n    VV(-80, -40, 72, 0.5),\r\n    VV(-38, -150, 43, 1),\r\n    VV(43, -110, -29, 0.5),\r\n    VV(130, -106, 65, 1),\r\n], 2, [-12, -12, -12, -8, -8, -4, -4, 0, 0, 4, 4, 8, 8, 12, 12, 12]);\r\nNURBS.prototype.tIncrement = 1 / 128;\r\nfunction minAndMax(arr, start = 0, end = arr.length) {\r\n    let min = Infinity, max = -Infinity;\r\n    for (let i = start; i < end; i++) {\r\n        if (min > arr[i])\r\n            min = arr[i];\r\n        if (max < arr[i])\r\n            max = arr[i];\r\n    }\r\n    return [min, max];\r\n}\r\n//# sourceMappingURL=NURBS.js.map","import { assert, assertInst, assertNumbers, assertVectors, callsce, eq, eq0, floatHashCode, hasConstructor, M4, Transformable, V3, VV, } from 'ts3dutils';\r\nimport { BezierCurve, EllipseCurve, HyperbolaCurve, L3, ParabolaCurve } from './index';\r\n/**\r\n * Plane x DOT this.normal1 = this.w\r\n */\r\nexport class P3 extends Transformable {\r\n    /**\r\n     * Oriented plane, i.e. splits R^3 in half, with one half being \"in front\" of the plane.\r\n     * Leads to multiple comparisons: isCoplanarToPlane returns if the plane occupies the same space,\r\n     * like returns if the plane occupies the same space and has the same orientation\r\n     *\r\n     * Points x on the plane fulfill the equation: normal1 DOT x = w\r\n     *\r\n     * @param normal1 unit plane normal1\r\n     * @param w signed (rel to normal1) distance from the origin\r\n     */\r\n    constructor(normal1, w = 0) {\r\n        super();\r\n        this.normal1 = normal1;\r\n        this.w = w;\r\n        assertVectors(normal1);\r\n        assertNumbers(w);\r\n        assert(normal1.hasLength(1), 'normal1.hasLength(1)' + normal1);\r\n    }\r\n    get anchor() {\r\n        return this.normal1.times(this.w);\r\n    }\r\n    static throughPoints(a, b, c) {\r\n        assertVectors(a, b, c);\r\n        const n1 = b\r\n            .minus(a)\r\n            .cross(c.minus(a))\r\n            .unit();\r\n        return new P3(n1, n1.dot(a));\r\n    }\r\n    static normalOnAnchor(normal, anchor) {\r\n        assertVectors(normal, anchor);\r\n        const n1 = normal.unit();\r\n        return new this(n1, n1.dot(anchor));\r\n    }\r\n    /**\r\n     * Create a plane which intersects the X, Y and Z axes at the specified offsets.\r\n     * x/x0 + y/y0 + y/y0 = 1\r\n     */\r\n    static forAxisIntercepts(x0, y0, z0) {\r\n        assertNumbers(x0, y0, z0);\r\n        const normal = new V3(1 / x0, 1 / y0, 1 / z0);\r\n        return new P3(normal.unit(), normal.length());\r\n    }\r\n    /**\r\n     * Create a plane containing `anchor` and extending in directions `v0` and `v1`.\r\n     * `v0` and `v1` may not be parallel.\r\n     * @param anchor\r\n     * @param v0\r\n     * @param v1\r\n     */\r\n    static forAnchorAndPlaneVectors(anchor, v0, v1) {\r\n        assertVectors(anchor, v0, v1);\r\n        assert(!v0.isParallelTo(v1));\r\n        return this.normalOnAnchor(v0.cross(v1), anchor);\r\n    }\r\n    /**\r\n     * Create a plane which contains botha point and a line. The point may not lie on the line.\r\n     * @param p\r\n     * @param line\r\n     */\r\n    static forPointAndLine(p, line) {\r\n        return this.forAnchorAndPlaneVectors(line.anchor, line.dir1, line.anchor.to(p));\r\n    }\r\n    /**\r\n     * ax + by + cz + d = 0\r\n     */\r\n    static forABCD(a, b, c, d) {\r\n        const normalLength = Math.hypot(a, b, c);\r\n        if (eq0(normalLength))\r\n            return undefined;\r\n        return new P3(new V3(a / normalLength, b / normalLength, c / normalLength), -d / normalLength);\r\n    }\r\n    static vanishingPlane(m4) {\r\n        return P3.forABCD(m4.m[12], m4.m[13], m4.m[14], m4.m[15]);\r\n    }\r\n    static forAABB(aabb, distance = 0) {\r\n        return [\r\n            new P3(V3.X, aabb.max.x + distance),\r\n            new P3(V3.X.negated(), -aabb.min.x - distance),\r\n            new P3(V3.Y, aabb.max.y + distance),\r\n            new P3(V3.Y.negated(), -aabb.min.y - distance),\r\n            new P3(V3.Z, aabb.max.z + distance),\r\n            new P3(V3.Z.negated(), -aabb.min.z - distance),\r\n        ];\r\n    }\r\n    // Fit a plane to a collection of points.\r\n    // Fast, and accurate to within a few degrees.\r\n    // Returns None if the points do not span a plane.\r\n    static fromPoints(points) {\r\n        const n = points.length;\r\n        if (n < 3) {\r\n            return undefined;\r\n        }\r\n        const centroid = V3.add(...points).div(n);\r\n        // Calculate full 3x3 covariance matrix, excluding symmetries:\r\n        let xx = 0.0;\r\n        let xy = 0.0;\r\n        let xz = 0.0;\r\n        let yy = 0.0;\r\n        let yz = 0.0;\r\n        let zz = 0.0;\r\n        for (const p of points) {\r\n            const r = p.minus(centroid);\r\n            xx += r.x * r.x;\r\n            xy += r.x * r.y;\r\n            xz += r.x * r.z;\r\n            yy += r.y * r.y;\r\n            yz += r.y * r.z;\r\n            zz += r.z * r.z;\r\n        }\r\n        xx /= n;\r\n        xy /= n;\r\n        xz /= n;\r\n        yy /= n;\r\n        yz /= n;\r\n        zz /= n;\r\n        let weighted_dir = V3.O;\r\n        {\r\n            const det_x = yy * zz - yz * yz;\r\n            const axis_dir = new V3(det_x, xz * yz - xy * zz, xy * yz - xz * yy);\r\n            let weight = det_x * det_x;\r\n            if (weighted_dir.dot(axis_dir) < 0.0) {\r\n                weight = -weight;\r\n            }\r\n            weighted_dir = weighted_dir.plus(axis_dir.times(weight));\r\n        }\r\n        {\r\n            const det_y = xx * zz - xz * xz;\r\n            const axis_dir = new V3(xz * yz - xy * zz, det_y, xy * xz - yz * xx);\r\n            let weight = det_y * det_y;\r\n            if (weighted_dir.dot(axis_dir) < 0.0) {\r\n                weight = -weight;\r\n            }\r\n            weighted_dir = weighted_dir.plus(axis_dir.times(weight));\r\n        }\r\n        {\r\n            const det_z = xx * yy - xy * xy;\r\n            const axis_dir = new V3(xy * yz - xz * yy, xy * xz - yz * xx, det_z);\r\n            let weight = det_z * det_z;\r\n            if (weighted_dir.dot(axis_dir) < 0.0) {\r\n                weight = -weight;\r\n            }\r\n            weighted_dir = weighted_dir.plus(axis_dir.times(weight));\r\n        }\r\n        const normal = weighted_dir.unit();\r\n        return P3.normalOnAnchor(normal, centroid);\r\n    }\r\n    axisIntercepts() {\r\n        const w = this.w, n = this.normal1;\r\n        return new V3(w / n.x, w / n.y, w / n.z);\r\n    }\r\n    isCoplanarToPlane(plane) {\r\n        assertInst(P3, plane);\r\n        return this.like(plane) || this.likeFlipped(plane);\r\n    }\r\n    like(plane) {\r\n        assertInst(P3, plane);\r\n        return eq(this.w, plane.w) && this.normal1.like(plane.normal1);\r\n    }\r\n    likeFlipped(plane) {\r\n        assertInst(P3, plane);\r\n        return eq(this.w, -plane.w) && this.normal1.like(plane.normal1.negated());\r\n    }\r\n    /**\r\n     * True iff plane.normal1 is equal to this.normal1 or it's negation.\r\n     *\r\n     */\r\n    isParallelToPlane(plane) {\r\n        assertInst(P3, plane);\r\n        return eq(1, Math.abs(this.normal1.dot(plane.normal1)));\r\n    }\r\n    isParallelToLine(line) {\r\n        assertInst(L3, line);\r\n        return eq0(this.normal1.dot(line.dir1));\r\n    }\r\n    isPerpendicularToLine(line) {\r\n        assertInst(L3, line);\r\n        // this.normal1 || line.dir1\r\n        return eq(1, Math.abs(this.normal1.dot(line.dir1)));\r\n    }\r\n    isPerpendicularToPlane(plane) {\r\n        assertInst(P3, plane);\r\n        return eq0(this.normal1.dot(plane.normal1));\r\n    }\r\n    toSource() {\r\n        return callsce('new P3', this.normal1, this.w);\r\n    }\r\n    translated(offset) {\r\n        return new P3(this.normal1, this.w + offset.dot(this.normal1));\r\n    }\r\n    transform(m4) {\r\n        // See https://stackoverflow.com/questions/7685495/transforming-a-3d-plane-using-a-4x4-matrix\r\n        // See http://www.songho.ca/opengl/gl_normaltransform.html\r\n        // with homogeneous coordinates, the hessian normal form of this plane is\r\n        // (p, 1) * (normal1, -w) = 0\r\n        // transformation: (m4^-1 * (p, 1)) DOT (normal1, -w) = 0\r\n        // => (p, 1) DOT ((m4^-T) * (normal1, -w)) = 0\r\n        // (validity of the above transformation is easily seen by expanding the matrix multiplication and dot product)\r\n        // hence, (newNormal, newW) = (m4^-T) * (normal1, -w)\r\n        // we divide both newNormal and newW by newNormal.length() to normalize the normal vector\r\n        const m4InversedTransposed = M4.transpose(M4.inverse(m4, M4.temp0), M4.temp1);\r\n        const [nx, ny, nz] = this.normal1;\r\n        const newNormal = m4InversedTransposed.timesVector(VV(nx, ny, nz, -this.w));\r\n        return P3.forABCD(newNormal.x, newNormal.y, newNormal.z, newNormal.w);\r\n    }\r\n    distanceToLine(line) {\r\n        assertInst(L3, line);\r\n        if (!this.isParallelToLine(line)) {\r\n            return this.distanceToPoint(line.anchor);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    containsPoint(x) {\r\n        assertVectors(x);\r\n        return eq(this.w, this.normal1.dot(x));\r\n    }\r\n    containsLine(line) {\r\n        assertInst(L3, line);\r\n        return this.containsPoint(line.anchor) && this.isParallelToLine(line);\r\n    }\r\n    distanceToPointSigned(point) {\r\n        assertInst(V3, point);\r\n        return this.normal1.dot(point) - this.w;\r\n    }\r\n    distanceToPoint(point) {\r\n        assertInst(V3, point);\r\n        return Math.abs(this.normal1.dot(point) - this.w);\r\n    }\r\n    intersectionWithLine(line) {\r\n        return line.intersectionWithPlane(this);\r\n    }\r\n    intersectionWithPlane(plane) {\r\n        assertInst(P3, plane);\r\n        /*\r\n\r\n         this: n0 * x = w0\r\n         plane: n1 * x = w1\r\n         plane perpendicular to both which goes through origin:\r\n         n2 := n0 X x1\r\n         n2 * x = 0\r\n         */\r\n        if (this.isParallelToPlane(plane)) {\r\n            return undefined;\r\n        }\r\n        /*\r\n         var n0 = this.normal1, n1 = plane.normal1, n2 = n0.cross(n1).unit(), m = M4.forSys(n0, n1, n2)\r\n         var x0 = this.anchor, x1 = plane.anchor, x2 = V3.O\r\n         var p = n2.times(x2.dot(n2))\r\n         .plus(n1.cross(n2).times(x0.dot(n0)))\r\n         .plus(n2.cross(n0).times(x1.dot(n1)))\r\n         .div(m.determinant())\r\n         */\r\n        const n0 = this.normal1, n1 = plane.normal1, n2 = n0.cross(n1).unit();\r\n        const p = M4.forRows(n0, n1, n2)\r\n            .inversed()\r\n            .transformVector(new V3(this.w, plane.w, 0));\r\n        return new L3(p, n2);\r\n    }\r\n    /**\r\n     * Returns the point in the plane closest to the given point\r\n     *\r\n     */\r\n    projectedPoint(x) {\r\n        // See http://math.stackexchange.com/questions/444968/project-a-point-in-3d-on-a-given-plane\r\n        // p = x - ((x - planeAnchor) * normal1) * normal1\r\n        return x.minus(this.normal1.times(x.minus(this.anchor).dot(this.normal1)));\r\n    }\r\n    projectedVector(x) {\r\n        // See V3.rejectedFrom. Simplified, as this.normal1.length() == 1\r\n        return x.minus(this.normal1.times(x.dot(this.normal1)));\r\n    }\r\n    flipped() {\r\n        return new P3(this.normal1.negated(), -this.w);\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.containsLine(curve);\r\n        }\r\n        else if (curve instanceof EllipseCurve || curve instanceof HyperbolaCurve || curve instanceof ParabolaCurve) {\r\n            return this.containsPoint(curve.center) && this.normal1.isParallelTo(curve.normal);\r\n        }\r\n        else if (curve instanceof BezierCurve) {\r\n            return curve.points.every(p => this.containsPoint(p));\r\n        }\r\n        else {\r\n            throw new Error('' + curve);\r\n        }\r\n    }\r\n    equals(obj) {\r\n        return hasConstructor(obj, P3) && this.normal1.equals(obj.normal1) && this.w == obj.w;\r\n    }\r\n    hashCode() {\r\n        return (this.normal1.hashCode() * 31) | (0 + floatHashCode(this.w));\r\n    }\r\n}\r\nP3.YZ = new P3(V3.X, 0);\r\nP3.ZX = new P3(V3.Y, 0);\r\nP3.XY = new P3(V3.Z, 0);\r\n//# sourceMappingURL=P3.js.map","import { callsce, eq, eq0, le, NLA_PRECISION, Transformable } from 'ts3dutils';\r\nimport { CalculateAreaVisitor, dotCurve2, ImplicitCurve, P3, PICurve, PPCurve, ZDirVolumeVisitor, } from '../index';\r\nimport { ceil, floor, PI, sign } from '../math';\r\nexport class Surface extends Transformable {\r\n    static loopContainsPointGeneral(loop, pWC, testLine, lineOut) {\r\n        const testPlane = P3.normalOnAnchor(lineOut, pWC);\r\n        // edges colinear to the testing line; these will always be counted as \"inside\" relative to the testing line\r\n        const colinearEdges = loop.map(edge => edge.colinearToLine(testLine));\r\n        let inside = false;\r\n        function logIS(isP) {\r\n            const isT = testLine.pointT(isP);\r\n            if (eq0(isT)) {\r\n                return true;\r\n            }\r\n            else if (isT > 0) {\r\n                inside = !inside;\r\n            }\r\n            return false;\r\n        }\r\n        for (let edgeIndex = 0; edgeIndex < loop.length; edgeIndex++) {\r\n            const edge = loop[edgeIndex];\r\n            const nextEdgeIndex = (edgeIndex + 1) % loop.length, nextEdge = loop[nextEdgeIndex];\r\n            //console.log(edge.toSource()) {p:V(2, -2.102, 0),\r\n            if (colinearEdges[edgeIndex]) {\r\n                const lineAT = testLine.pointT(edge.a), lineBT = testLine.pointT(edge.b);\r\n                if (Math.min(lineAT, lineBT) <= NLA_PRECISION && -NLA_PRECISION <= Math.max(lineAT, lineBT)) {\r\n                    return PointVsFace.ON_EDGE;\r\n                }\r\n                // edge colinear to intersection\r\n                const nextInside = colinearEdges[nextEdgeIndex] ||\r\n                    dotCurve2(nextEdge.curve, nextEdge.aT, lineOut, sign(nextEdge.deltaT())) < 0;\r\n                if (!nextInside) {\r\n                    if (logIS(edge.b))\r\n                        return PointVsFace.ON_EDGE;\r\n                }\r\n            }\r\n            else {\r\n                for (const edgeT of edge.edgeISTsWithPlane(testPlane)) {\r\n                    if (edgeT == edge.bT) {\r\n                        if (!testLine.containsPoint(edge.b))\r\n                            continue;\r\n                        // endpoint lies on intersection line\r\n                        if (edge.b.like(pWC)) {\r\n                            // TODO: refactor, dont check for different sides, just logIs everything\r\n                            return PointVsFace.ON_EDGE;\r\n                        }\r\n                        const edgeInside = dotCurve2(edge.curve, edge.bT, lineOut, -sign(edge.deltaT())) < 0;\r\n                        const nextInside = colinearEdges[nextEdgeIndex] ||\r\n                            dotCurve2(nextEdge.curve, nextEdge.aT, lineOut, sign(nextEdge.deltaT())) < 0;\r\n                        if (edgeInside != nextInside) {\r\n                            if (logIS(edge.b))\r\n                                return PointVsFace.ON_EDGE;\r\n                        }\r\n                    }\r\n                    else if (edgeT != edge.aT) {\r\n                        const p = edge.curve.at(edgeT);\r\n                        if (!testLine.containsPoint(p))\r\n                            continue;\r\n                        // edge crosses line, neither starts nor ends on it\r\n                        if (logIS(p))\r\n                            return PointVsFace.ON_EDGE;\r\n                        // TODO: tangents?\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return inside ? PointVsFace.INSIDE : PointVsFace.OUTSIDE;\r\n    }\r\n    static loopContainsPointEllipse(loop, pWC, testLine, pWCT) {\r\n        const lineOut = testLine.normal;\r\n        const testPlane = P3.normalOnAnchor(testLine.normal, pWC);\r\n        const colinearEdges = loop.map(edge => testLine.isColinearTo(edge.curve));\r\n        let inside = false;\r\n        if (undefined === pWCT) {\r\n            pWCT = testLine.pointT(pWC);\r\n        }\r\n        const pT = pWCT;\r\n        function logIS(isP) {\r\n            const isT = testLine.pointT(isP);\r\n            if (eq(pT, isT)) {\r\n                return true;\r\n            }\r\n            else if (pT < isT && le(isT, PI)) {\r\n                inside = !inside;\r\n            }\r\n            return false;\r\n        }\r\n        for (let edgeIndex = 0; edgeIndex < loop.length; edgeIndex++) {\r\n            const edge = loop[edgeIndex];\r\n            const nextEdgeIndex = (edgeIndex + 1) % loop.length, nextEdge = loop[nextEdgeIndex];\r\n            //console.log(edge.toSource()) {p:V(2, -2.102, 0),\r\n            if (colinearEdges[edgeIndex]) {\r\n                let edgeT;\r\n                if (edge.curve.containsPoint(pWC) &&\r\n                    le(edge.minT, (edgeT = edge.curve.pointT(pWC))) &&\r\n                    le(edgeT, edge.maxT)) {\r\n                    return PointVsFace.ON_EDGE;\r\n                }\r\n                // edge colinear to intersection\r\n                const nextInside = colinearEdges[nextEdgeIndex] ||\r\n                    dotCurve2(nextEdge.curve, nextEdge.aT, lineOut, sign(nextEdge.deltaT())) < 0;\r\n                if (!nextInside && testLine.containsPoint(edge.b)) {\r\n                    if (logIS(edge.b))\r\n                        return PointVsFace.ON_EDGE;\r\n                }\r\n            }\r\n            else {\r\n                for (const edgeT of edge.edgeISTsWithPlane(testPlane)) {\r\n                    if (edgeT == edge.bT) {\r\n                        if (!testLine.containsPoint(edge.b))\r\n                            continue;\r\n                        // endpoint lies on intersection testLine\r\n                        const edgeInside = dotCurve2(edge.curve, edge.bT, lineOut, -sign(edge.deltaT())) < 0;\r\n                        const nextInside = colinearEdges[nextEdgeIndex] ||\r\n                            dotCurve2(nextEdge.curve, nextEdge.aT, lineOut, sign(nextEdge.deltaT())) < 0;\r\n                        if (edgeInside != nextInside) {\r\n                            if (logIS(edge.b))\r\n                                return PointVsFace.ON_EDGE;\r\n                        }\r\n                    }\r\n                    else if (edgeT != edge.aT) {\r\n                        const p = edge.curve.at(edgeT);\r\n                        if (!testLine.containsPoint(p))\r\n                            continue;\r\n                        // edge crosses testLine, neither starts nor ends on it\r\n                        if (logIS(p))\r\n                            return PointVsFace.ON_EDGE;\r\n                        // TODO: tangents?\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return inside ? PointVsFace.INSIDE : PointVsFace.OUTSIDE;\r\n    }\r\n    toString() {\r\n        return this.toSource();\r\n    }\r\n    toSource(rounder = x => x) {\r\n        return callsce.call(undefined, 'new ' + this.constructor.name, ...this.getConstructorParameters());\r\n    }\r\n    /**\r\n     * Return points which would touch AABB. Doesnt include borders due to paramtetric bounds, for example.\r\n     */\r\n    getExtremePoints() {\r\n        return [];\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        return surface.isCurvesWithSurface(this); //.map(curve => curve.reversed())\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof PICurve) {\r\n            // if (this.equals(curve.parametricSurface) || this.equals(curve.implicitSurface)) {\r\n            // \treturn true\r\n            // }\r\n        }\r\n        if (curve instanceof PPCurve) {\r\n            if (this.equals(curve.parametricSurface1) || this.equals(curve.parametricSurface2)) {\r\n                return true;\r\n            }\r\n        }\r\n        if (curve instanceof ImplicitCurve) {\r\n            for (let i = ceil(curve.tMin) + 1; i <= floor(curve.tMax) - 1; i++) {\r\n                if (!this.containsPoint(curve.points[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    flipped2(doFlip) {\r\n        return doFlip ? this.flipped() : this;\r\n    }\r\n    clipCurves(curves) {\r\n        return curves;\r\n    }\r\n    equals(obj) {\r\n        return (this === obj ||\r\n            (this.constructor === obj.constructor &&\r\n                this.getConstructorParameters().equals(obj.getConstructorParameters())));\r\n    }\r\n    hashCode() {\r\n        return this.getConstructorParameters().hashCode();\r\n    }\r\n    zDirVolume(allEdges) {\r\n        return this.visit(ZDirVolumeVisitor, allEdges);\r\n    }\r\n    calculateArea(allEdges) {\r\n        return this.visit(CalculateAreaVisitor, allEdges);\r\n    }\r\n}\r\nexport var PointVsFace;\r\n(function (PointVsFace) {\r\n    PointVsFace[PointVsFace[\"INSIDE\"] = 0] = \"INSIDE\";\r\n    PointVsFace[PointVsFace[\"OUTSIDE\"] = 1] = \"OUTSIDE\";\r\n    PointVsFace[PointVsFace[\"ON_EDGE\"] = 2] = \"ON_EDGE\";\r\n})(PointVsFace || (PointVsFace = {}));\r\nexport class ImplicitSurface extends Surface {\r\n    static is(obj) {\r\n        return obj.implicitFunction && obj.didp;\r\n    }\r\n}\r\n//# sourceMappingURL=Surface.js.map","import { AABB, assert, assertNumbers, between, isCCW, lerp, V, V3 } from 'ts3dutils';\r\nimport { Mesh } from 'tsgl';\r\nimport { breakDownPPCurves, Curve, MathFunctionR2R, PICurve, Surface } from '../index';\r\nimport { ceil, min } from '../math';\r\nexport class ParametricSurface extends Surface {\r\n    constructor(uMin, uMax, vMin, vMax) {\r\n        super();\r\n        this.uMin = uMin;\r\n        this.uMax = uMax;\r\n        this.vMin = vMin;\r\n        this.vMax = vMax;\r\n        assertNumbers(uMin, uMax, vMin, vMax);\r\n        assert(uMin < uMax);\r\n        assert(vMin < vMax);\r\n        assert((x => x[x.length - 4])(this.getConstructorParameters()) == this.uMin, this.getConstructorParameters(), this.uMin);\r\n    }\r\n    static isCurvesParametricImplicitSurface(ps, is, uStep, vStep = uStep, curveStepSize) {\r\n        const pf = ps.pUVFunc(), icc = is.implicitFunction();\r\n        const dpdu = ps.dpdu();\r\n        const dpdv = ps.dpdv();\r\n        const didp = is.didp.bind(is);\r\n        const ist = (x, y) => icc(pf(x, y));\r\n        const didu = (u, v) => didp(pf(u, v)).dot(dpdu(u, v));\r\n        const didv = (u, v) => didp(pf(u, v)).dot(dpdv(u, v));\r\n        const mf = MathFunctionR2R.forFFxFy(ist, didu, didv);\r\n        const curves = Curve.breakDownIC(mf, ps, uStep, vStep, curveStepSize, (u, v) => is.containsPoint(pf(u, v))).map(({ points, tangents }, i) => PICurve.forParametricPointsTangents(ps, is, points, tangents, curveStepSize));\r\n        return curves;\r\n    }\r\n    static isCurvesParametricParametricSurface(ps1, ps2, s1Step, t1Step = s1Step, curveStepSize) {\r\n        return breakDownPPCurves(ps1, ps2, s1Step, t1Step, curveStepSize);\r\n    }\r\n    static is(obj) {\r\n        return obj.pUVFunc;\r\n    }\r\n    pUV(u, v) {\r\n        return this.pUVFunc()(u, v);\r\n    }\r\n    pUVFunc() {\r\n        return this.pUV.bind(this);\r\n    }\r\n    uvP(pWC) {\r\n        return this.uvPFunc()(pWC);\r\n    }\r\n    uvPFunc() {\r\n        return this.uvP.bind(this);\r\n    }\r\n    bounds(u, v) {\r\n        return this.uMin <= u && u <= this.uMax && this.vMin <= v && v <= this.vMax;\r\n    }\r\n    /**\r\n     * Positive values are inside bounds.\r\n     */\r\n    boundsSigned(u, v) {\r\n        return min(u - this.uMin, this.uMax - u, v - this.vMin, this.vMax - v);\r\n    }\r\n    normalP(p) {\r\n        const pmPoint = this.uvPFunc()(p);\r\n        return this.normalUV(pmPoint.x, pmPoint.y);\r\n    }\r\n    normalUVFunc() {\r\n        return this.normalUV.bind(this);\r\n    }\r\n    normalUV(u, v) {\r\n        return this.normalUVFunc()(u, v);\r\n    }\r\n    parametersValid(u, v) {\r\n        return between(u, this.uMin, this.uMax) && between(v, this.vMin, this.vMax);\r\n    }\r\n    toMesh(uStep = this.uStep, vStep = this.vStep) {\r\n        assert(isFinite(this.vMin) && isFinite(this.vMax) && isFinite(this.uMin) && isFinite(this.uMax));\r\n        assert(isFinite(uStep) && isFinite(vStep));\r\n        return Mesh.parametric(this.pUVFunc(), this.normalUVFunc(), this.uMin, this.uMax, this.vMin, this.vMax, ceil((this.uMax - this.uMin) / uStep), ceil((this.vMax - this.vMin) / vStep));\r\n    }\r\n    isCurvesWithImplicitSurface(is, uStep, vStep, stepSize) {\r\n        return ParametricSurface.isCurvesParametricImplicitSurface(this, is, uStep, vStep, stepSize);\r\n    }\r\n    edgeLoopCCW(contour) {\r\n        const ptpF = this.uvPFunc();\r\n        return isCCW(contour.flatMap(e => e.getVerticesNo0()).map(v => ptpF(v)), V3.Z);\r\n    }\r\n    like(object) {\r\n        if (!this.isCoplanarTo(object))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        const pSMinTMin = this.pUVFunc()(this.uMin, this.vMin);\r\n        const thisNormal = this.normalUVFunc()(this.uMin, this.vMin);\r\n        const otherNormal = object.normalP(pSMinTMin);\r\n        return 0 < thisNormal.dot(otherNormal);\r\n    }\r\n    getApproxAABB() {\r\n        const result = new AABB();\r\n        result.addPoints(this.getExtremePoints());\r\n        const ps = [V(0, 0), V(0, 1), V(1, 0), V(1, 1), V(0.5, 0.5)].map(p => this.pUV(lerp(this.uMin, this.uMax, p.x), lerp(this.vMin, this.vMax, p.y)));\r\n        result.addPoints(ps);\r\n        return result;\r\n    }\r\n}\r\n//# sourceMappingURL=ParametricSurface.js.map","import { assert, assertInst, assertVectors, eq, eq0, getIntervals, M4, newtonIterate, pqFormula, TAU, V3, Vector, } from 'ts3dutils';\r\nimport { CylinderSurface, EllipseCurve, HyperbolaCurve, ImplicitSurface, L3, P3, ParabolaCurve, ParametricSurface, PlaneSurface, Surface, } from '../index';\r\nimport { abs, cos, max, min, PI, sign, sin, sqrt, SQRT1_2 } from '../math';\r\nexport class ConicSurface extends ParametricSurface {\r\n    /**\r\n     * returns new cone C = {apex + f1 * z * cos(d) + f2 * z * sin(d) + f3 * z | -PI <= d <= PI, 0 <= z}\r\n     * @param f1\r\n     * @param f2\r\n     * @param dir Direction in which the cone opens. The ellipse spanned by f1, f2 is contained at (apex + f1).\r\n     */\r\n    constructor(center, f1, f2, dir, uMin = 0, uMax = PI, vMin = 0, vMax = 16) {\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.center = center;\r\n        this.f1 = f1;\r\n        this.f2 = f2;\r\n        this.dir = dir;\r\n        assertVectors(center, f1, f2, dir);\r\n        assert(0 <= vMin);\r\n        this.matrix = M4.forSys(f1, f2, dir, center);\r\n        this.matrixInverse = this.matrix.inversed();\r\n        this.normalDir = sign(this.f1.cross(this.f2).dot(this.dir));\r\n        this.pLCNormalWCMatrix = this.matrix\r\n            .as3x3()\r\n            .inversed()\r\n            .transposed()\r\n            .scale(this.normalDir);\r\n    }\r\n    pointFoot(pWC, startU, startV) {\r\n        if (undefined === startU || undefined === startV) {\r\n            // similar to uvP\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            const angle = pLC.angleXY();\r\n            if (undefined === startU) {\r\n                startU = angle < -PI / 2 ? angle + TAU : angle;\r\n            }\r\n            if (undefined === startV) {\r\n                startV = pLC.z + (pLC.lengthXY() - pLC.z) * SQRT1_2;\r\n            }\r\n        }\r\n        const f = ([u, v]) => {\r\n            const pUVToPWC = this.pUV(u, v).to(pWC);\r\n            return [this.dpdu()(u, v).dot(pUVToPWC), this.dpdv()(u).dot(pUVToPWC)];\r\n        };\r\n        const { 0: x, 1: y } = newtonIterate(f, [startU, startV]);\r\n        return new V3(x, y, 0);\r\n    }\r\n    get apex() {\r\n        return this.center;\r\n    }\r\n    static atApexThroughEllipse(apex, ellipse, uMin, uMax, vMin, vMax) {\r\n        assertVectors(apex);\r\n        assertInst(EllipseCurve, ellipse);\r\n        return new ConicSurface(apex, ellipse.f1, ellipse.f2, apex.to(ellipse.center), uMin, uMax, vMin, vMax);\r\n    }\r\n    static unitISLineTs(anchor, dir) {\r\n        const { x: ax, y: ay, z: az } = anchor;\r\n        const { x: dx, y: dy, z: dz } = dir;\r\n        // this cone: x² + y² = z²\r\n        // line: p = anchor + t * dir1\r\n        // split line equation into 3 component equations, insert into cone equation\r\n        // transform to form (a t² + b t + c = 0) and solve with pqFormula\r\n        const a = dx * dx + dy * dy - dz * dz;\r\n        const b = 2 * (ax * dx + ay * dy - az * dz);\r\n        const c = ax * ax + ay * ay - az * az;\r\n        // cone only defined for 0 <= z, so filter invalid values\r\n        return pqFormula(b / a, c / a).filter(t => 0 < az + t * dz);\r\n    }\r\n    // calculate intersection of plane ax + cz = d and cone x² + y² = z²\r\n    static unitISPlane(a, c, d) {\r\n        if (eq0(c)) {\r\n            // plane is \"vertical\", i.e. parallel to Y and Z axes\r\n            assert(!eq0(a)); // normal would be zero, which is invalid\r\n            // z² - y² = d²/a²\r\n            if (eq0(d)) {\r\n                // d = 0 => z² - y² = 0 => z² = y² => z = y\r\n                // plane goes through origin/V3.O\r\n                return [\r\n                    new L3(V3.O, new V3(0, -SQRT1_2, -SQRT1_2), undefined, 0),\r\n                    new L3(V3.O, new V3(0, -SQRT1_2, SQRT1_2), 0),\r\n                ];\r\n            }\r\n            else {\r\n                // hyperbola\r\n                const center = new V3(d / a, 0, 0);\r\n                const f1 = new V3(0, 0, abs(d / a)); // abs, because we always want the hyperbola to be pointing up\r\n                const f2 = new V3(0, d / a, 0);\r\n                return [new HyperbolaCurve(center, f1, f2)];\r\n            }\r\n        }\r\n        else {\r\n            // c != 0\r\n            const aa = a * a, cc = c * c;\r\n            if (eq0(d)) {\r\n                // ax + cz = d => x = d - cz / a => x² = d² - 2cdz/a + c²z²/a²\r\n                // x² + y² = z²\r\n                // => d² - 2cdz/a + c²z²/a² + y² = z²\r\n                if (eq(aa, cc)) {\r\n                    return [new L3(V3.O, new V3(c, 0, -a).unit())];\r\n                }\r\n                else if (aa < cc) {\r\n                    throw new Error('intersection is single point V3.O');\r\n                }\r\n                else if (aa > cc) {\r\n                    return [\r\n                        new L3(V3.O, new V3(c, sqrt(aa - cc), -a).unit()),\r\n                        new L3(V3.O, new V3(c, -sqrt(aa - cc), -a).unit()),\r\n                    ];\r\n                }\r\n            }\r\n            else {\r\n                if (eq(aa, cc)) {\r\n                    // parabola\r\n                    const parabolaVertex = new V3(d / 2 / a, 0, d / 2 / c);\r\n                    const parabolaVertexTangentPoint = new V3(d / 2 / a, d / c, d / 2 / c);\r\n                    const p2 = new V3(0, 0, d / c);\r\n                    const f2 = p2.minus(parabolaVertex);\r\n                    return [\r\n                        new ParabolaCurve(parabolaVertex, parabolaVertexTangentPoint.minus(parabolaVertex), f2.z < 0 ? f2.negated() : f2),\r\n                    ];\r\n                }\r\n                else if (aa < cc) {\r\n                    // ellipse\r\n                    const center = new V3(-a * d / (cc - aa), 0, d * c / (cc - aa));\r\n                    if (center.z < 0) {\r\n                        return [];\r\n                    }\r\n                    const p1 = new V3(d / (a - c), 0, -d / (a - c));\r\n                    const p2 = new V3(-a * d / (cc - aa), d / sqrt(cc - aa), d * c / (cc - aa));\r\n                    return [new EllipseCurve(center, center.to(p1), center.to(p2), -PI, PI)];\r\n                }\r\n                else if (aa > cc) {\r\n                    // hyperbola\r\n                    const center = new V3(-a * d / (cc - aa), 0, d * c / (cc - aa));\r\n                    // const p1 = new V3(d / (a - c), 0, -d / (a - c))\r\n                    // const p2 = new V3(-a * d / (cc - aa), d / sqrt(aa - cc), d * c / (cc - aa))\r\n                    // const f1 = center.to(p1)\r\n                    const f1 = new V3(d * c / (aa - cc), 0, -d * a / (aa - cc));\r\n                    const f2 = new V3(0, d / sqrt(aa - cc), 0);\r\n                    return [new HyperbolaCurve(center, f1.z > 0 ? f1 : f1.negated(), f2)];\r\n                }\r\n            }\r\n        }\r\n        throw new Error('???');\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (Object.getPrototypeOf(this) == Object.getPrototypeOf(obj) &&\r\n                this.center.equals(obj.center) &&\r\n                this.f1.equals(obj.f1) &&\r\n                this.f2.equals(obj.f2) &&\r\n                this.dir.equals(obj.dir)));\r\n    }\r\n    like(object) {\r\n        if (!this.isCoplanarTo(object))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        return this.normalDir == object.normalDir;\r\n    }\r\n    getVectors() {\r\n        return [\r\n            { anchor: this.center, dir1: this.dir },\r\n            { anchor: this.center.plus(this.dir), dir1: this.f1 },\r\n            { anchor: this.center.plus(this.dir), dir1: this.f2 },\r\n        ];\r\n    }\r\n    getSeamPlane() {\r\n        return P3.forAnchorAndPlaneVectors(this.center, this.f1, this.dir);\r\n    }\r\n    loopContainsPoint(contour, p) {\r\n        assertVectors(p);\r\n        const line = this.center.like(p)\r\n            ? new L3(p, this.matrix.transformVector(new V3(0, 1, 1)).unit())\r\n            : L3.throughPoints(p, this.apex);\r\n        const lineOut = line.dir1.cross(this.dir);\r\n        return Surface.loopContainsPointGeneral(contour, p, line, lineOut);\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.center, this.f1, this.f2, this.dir, this.uMin, this.uMax, this.vMin, this.vMax];\r\n    }\r\n    isTsForLine(line) {\r\n        // transforming line manually has advantage that dir1 will not be renormalized,\r\n        // meaning that calculated values t for lineLC are directly transferable to line\r\n        const anchorLC = this.matrixInverse.transformPoint(line.anchor);\r\n        const dirLC = this.matrixInverse.transformVector(line.dir1);\r\n        return ConicSurface.unitISLineTs(anchorLC, dirLC);\r\n    }\r\n    /**\r\n     * Interestingly, two cones don't need to have parallel dirs to be coplanar.\r\n     */\r\n    isCoplanarTo(surface) {\r\n        if (this === surface)\r\n            return true;\r\n        if (!(surface instanceof ConicSurface) || !this.apex.like(surface.apex))\r\n            return false;\r\n        // at this point apexes are equal\r\n        return this.containsEllipse(new EllipseCurve(surface.center.plus(surface.dir), surface.f1, surface.f2));\r\n    }\r\n    containsEllipse(ellipse) {\r\n        const ellipseLC = ellipse.transform(this.matrixInverse);\r\n        if (ellipseLC.center.z < 0) {\r\n            return false;\r\n        }\r\n        const { f1, f2 } = ellipseLC.rightAngled();\r\n        const p1 = ellipseLC.center.plus(f1), p2 = ellipseLC.center.plus(f2);\r\n        // check if both endpoints are on the cone's surface\r\n        // and that one main axis is perpendicular to the Z-axis\r\n        return eq(Math.pow(p1.x, 2) + Math.pow(p1.y, 2), Math.pow(p1.z, 2)) && eq(Math.pow(p2.x, 2) + Math.pow(p2.y, 2), Math.pow(p2.z, 2)) && (eq0(f1.z) || eq0(f2.z));\r\n    }\r\n    containsLine(line) {\r\n        const lineLC = line.transform(this.matrixInverse);\r\n        const d = lineLC.dir1;\r\n        return lineLC.containsPoint(V3.O) && eq(d.x * d.x + d.y * d.y, d.z * d.z);\r\n    }\r\n    containsParabola(curve) {\r\n        assertInst(ParabolaCurve, curve);\r\n        const curveLC = curve.transform(this.matrixInverse);\r\n        if (curveLC.center.z < 0 || curveLC.f2.z < 0) {\r\n            return false;\r\n        }\r\n        const { center, f1, f2 } = curveLC.rightAngled();\r\n        // check if center is on the surface,\r\n        // that tangent is perpendicular to the Z-axis\r\n        // and that \"y\" axis is parallel to surface\r\n        return (eq(center.x * center.x + center.y * center.y, center.z * center.z) &&\r\n            eq0(f1.z) &&\r\n            eq(f2.x * f2.x + f2.y * f2.y, f2.z * f2.z));\r\n    }\r\n    containsHyperbola(curve) {\r\n        // calculate intersection of plane ax + cz = 1 and cone x² + y² = z²\r\n        // const center = new V3(-a / (cc - aa), 0, 1 / (cc - aa))\r\n        // const p1 = new V3(1 / (a - c), 0, -1 / (a - c))\r\n        // const p2 = new V3(-a / (cc - aa), 1 / sqrt(aa - cc), 1 / (cc - aa))\r\n        // const f1 = new V3(1 * c / (aa - cc), 0, -a / (aa - cc) )\r\n        // const f2 = new V3(0, 1 / sqrt(aa - cc), 0)\r\n        assertInst(HyperbolaCurve, curve);\r\n        const curveLC = curve.transform(this.matrixInverse).rightAngled();\r\n        const centerXY = curveLC.center.xy();\r\n        if (centerXY.likeO()) {\r\n            return false;\r\n        }\r\n        const rot = centerXY.angleXY();\r\n        const { center, f1, f2 } = curveLC.rotateZ(-rot);\r\n        // s = a / (aa - cc)\r\n        // t = -c / (aa - cc)\r\n        // s + t = 1 / (a + c)\r\n        // s - t = 1 / (a - c)\r\n        // (s + t)(s - t) = (ss - tt) = 1 / (aa - cc)\r\n        // u = 1 / sqrt(aa - cc) = sqrt(ss - tt)\r\n        // check if center is on the surface,\r\n        // that tangent is perpendicular to the Z-axis\r\n        return (f1.z > 0 &&\r\n            eq(center.x, f1.z) &&\r\n            eq(center.z, f1.x) &&\r\n            eq0(center.y) &&\r\n            eq0(f1.y) &&\r\n            eq(sqrt(abs(Math.pow(center.x, 2) - Math.pow(center.z, 2))), abs(f2.y)) &&\r\n            eq0(f2.x) &&\r\n            eq0(f2.z));\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof EllipseCurve) {\r\n            return this.containsEllipse(curve);\r\n        }\r\n        else if (curve instanceof L3) {\r\n            return this.containsLine(curve);\r\n        }\r\n        else if (curve instanceof HyperbolaCurve) {\r\n            return this.containsHyperbola(curve);\r\n        }\r\n        else if (curve instanceof ParabolaCurve) {\r\n            return this.containsParabola(curve);\r\n        }\r\n        else {\r\n            return super.containsCurve(curve);\r\n        }\r\n    }\r\n    transform(m4) {\r\n        return new ConicSurface(m4.transformPoint(this.center), m4.transformVector(this.f1).times(m4.isMirroring() ? -1 : 1), m4.transformVector(this.f2), m4.transformVector(this.dir), this.uMin, this.uMax, this.vMin, this.vMax);\r\n    }\r\n    transform4(m4) {\r\n        const transformedApex = m4.timesVector(Vector.fromV3AndWeight(this.center, 1));\r\n        const isometricZ = (z) => new EllipseCurve(new V3(0, 0, z), new V3(z, 0, 0), new V3(0, z, 0));\r\n        if (!eq0(transformedApex.w)) {\r\n            // sMin doesn't change, but tMin does...\r\n            const c = m4.transformPoint(this.center), f1 = m4.transformVector2(this.f1, this.center).times(m4.isMirroring() ? -1 : 1), f2 = m4.transformVector2(this.f2, this.center), dir = m4.transformVector2(this.dir, this.center);\r\n            const matrixInv = M4.forSys(f1, f2, dir, c).inversed();\r\n            const aabb = isometricZ(this.vMin)\r\n                .transform4(matrixInv.times(m4.times(this.matrix)))\r\n                .getAABB()\r\n                .addAABB(isometricZ(this.vMax)\r\n                .transform4(matrixInv.times(m4.times(this.matrix)))\r\n                .getAABB());\r\n            return new ConicSurface(c, f1, f2, dir, this.uMin, this.uMax, aabb.min.z, aabb.max.z);\r\n        }\r\n        else {\r\n            const dir = transformedApex.V3();\r\n            const baseCurve = isometricZ(this.vMin).transform4(m4.times(this.matrix));\r\n            const matrixInv = M4.forSys(baseCurve.f1, baseCurve.f2, dir.unit(), baseCurve.center).inversed();\r\n            const aabb = isometricZ(this.vMax)\r\n                .transform4(matrixInv.times(m4.times(this.matrix)))\r\n                .getAABB();\r\n            return new CylinderSurface(baseCurve, dir.unit(), this.uMin, this.uMax, min(0, aabb.min.z, aabb.max.z), max(0, aabb.min.z, aabb.max.z));\r\n        }\r\n    }\r\n    flipped() {\r\n        return new ConicSurface(this.center, this.f1.negated(), this.f2, this.dir);\r\n    }\r\n    normalUVFunc() {\r\n        const { f1, f2 } = this, f3 = this.dir;\r\n        return (d, _z) => {\r\n            return f2\r\n                .cross(f1)\r\n                .plus(f2.cross(f3.times(Math.cos(d))))\r\n                .plus(f3.cross(f1.times(Math.sin(d))))\r\n                .unit();\r\n        };\r\n    }\r\n    normalP(p) {\r\n        //TODO assert(!p.like(this.center))\r\n        const pLC = this.matrixInverse.transformPoint(p);\r\n        return this.normalUVFunc()(pLC.angleXY(), pLC.z);\r\n    }\r\n    pUVFunc() {\r\n        return (u, v) => {\r\n            // center + f1 v cos u + f2 v sin u + v dir\r\n            const resultLC = new V3(v * cos(u), v * sin(u), v);\r\n            return this.matrix.transformPoint(resultLC);\r\n        };\r\n    }\r\n    dpdu() {\r\n        return (u, v) => {\r\n            const resultLC = new V3(v * -sin(u), v * cos(u), 0);\r\n            return this.matrix.transformVector(resultLC);\r\n        };\r\n    }\r\n    dpdv() {\r\n        return s => {\r\n            const resultLC = new V3(cos(s), sin(s), 1);\r\n            return this.matrix.transformVector(resultLC);\r\n        };\r\n    }\r\n    implicitFunction() {\r\n        return pWC => {\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            const radiusLC = pLC.lengthXY();\r\n            return this.normalDir * (radiusLC - pLC.z);\r\n        };\r\n    }\r\n    didp(pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        return this.pLCNormalWCMatrix.transformVector(pLC\r\n            .xy()\r\n            .unit()\r\n            .withElement('z', -1)\r\n            .times(this.normalDir));\r\n    }\r\n    containsPoint(p) {\r\n        return eq0(this.implicitFunction()(p));\r\n    }\r\n    uvP(pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const angle = pLC.angleXY();\r\n        return new V3(angle < -PI / 2 ? angle + TAU : angle, pLC.z, 0);\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface.plane);\r\n        }\r\n        else if (ImplicitSurface.is(surface)) {\r\n            return ParametricSurface.isCurvesParametricImplicitSurface(this, surface, 0.1, 0.1 / this.dir.length(), 0.02);\r\n        }\r\n        return super.isCurvesWithSurface(surface);\r\n    }\r\n    getCenterLine() {\r\n        return new L3(this.center, this.dir);\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        assertInst(P3, plane);\r\n        const planeLC = plane.transform(this.matrixInverse);\r\n        const planeNormal = planeLC.normal1;\r\n        const c = planeNormal.z;\r\n        /** \"rotate\" plane normal1 when passing to {@link ConicSurface.unitISPlane} so that\r\n         *  y-component of normal1 is 0 */\r\n        const a = planeNormal.lengthXY();\r\n        const d = planeLC.w;\r\n        // generated curves need to be rotated back before transforming to world coordinates\r\n        const rotationMatrix = M4.rotateZ(planeNormal.angleXY());\r\n        const wcMatrix = eq0(planeNormal.lengthXY()) ? this.matrix : this.matrix.times(rotationMatrix);\r\n        return ConicSurface.unitISPlane(a, c, d).flatMap(curve => {\r\n            const curveWC = curve.transform(wcMatrix);\r\n            if (curve instanceof EllipseCurve) {\r\n                const curveLC = curve.transform(rotationMatrix);\r\n                const ts = curveLC.isTsWithPlane(P3.ZX);\r\n                const intervals = getIntervals(ts, -PI, PI).filter(([a, b]) => curveLC.at((a + b) / 2).y > 0);\r\n                return intervals.flatMap(([a, b]) => curveWC.split(a, b));\r\n            }\r\n            const p = curveWC.at(0.2);\r\n            return this.normalP(p)\r\n                .cross(plane.normal1)\r\n                .dot(curveWC.tangentAt(0.2)) > 0\r\n                ? curveWC\r\n                : curveWC.reversed();\r\n        });\r\n    }\r\n    debugInfo() {\r\n        return {\r\n            ps: [this.center],\r\n            lines: [this.center, this.center.plus(this.f1), this.center.plus(this.f2), this.center.plus(this.dir)],\r\n        };\r\n    }\r\n}\r\n/**\r\n * Unit cone. x² + y² = z², 0 <= z\r\n */\r\nConicSurface.UNIT = new ConicSurface(V3.O, V3.X, V3.Y, V3.Z);\r\nConicSurface.prototype.uStep = PI / 16;\r\nConicSurface.prototype.vStep = 256;\r\n//# sourceMappingURL=ConicSurface.js.map","import { assert, assertInst, assertNumbers, assertVectors, hasConstructor, M4, V3 } from 'ts3dutils';\r\nimport { ConicSurface, Curve, EllipseCurve, EllipsoidSurface, ImplicitCurve, ImplicitSurface, L3, P3, ParametricSurface, PlaneSurface, PointProjectedSurface, Surface, } from '../index';\r\nimport { sign } from '../math';\r\n/**\r\n * Surface normal1 is (t, z) => this.baseCurve.tangentAt(t) X this.dir\r\n * Choose dir appropriately to select surface orientation.\r\n */\r\nexport class ProjectedCurveSurface extends ParametricSurface {\r\n    constructor(baseCurve, dir, uMin = baseCurve.tMin, uMax = baseCurve.tMax, vMin = -100, vMax = 100) {\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.baseCurve = baseCurve;\r\n        this.dir = dir;\r\n        assertInst(Curve, baseCurve);\r\n        assertInst(V3, dir);\r\n        assert(uMin < uMax);\r\n        assert(vMin < vMax);\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.baseCurve, this.dir, this.uMin, this.uMax, this.vMin, this.vMax];\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (Object.getPrototypeOf(this) == Object.getPrototypeOf(obj) &&\r\n                this.dir.equals(obj.dir) &&\r\n                this.baseCurve.equals(obj.baseCurve)));\r\n    }\r\n    hashCode() {\r\n        return [this.dir, this.baseCurve].hashCode();\r\n    }\r\n    containsLine(line) {\r\n        return this.dir.isParallelTo(line.dir1) && this.containsPoint(line.anchor);\r\n    }\r\n    dpdu() {\r\n        return (u, v) => this.baseCurve.tangentAt(u);\r\n    }\r\n    dpdv() {\r\n        return (u, v) => this.dir;\r\n    }\r\n    normalUV(u, v) {\r\n        return this.baseCurve\r\n            .tangentAt(u)\r\n            .cross(this.dir)\r\n            .unit();\r\n    }\r\n    pUV(u, v) {\r\n        return this.baseCurve.at(u).plus(this.dir.times(v));\r\n    }\r\n    pointFoot(pWC, ss) {\r\n        const basePlane = new P3(this.dir.unit(), 0);\r\n        const projCurve = this.baseCurve.project(basePlane);\r\n        const projPoint = basePlane.projectedPoint(pWC);\r\n        const t = projCurve.closestTToPoint(projPoint, ss, this.uMin, this.uMax);\r\n        const z = L3.pointT(this.baseCurve.at(t), this.dir, pWC);\r\n        return new V3(t, z, 0);\r\n    }\r\n    uvPFunc() {\r\n        const projPlane = new P3(this.dir.unit(), 0);\r\n        const projBaseCurve = this.baseCurve.project(projPlane);\r\n        return pWC => {\r\n            const projPoint = projPlane.projectedPoint(pWC);\r\n            assertNumbers(this.uMin);\r\n            const t = projBaseCurve.pointT(projPoint, this.uMin, this.uMax);\r\n            const z = L3.pointT(this.baseCurve.at(t), this.dir, pWC);\r\n            return new V3(t, z, 0);\r\n        };\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        assertInst(P3, plane);\r\n        if (this.dir.isPerpendicularTo(plane.normal1)) {\r\n            const ts = this.baseCurve.isTsWithPlane(plane);\r\n            return ts.map(t => {\r\n                const l3dir = 0 < this.baseCurve.tangentAt(t).dot(plane.normal1) ? this.dir : this.dir.negated();\r\n                return new L3(this.baseCurve.at(t), l3dir.unit());\r\n            });\r\n        }\r\n        else {\r\n            let projCurve = this.baseCurve.transform(M4.project(plane, this.dir));\r\n            if (this.dir.dot(plane.normal1) > 0) {\r\n                // we need to flip the ellipse so the tangent is correct\r\n                projCurve = projCurve.reversed();\r\n            }\r\n            return [projCurve];\r\n        }\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface.plane);\r\n        }\r\n        if (surface instanceof ProjectedCurveSurface) {\r\n            const dir1 = surface.dir;\r\n            if (this.dir.isParallelTo(dir1)) {\r\n                const ts = surface.baseCurve.isTsWithSurface(this);\r\n                return ts.map(t => {\r\n                    const p = surface.baseCurve.at(t);\r\n                    const correctDir = this.normalP(p).cross(surface.normalP(p));\r\n                    return new L3(p, dir1.times(sign(correctDir.dot(dir1))));\r\n                });\r\n            }\r\n            else if (ImplicitSurface.is(surface)) {\r\n                let curves2 = ParametricSurface.isCurvesParametricImplicitSurface(this, surface, 0.1, 0.1 / surface.dir.length(), 0.05);\r\n                curves2 = surface.clipCurves(curves2);\r\n                return curves2;\r\n            }\r\n            else {\r\n                let curves2 = ParametricSurface.isCurvesParametricParametricSurface(this, surface, 0.05, 0.1 / surface.dir.length(), 0.05);\r\n                curves2 = this.clipCurves(curves2);\r\n                curves2 = surface.clipCurves(curves2);\r\n                return curves2;\r\n            }\r\n        }\r\n        if (surface instanceof EllipsoidSurface) {\r\n            return surface.isCurvesWithSurface(this);\r\n        }\r\n        return super.isCurvesWithSurface(surface);\r\n    }\r\n    containsPoint(pWC) {\r\n        const uv = this.uvPFunc()(pWC);\r\n        return this.pUVFunc()(uv.x, uv.y).like(pWC);\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.dir.isParallelTo(curve.dir1) && this.containsPoint(curve.anchor);\r\n        }\r\n        if (curve instanceof ImplicitCurve) {\r\n            return super.containsCurve(curve);\r\n        }\r\n        // project baseCurve and test curve onto a common plane and check if the curves are alike\r\n        const projPlane = new P3(this.dir.unit(), 0);\r\n        const projBaseCurve = this.baseCurve.project(projPlane);\r\n        const projCurve = curve.project(projPlane);\r\n        return projBaseCurve.isColinearTo(projCurve);\r\n    }\r\n    isCoplanarTo(surface) {\r\n        return (this == surface ||\r\n            (hasConstructor(surface, ProjectedCurveSurface) &&\r\n                this.dir.isParallelTo(surface.dir) &&\r\n                this.containsCurve(surface.baseCurve)));\r\n    }\r\n    like(object) {\r\n        if (!this.isCoplanarTo(object))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        const p00 = this.pUVFunc()(0, 0);\r\n        const thisNormal = this.normalUVFunc()(0, 0);\r\n        const otherNormal = object.normalP(p00);\r\n        return 0 < thisNormal.dot(otherNormal);\r\n    }\r\n    loopContainsPoint(loop, p) {\r\n        assertVectors(p);\r\n        assert(isFinite(p.x), p.y, p.z);\r\n        const line = new L3(p, this.dir.unit());\r\n        const ptpf = this.uvPFunc();\r\n        const pp = ptpf(p);\r\n        if (isNaN(pp.x)) {\r\n            console.log(this.sce, p.sce);\r\n            assert(false);\r\n        }\r\n        const lineOut = this.baseCurve.tangentAt(pp.x).rejectedFrom(this.dir);\r\n        return Surface.loopContainsPointGeneral(loop, p, line, lineOut);\r\n    }\r\n    transform(m4) {\r\n        const f = m4.isMirroring() ? -1 : 1;\r\n        return new this.constructor(this.baseCurve.transform(m4), m4.transformVector(this.dir).times(f), this.uMin, this.uMax, 1 == f ? this.vMin : -this.vMax, 1 == f ? this.vMax : -this.vMin);\r\n    }\r\n    transform4(m4) {\r\n        const vp = m4.vanishingPoint(this.dir);\r\n        if (!vp) {\r\n            const f = m4.isMirroring() ? -1 : 1;\r\n            return new this.constructor(this.baseCurve.transform4(m4), m4\r\n                .normalized()\r\n                .transformVector(this.dir)\r\n                .times(f), undefined, undefined, 1 == f ? this.tMin : -this.tMax, 1 == f ? this.tMax : -this.tMin);\r\n        }\r\n        const curveT = this.baseCurve.transform4(m4);\r\n        if (curveT instanceof EllipseCurve) {\r\n            console.log(vp.sce, curveT.sce);\r\n            return ConicSurface.atApexThroughEllipse(vp, m4.isMirroring() ? curveT : curveT.reversed(), this.sMin, this.sMax, 1, 2);\r\n        }\r\n        return new PointProjectedSurface(curveT, vp, P3.throughPoints(curveT.at(curveT.tMin), curveT.at((curveT.tMin + curveT.tMax) / 2), curveT.at(curveT.tMax)), 1, this.sMin, this.sMax, 1, 2);\r\n    }\r\n    isTsForLine(line) {\r\n        assertInst(L3, line);\r\n        const projPlane = new P3(this.dir.unit(), 0);\r\n        const projDir = projPlane.projectedVector(line.dir1);\r\n        if (projDir.likeO()) {\r\n            // line is parallel to this.dir\r\n            return [];\r\n        }\r\n        const projAnchor = projPlane.projectedPoint(line.anchor);\r\n        const projBaseCurve = this.baseCurve.project(projPlane);\r\n        return projBaseCurve\r\n            .isInfosWithLine(projAnchor, projDir, this.uMin, this.uMax, line.tMin, line.tMax)\r\n            .map(info => info.tOther);\r\n    }\r\n    flipped() {\r\n        return new this.constructor(this.baseCurve, this.dir.negated(), this.uMin, this.uMax, -this.vMax, -this.vMin);\r\n    }\r\n}\r\nProjectedCurveSurface.prototype.uStep = 1 / 128;\r\nProjectedCurveSurface.prototype.vStep = 256;\r\n//# sourceMappingURL=ProjectedCurveSurface.js.map","import { assert, assertInst, DEG, eq0, fuzzyBetween, hasConstructor, lerp, lt, M4, V3, VV } from 'ts3dutils';\r\nimport { EllipseCurve, HyperbolaCurve, intersectionUnitCircleLine2, L3, NURBS, NURBSSurface, P3, ParametricSurface, PlaneSurface, Surface, } from '../index';\r\nimport { abs, cos, PI, sin } from '../math';\r\n/**\r\n * Rotation surface with r = f(z)\r\n */\r\nexport class RotatedCurveSurface extends ParametricSurface {\r\n    constructor(curve, matrix = M4.IDENTITY, uMin = 0, uMax = PI, vMin = curve.tMin, vMax = curve.tMax) {\r\n        // d/dz (r(z))\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.curve = curve;\r\n        this.matrix = matrix;\r\n        assertInst(M4, matrix);\r\n        assert(matrix.isNoProj());\r\n        assert(eq0(curve.at(vMin).y));\r\n        this.matrixInverse = matrix.inversed();\r\n        this.vStep = this.curve.tIncrement;\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.curve, this.matrix, this.uMin, this.uMax, this.vMin, this.vMax];\r\n    }\r\n    flipped() {\r\n        return new RotatedCurveSurface(this.curve, this.matrix.times(M4.mirror(P3.YZ)), this.uMin, this.uMax, this.vMin, this.vMax);\r\n    }\r\n    transform(m4) {\r\n        return new RotatedCurveSurface(this.curve, m4.isMirroring() ? m4.times(this.matrix).times(M4.mirror(P3.YZ)) : m4.times(this.matrix), this.uMin, this.uMax, this.vMin, this.vMax);\r\n    }\r\n    containsPoint(pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const radius = pLC.lengthXY();\r\n        return this.curve.containsPoint(new V3(radius, 0, pLC.z));\r\n    }\r\n    pUVFunc() {\r\n        return (u, v) => {\r\n            const { x: radius, z: z } = this.curve.at(v);\r\n            return this.matrix.transformPoint(V3.polar(radius, u, z));\r\n        };\r\n    }\r\n    dpdu() {\r\n        return (u, v) => {\r\n            const radius = this.curve.at(v).x;\r\n            const resultLC = new V3(radius * -sin(u), radius * cos(u), 0);\r\n            return this.matrix.transformVector(resultLC);\r\n        };\r\n    }\r\n    dpdv() {\r\n        return (u, v) => {\r\n            const { x: drdt, z: dzdt } = this.curve.tangentAt(v);\r\n            return this.matrix.transformVector(V3.polar(drdt, u, dzdt));\r\n        };\r\n    }\r\n    normalUVFunc() {\r\n        const matrix = this.matrix\r\n            .inversed()\r\n            .transposed()\r\n            .as3x3();\r\n        const normalLength = this.matrix.isMirroring() ? -1 : 1;\r\n        return (u, v) => {\r\n            const { x: drdt, z: dzdt } = this.curve.tangentAt(v);\r\n            return matrix.transformVector(V3.polar(dzdt, u, -drdt)).toLength(normalLength);\r\n        };\r\n    }\r\n    uvPFunc() {\r\n        return pWC => {\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            const angle = EllipseCurve.XYLCPointT(pLC, this.uMin, this.uMax);\r\n            const radius = pLC.lengthXY();\r\n            return new V3(angle, this.curve.pointT(new V3(radius, 0, pLC.z)), 0);\r\n        };\r\n    }\r\n    pointFoot(pWC, startS, startT) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const angle = abs(pLC.angleXY());\r\n        const radius = pLC.lengthXY();\r\n        return new V3(angle, this.curve.closestTToPoint(new V3(radius, 0, pLC.z)), 0);\r\n    }\r\n    isTsForLine(line) {\r\n        const anchorLC = this.matrixInverse.transformPoint(line.anchor);\r\n        const dirLC = this.matrixInverse.transformVector(line.dir1);\r\n        if (dirLC.isParallelTo(V3.Z)) {\r\n            if (!fuzzyBetween(anchorLC.angleXY(), this.uMin, this.uMax))\r\n                return [];\r\n            return this.curve\r\n                .isInfosWithLine(new V3(anchorLC.lengthXY(), 0, anchorLC.z), dirLC)\r\n                .map(info => info.tOther);\r\n        }\r\n        else if (L3.containsPoint(anchorLC.xy(), dirLC.xy(), V3.O)) {\r\n            // line goes through Z axis\r\n            const dotter = dirLC.xy().unit();\r\n            return [\r\n                ...this.curve.isInfosWithLine(new V3(dotter.dot(anchorLC), 0, anchorLC.z), new V3(dotter.dot(dirLC), 0, dirLC.z)),\r\n                ...this.curve.isInfosWithLine(new V3(-dotter.dot(anchorLC), 0, anchorLC.z), new V3(-dotter.dot(dirLC), 0, dirLC.z)),\r\n            ]\r\n                .map(info => info.tOther)\r\n                .filter(t => fuzzyBetween(L3.at(anchorLC, dirLC, t).angleXY(), this.uMin, this.uMax));\r\n        }\r\n        else if (dirLC.isPerpendicularTo(V3.Z)) {\r\n            const secs = this.isCurvesWithPlaneLC(new P3(V3.Z, anchorLC.z));\r\n            if (!secs)\r\n                return [];\r\n            return secs.flatMap(sec => sec.isInfosWithLine(anchorLC, dirLC).map(info => info.tOther));\r\n        }\r\n        else {\r\n            // transform into hyperbola\r\n            // f(t) = V(((ax + t dx)² + (ay + t dy)²) ** 1/2, 0, az + t dz)\r\n            // f(t) = V((ax² + 2 ax t dx + t² dx² + ay² + 2 ay t dy + t² dy²) ** 1/2, 0, az + t dz)\r\n            // f(t) = V((t² (dx² + dy²) + 2 t (ax dx + ay dy) + ax² + ay²) ** 1/2, 0, az + t * dz)\r\n            // (anchorLC.xy + t * dirLC.xy) * dir.xy = 0\r\n            // t * dirLC.xy² = -anchorLC.xy * dirLC.xy\r\n            const closestTToZ = -anchorLC.xy().dot(dirLC.xy()) / dirLC.xy().squared();\r\n            const closestPointToZ = L3.at(anchorLC, dirLC, closestTToZ);\r\n            const scaleX = closestPointToZ.lengthXY();\r\n            const lineGradientWC = dirLC.z / dirLC.lengthXY();\r\n            const scaleZ = scaleX * lineGradientWC;\r\n            const hc = HyperbolaCurve.XY.transform(M4.rotateX(90 * DEG)\r\n                .scale(scaleX, 0, scaleZ)\r\n                .translate(0, 0, closestPointToZ.z));\r\n            const infos = hc.isInfosWithCurve(this.curve);\r\n            return infos\r\n                .map(info => (info.p.z - anchorLC.z) / dirLC.z)\r\n                .filter(t => fuzzyBetween(L3.at(anchorLC, dirLC, t).angleXY(), this.uMin, this.uMax));\r\n        }\r\n    }\r\n    isCurvesWithPlaneLC(planeLC) {\r\n        if (planeLC.normal1.isParallelTo(V3.Z)) {\r\n            return this.curve.isTsWithPlane(planeLC).map(t => {\r\n                const { x: radius } = this.curve.at(t);\r\n                return new EllipseCurve(new V3(0, 0, planeLC.w), new V3(radius, 0, 0), new V3(0, radius, 0), this.uMin, this.uMax).transform(this.matrix);\r\n            });\r\n        }\r\n        else if (planeLC.normal1.isPerpendicularTo(V3.Z) && planeLC.containsPoint(V3.O)) {\r\n            return [this.curve.rotateZ(V3.Y.angleRelativeNormal(planeLC.normal1, V3.Z)).transform(this.matrix)];\r\n        }\r\n        return undefined;\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        const planeLC = plane.transform(this.matrixInverse);\r\n        const planeLCCurves = this.isCurvesWithPlaneLC(planeLC);\r\n        if (planeLCCurves) {\r\n            return planeLCCurves.map(curve => curve.transform(this.matrix));\r\n        }\r\n        else {\r\n            return ParametricSurface.isCurvesParametricImplicitSurface(this, new PlaneSurface(plane), 0.05, 0.05, 0.02);\r\n        }\r\n    }\r\n    loopContainsPoint(loop, pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const angle = EllipseCurve.XYLCPointT(pLC, this.uMin, this.uMax);\r\n        const testCurveLC = EllipseCurve.semicircle(pLC.lengthXY(), new V3(0, 0, pLC.z));\r\n        const testCurveWC = testCurveLC.transform(this.matrix);\r\n        return Surface.loopContainsPointEllipse(loop, pWC, testCurveWC, angle);\r\n    }\r\n    isCoplanarTo(surface) {\r\n        if (this === surface)\r\n            return true;\r\n        if (!hasConstructor(surface, RotatedCurveSurface))\r\n            return false;\r\n        const surfaceLCToThisLC = this.matrixInverse.times(surface.matrix);\r\n        assert(!surfaceLCToThisLC.X.xy().likeO());\r\n        const zRotation = surfaceLCToThisLC.X.angleXY();\r\n        return surface.curve.transform(M4.rotateZ(-zRotation).times(surfaceLCToThisLC)).isColinearTo(this.curve);\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface.plane);\r\n        }\r\n        return super.isCurvesWithSurface(surface);\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve.constructor == this.curve.constructor) {\r\n            const curveLC = curve.transform(this.matrixInverse);\r\n            // find a point on curveLC which isn't on the Z-axis\r\n            const t = [0, 0.5, 1].map(x => lerp(curveLC.tMin, curveLC.tMax, x)).withMax(t => curveLC.at(t).lengthXY());\r\n            const angle = curveLC.at(t).angleXY();\r\n            const curveLCRotated = curveLC.rotateZ(-angle);\r\n            if (this.curve.isColinearTo(curveLCRotated)) {\r\n                return true;\r\n            }\r\n        }\r\n        if (curve instanceof EllipseCurve) {\r\n            const curveLC = curve.transform(this.matrixInverse);\r\n            if (curveLC.normal.isParallelTo(V3.Z)) {\r\n                return (curveLC.isCircular() && this.curve.containsPoint(new V3(curveLC.f1.length(), 0, curveLC.center.z)));\r\n            }\r\n            return false;\r\n        }\r\n        return super.containsCurve(curve);\r\n    }\r\n    getExtremePoints() {\r\n        return getExtremePointsHelper.call(this, this.curve);\r\n    }\r\n    asNURBSSurface() {\r\n        // y = 0 for baseNURBS\r\n        const baseNURBS = NURBS.fromEllipse(this.curve);\r\n        const rotationNURBS = NURBS.UnitCircle(2, this.tMin, this.tMax);\r\n        return new NURBSSurface(rotationNURBS.points.flatMap(rv => baseNURBS.points.map(b => this.matrix.timesVector(VV(rv.x * b.x, rv.y * b.x, b.z * rv.w, rv.w * b.w)))), baseNURBS.knots, rotationNURBS.knots, baseNURBS.degree, rotationNURBS.degree, baseNURBS.tMin, baseNURBS.tMax, rotationNURBS.tMin, rotationNURBS.tMax);\r\n    }\r\n}\r\nRotatedCurveSurface.prototype.uStep = EllipseCurve.prototype.tIncrement;\r\nexport function getExtremePointsHelper(curve) {\r\n    // this logic comes from EllipseCurve.roots\r\n    const f1 = this.matrix.X;\r\n    const f2 = this.matrix.Y;\r\n    return [0, 1, 2].flatMap(dim => {\r\n        const a = f2.e(dim), b = -f1.e(dim);\r\n        const xiEtas = eq0(a) && eq0(b) ? [[1, 0]] : intersectionUnitCircleLine2(a, b, 0);\r\n        return xiEtas.flatMap(([xi, eta]) => {\r\n            const u = Math.atan2(eta, xi);\r\n            if (!(lt(this.uMin, u) && lt(u, this.uMax)))\r\n                return [];\r\n            const testCurve = curve.transform(this.matrix.times(M4.rotateZ(u)));\r\n            return testCurve.roots()[dim].map(v => this.pUV(u, v));\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=RotatedCurveSurface.js.map","import { assert, assertInst, assertVectors, eq0, hasConstructor, M4, pqFormula, TAU, V3 } from 'ts3dutils';\r\nimport { BezierCurve, EllipseCurve, L3, OUTSIDE, P3, ProjectedCurveSurface, Surface, } from '../index';\r\nimport { sign } from '../math';\r\nexport class CylinderSurface extends ProjectedCurveSurface {\r\n    // @ts-ignore\r\n    // readonly baseCurve: EllipseCurve\r\n    constructor(baseCurve, dir1, uMin = baseCurve.tMin, uMax = baseCurve.tMax, zMin = -Infinity, zMax = Infinity) {\r\n        super(baseCurve, dir1, uMin, uMax, zMin, zMax);\r\n        this.baseCurve = baseCurve;\r\n        assertInst(EllipseCurve, baseCurve);\r\n        //assert(!baseCurve.normal1.isPerpendicularTo(dir1), !baseCurve.normal1.isPerpendicularTo(dir1))\r\n        this.matrix = M4.forSys(baseCurve.f1, baseCurve.f2, dir1, baseCurve.center);\r\n        this.matrixInverse = this.matrix.inversed();\r\n        this.normalDir = sign(this.baseCurve.normal.dot(this.dir));\r\n        this.pLCNormalWCMatrix = this.matrix\r\n            .as3x3()\r\n            .inversed()\r\n            .transposed()\r\n            .scale(this.normalDir);\r\n        this.pWCNormalWCMatrix = this.pLCNormalWCMatrix.times(this.matrixInverse);\r\n    }\r\n    static semicylinder(radius, sMin, sMax, tMin, tMax) {\r\n        return new CylinderSurface(new EllipseCurve(V3.O, new V3(radius, 0, 0), new V3(0, radius, 0)), V3.Z, sMin, sMax, tMin, tMax);\r\n    }\r\n    /**\r\n     *\r\n     * @param anchorLC\r\n     * @param dirLC not necessarily unit\r\n     */\r\n    static unitISLineTs(anchorLC, dirLC) {\r\n        const { x: ax, y: ay } = anchorLC;\r\n        const { x: dx, y: dy } = dirLC;\r\n        // this cylinder: x² + y² = 1\r\n        // line: p = anchorLC + t * dirLC\r\n        // split line equation into 3 component equations, insert into cylinder equation\r\n        // x = ax + t * dx\r\n        // y = ay + t * dy\r\n        // (ax² + 2 ax t dx + t²dx²) + (ay² + 2 ay t dy + t²dy²) = 1\r\n        // transform to form (a t² + b t + c = 0) and solve with pqFormula\r\n        const a = Math.pow(dx, 2) + Math.pow(dy, 2);\r\n        const b = 2 * (ax * dx + ay * dy);\r\n        const c = Math.pow(ax, 2) + Math.pow(ay, 2) - 1;\r\n        return pqFormula(b / a, c / a).filter(t => EllipseCurve.XYLCValid(new V3(ax + dx * t, ay + dy * t, 0)));\r\n    }\r\n    normalP(p) {\r\n        return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(p).xy()).unit();\r\n    }\r\n    loopContainsPoint(loop, p) {\r\n        assertVectors(p);\r\n        if (!this.containsPoint(p))\r\n            return OUTSIDE;\r\n        const line = new L3(p, this.dir.unit());\r\n        const lineOut = this.dir.cross(this.normalP(p));\r\n        return Surface.loopContainsPointGeneral(loop, p, line, lineOut);\r\n    }\r\n    isTsForLine(line) {\r\n        assertInst(L3, line);\r\n        // transforming line manually has advantage that dir1 will not be renormalized,\r\n        // meaning that calculated values t for localLine are directly transferable to line\r\n        const dirLC = this.matrixInverse.transformVector(line.dir1);\r\n        if (dirLC.isParallelTo(V3.Z)) {\r\n            // line is parallel to this.dir\r\n            return [];\r\n        }\r\n        const anchorLC = this.matrixInverse.transformPoint(line.anchor);\r\n        assert(!CylinderSurface.unitISLineTs(anchorLC, dirLC).length ||\r\n            !isNaN(CylinderSurface.unitISLineTs(anchorLC, dirLC)[0]), 'sad ' + dirLC);\r\n        return CylinderSurface.unitISLineTs(anchorLC, dirLC);\r\n    }\r\n    isCoplanarTo(surface) {\r\n        return (this == surface ||\r\n            (hasConstructor(surface, CylinderSurface) &&\r\n                this.dir.isParallelTo(surface.dir) &&\r\n                this.containsEllipse(surface.baseCurve, false)));\r\n    }\r\n    like(surface) {\r\n        if (!this.isCoplanarTo(surface))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        const thisFacesOut = 0 < this.baseCurve.normal.dot(this.dir);\r\n        const objectFacesOut = 0 < surface.baseCurve.normal.dot(surface.dir);\r\n        return thisFacesOut == objectFacesOut;\r\n    }\r\n    containsEllipse(ellipse, checkAABB = true) {\r\n        const projEllipse = ellipse.transform(M4.project(this.baseCurve.getPlane(), this.dir));\r\n        return this.baseCurve == ellipse || this.baseCurve.isColinearTo(projEllipse);\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.containsLine(curve);\r\n        }\r\n        else if (curve instanceof EllipseCurve) {\r\n            return this.containsEllipse(curve);\r\n        }\r\n        else if (curve instanceof BezierCurve) {\r\n            return false;\r\n        }\r\n        else {\r\n            return super.containsCurve(curve);\r\n        }\r\n    }\r\n    implicitFunction() {\r\n        return (pWC) => {\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            return (pLC.lengthXY() - 1) * this.normalDir;\r\n        };\r\n    }\r\n    didp(pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const pLCLengthXY = pLC.lengthXY();\r\n        const didpLC = new V3(pLC.x / pLCLengthXY, pLC.y / pLCLengthXY, 0);\r\n        return this.pLCNormalWCMatrix.transformVector(didpLC);\r\n    }\r\n    containsPoint(pWC) {\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        return this.baseCurve.isValidT(EllipseCurve.XYLCPointT(pLC, this.uMin, this.uMax));\r\n    }\r\n    uvP(pWC) {\r\n        assert(arguments.length == 1);\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        const u = EllipseCurve.XYLCPointT(pLC, this.vMin, this.vMax);\r\n        return new V3(u, pLC.z, 0);\r\n    }\r\n    isCurvesWithSurface(surface2) {\r\n        if (surface2 instanceof ProjectedCurveSurface) {\r\n            if (surface2.dir.isParallelTo(this.dir)) {\r\n                const projectedCurve = surface2.baseCurve.transform(M4.project(this.baseCurve.getPlane(), this.dir));\r\n                return this.baseCurve.isInfosWithCurve(projectedCurve).map(info => {\r\n                    const lineDir = sign(this.normalP(info.p)\r\n                        .cross(surface2.normalP(info.p))\r\n                        .dot(this.dir)) || 1;\r\n                    return new L3(info.p, this.dir.times(lineDir));\r\n                });\r\n            }\r\n        }\r\n        if (surface2 instanceof CylinderSurface) {\r\n            if (eq0(this.getCenterLine().distanceToLine(surface2.getCenterLine()))) {\r\n                throw new Error();\r\n            }\r\n        }\r\n        return super.isCurvesWithSurface(surface2);\r\n    }\r\n    getCenterLine() {\r\n        return new L3(this.baseCurve.center, this.dir);\r\n    }\r\n    facesOutwards() {\r\n        return this.baseCurve.normal.dot(this.dir) > 0;\r\n    }\r\n    getSeamPlane() {\r\n        let normal = this.baseCurve.f1.cross(this.dir);\r\n        normal = normal.times(-sign(normal.dot(this.baseCurve.f2)));\r\n        return P3.normalOnAnchor(normal, this.baseCurve.center);\r\n    }\r\n    clipCurves(curves) {\r\n        return curves.flatMap(curve => curve.clipPlane(this.getSeamPlane()));\r\n    }\r\n}\r\nCylinderSurface.UNIT = new CylinderSurface(EllipseCurve.UNIT, V3.Z, undefined, undefined, 0, 1);\r\nCylinderSurface.prototype.uStep = TAU / 32;\r\nCylinderSurface.prototype.vStep = 256;\r\n//# sourceMappingURL=CylinderSurface.js.map","import { arrayFromFunction, assert, assertf, assertInst, assertNumbers, assertVectors, between, checkDerivate, clamp, eq, eq0, fuzzyBetween, gaussLegendreQuadrature24, getIntervals, getRoots, glqInSteps, hasConstructor, le, lt, M4, MINUS, newtonIterate, NLA_PRECISION, pqFormula, snap, toSource, V, V3, } from 'ts3dutils';\r\nimport { CylinderSurface, Edge, EllipseCurve, getExtremePointsHelper, L3, P3, ParametricSurface, PICurve, PlaneSurface, PointVsFace, ProjectedCurveSurface, Surface, } from '../index';\r\nimport { abs, cos, max, min, PI, sign, sin, sqrt } from '../math';\r\nexport class EllipsoidSurface extends ParametricSurface {\r\n    constructor(center, f1, f2, f3, uMin = 0, uMax = PI, vMin = -PI / 2, vMax = PI / 2) {\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.center = center;\r\n        this.f1 = f1;\r\n        this.f2 = f2;\r\n        this.f3 = f3;\r\n        assert(0 <= uMin && uMin <= PI);\r\n        assert(0 <= uMax && uMax <= PI);\r\n        assert(-PI / 2 <= vMin && vMin <= PI / 2);\r\n        assert(-PI / 2 <= vMax && vMax <= PI / 2);\r\n        assertVectors(center, f1, f2, f3);\r\n        this.matrix = M4.forSys(f1, f2, f3, center);\r\n        this.matrixInverse = this.matrix.inversed();\r\n        this.normalDir = sign(this.f1.cross(this.f2).dot(this.f3));\r\n        this.pLCNormalWCMatrix = this.matrix\r\n            .as3x3()\r\n            .inversed()\r\n            .transposed()\r\n            .scale(this.normalDir);\r\n        this.pWCNormalWCMatrix = this.pLCNormalWCMatrix.times(this.matrixInverse);\r\n    }\r\n    static unitArea(contour) {\r\n        const totalArea = contour\r\n            .map(edge => {\r\n            if (edge.curve instanceof PICurve) {\r\n                const points = edge.curve.calcSegmentPoints(edge.aT, edge.bT, edge.a, edge.b, edge.aT > edge.bT, true);\r\n                let sum = 0;\r\n                for (let i = 0; i < points.length - 1; i++) {\r\n                    const p = points[i], ppp = points[i + 1];\r\n                    sum += (abs(p.angleXY()) + abs(ppp.angleXY())) / 2 * (ppp.z - p.z);\r\n                }\r\n                return sum;\r\n            }\r\n            else if (edge.curve instanceof EllipseCurve) {\r\n                const f = (t) => {\r\n                    const at = edge.curve.at(t), tangent = edge.curve.tangentAt(t);\r\n                    const angleXY = abs(at.angleXY());\r\n                    //const arcLength = angleXY * Math.sqrt(1 - at.z ** 2) ( == at.lengthXY())\r\n                    //const scaling = tangent.z / at.lengthXY()\r\n                    return angleXY * tangent.z;\r\n                };\r\n                const val = glqInSteps(f, edge.aT, edge.bT, 1);\r\n                return val;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        })\r\n            .sum();\r\n        return totalArea;\r\n    }\r\n    /**\r\n     * unit sphere: x² + y² + z² = 1\r\n     * line: p = anchor + t * dir |^2\r\n     * p² = (anchor + t * dir)^2\r\n     * 1 == (anchor + t * dir)^2\r\n     * 1 == anchor DOT anchor + 2 * anchor * t * dir + t² * dir DOT dir\r\n     */\r\n    static unitISTsWithLine(anchor, dir) {\r\n        // for 0 = a t² + b t + c\r\n        const a = dir.dot(dir);\r\n        const b = 2 * anchor.dot(dir);\r\n        const c = anchor.dot(anchor) - 1;\r\n        return pqFormula(b / a, c / a).filter(t => le(0, anchor.y + t * dir.y));\r\n    }\r\n    /**\r\n     * unit sphere: x² + y² + z² = 1\r\n     * plane: normal1 DOT p = w\r\n     */\r\n    static unitISCurvesWithPlane(plane) {\r\n        const distPlaneCenter = Math.abs(plane.w);\r\n        if (lt(distPlaneCenter, 1)) {\r\n            // result is a circle\r\n            // radius of circle: imagine right angled triangle (origin -> center of intersection circle -> point on\r\n            // intersection circle) pythagoras: 1² == distPlaneCenter² + isCircleRadius² => isCircleRadius == sqrt(1 -\r\n            // distPlaneCenter²)\r\n            const isCircleRadius = Math.sqrt(1 - Math.pow(distPlaneCenter, 2));\r\n            const anchorY = plane.normal1.y * plane.w;\r\n            const d = abs(distPlaneCenter * isCircleRadius);\r\n            if (le(anchorY, -d) && !eq0(distPlaneCenter)) {\r\n                return [];\r\n            }\r\n            else if (le(anchorY, 0) && !plane.normal1.isParallelTo(V3.Y)) {\r\n                const f1 = plane.normal1.isParallelTo(V3.Y) ? V3.Z : plane.normal1.cross(V3.Y).toLength(isCircleRadius);\r\n                const f2 = f1.cross(plane.normal1);\r\n                const minEta = -anchorY / f2.y, minT = max(0, Math.asin(minEta));\r\n                return [new EllipseCurve(plane.anchor, f1, f2, minT, PI - minT)];\r\n            }\r\n            else {\r\n                const f2 = (plane.normal1.isParallelTo(V3.Y) ? V3.X : plane.normal1.cross(V3.Y)).toLength(isCircleRadius);\r\n                const f1 = f2.cross(plane.normal1);\r\n                const minXi = eq0(f1.y) ? -1 : -anchorY / f1.y, maxT = Math.acos(max(-1, minXi - NLA_PRECISION));\r\n                return [\r\n                    new EllipseCurve(plane.anchor, f1.negated(), f2, PI - maxT, PI),\r\n                    new EllipseCurve(plane.anchor, f1, f2.negated(), 0, maxT),\r\n                ];\r\n            }\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    static unitISCurvesWithEllipsoidSurface(surface) {\r\n        if (surface.isSphere()) {\r\n            const surfaceRadius = surface.f1.length();\r\n            const surfaceCenterDist = surface.center.length();\r\n            if (le(1, surfaceCenterDist - surfaceRadius) ||\r\n                le(surfaceCenterDist + surfaceRadius, 1) ||\r\n                le(surfaceCenterDist - surfaceRadius, -1)) {\r\n                return [];\r\n            }\r\n            else {\r\n                // origin, surface.center and points on the intersection curves form a triangle.\r\n                // the height on the segment origin - surface.center is the radius of the is curves\r\n                // the distance from the origin to the lot point is the distance to the intersection plane\r\n                function heron(a, b, c) {\r\n                    const p = (a + b + c) / 2;\r\n                    return sqrt(p * (p - a) * (p - b) * (p - c));\r\n                }\r\n                const triangleArea = heron(1, surfaceRadius, surfaceCenterDist);\r\n                const radius = triangleArea * 2 / surfaceCenterDist;\r\n                const isCurvesCenterDist = sign(1 + Math.pow(surfaceCenterDist, 2) - Math.pow(surfaceRadius, 2)) * sqrt(1 - Math.pow(radius, 2));\r\n                const plane = new P3(surface.center.unit(), isCurvesCenterDist);\r\n                return EllipsoidSurface.unitISCurvesWithPlane(plane.flipped());\r\n            }\r\n        }\r\n        throw new Error();\r\n    }\r\n    static unitISCurvesWithCylinderSurface(surface) {\r\n        if (new L3(surface.baseCurve.center, surface.dir).containsPoint(V3.O)) {\r\n            const projEllipse = surface.baseCurve.transform(M4.project(new P3(surface.dir, 0)));\r\n            const f1Length = projEllipse.f1.length(), f2Length = projEllipse.f2.length();\r\n            if (lt(1, min(f1Length, f2Length)))\r\n                return [];\r\n            if (projEllipse.isCircular()) {\r\n                const distISCurveCenter = Math.sqrt(1 - Math.pow(min(1, f1Length), 2));\r\n                const isCurveCenter = (surface.dir.y < 0 ? surface.dir.negated() : surface.dir).times(distISCurveCenter);\r\n                // isCurve.at(t).y = isCurveCenter.y + projEllipse.f1.y * cos(t) + projEllipse.f2.y * sin(t) = 0\r\n                return [new EllipseCurve(isCurveCenter, projEllipse.f1, projEllipse.f2)];\r\n            }\r\n        }\r\n        throw new Error();\r\n    }\r\n    static sphere(radius, center = V3.O) {\r\n        assertNumbers(radius);\r\n        return new EllipsoidSurface(center, new V3(radius, 0, 0), new V3(0, radius, 0), new V3(0, 0, radius));\r\n    }\r\n    /**\r\n     * x²/a² + y²/b² + z²/c² = 1\r\n     */\r\n    static forABC(a, b, c, center = V3.O) {\r\n        return new EllipsoidSurface(center, new V3(a, 0, 0), new V3(0, b, 0), new V3(0, 0, c));\r\n    }\r\n    static calculateAreaSpheroid(a, b, c, edges) {\r\n        assertf(() => a.isPerpendicularTo(b));\r\n        assertf(() => b.isPerpendicularTo(c));\r\n        assertf(() => c.isPerpendicularTo(a));\r\n        // handling discontinuities:\r\n        // option 1: check for intersections with baseline, if there are any integrate parts separetely\r\n        // \"rotate\" the edge so that there are no overlaps\r\n        const matrix = M4.forSys(a, b, c), matrixInverse = matrix.inversed();\r\n        const circleRadius = a.length();\r\n        const c1 = c.unit();\r\n        const totalArea = edges\r\n            .map(edge => {\r\n            if (edge.curve instanceof EllipseCurve) {\r\n                const f = (t) => {\r\n                    const at = edge.curve.at(t), tangent = edge.tangentAt(t);\r\n                    const localAt = matrixInverse.transformPoint(at);\r\n                    const angleXY = localAt.angleXY();\r\n                    const arcLength = angleXY * circleRadius * Math.sqrt(1 + Math.pow(localAt.z, 2));\r\n                    const scaling = Math.sqrt(1 + Math.pow(c1.dot(tangent), 2));\r\n                    return arcLength * scaling;\r\n                };\r\n                const val = glqInSteps(f, edge.aT, edge.bT, 1);\r\n                return val;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        })\r\n            .sum();\r\n        return totalArea;\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.center, this.f1, this.f2, this.f3, this.uMin, this.uMax, this.vMin, this.vMax];\r\n    }\r\n    equals(obj) {\r\n        return (this == obj || (Object.getPrototypeOf(obj) == this.constructor.prototype && this.matrix.equals(obj.matrix)));\r\n    }\r\n    edgeLoopCCW(loop) {\r\n        return EllipsoidSurface.unitArea(loop.map(edge => edge.transform(this.matrixInverse))) > 0;\r\n        //let totalAngle = 0\r\n        //for (let i = 0; i < contour.length; i++) {\r\n        //    const ipp = (i + 1) % contour.length\r\n        //    const edge = contour[i], nextEdge = contour[ipp]\r\n        //    totalAngle += edge.bDir.angleRelativeNormal(nextEdge.aDir, this.normalP(edge.b))\r\n        //}\r\n        //return le(0, totalAngle)\r\n    }\r\n    like(object) {\r\n        if (!this.isCoplanarTo(object))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        return this.matrix.determinant3() * object.matrix.determinant3() > 0;\r\n    }\r\n    rootPoints() { }\r\n    toMesh() {\r\n        return ParametricSurface.prototype.toMesh.call(this);\r\n    }\r\n    clipCurves(curves) {\r\n        return curves.flatMap(curve => curve.clipPlane(this.getSeamPlane()));\r\n    }\r\n    dpdu() {\r\n        // dp(u, v) = new V3(cos(t) * cos(s), cos(t) * sin(s), sin(t)\r\n        return (u, v) => this.matrix.transformVector(new V3(cos(v) * -sin(u), cos(v) * cos(u), 0));\r\n    }\r\n    dpdv() {\r\n        return (u, v) => this.matrix.transformVector(new V3(-sin(v) * cos(u), -sin(v) * sin(u), cos(v)));\r\n    }\r\n    isCurvesWithPCS(surface) {\r\n        let curves2 = ParametricSurface.isCurvesParametricImplicitSurface(surface, this, 0.1, 0.1 / surface.dir.length(), 0.05);\r\n        curves2 = this.clipCurves(curves2);\r\n        return curves2;\r\n    }\r\n    isCurvesWithPCSSmart(surface) {\r\n        const surfaceLC = surface.transform(this.matrixInverse);\r\n        //const lcMinZ0RelO =\r\n        const baseCurveLC = surfaceLC.baseCurve.project(new P3(surfaceLC.dir, 0));\r\n        const ists = baseCurveLC.isTsWithSurface(EllipsoidSurface.UNIT);\r\n        const insideIntervals = getIntervals(ists, baseCurveLC.tMin, baseCurveLC.tMax).filter(([a, b]) => baseCurveLC.at((a + b) / 2).length() < 1);\r\n        const projectedCurves = [0, 1].map(id => {\r\n            return (t) => {\r\n                const atSqr = snap(baseCurveLC.at(t).squared(), 1);\r\n                const lineISTs = /* +- */ sqrt(1 - atSqr);\r\n                //assert(!isNaN(lineISTs))\r\n                return eq0(lineISTs)\r\n                    ? baseCurveLC.at(t)\r\n                    : baseCurveLC.at(t).plus(surfaceLC.dir.times(sign(id - 0.5) * lineISTs));\r\n            };\r\n        });\r\n        const dProjectedCurves = [0, 1].map(id => {\r\n            return (t) => {\r\n                // d/dt sqrt(1 - baseCurveLC.at(t).squared())\r\n                // = -1/2 * 1/sqrt(1 - baseCurveLC.at(t).squared()) * -2*baseCurveLC.at(t) * baseCurveLC.tangentAt(t)\r\n                const atSqr = snap(baseCurveLC.at(t).squared(), 1);\r\n                const lineISTs = /* +- */ baseCurveLC\r\n                    .at(t)\r\n                    .times(-1 / sqrt(1 - atSqr))\r\n                    .dot(baseCurveLC.tangentAt(t));\r\n                //assert(!isNaN(lineISTs))\r\n                return baseCurveLC.tangentAt(t).plus(surfaceLC.dir.times(sign(id - 0.5) * lineISTs));\r\n            };\r\n        });\r\n        //const f2 = t => sqrt(1 - baseCurveLC.at(t).squared())\r\n        //const df2 = t => baseCurveLC.at(t).times(-1 / sqrt(1 -\r\n        // baseCurveLC.at(t).squared())).dot(baseCurveLC.tangentAt(t)) checkDerivate(f2, df2, 0.31, 0.60)\r\n        const curves = [];\r\n        for (const [aT, bT] of insideIntervals) {\r\n            //const aLine = new L3(baseCurveLC.at(aT), surfaceLC.dir1)\r\n            //const a = EllipsoidSurface.UNIT.isTsForLine(aLine).map(t => aLine.at(t))\r\n            //const bLine = new L3(baseCurveLC.at(bT), surfaceLC.dir1)\r\n            //const b = EllipsoidSurface.UNIT.isTsForLine(bLine).map(t => bLine.at(t))\r\n            for (const i of [0, 1]) {\r\n                const f = (t) => projectedCurves[i](t).y;\r\n                const df = (t) => dProjectedCurves[i](t).y;\r\n                checkDerivate(f, df, aT + 0.1, bT - 0.1);\r\n                const tsAtY0 = getRoots(f, aT + NLA_PRECISION, bT - NLA_PRECISION, 1 / (1 << 11), df);\r\n                const ii2 = getIntervals(tsAtY0, aT, bT).filter(([a, b]) => f((a + b) / 2) > 0);\r\n                for (const [aT2, bT2] of ii2) {\r\n                    let aP = projectedCurves[i](aT2), bP = projectedCurves[i](bT2);\r\n                    0 === i && ([aP, bP] = [bP, aP]);\r\n                    assert(EllipsoidSurface.UNIT.containsPoint(aP));\r\n                    assert(EllipsoidSurface.UNIT.containsPoint(bP));\r\n                    curves.push(PICurve.forStartEnd(surface, this, this.matrix.transformPoint(bP), this.matrix.transformPoint(aP), undefined));\r\n                }\r\n            }\r\n        }\r\n        return surface.clipCurves(curves);\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface.plane);\r\n        }\r\n        else if (surface instanceof CylinderSurface) {\r\n            return this.isCurvesWithCylinderSurface(surface);\r\n        }\r\n        else if (surface instanceof EllipsoidSurface) {\r\n            const surfaceLC = surface.transform(this.matrixInverse);\r\n            const curves = EllipsoidSurface.unitISCurvesWithEllipsoidSurface(surfaceLC).map(c => c.transform(this.matrix));\r\n            return surface.clipCurves(curves);\r\n        }\r\n        else if (surface instanceof ProjectedCurveSurface) {\r\n            return this.isCurvesWithPCS(surface);\r\n        }\r\n        else if (surface instanceof ParametricSurface) {\r\n            let curves2 = ParametricSurface.isCurvesParametricImplicitSurface(surface, this, 0.1, 0.1, 0.05);\r\n            curves2 = this.clipCurves(curves2);\r\n            curves2 = surface.clipCurves(curves2);\r\n            return curves2;\r\n        }\r\n        else {\r\n            throw new Error();\r\n        }\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        const planeLC = plane.transform(this.matrixInverse);\r\n        return EllipsoidSurface.unitISCurvesWithPlane(planeLC).map(c => c.transform(this.matrix));\r\n    }\r\n    isCurvesWithCylinderSurface(surface) {\r\n        if (L3.containsPoint(surface.baseCurve.center, surface.dir, this.center)) {\r\n            assert(this.isSphere());\r\n            const ellipseProjected = surface.baseCurve.transform(M4.project(surface.baseCurve.getPlane(), surface.dir));\r\n            if (ellipseProjected.isCircular()) {\r\n                const thisRadius = this.f1.length();\r\n                const surfaceRadius = ellipseProjected.f1.length();\r\n                // sphereRadius² = distanceISFromCenter² + isRadius²\r\n                if (eq(thisRadius, surfaceRadius)) {\r\n                    // return\r\n                }\r\n                else if (surfaceRadius < thisRadius) {\r\n                }\r\n                assert(false);\r\n            }\r\n        }\r\n        return this.isCurvesWithPCS(surface);\r\n    }\r\n    isTsForLine(line) {\r\n        assertInst(L3, line);\r\n        // transforming line manually has advantage that dir1 will not be renormalized,\r\n        // meaning that calculated values t for localLine are directly transferable to line\r\n        const anchorLC = this.matrixInverse.transformPoint(line.anchor);\r\n        const dirLC = this.matrixInverse.transformVector(line.dir1);\r\n        return EllipsoidSurface.unitISTsWithLine(anchorLC, dirLC);\r\n    }\r\n    isCoplanarTo(surface) {\r\n        if (this === surface)\r\n            return true;\r\n        if (!hasConstructor(surface, EllipsoidSurface))\r\n            return false;\r\n        if (!this.center.like(surface.center))\r\n            return false;\r\n        if (this.isSphere())\r\n            return surface.isSphere() && eq(this.f1.length(), this.f2.length());\r\n        const otherMatrixLC = this.matrixInverse.times(surface.matrix);\r\n        // Ellipsoid with matrix otherMatrixLC is unit sphere iff otherMatrixLC is orthogonal\r\n        return otherMatrixLC.like3x3() && otherMatrixLC.isOrthogonal();\r\n    }\r\n    containsEllipse(ellipse) {\r\n        const ellipseLC = ellipse.transform(this.matrixInverse);\r\n        const distEllipseLCCenter = ellipseLC.center.length();\r\n        const correctRadius = Math.sqrt(1 - Math.pow(distEllipseLCCenter, 2));\r\n        return lt(distEllipseLCCenter, 1) && ellipseLC.isCircular() && ellipseLC.f1.hasLength(correctRadius);\r\n        //&& le(0, ellipseLC.getAABB().min.y)\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof EllipseCurve) {\r\n            return this.containsEllipse(curve);\r\n        }\r\n        else {\r\n            return super.containsCurve(curve);\r\n        }\r\n    }\r\n    transform(m4) {\r\n        assert(m4.isNoProj(), () => m4.sce);\r\n        return new EllipsoidSurface(m4.transformPoint(this.center), m4.transformVector(this.f1), m4.transformVector(this.f2), m4.transformVector(this.f3).times(m4.isMirroring() ? -1 : 1));\r\n    }\r\n    transform4(m4) {\r\n        console.log('transform4');\r\n        const resultMatrix = m4.times(this.matrix);\r\n        console.log(resultMatrix.toString());\r\n        const scaleDir = V(resultMatrix.m[12], resultMatrix.m[13], resultMatrix.m[14]);\r\n        // need to find parameters where scaleDir is parallel to the normal\r\n        const pLC = this.pLCNormalWCMatrix.inversed().transformPoint(scaleDir);\r\n        const s = pLC.angleXY();\r\n        const t = Math.asin(clamp(pLC.z, -1, 1));\r\n        const fa = resultMatrix.transformPoint(scaleDir.unit());\r\n        const fb = resultMatrix.transformPoint(scaleDir.unit().negated());\r\n        const newCenter = V3.lerp(fa, fb, 0.5);\r\n        console.log(scaleDir.sce, s, t, fa, fb, 'newCenter', newCenter.sce);\r\n        return new EllipsoidSurface(newCenter, m4.transformVector2(this.f1, this.center), m4.transformVector2(this.f2, this.center), m4.transformVector2(this.f3, this.center).times(m4.isMirroring() ? -1 : 1));\r\n    }\r\n    isInsideOut() {\r\n        return this.f1.cross(this.f2).dot(this.f3) < 0;\r\n    }\r\n    flipped() {\r\n        return new EllipsoidSurface(this.center, this.f1, this.f2, this.f3.negated(), this.uMin, this.uMax, -this.vMax, -this.vMin);\r\n    }\r\n    normalUVFunc() {\r\n        // ugh\r\n        // paramtric ellipsoid point q(a, b)\r\n        // normal1 == (dq(a, b) / da) X (dq(a, b) / db) (cross product of partial derivatives)\r\n        // normal1 == cos b * (f2 X f3 * cos b * cos a + f3 X f1 * cos b * sin a + f1 X f2 * sin b)\r\n        return (a, b) => {\r\n            const { f1, f2, f3 } = this;\r\n            const normal = f2\r\n                .cross(f3)\r\n                .times(Math.cos(b) * Math.cos(a))\r\n                .plus(f3.cross(f1).times(Math.cos(b) * Math.sin(a)))\r\n                .plus(f1.cross(f2).times(Math.sin(b)))\r\n                //.times(Math.cos(b))\r\n                .unit();\r\n            return normal;\r\n        };\r\n    }\r\n    normalP(p) {\r\n        return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(p)).unit();\r\n    }\r\n    normalUV(u, v) {\r\n        return this.pLCNormalWCMatrix.transformVector(V3.sphere(u, v)).unit();\r\n    }\r\n    uvPFunc() {\r\n        return (pWC) => {\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            const alpha = abs(pLC.angleXY());\r\n            const beta = Math.asin(clamp(pLC.z, -1, 1));\r\n            assert(isFinite(alpha));\r\n            assert(isFinite(beta));\r\n            return new V3(alpha, beta, 0);\r\n        };\r\n    }\r\n    pUVFunc() {\r\n        // this(a, b) = f1 cos a cos b + f2 sin a cos b + f2 sin b\r\n        return (alpha, beta) => {\r\n            return this.matrix.transformPoint(V3.sphere(alpha, beta));\r\n        };\r\n    }\r\n    isSphere() {\r\n        return (eq(this.f1.length(), this.f2.length()) &&\r\n            eq(this.f2.length(), this.f3.length()) &&\r\n            eq(this.f3.length(), this.f1.length()) &&\r\n            this.f1.isPerpendicularTo(this.f2) &&\r\n            this.f2.isPerpendicularTo(this.f3) &&\r\n            this.f3.isPerpendicularTo(this.f1));\r\n    }\r\n    isVerticalSpheroid() {\r\n        return (eq(this.f1.length(), this.f2.length()) &&\r\n            this.f1.isPerpendicularTo(this.f2) &&\r\n            this.f2.isPerpendicularTo(this.f3) &&\r\n            this.f3.isPerpendicularTo(this.f1));\r\n    }\r\n    mainAxes() {\r\n        // q(a, b) = f1 cos a cos b + f2 sin a cos b + f3 sin b\r\n        // q(s, t, u) = s * f1 + t * f2 + u * f3 with s² + t² + u² = 1\r\n        // (del q(a, b) / del a) = f1 (-sin a) cos b  + f2 cos a cos b\r\n        // (del q(a, b) / del b) = f1 cos a (-sin b) + f2 sin a (-sin b) + f2 cos b\r\n        // del q(s, t, u) / del a = -t f1 + s f2\r\n        // (del q(a, b) / del a) DOT q(a, b) == 0\r\n        // (f1 (-sin a) cos b  + f2 cos a cos b) DOT (f1 cos a cos b + f2 sin a cos b + f2 sin b) == 0\r\n        // (del q(a, b) / del b) DOT q(a, b) == 0\r\n        // (f1 cos a (-sin b) + f2 sin a (-sin b) + f2 cos b) DOT (f1 cos a cos b + f2 sin a cos b + f2 sin b) == 0\r\n        // Solve[\r\n        // (f1 (-sin a) cos b  + f2 cos a cos b) * (f1 cos a cos b + f2 sin a cos b + f2 sin b) = 0,\r\n        // (f1 cos a (-sin b) + f2 sin a (-sin b) + f2 cos b) * (f1 cos a cos b + f2 sin a cos b + f2 sin b) = 0}, a, b]\r\n        const { f1, f2, f3 } = this;\r\n        if (eq0(f1.dot(f2)) && eq0(f2.dot(f3)) && eq0(f3.dot(f1))) {\r\n            return this;\r\n        }\r\n        //const f = ([a, b], x?) => {\r\n        //    const sinA = Math.sin(a), cosA = Math.cos(a), sinB = Math.sin(b), cosB = Math.cos(b)\r\n        //    const centerToP = V3.add(f1.times(cosA * cosB), f2.times(sinA * cosB), f3.times(sinB))\r\n        //    const centerToPdelA = f1.times(-sinA * cosB).plus(f2.times(cosA * cosB))\r\n        //    const centerToPdelB = V3.add(f1.times(cosA * -sinB), f2.times(sinA * -sinB), f3.times(cosB))\r\n        //    x && console.log(centerToP.sce, centerToPdelA.sce, centerToPdelB.sce)\r\n        //    return [centerToP.dot(centerToPdelA), centerToP.dot(centerToPdelB)]\r\n        //}\r\n        //const mainF1Params = newtonIterate(f, [0, 0], 8), mainF1 = this.pUVFunc()(mainF1Params[0], mainF1Params[1])\r\n        //console.log(f(mainF1Params, 1).sce)\r\n        //const mainF2Params = newtonIterate(f, this.uvPFunc()(f2.rejectedFrom(mainF1)).toArray(2), 8),\r\n        //   mainF2 = this.pUVFunc()(mainF2Params[0], mainF2Params[1])\r\n        //console.log(this.normalUVFunc()(mainF2Params[0], mainF2Params[1]).sce)\r\n        //assert(mainF1.isPerpendicularTo(mainF2), mainF1, mainF2, mainF1.dot(mainF2), mainF1Params)\r\n        //const mainF3Params = this.uvPFunc()(mainF1.cross(mainF2)), mainF3 = this.pUVFunc()(mainF3Params[0],\r\n        // mainF3Params[1]) return new EllipsoidSurface(this.center, mainF1, mainF2, mainF3)\r\n        const { U, SIGMA } = this.matrix.svd3();\r\n        assert(SIGMA.isDiagonal());\r\n        assert(U.isOrthogonal());\r\n        const U_SIGMA = U.times(SIGMA);\r\n        // column vectors of U_SIGMA\r\n        const [mainF1, mainF2, mainF3] = arrayFromFunction(3, i => new V3(U_SIGMA.m[i], U_SIGMA.m[i + 4], U_SIGMA.m[i + 8]));\r\n        return new EllipsoidSurface(this.center, mainF1, mainF2, mainF3);\r\n    }\r\n    containsPoint(p) {\r\n        return eq0(this.implicitFunction()(p));\r\n    }\r\n    boundsFunction() {\r\n        return (a, b) => between(a, 0, PI) && between(b, -PI, PI);\r\n    }\r\n    volume() {\r\n        return 4 / 3 * Math.PI * this.f1.dot(this.f2.cross(this.f3));\r\n    }\r\n    loopContainsPoint(loop, pWC) {\r\n        if (!this.containsPoint(pWC))\r\n            return PointVsFace.OUTSIDE;\r\n        assertVectors(pWC);\r\n        assert(Edge.isLoop(loop));\r\n        const pLCXY = this.matrixInverse.transformPoint(pWC).xy();\r\n        const testLine = new EllipseCurve(this.center, this.f3, pLCXY.likeO() ? this.f2 : this.matrix.transformVector(pLCXY.unit()));\r\n        if (P3.normalOnAnchor(this.f2.unit(), this.center).containsPoint(pWC)) {\r\n            return loop.some(edge => edge.curve.containsPoint(pWC) && fuzzyBetween(edge.curve.pointT(pWC), edge.minT, edge.maxT))\r\n                ? PointVsFace.ON_EDGE\r\n                : PointVsFace.OUTSIDE;\r\n        }\r\n        return Surface.loopContainsPointEllipse(loop, pWC, testLine);\r\n    }\r\n    surfaceAreaApprox() {\r\n        // See https://en.wikipedia.org/wiki/Ellipsoid#Surface_area\r\n        const mainAxes = this.mainAxes(), a = mainAxes.f1.length(), b = mainAxes.f2.length(), c = mainAxes.f3.length();\r\n        const p = 1.6075;\r\n        return 4 * PI * Math.pow((Math.pow(a * b, p) + Math.pow(b * c, p) + Math.pow(c * a, p)) / 3, 1 / p);\r\n    }\r\n    surfaceArea() {\r\n        // See https://en.wikipedia.org/wiki/Ellipsoid#Surface_area\r\n        const mainAxes = this.mainAxes(), f1l = mainAxes.f1.length(), f2l = mainAxes.f2.length(), f3l = mainAxes.f3.length(), [c, b, a] = [f1l, f2l, f3l].sort(MINUS);\r\n        // https://en.wikipedia.org/w/index.php?title=Spheroid&oldid=761246800#Area\r\n        function spheroidArea(a, c) {\r\n            if (c < a) {\r\n                const eccentricity2 = 1 - Math.pow(c, 2) / Math.pow(a, 2);\r\n                const eccentricity = Math.sqrt(eccentricity2);\r\n                return 2 * PI * Math.pow(a, 2) * (1 + (1 - eccentricity2) / Math.sqrt(eccentricity) * Math.atanh(eccentricity));\r\n            }\r\n            else {\r\n                const eccentricity = Math.sqrt(1 - Math.pow(a, 2) / Math.pow(c, 2));\r\n                return 2 * PI * Math.pow(a, 2) * (1 + c / a / eccentricity * Math.asin(eccentricity));\r\n            }\r\n        }\r\n        if (eq(a, b)) {\r\n            return spheroidArea(a, c);\r\n        }\r\n        else if (eq(b, c)) {\r\n            return spheroidArea(b, a);\r\n        }\r\n        else if (eq(c, a)) {\r\n            return spheroidArea(c, b);\r\n        }\r\n        const phi = Math.acos(c / a);\r\n        const kk = Math.pow(a, 2) * (Math.pow(b, 2) - Math.pow(c, 2)) / (Math.pow(b, 2) * (Math.pow(a, 2) - Math.pow(c, 2)));\r\n        const incompleteEllipticInt1 = gaussLegendreQuadrature24(phi => Math.pow(1 - kk * Math.pow(Math.sin(phi), 2), -0.5), 0, phi);\r\n        const incompleteEllipticInt2 = gaussLegendreQuadrature24(phi => Math.pow(1 - kk * Math.pow(Math.sin(phi), 2), 0.5), 0, phi);\r\n        return ((2 * PI * Math.pow(c, 2) + 2 * PI * a * b / Math.sin(phi)) *\r\n            (incompleteEllipticInt2 * Math.pow(Math.sin(phi), 2) + incompleteEllipticInt1 * Math.pow(Math.cos(phi), 2)));\r\n    }\r\n    getSeamPlane() {\r\n        const plane = P3.forAnchorAndPlaneVectors(this.center, this.f1, this.f3);\r\n        return plane.normal1.dot(this.f2) < 0 ? plane : plane.flipped();\r\n    }\r\n    getExtremePoints() {\r\n        return getExtremePointsHelper.call(this, new EllipseCurve(V3.O, V3.X, V3.Z, -PI / 2, PI / 2));\r\n    }\r\n    pointFoot(pWC, startS, startT) {\r\n        console.log(pWC.sce);\r\n        if (undefined === startS || undefined === startT) {\r\n            let pLC1 = this.matrixInverse.transformPoint(pWC).unit();\r\n            if (pLC1.y < 0)\r\n                pLC1 = pLC1.negated();\r\n            ({ x: startS, y: startT } = EllipsoidSurface.UNIT.uvP(pLC1));\r\n        }\r\n        const dpdu = this.dpdu();\r\n        const dpdv = this.dpdv();\r\n        const [u, v] = newtonIterate(([u, v]) => {\r\n            const p = this.pUV(u, v);\r\n            console.log([p, p.plus(dpdu(u, v)), p, p.plus(dpdv(u, v))].map(toSource).join() + ',');\r\n            const pUVToPWC = this.pUV(u, v).to(pWC);\r\n            return [pUVToPWC.dot(dpdu(u, v)), pUVToPWC.dot(dpdv(u, v))];\r\n        }, [startS, startT], 8, undefined, 0.1);\r\n        return new V3(u, v, 0);\r\n    }\r\n    implicitFunction() {\r\n        return (pWC) => {\r\n            const pLC = this.matrixInverse.transformPoint(pWC);\r\n            return (pLC.length() - 1) * this.normalDir;\r\n        };\r\n    }\r\n    // = this.inverseMatrix.transformPoint(this.inverseMatrix.transformPoint(pWC).unit())\r\n    didp(pWC) {\r\n        // i(pWC) = this.inverseMatrix.transformPoint(pWC).length() - 1\r\n        // chain diff rule\r\n        const pLC = this.matrixInverse.transformPoint(pWC);\r\n        return this.pLCNormalWCMatrix.transformVector(pLC.unit()); //.times(this.normalDir)\r\n    }\r\n    /*+\r\n     * An ellipsoid remains an ellipsoid after a perspective transform (as long as it does not intersect the vanishing\r\n     * plane. This transforms a matrix with a perspective component into one which would return an identical ellipsoid,\r\n     * but with no perspective component.\r\n     */\r\n    static unitTransform4(m) {\r\n        m.m[15] !== 1 && (m = m.divScalar(m.m[15]));\r\n        // X * P = m => X = m * P^-1\r\n        // prettier-ignore\r\n        const Pinv = new M4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -m.m[12], -m.m[13], -m.m[14], 1);\r\n        const pn = new V3(m.m[12], m.m[13], m.m[14]), pw = m.m[15];\r\n        const pwSqrMinusPnSqr = Math.pow(pw, 2) - pn.squared();\r\n        if (lt(pwSqrMinusPnSqr, 0)) {\r\n            throw new Error('vanishing plane intersects unit sphere');\r\n        }\r\n        const c = pn.div(-pwSqrMinusPnSqr);\r\n        const scale = pn.times(pw * pn.length() / (pn.squared() * -pwSqrMinusPnSqr));\r\n        const scale1 = pw / -pwSqrMinusPnSqr;\r\n        const scale2 = 1 / sqrt(pwSqrMinusPnSqr);\r\n        const rotNX = M4.forSys(pn.unit(), pn.getPerpendicular().unit());\r\n        return M4.product(m, Pinv, M4.translate(c), rotNX, M4.scale(scale1, scale2, scale2), rotNX.transposed());\r\n    }\r\n}\r\nEllipsoidSurface.UNIT = new EllipsoidSurface(V3.O, V3.X, V3.Y, V3.Z);\r\nEllipsoidSurface.prototype.uStep = PI / 32;\r\nEllipsoidSurface.prototype.vStep = PI / 32;\r\n//# sourceMappingURL=EllipsoidSurface.js.map","import { assert, assertInst, callsce, hasConstructor, isCCW, M4, V3 } from 'ts3dutils';\r\nimport { Edge, ImplicitCurve, L3, P3, ParametricSurface, Surface } from '../index';\r\nexport class PlaneSurface extends ParametricSurface {\r\n    constructor(plane, right = plane.normal1.getPerpendicular().unit(), up = plane.normal1.cross(right).unit(), uMin = -100, uMax = 100, vMin = -100, vMax = 100) {\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.plane = plane;\r\n        this.right = right;\r\n        this.up = up;\r\n        assertInst(P3, plane);\r\n        assert(this.right.cross(this.up).like(this.plane.normal1));\r\n        this.matrix = M4.forSys(right, up, plane.normal1, plane.anchor);\r\n    }\r\n    toSource(rounder = x => x) {\r\n        return callsce.call(undefined, 'new PlaneSurface', ...this.getConstructorParameters());\r\n    }\r\n    static throughPoints(a, b, c) {\r\n        return new PlaneSurface(P3.throughPoints(a, b, c));\r\n    }\r\n    static forAnchorAndPlaneVectors(anchor, v0, v1, uMin, uMax, vMin, vMax) {\r\n        return new PlaneSurface(P3.forAnchorAndPlaneVectors(anchor, v0, v1), v0, v1, uMin, uMax, vMin, vMax);\r\n    }\r\n    isCoplanarTo(surface) {\r\n        return hasConstructor(surface, PlaneSurface) && this.plane.isCoplanarToPlane(surface.plane);\r\n    }\r\n    isTsForLine(line) {\r\n        return line.isTsWithPlane(this.plane);\r\n    }\r\n    like(surface) {\r\n        return hasConstructor(surface, PlaneSurface) && this.plane.like(surface.plane);\r\n    }\r\n    pUV(u, v) {\r\n        return this.matrix.transformPoint(new V3(u, v, 0));\r\n    }\r\n    implicitFunction() {\r\n        return p => this.plane.distanceToPointSigned(p);\r\n    }\r\n    isCurvesWithSurface(surface2) {\r\n        if (surface2 instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface2.plane);\r\n        }\r\n        return super.isCurvesWithSurface(surface2);\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        const result = this.plane.intersectionWithPlane(plane);\r\n        return result ? [result] : [];\r\n    }\r\n    edgeLoopCCW(contour) {\r\n        assert(Edge.isLoop(contour), 'isLoop');\r\n        return isCCW(contour.flatMap(edge => edge.points()), this.plane.normal1);\r\n    }\r\n    loopContainsPoint(loop, p) {\r\n        const dir = this.right.plus(this.up.times(0.123)).unit();\r\n        const line = new L3(p, dir);\r\n        const lineOut = dir.cross(this.plane.normal1);\r\n        return Surface.loopContainsPointGeneral(loop, p, line, lineOut);\r\n    }\r\n    uvPFunc() {\r\n        const matrixInverse = this.matrix.inversed();\r\n        return function (pWC) {\r\n            return matrixInverse.transformPoint(pWC);\r\n        };\r\n    }\r\n    pointFoot(pWC) {\r\n        return this.uvP(pWC);\r\n    }\r\n    normalP(pWC) {\r\n        return this.plane.normal1;\r\n    }\r\n    containsPoint(p) {\r\n        return this.plane.containsPoint(p);\r\n    }\r\n    containsCurve(curve) {\r\n        return curve instanceof ImplicitCurve ? super.containsCurve(curve) : this.plane.containsCurve(curve);\r\n    }\r\n    transform(m4) {\r\n        return new PlaneSurface(this.plane.transform(m4));\r\n    }\r\n    transform4(m4) {\r\n        return new PlaneSurface(this.plane.transform(m4));\r\n    }\r\n    flipped() {\r\n        return new PlaneSurface(this.plane.flipped(), this.right, this.up.negated());\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.plane, this.right, this.up, this.uMin, this.uMax, this.vMin, this.vMax];\r\n    }\r\n    dpdu() {\r\n        return () => this.right;\r\n    }\r\n    dpdv() {\r\n        return () => this.up;\r\n    }\r\n    didp(pWC) {\r\n        return this.plane.normal1;\r\n    }\r\n    normalUV() {\r\n        return this.plane.normal1;\r\n    }\r\n}\r\nPlaneSurface.prototype.uStep = 1e6;\r\nPlaneSurface.prototype.vStep = 1e6;\r\n//# sourceMappingURL=PlaneSurface.js.map","import { assert, assertInst, assertVectors, hasConstructor, M4, newtonIterate, pqFormula, V3 } from 'ts3dutils';\r\nimport { Curve, EllipseCurve, ImplicitCurve, ImplicitSurface, L3, ParametricSurface, PlaneSurface, Surface, } from '../index';\r\nexport class PointProjectedSurface extends ParametricSurface {\r\n    constructor(curve, apex, curvePlane, normalDir = 1, sMin = curve.tMin, sMax = curve.tMax, tMin = 0, tMax = 16) {\r\n        super(sMin, sMax, tMin, tMax);\r\n        this.curve = curve;\r\n        this.apex = apex;\r\n        this.curvePlane = curvePlane;\r\n        this.normalDir = normalDir;\r\n        assertInst(Curve, curve);\r\n        assert(!(curve instanceof L3), 'use PlaneSurface instead');\r\n        assert(!(curve instanceof EllipseCurve), 'use ConicSurface instead');\r\n        assert(!(curve instanceof ImplicitCurve), 'this just seems like a terrible idea');\r\n        assert(new PlaneSurface(curvePlane).containsCurve(curve));\r\n        assertVectors(apex);\r\n        assert(0 <= tMin);\r\n        this.planeProjectionMatrix = M4.projectPlanePoint(apex, curvePlane);\r\n        this.uStep = curve.tIncrement;\r\n    }\r\n    pointFoot(pWC, ss, st) {\r\n        if (undefined === ss || undefined === st) {\r\n            // similar to stP\r\n            if (undefined === ss) {\r\n                ss = pWC.like(this.apex)\r\n                    ? 0\r\n                    : this.curve.closestTToPoint(this.planeProjectionMatrix.transformPoint(pWC)) * this.normalDir;\r\n            }\r\n            if (undefined === st) {\r\n                st = V3.inverseLerp(this.apex, this.curve.at(ss), pWC);\r\n            }\r\n        }\r\n        const f = ([s, t]) => {\r\n            const pSTToPWC = this.pST(s, t).to(pWC);\r\n            return [this.dpds()(s, t).dot(pSTToPWC), this.dpdt()(s).dot(pSTToPWC)];\r\n        };\r\n        const { 0: x, 1: y } = newtonIterate(f, [ss, st]);\r\n        return new V3(x, y, 0);\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.curve, this.apex, this.curvePlane, this.normalDir, this.sMin, this.sMax, this.tMin, this.tMax];\r\n    }\r\n    static unitISLineTs(anchor, dir) {\r\n        const { x: ax, y: ay, z: az } = anchor;\r\n        const { x: dx, y: dy, z: dz } = dir;\r\n        // this cone: x² + y² = z²\r\n        // line: p = anchor + t * dir1\r\n        // split line equation into 3 component equations, insert into cone equation\r\n        // transform to form (a t² + b t + c = 0) and solve with pqFormula\r\n        const a = dx * dx + dy * dy - dz * dz;\r\n        const b = 2 * (ax * dx + ay * dy - az * dz);\r\n        const c = ax * ax + ay * ay - az * az;\r\n        // cone only defined for 0 <= z, so filter invalid values\r\n        return pqFormula(b / a, c / a).filter(t => 0 < az + t * dz);\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (hasConstructor(obj, PointProjectedSurface) && this.curve.equals(obj.curve) && this.apex.equals(this.apex)));\r\n    }\r\n    like(object) {\r\n        if (!this.isCoplanarTo(object))\r\n            return false;\r\n        // normals need to point in the same direction (outwards or inwards) for both\r\n        return this.normalDir == object.normalDir;\r\n    }\r\n    loopContainsPoint(contour, p) {\r\n        assertVectors(p);\r\n        const line = this.apex.like(p)\r\n            ? new L3(p, this.apex.to(this.curve.at(this.curve.tMin)).unit())\r\n            : L3.throughPoints(p, this.apex);\r\n        const lineOut = line.dir1.cross(this.curvePlane.normal1);\r\n        return Surface.loopContainsPointGeneral(contour, p, line, lineOut);\r\n    }\r\n    isTsForLine(line) {\r\n        // transforming line manually has advantage that dir1 will not be renormalized,\r\n        // meaning that calculated values t for lineLC are directly transferable to line\r\n        const anchorPlane = this.planeProjectionMatrix.transformPoint(line.anchor);\r\n        const anchor2Plane = this.planeProjectionMatrix.transformPoint(line.anchor.plus(line.dir1));\r\n        if (anchorPlane.like(anchor2Plane)) {\r\n            // line projects onto a point in plane.\r\n            // there are either no or infinite intersection points\r\n            return [];\r\n        }\r\n        return this.curve\r\n            .isInfosWithLine(anchorPlane, anchorPlane.to(anchor2Plane), undefined, undefined, line.tMin, line.tMax)\r\n            .map(info => info.tOther);\r\n    }\r\n    /**\r\n     * Interestingly, two cones don't need to have parallel dirs to be coplanar.\r\n     */\r\n    isCoplanarTo(surface) {\r\n        if (this === surface)\r\n            return true;\r\n        if (!(surface instanceof PointProjectedSurface) || !this.apex.like(surface.apex))\r\n            return false;\r\n        // at this point apexes are equal\r\n        return this.containsCurve(surface.curve);\r\n    }\r\n    containsLine(line) {\r\n        if (this.curvePlane.isParallelToLine(line)) {\r\n            return false;\r\n        }\r\n        if (!line.containsPoint(this.apex)) {\r\n            return false;\r\n        }\r\n        const p = this.curvePlane.intersectionWithLine(line);\r\n        return this.curve.containsPoint(p);\r\n    }\r\n    containsCurve(curve) {\r\n        if (curve instanceof L3) {\r\n            return this.containsLine(curve);\r\n        }\r\n        else if (!(curve instanceof ImplicitCurve)) {\r\n            const otherCurveOnThisPlane = curve.transform(this.planeProjectionMatrix);\r\n            return this.curve.isColinearTo(otherCurveOnThisPlane);\r\n        }\r\n        else {\r\n            return super.containsCurve(curve);\r\n        }\r\n    }\r\n    transform(m4) {\r\n        return new PointProjectedSurface(this.curve.transform(m4), m4.transformPoint(this.apex), this.curvePlane.transform(m4), (m4.isMirroring() ? -1 : 1) * this.normalDir, this.sMin, this.sMax, this.tMin, this.tMax);\r\n    }\r\n    flipped() {\r\n        return new PointProjectedSurface(this.curve, this.apex, this.curvePlane, -this.normalDir, -this.sMax, -this.sMin, this.tMin, this.tMax);\r\n    }\r\n    normalSTFunc() {\r\n        const dpdt = this.dpdt();\r\n        return (s, t) => this.curve\r\n            .tangentAt(s * this.normalDir)\r\n            .times(this.normalDir)\r\n            .cross(dpdt(s))\r\n            .unit();\r\n    }\r\n    pSTFunc() {\r\n        return (s, t) => {\r\n            return this.apex.lerp(this.curve.at(s * this.normalDir), t);\r\n        };\r\n    }\r\n    dpds() {\r\n        return (s, t) => {\r\n            return this.curve.tangentAt(s * this.normalDir).times(t * this.normalDir);\r\n        };\r\n    }\r\n    dpdt() {\r\n        return s => {\r\n            return this.apex.to(this.curve.at(s * this.normalDir));\r\n        };\r\n    }\r\n    containsPoint(pWC) {\r\n        return this.apex.like(pWC) || this.curve.containsPoint(this.planeProjectionMatrix.transformPoint(pWC));\r\n    }\r\n    stP(pWC) {\r\n        const s = pWC.like(this.apex) ? 0 : this.curve.pointT(this.planeProjectionMatrix.transformPoint(pWC));\r\n        const t = V3.inverseLerp(this.apex, this.curve.at(s), pWC);\r\n        return new V3(s * this.normalDir, t, 0);\r\n    }\r\n    isCurvesWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.isCurvesWithPlane(surface.plane);\r\n        }\r\n        else if (ImplicitSurface.is(surface)) {\r\n            return ParametricSurface.isCurvesParametricImplicitSurface(this, surface, 0.1, 0.1 / this.curvePlane.distanceToPoint(this.apex), 0.02);\r\n        }\r\n        return super.isCurvesWithSurface(surface);\r\n    }\r\n    isCurvesWithPlane(plane) {\r\n        if (plane.containsPoint(this.apex)) {\r\n            if (plane.isParallelToPlane(this.curvePlane)) {\r\n                return [];\r\n            }\r\n            return this.curve.isTsWithPlane(plane).map(t => L3.throughPoints(this.apex, this.curve.at(t)));\r\n        }\r\n        return [this.curve.transform(M4.projectPlanePoint(this.apex, plane))];\r\n    }\r\n}\r\nPointProjectedSurface.prototype.vStep = 256;\r\n//# sourceMappingURL=PointProjectedSurface.js.map","import { arrayFromFunction, assert, MINUS, V3, Vector } from 'ts3dutils';\r\nimport { NURBS, ParametricSurface } from '../index';\r\nexport class NURBSSurface extends ParametricSurface {\r\n    constructor(\r\n    /**\r\n     * Control points in u-major order. I.e. the first pointCountU points are a NURBS.\r\n     */\r\n    points, knotsU, knotsV, degreeU, degreeV, uMin = knotsU[degreeU], uMax = knotsU[knotsU.length - degreeU - 1], vMin = knotsV[degreeV], vMax = knotsV[knotsV.length - degreeV - 1]) {\r\n        super(uMin, uMax, vMin, vMax);\r\n        this.points = points;\r\n        this.knotsU = knotsU;\r\n        this.knotsV = knotsV;\r\n        this.degreeU = degreeU;\r\n        this.degreeV = degreeV;\r\n        const pointCountU = knotsU.length - 1 - degreeU;\r\n        const pointCountV = knotsV.length - 1 - degreeV;\r\n        assert(pointCountU * pointCountV == points.length);\r\n        assert(degreeU <= degreeV, 'degreeU <= degreeV');\r\n        assert(-1 == knotsU.firstUnsorted(MINUS), 'knot values must be in ascending order');\r\n        assert(-1 == knotsV.firstUnsorted(MINUS), 'knot values must be in ascending order');\r\n    }\r\n    getConstructorParameters() {\r\n        return [\r\n            this.points,\r\n            this.knotsU,\r\n            this.knotsV,\r\n            this.degreeU,\r\n            this.degreeV,\r\n            this.uMin,\r\n            this.uMax,\r\n            this.vMin,\r\n            this.vMax,\r\n        ];\r\n    }\r\n    transform(m4) {\r\n        return this.transform4(m4);\r\n    }\r\n    transform4(m4) {\r\n        return new NURBSSurface(this.points.map(p => m4.timesVector(p)), this.knotsU, this.knotsV, this.degreeU, this.degreeV, this.uMin, this.uMax, this.vMin, this.vMax);\r\n    }\r\n    pUV(u, v) {\r\n        return this.isoparametricU(u).at(v);\r\n    }\r\n    dpdu() {\r\n        return (u, v) => this.isoparametricV(v).tangentAt(u);\r\n    }\r\n    dpdv() {\r\n        return (u, v) => this.isoparametricU(u).tangentAt(v);\r\n    }\r\n    normalUV(u, v) {\r\n        const normal = this.dpdu()(u, v).cross(this.dpdv()(u, v));\r\n        return normal.likeO() ? V3.X : normal.unit();\r\n    }\r\n    isoparametricU(u) {\r\n        const pointCountU = this.knotsU.length - 1 - this.degreeU;\r\n        const pointCountV = this.knotsV.length - 1 - this.degreeV;\r\n        return new NURBS(arrayFromFunction(pointCountV, i => {\r\n            return deBoor(this.points.slice(i * pointCountU, (i + 1) * pointCountU), this.degreeU, this.knotsU, u);\r\n        }), this.degreeV, this.knotsV, this.vMin, this.vMax);\r\n    }\r\n    isoparametricV(v) {\r\n        const pointCountU = this.knotsU.length - 1 - this.degreeU;\r\n        return new NURBS(arrayFromFunction(pointCountU, i => {\r\n            return deBoor(this.points.sliceStep(i, this.points.length, pointCountU, 1), this.degreeV, this.knotsV, v);\r\n        }), this.degreeU, this.knotsU, this.uMin, this.uMax);\r\n    }\r\n    debugInfo() {\r\n        const pointCountU = this.knotsU.length - 1 - this.degreeU;\r\n        const pointCountV = this.knotsV.length - 1 - this.degreeV;\r\n        const grid = [];\r\n        for (let u = 0; u < pointCountU; u++) {\r\n            for (let v = 0; v < pointCountV; v++) {\r\n                const i = v * pointCountU + u;\r\n                if (u < pointCountU - 1) {\r\n                    const j = v * pointCountU + u + 1;\r\n                    grid.push(this.points[i].p3(), this.points[j].p3());\r\n                }\r\n                if (v < pointCountV - 1) {\r\n                    const j = (v + 1) * pointCountU + u;\r\n                    grid.push(this.points[i].p3(), this.points[j].p3());\r\n                }\r\n            }\r\n        }\r\n        return { points: this.points.map(p => p.p3()), lines: grid };\r\n    }\r\n    flipped() {\r\n        const pointCountU = this.knotsU.length - 1 - this.degreeU;\r\n        return new NURBSSurface(arrayFromFunction(this.points.length, i => {\r\n            const u = i % pointCountU;\r\n            return this.points[i - u + (pointCountU - u - 1)];\r\n        }), this.knotsU.map(x => -x).reverse(), this.knotsV, this.degreeU, this.degreeV, -this.uMax, -this.uMin, this.vMin, this.vMax);\r\n    }\r\n}\r\nNURBSSurface.prototype.uStep = 1 / 8;\r\nNURBSSurface.prototype.vStep = 1 / 8;\r\nfunction getInterval(degree, knots, t) {\r\n    for (let s = degree; s < knots.length - 1 - degree; s++) {\r\n        if (t >= knots[s] && t <= knots[s + 1]) {\r\n            return s;\r\n        }\r\n    }\r\n    throw new Error(t + ' ' + knots);\r\n}\r\nfunction deBoor(points, degree, knots, t) {\r\n    // find s (the spline segment) for the [t] value provided\r\n    const s = getInterval(degree, knots, t);\r\n    const v = Vector.pack(points, new Float64Array(points.length * 4));\r\n    // l (level) goes from 1 to the curve degree + 1\r\n    for (let l = 1; l <= degree; l++) {\r\n        // build level l of the pyramid\r\n        for (let i = s; i > s - degree - 1 + l; i--) {\r\n            const alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i]);\r\n            // interpolate each component\r\n            for (let d = 0; d < 4; d++) {\r\n                v[i * 4 + d] = (1 - alpha) * v[(i - 1) * 4 + d] + alpha * v[i * 4 + d];\r\n            }\r\n        }\r\n    }\r\n    return new Vector(v.slice(s * 4, s * 4 + 4));\r\n}\r\n//# sourceMappingURL=NURBSSurface.js.map","import { assert, gaussLegendre24Weights, gaussLegendre24Xs, gaussLegendreQuadrature24, glqInSteps, M4, V, V3, } from 'ts3dutils';\r\nimport { ConicSurface, EllipseCurve, EllipsoidSurface, HyperbolaCurve, ImplicitCurve, L3, ParabolaCurve, ParametricSurface, PlaneSurface, ProjectedCurveSurface, RotatedCurveSurface, } from '../index';\r\nimport { cos, sin } from '../math';\r\n/**\r\n * In general: the z-dir shadow volume of a face is the integral: SURFACE_INTEGRAL[p in face] (normal(p).z * p.z) dp\r\n * In general: the centroid of the z-dir shadow volume of a face is the integral:\r\n *     SURFACE_INTEGRAL[p in face] ((p schur (1, 1, 0.5)) * normal(p).z * p.z) dp\r\n *     dividing the z component by 2 is usually done at the very end\r\n */\r\nexport const ZDirVolumeVisitor = {\r\n    [ConicSurface.name](edges) {\r\n        console.log(this);\r\n        const dpdu = this.dpdu();\r\n        const dpdv = this.dpdv();\r\n        // INT[edge.at; edge.bT] (at(t) DOT dir) * (at(t) - at(t).projectedOn(dir) / 2).z dt\r\n        const totalVolume = edges\r\n            .map(edgeWC => {\r\n            const curveWC = edgeWC.curve;\r\n            if (curveWC instanceof EllipseCurve ||\r\n                curveWC instanceof HyperbolaCurve ||\r\n                curveWC instanceof ParabolaCurve) {\r\n                const f = (curveT) => {\r\n                    const at = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                    const uvOfPWC = this.uvP(at);\r\n                    // INTEGRATE [0; atUV.y] (dpdu(atUV.x, t) X dpdv(atUV.x)).z * pUV(atUV.x, t).z dt\r\n                    // dpdu(u, v) === t * dpdu(s, 1)\r\n                    // => INTEGRATE [0; atUV.y] (t * dpdu(atUV.x, 1) X dpdv(atUV.x)).z * pUV(atUV.x, t).z dt\r\n                    // => (dpdu(atUV.x, 1) X dpdv(atUV.x)).z * INTEGRATE [0; atUV.y] t * pUV(atUV.x, t).z dt\r\n                    // pUV(u, v) === t * (pUV(s, 1) - center) + center\r\n                    // => (dpdu(atUV.x, 1) X dpdv(atUV.x)).z\r\n                    //      * INTEGRATE [0; atUV.y] t² * (pUV(atUV.x, t) - center).z + t * center.z dt\r\n                    // => (dpdu(atUV.x, 1) X dpdv(atUV.x)).z\r\n                    //      * INTEGRATE [0; atUV.y] t² * (pUV(atUV.x, t) - center).z + t * center.z dt\r\n                    // => (dpdu(atUV.x, 1) X dpdv(atUV.x)).z\r\n                    //      * (1/3 t³ pUV(atUV.x, 1).z + 1/2 t² center.z)[0; atUV.y]\r\n                    const du = -M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x))\r\n                        .inversed()\r\n                        .transformVector(tangentWC).x;\r\n                    const factor = Math.pow(uvOfPWC.y, 3) / 3 * (this.pUV(uvOfPWC.x, 1).z - this.center.z) +\r\n                        Math.pow(uvOfPWC.y, 2) / 2 * this.center.z;\r\n                    const actual = dpdu(uvOfPWC.x, factor).cross(dpdv(uvOfPWC.x)).z;\r\n                    return actual * du;\r\n                };\r\n                const val = glqInSteps(f, edgeWC.aT, edgeWC.bT, 1);\r\n                return val;\r\n            }\r\n            else if (curveWC instanceof L3) {\r\n                return 0;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        })\r\n            .sum();\r\n        const centroidZX2Parts = edges.map(edgeWC => {\r\n            const curveWC = edgeWC.curve;\r\n            if (curveWC instanceof EllipseCurve ||\r\n                curveWC instanceof HyperbolaCurve ||\r\n                curveWC instanceof ParabolaCurve) {\r\n                const f = (curveT) => {\r\n                    const at = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                    const uvOfPWC = this.uvP(at);\r\n                    // INTEGRATE [0; atUV.y] dpdu(atUV.x, t) X dpdv(atUV.x, t) * pUV(atUV.x, t).z dt\r\n                    // dpdv is constant with respect to t\r\n                    // => (dpdu(atUV.x, t) X dpdv(atUV.x, t)).z\r\n                    //      * (INTEGRATE [0; atUV.y] t * pUV(atUV.x, t) * pUV(atUV.x, t).z dt)\r\n                    // dpdu(u, v) === t * dpdu(s, 1)\r\n                    // pUV(u, v) === t * (pUV(s, 1) - center) + center\r\n                    // INTEGRATE [0; atUV.y] t * pUV(atUV.x, t) * pUV(atUV.x, t).z dt\r\n                    // = INTEGRATE [0; atUV.y] t *\r\n                    //                         (t * (pUV(s, 1) - center) + center) *\r\n                    //                         (t (pUV(s, 1) - center).z + center.z) dt\r\n                    // = INTEGRATE [0; atUV.y] t³ (pUV(s, 1) - center) * (pUV(s, 1) - center).z\r\n                    //                       + t² ((pUV(s, 1) - center) * center.z + (pUV(s, 1) - center).z * center)\r\n                    //                       + t center center.z dt\r\n                    // = (1/4 t^4 (pUV(s, 1) - center) * (pUV(s, 1) - center).z\r\n                    //   (1/3 t³ ((pUV(s, 1) - center) * center.z + (pUV(s, 1) - center).z * center)\r\n                    //   (1/2 t² center center.z dt)[0; atUV.y]\r\n                    const pUVS1V = this.pUV(uvOfPWC.x, 1).minus(this.center);\r\n                    const factor = V3.add(pUVS1V.times(1 / 4 * Math.pow(uvOfPWC.y, 4) * pUVS1V.z + 1 / 3 * Math.pow(uvOfPWC.y, 3) * this.center.z), this.center.times(1 / 3 * Math.pow(uvOfPWC.y, 3) * pUVS1V.z + 1 / 2 * Math.pow(uvOfPWC.y, 2) * this.center.z));\r\n                    const partialCentroid = factor.times(dpdu(uvOfPWC.x, 1).cross(dpdv(uvOfPWC.x)).z);\r\n                    const ds = -M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x))\r\n                        .inversed()\r\n                        .transformVector(tangentWC).x;\r\n                    return partialCentroid.times(ds);\r\n                };\r\n                return glqV3(f, edgeWC.aT, edgeWC.bT);\r\n            }\r\n            else if (curveWC instanceof L3) {\r\n                return V3.O;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        });\r\n        const centroid = V3.add(...centroidZX2Parts)\r\n            .schur(new V3(1, 1, 0.5))\r\n            .div(totalVolume);\r\n        return { volume: totalVolume, centroid: centroid };\r\n    },\r\n    [PlaneSurface.name](edges) {\r\n        const r1 = this.right;\r\n        const u1 = this.up;\r\n        const c = this.plane.anchor;\r\n        assert(r1.hasLength(1));\r\n        assert(u1.hasLength(1));\r\n        assert(r1.isPerpendicularTo(u1));\r\n        const volumeAndCentroidZX2Parts = edges.map((edgeWC) => {\r\n            const curveWC = edgeWC.curve;\r\n            if (curveWC instanceof L3) {\r\n                // split shadow volume into two triangle shadow volumes and use the same logic as for mesh triangles:\r\n                function triangleShadowVolumeAndCentroid(a, b, c) {\r\n                    const ab = b.minus(a), ac = c.minus(a);\r\n                    const normal = ab.cross(ac);\r\n                    const faceCentroid = V3.add(a, b, c).div(3);\r\n                    return [\r\n                        faceCentroid.z * normal.z / 2,\r\n                        V3.add(a.times(2 * a.z + b.z + c.z), b.times(a.z + 2 * b.z + c.z), c.times(a.z + b.z + 2 * c.z)).times(normal.z),\r\n                    ];\r\n                }\r\n                const a = edgeWC.a, b = edgeWC.b;\r\n                const as = a.dot(r1);\r\n                const bs = b.dot(r1);\r\n                const aBase = this.pUV(as, 0);\r\n                const bBase = this.pUV(bs, 0);\r\n                const [v1, c1] = triangleShadowVolumeAndCentroid(a, b, aBase);\r\n                const [v2, c2] = triangleShadowVolumeAndCentroid(bBase, aBase, b);\r\n                return [v1 + v2, c1.plus(c2).div(24)];\r\n            }\r\n            else if (curveWC instanceof ImplicitCurve) {\r\n                throw new Error();\r\n            }\r\n            else {\r\n                const sliceAreaAndCentroidZX2TimesDs = (curveT) => {\r\n                    const p = curveWC.at(curveT);\r\n                    const s = p.dot(r1);\r\n                    const t = p.dot(u1);\r\n                    const area = t * c.z + s * t * r1.z + 1 / 2 * Math.pow(t, 2) * u1.z;\r\n                    const ds = -curveWC.tangentAt(curveT).dot(r1);\r\n                    return [\r\n                        area * ds,\r\n                        ...V3.add(c.times(area), r1.times(c.z * s * t + r1.z * Math.pow(s, 2) * t + 1 / 2 * s * Math.pow(t, 2) * u1.z), u1.times(1 / 2 * c.z * Math.pow(t, 2) + 1 / 2 * r1.z * s * Math.pow(t, 2) + 1 / 3 * Math.pow(t, 3) * u1.z)).times(ds),\r\n                    ];\r\n                };\r\n                const [vol, cx, cy, cz] = glqArray(sliceAreaAndCentroidZX2TimesDs, edgeWC.aT, edgeWC.bT, 4);\r\n                return [vol * this.plane.normal1.z, new V3(cx, cy, cz).times(this.plane.normal1.z)];\r\n            }\r\n        });\r\n        return mergeVolumeAndCentroidZX2Parts(volumeAndCentroidZX2Parts);\r\n    },\r\n    /**\r\n     * Generic implementation.\r\n     */\r\n    [ParametricSurface.name](edges) {\r\n        const dpdu = this.dpdu();\r\n        const dpdv = this.dpdv();\r\n        const volume = edges.map((edgeWC) => {\r\n            const curveWC = edgeWC.curve;\r\n            if (curveWC instanceof ImplicitCurve) {\r\n                throw new Error();\r\n            }\r\n            else {\r\n                const sliceAreaAndCentroidZX2TimesDs = (curveT) => {\r\n                    // use curve.tangent not edge.tangent, reverse edges are handled by the integration boundaries\r\n                    const pWC = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                    const uvOfPWC = this.uvP(pWC);\r\n                    const slice = (t) => {\r\n                        const p = this.pUV(uvOfPWC.x, t);\r\n                        const normal = dpdu(uvOfPWC.x, t).cross(dpdv(uvOfPWC.x, t));\r\n                        return p.z * normal.z;\r\n                    };\r\n                    const sliceIntegral0ToPWCT = glqInSteps(slice, 0, uvOfPWC.y, 1);\r\n                    // const dt = tangentWC.dot(scalingVector)\r\n                    const dt = -M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x, uvOfPWC.y))\r\n                        .inversed()\r\n                        .transformVector(tangentWC).x;\r\n                    const sliceAreaTimesDs = sliceIntegral0ToPWCT * dt;\r\n                    const slice2 = (t) => {\r\n                        const p = this.pUV(uvOfPWC.x, t);\r\n                        const normal = dpdu(uvOfPWC.x, t).cross(dpdv(uvOfPWC.x, t));\r\n                        return p.times(p.z * normal.z);\r\n                    };\r\n                    const sliceIntegral0ToPWCT2 = glqV3(slice2, 0, uvOfPWC.y);\r\n                    // const dt = tangentWC.dot(scalingVector)\r\n                    const sliceCentroidZX2TimesDs = sliceIntegral0ToPWCT2.times(dt);\r\n                    return [sliceAreaTimesDs, ...sliceCentroidZX2TimesDs.toArray()];\r\n                };\r\n                const [vol, cx, cy, cz] = glqArray(sliceAreaAndCentroidZX2TimesDs, edgeWC.aT, edgeWC.bT, 4);\r\n                return [vol, new V3(cx, cy, cz)];\r\n            }\r\n        });\r\n        return mergeVolumeAndCentroidZX2Parts(volume);\r\n    },\r\n    /**\r\n     * at(t)\r\n     * |\\                                    ^\r\n     * | \\ at(t).projectedOn(dir1)            \\  dir1\r\n     * |  \\                                    \\\r\n     * |   \\ at(t).rejectedFrom(dir1) = b\r\n     * |   |\r\n     * |___|\r\n     *        z = 0\r\n     *\r\n     *\r\n     * A = ((at(t) + at(t).rejectedFrom(dir1)) / 2).z * at(t).projectedOn(dir1).lengthXY()\r\n     * scaling = tangentAt(t) DOT dir1.cross(V3.Z).unit()\r\n     */\r\n    [ProjectedCurveSurface.name](edges) {\r\n        if (V3.Z.cross(this.dir).likeO())\r\n            return { volume: 0, centroid: V3.O };\r\n        // normalize this.dir so it always points up\r\n        const upDir1 = this.dir.toLength(Math.sign(this.dir.z) || 1);\r\n        const scalingVector = V3.Z.cross(upDir1).unit();\r\n        // the length of the base of the trapezoid is calculated by dotting with the baseVector\r\n        const baseVector = upDir1.rejectedFrom(V3.Z).unit();\r\n        // INT[edge.at; edge.bT] (at(t) DOT dir1) * (at(t) - at(t).projectedOn(dir) / 2).z\r\n        const volume = edges.map((edgeWC) => {\r\n            if (edgeWC.curve instanceof L3) {\r\n                return [0, V3.O];\r\n            }\r\n            else if (edgeWC.curve instanceof ImplicitCurve) {\r\n                return [0, V3.O];\r\n                // \tconst { points, tangents } = edgeWC.curve\r\n                // \tconst minT = edgeWC.minT,\r\n                // \t\tmaxT = edgeWC.maxT\r\n                // \tlet sum = 0\r\n                // \tconst start = Math.ceil(minT + NLA_PRECISION)\r\n                // \tconst end = Math.floor(maxT - NLA_PRECISION)\r\n                // \tfor (let i = start; i <= end; i++) {\r\n                // \t\tconst at = points[i],\r\n                // \t\t\ttangent = tangents[i]\r\n                // \t\tconst area = (at.z + at.rejectedFrom1(upDir1).z) / 2 * at.projectedOn(upDir1).dot(baseVector)\r\n                // \t\tconst scale = tangent.dot(scalingVector)\r\n                // \t\tsum += area * scale\r\n                // \t}\r\n                // \tconst f = (t: number) => {\r\n                // \t\tconst at = edgeWC.curve.at(t),\r\n                // \t\t\ttangent = edgeWC.curve.tangentAt(t)\r\n                // \t\tconst area = (at.z + at.rejectedFrom1(upDir1).z) / 2 * at.projectedOn(upDir1).dot(baseVector)\r\n                // \t\tconst scale = tangent.dot(scalingVector)\r\n                // \t\treturn area * scale\r\n                // \t}\r\n                // \tsum += f(minT) * (start - minT - 0.5)\r\n                // \tsum += f(maxT) * (maxT - end - 0.5)\r\n                // \treturn sum * Math.sign(edgeWC.deltaT())\r\n            }\r\n            else {\r\n                const f = (curveT) => {\r\n                    // use curve.tangent not edge.tangent, reverse edges are handled by the integration boundaries\r\n                    const at = edgeWC.curve.at(curveT), tangent = edgeWC.curve.tangentAt(curveT);\r\n                    const b = at.rejectedFrom1(upDir1);\r\n                    const area = at.z * b.to(at).dot(baseVector) / 2 + b.z * b.to(at).dot(baseVector) / 2;\r\n                    const areaCentroidA = V3.add(at.xy(), b, at).times(at.z * b.to(at).dot(baseVector) / 2 / 3);\r\n                    const areaCentroidB = V3.add(at.xy(), b, b.xy()).times(b.z * b.to(at).dot(baseVector) / 2 / 3);\r\n                    const scale = tangent.dot(scalingVector);\r\n                    return [\r\n                        area * scale,\r\n                        ...areaCentroidA\r\n                            .plus(areaCentroidB)\r\n                            .times(scale)\r\n                            .schur(V(1, 1, 2)),\r\n                    ];\r\n                };\r\n                const [vol, cx, cy, cz] = glqArray(f, edgeWC.aT, edgeWC.bT, 4);\r\n                return [vol, new V3(cx, cy, cz)];\r\n            }\r\n        });\r\n        return mergeVolumeAndCentroidZX2Parts(volume);\r\n    },\r\n    // volume does scale linearly, so this could be done in the local coordinate system\r\n    // however, shear matrices lead to point-to-plane distances having to be calculated along a vector other than\r\n    // the plane normal\r\n    [RotatedCurveSurface.name](edges) {\r\n        const dpdu = this.dpdu();\r\n        const dpdv = this.dpdv();\r\n        const totalVolume = edges\r\n            .map(edgeWC => {\r\n            const curveWC = edgeWC.curve;\r\n            const f = (curveT) => {\r\n                const pWC = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                const uvOfPWC = this.uvP(pWC);\r\n                const pLC = this.matrixInverse.transformPoint(pWC);\r\n                const dpdvAtS0 = this instanceof RotatedCurveSurface\r\n                    ? this.curve.tangentAt(uvOfPWC.y)\r\n                    : V(-pLC.z, 0, pLC.lengthXY());\r\n                // const slice = (phi: number) => {\r\n                // \tconst p = this.pUV(phi, uvOfPWC.y)\r\n                // \tconst normal = dpdu(phi, uvOfPWC.y).cross(dpdv(phi, uvOfPWC.y))\r\n                // \treturn p.z * normal.z\r\n                // }\r\n                // const z = this.curve.at(uvOfPWC.y).z\r\n                // const r = this.curve.at(uvOfPWC.y).lengthXY()\r\n                // const pz =\r\n                // \tthis.f1.z * r * cos(s) +\r\n                // \tthis.f2.z * r * sin(s) +\r\n                // \tthis.f3.z * z +\r\n                // \tthis.center.z\r\n                // const dpdux = this.f1.x * r * -sin(s) + this.f2.x * r * cos(s)\r\n                // const dpduy = this.f1.y * r * -sin(s) + this.f2.y * r * cos(s)\r\n                // const dpdvx = this.f1.x * dr * cos(s) + this.f2.x * dr * sin(s) + this.f3.x * dz\r\n                // const dpdvy = this.f1.y * dr * cos(s) + this.f2.y * dr * sin(s) + this.f3.y * dz\r\n                // const normalz = dpdux * dpdvy - dpduy * dpdvx\r\n                // result = pz * normalz\r\n                const r = pLC.lengthXY(), z = pLC.z;\r\n                const dr = dpdvAtS0.x;\r\n                const dz = dpdvAtS0.z;\r\n                const a = this.matrix.X.z * r, b = this.matrix.Y.z * r, c = this.matrix.Z.z * z + this.matrix.O.z;\r\n                const t0 = (this.matrix.X.x * this.matrix.Y.y - this.matrix.X.y * this.matrix.Y.x) * r * dr;\r\n                const t1 = (this.matrix.Y.x * this.matrix.X.y - this.matrix.Y.y * this.matrix.X.x) * r * dr;\r\n                const t2 = (this.matrix.X.x * this.matrix.X.y - this.matrix.X.y * this.matrix.X.x) * r * dr;\r\n                const t3 = (this.matrix.Y.x * this.matrix.Y.y - this.matrix.Y.y * this.matrix.Y.x) * r * dr;\r\n                const t4 = (this.matrix.Y.x * this.matrix.Z.y - this.matrix.Y.y * this.matrix.Z.x) * r * dz;\r\n                const t5 = (this.matrix.X.x * this.matrix.Z.y - this.matrix.X.y * this.matrix.Z.x) * r * dz;\r\n                const sliceIntegral = (p) => {\r\n                    return ((6 * (c * (-t0 + t1) + a * t4 - b * t5) * p +\r\n                        3 * (3 * b * t0 - b * t1 + a * (t2 - t3) + 4 * c * t5) * cos(p) +\r\n                        3 * (3 * a * t1 - a * t0 - b * (t2 - t3) + 4 * c * t4) * sin(p) +\r\n                        3 * (a * t5 - b * t4 + c * (t2 - t3)) * cos(2 * p) +\r\n                        3 * (a * t4 + b * t5 + c * (t0 + t1)) * sin(2 * p) +\r\n                        (a * (t2 - t3) - b * (t0 + t1)) * cos(3 * p) +\r\n                        (a * (t0 + t1) + b * (t2 - t3)) * sin(3 * p)) /\r\n                        12);\r\n                };\r\n                const dt = M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x, uvOfPWC.y))\r\n                    .inversed()\r\n                    .transformVector(tangentWC).y;\r\n                const sliceIntegral0ToPWCS = sliceIntegral(uvOfPWC.x); //- sliceIntegral(0) //(always 0)\r\n                const result = sliceIntegral0ToPWCS * dt;\r\n                return result;\r\n            };\r\n            return gaussLegendreQuadrature24(f, edgeWC.aT, edgeWC.bT);\r\n        })\r\n            .sum();\r\n        // calc centroid:\r\n        const centroidZX2Parts = edges.map(edgeWC => {\r\n            const f = (curveT) => {\r\n                const curveWC = edgeWC.curve;\r\n                const pWC = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                const uvOfPWC = this.uvP(pWC);\r\n                const slice = (phi) => {\r\n                    const p = this.pUV(phi, uvOfPWC.y);\r\n                    const normal = dpdu(phi, uvOfPWC.y).cross(dpdv(phi, uvOfPWC.y));\r\n                    return p.times(p.z * normal.z);\r\n                };\r\n                const sliceIntegral0ToPWCS = glqV3(slice, 0, uvOfPWC.x);\r\n                const dt = M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x, uvOfPWC.y))\r\n                    .inversed()\r\n                    .transformVector(tangentWC).y;\r\n                const result = sliceIntegral0ToPWCS.times(dt);\r\n                return result;\r\n            };\r\n            return glqV3(f, edgeWC.aT, edgeWC.bT);\r\n        });\r\n        const centroid = V3.add(...centroidZX2Parts)\r\n            .schur(new V3(1, 1, 0.5))\r\n            .div(totalVolume);\r\n        return { volume: totalVolume, centroid: centroid };\r\n    },\r\n};\r\nZDirVolumeVisitor[EllipsoidSurface.name] = ZDirVolumeVisitor[RotatedCurveSurface.name];\r\nexport function glqV3(f, startT, endT) {\r\n    return gaussLegendre24Xs\r\n        .reduce((val, currVal, index) => {\r\n        const x = startT + (currVal + 1) / 2 * (endT - startT);\r\n        return val.plus(f(x).times(gaussLegendre24Weights[index]));\r\n    }, V3.O)\r\n        .times((endT - startT) / 2);\r\n}\r\nexport function glqArray(f, startT, endT, numEls = 3) {\r\n    const result = new Array(numEls).fill(0);\r\n    for (let i = 0; i < 24; i++) {\r\n        const x = startT + (gaussLegendre24Xs[i] + 1) / 2 * (endT - startT);\r\n        const fx = f(x);\r\n        for (let j = 0; j < numEls; j++) {\r\n            result[j] += fx[j] * gaussLegendre24Weights[i];\r\n        }\r\n    }\r\n    for (let j = 0; j < numEls; j++) {\r\n        result[j] *= (endT - startT) / 2;\r\n    }\r\n    return result;\r\n}\r\nfunction mergeVolumeAndCentroidZX2Parts(volumeAndCentroidZX2Parts) {\r\n    const volume = volumeAndCentroidZX2Parts.reduce((result, [volume]) => result + volume, 0);\r\n    const weightedCentroid = V3.add(...volumeAndCentroidZX2Parts.map(([, centroidZX2]) => centroidZX2)).schur(new V3(1, 1, 0.5));\r\n    return { volume, centroid: weightedCentroid.div(volume) };\r\n}\r\n//# sourceMappingURL=ZDirVolumeVisitor.js.map","import { assert, assertf, eq, glqInSteps, M4, NLA_PRECISION } from 'ts3dutils';\r\nimport { ConicSurface, EllipseCurve, EllipsoidSurface, HyperbolaCurve, ImplicitCurve, L3, ParabolaCurve, PlaneSurface, ProjectedCurveSurface, RotatedCurveSurface, } from '../index';\r\nimport { ceil, cos, floor, sign, sin } from '../math';\r\nexport const CalculateAreaVisitor = {\r\n    [ConicSurface.name](edges) {\r\n        const dpdu = this.dpdu();\r\n        const dpdv = this.dpdv();\r\n        // calculation cannot be done in local coordinate system, as the area doesnt scale proportionally\r\n        const totalArea = edges\r\n            .map(edge => {\r\n            if (edge.curve instanceof EllipseCurve ||\r\n                edge.curve instanceof HyperbolaCurve ||\r\n                edge.curve instanceof ParabolaCurve) {\r\n                const f = (t) => {\r\n                    const at = edge.curve.at(t), tangentWC = edge.tangentAt(t);\r\n                    const uvOfPWC = this.uvP(at);\r\n                    // INTEGRATE [0; atUV.y]\r\n                    //   dpdu(atUV.x, t) X dpdv(atUV.x, t)\r\n                    // dt\r\n                    // dpdv is constant with respect to t\r\n                    // => dpdv(atUV.x, 0) X (INTEGRATE [0; atUV.y] dpdu(atUV.x, t) dt)\r\n                    // dpdu(u, v) === v * dpdu(u, 1)\r\n                    // => dpdv(atUV.x, 0) X (1/2 t² dpdu(atUV.x, 1))[0; atUV.y]\r\n                    // => dpdv(atUV.x, 0) X dpdu(atUV.x, atUV.y² / 2)\r\n                    const du = -M4.forSys(dpdu(uvOfPWC.x, uvOfPWC.y), dpdv(uvOfPWC.x))\r\n                        .inversed()\r\n                        .transformVector(tangentWC).x;\r\n                    return (dpdu(uvOfPWC.x, Math.pow(uvOfPWC.y, 2) / 2)\r\n                        .cross(dpdv(uvOfPWC.x))\r\n                        .length() * du);\r\n                };\r\n                return glqInSteps(f, edge.aT, edge.bT, 1);\r\n            }\r\n            else if (edge.curve instanceof L3) {\r\n                return 0;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        })\r\n            .sum();\r\n        return totalArea * this.normalDir;\r\n    },\r\n    [PlaneSurface.name](edges) {\r\n        let totalArea = 0;\r\n        const r1 = this.right, u1 = this.up;\r\n        for (const edge of edges) {\r\n            let edgeArea;\r\n            const curve = edge.curve;\r\n            if (curve instanceof L3) {\r\n                edgeArea = (edge.a.dot(u1) + edge.b.dot(u1)) / 2 * edge.b.to(edge.a).dot(r1);\r\n            }\r\n            else if (curve instanceof EllipseCurve) {\r\n                // INTEGRATE[aT; bT] (curve.at(t) * u1) * (tangent(t) * r1) dt\r\n                // INTEGRATE[aT; bT] (u1 f1 cos t + u1 f2 sin t + u1 c) * (r1 f1 (-sin t) + r1 f2 cos t) dt\r\n                const { f1, f2, center } = curve;\r\n                const a = u1.dot(f1), b = u1.dot(f2), c = u1.dot(center), d = r1.dot(f1), e = r1.dot(f2);\r\n                function fArea(t) {\r\n                    return (0.25 *\r\n                        (2 * (-b * d + a * e) * t +\r\n                            4 * c * d * cos(t) +\r\n                            4 * c * e * sin(t) +\r\n                            (a * d - b * e) * cos(2 * t) +\r\n                            (b * d + a * e) * sin(2 * t)));\r\n                }\r\n                edgeArea = -(fArea(edge.bT) - fArea(edge.aT));\r\n            }\r\n            else if (curve instanceof ImplicitCurve) {\r\n                throw new Error('implement for implicitCurve');\r\n            }\r\n            else {\r\n                const dir1 = u1;\r\n                assertf(() => dir1.hasLength(1));\r\n                // INT[aT; bT] at(t) * dir1 * tangentAt(t).rejectedFrom(dir1) dt\r\n                const f = (curveT) => {\r\n                    const at = curve.at(curveT);\r\n                    const tangent = curve.tangentAt(curveT);\r\n                    const ds = r1.dot(tangent);\r\n                    const t = u1.dot(at);\r\n                    return ds * t;\r\n                };\r\n                edgeArea = glqInSteps(f, edge.aT, edge.bT, 3);\r\n            }\r\n            totalArea += edgeArea;\r\n        }\r\n        assert(isFinite(totalArea));\r\n        return totalArea;\r\n    },\r\n    [RotatedCurveSurface.name](edges, canApproximate = true) {\r\n        const f1 = this.matrix.X, f2 = this.matrix.Y, f3 = this.matrix.Z;\r\n        const likeVerticalSpheroid = eq(f1.length(), f2.length()) &&\r\n            f1.isPerpendicularTo(f2) &&\r\n            f2.isPerpendicularTo(f3) &&\r\n            f3.isPerpendicularTo(f1);\r\n        const areaParts = edges.map((edgeWC, ei) => {\r\n            console.log('edge', ei, edgeWC.sce);\r\n            const curveWC = edgeWC.curve;\r\n            if (edgeWC.curve instanceof ImplicitCurve) {\r\n                throw new Error();\r\n            }\r\n            else {\r\n                if (likeVerticalSpheroid) {\r\n                    const f = (curveT) => {\r\n                        const pWC = curveWC.at(curveT), tangent = curveWC.tangentAt(curveT);\r\n                        const pLC = this.matrixInverse.transformPoint(pWC);\r\n                        const { x: angleXY, y: t } = this.uvP(pWC);\r\n                        const arcRadius = this.matrix.transformVector(pLC.xy()).length();\r\n                        const arcLength = angleXY * arcRadius;\r\n                        const dpdv = this.dpdv()(angleXY, t).unit();\r\n                        const scaling = dpdv.dot(tangent);\r\n                        return arcLength * scaling;\r\n                    };\r\n                    return glqInSteps(f, edgeWC.aT, edgeWC.bT, 1);\r\n                }\r\n                else {\r\n                    const dpdu = this.dpdu(), dpdv = this.dpdv();\r\n                    const f2 = (curveT) => {\r\n                        const pWC = curveWC.at(curveT), tangentWC = curveWC.tangentAt(curveT);\r\n                        const uvPWC = this.uvP(pWC);\r\n                        const slice = (phi) => {\r\n                            //return this.dpdu()(phi, st.y).length() * this.dpdv()(phi, st.y).length()\r\n                            return dpdu(phi, uvPWC.y)\r\n                                .cross(dpdv(phi, uvPWC.y))\r\n                                .length();\r\n                        };\r\n                        // we need to do a coordinate transform from curveT to dt, as that is what we are integrating\r\n                        const dt = M4.forSys(dpdu(uvPWC.x, uvPWC.y), dpdv(uvPWC.x, uvPWC.y))\r\n                            .inversed()\r\n                            .transformVector(tangentWC).y;\r\n                        return glqInSteps(slice, 0, uvPWC.x, 1) * dt;\r\n                    };\r\n                    return glqInSteps(f2, edgeWC.aT, edgeWC.bT, 1);\r\n                }\r\n            }\r\n        });\r\n        return areaParts.sum();\r\n    },\r\n    [ProjectedCurveSurface.name](edges) {\r\n        // calculation cannot be done in local coordinate system, as the area doesn't scale proportionally\r\n        const thisDir1 = this.dir.unit();\r\n        const totalArea = edges\r\n            .map(edge => {\r\n            if (edge.curve instanceof L3) {\r\n                return 0;\r\n            }\r\n            else if (edge.curve instanceof ImplicitCurve) {\r\n                const { points, tangents } = edge.curve;\r\n                const minT = edge.minT, maxT = edge.maxT;\r\n                let sum = 0;\r\n                const start = ceil(minT + NLA_PRECISION);\r\n                const end = floor(maxT - NLA_PRECISION);\r\n                for (let i = start; i <= end; i++) {\r\n                    const at = points[i], tangent = tangents[i]; //.toLength(edge.curve.stepSize)\r\n                    const scaling = this.normalP(at)\r\n                        .cross(thisDir1)\r\n                        .unit()\r\n                        .dot(tangent);\r\n                    sum += at.dot(thisDir1) * scaling;\r\n                }\r\n                const f = (t) => {\r\n                    const at = edge.curve.at(t), tangent = edge.curve.tangentAt(t);\r\n                    const scaling = this.normalP(at)\r\n                        .cross(thisDir1)\r\n                        .unit()\r\n                        .dot(tangent);\r\n                    return at.dot(thisDir1) * scaling;\r\n                };\r\n                sum += f(minT) * (start - minT - 0.5);\r\n                sum += f(maxT) * (maxT - end - 0.5);\r\n                return sum * sign(edge.deltaT());\r\n            }\r\n            else {\r\n                const f = (t) => {\r\n                    const at = edge.curve.at(t);\r\n                    const tangent = edge.tangentAt(t);\r\n                    const scaling = tangent.rejected1Length(thisDir1);\r\n                    return at.dot(thisDir1) * scaling;\r\n                };\r\n                const val = glqInSteps(f, edge.aT, edge.bT, 1);\r\n                const sign = Math.sign(this.normalP(edge.a)\r\n                    .cross(this.dir)\r\n                    .dot(edge.curve.tangentAt(edge.aT)));\r\n                assert(0 !== sign);\r\n                return val * sign;\r\n            }\r\n        })\r\n            .sum();\r\n        console.log('totalArea', totalArea);\r\n        return totalArea;\r\n    },\r\n};\r\nCalculateAreaVisitor[EllipsoidSurface.name] = CalculateAreaVisitor[RotatedCurveSurface.name];\r\n//# sourceMappingURL=CalculateAreaVisitor.js.map","import * as opentype from 'opentype.js';\r\nimport { arrayFromFunction, assert, assertf, assertInst, assertNumbers, assertVectors, callsce, eq, eq0, GOLDEN_RATIO, le, lerp, lt, M4, MINUS, snap, TAU, V, V3, VV, } from 'ts3dutils';\r\nimport { BezierCurve, BRep, ConicSurface, CylinderSurface, Edge, EllipseCurve, EllipsoidSurface, Face, getGlobalId, L3, NURBS, P3, PCurveEdge, PlaneFace, PlaneSurface, ProjectedCurveSurface, RotatedCurveSurface, StraightEdge, XiEtaCurve, } from './index';\r\nimport { max, min, PI, SQRT1_2 } from './math';\r\nimport { NURBSSurface } from './surface/NURBSSurface';\r\n/**\r\n * Create a surface by projecting a curve in a direction.\r\n *\r\n * @param curve The curve to project.\r\n * @param offset The direction and distance to project curve.\r\n * @param flipped Whether the surface's default orientation (normal = curve tangent cross offset) should be flipped.\r\n */\r\nexport function projectCurve(curve, offset, flipped) {\r\n    if (curve instanceof L3) {\r\n        const surfaceNormal = offset.cross(curve.dir1).toLength(flipped ? -1 : 1);\r\n        return new PlaneSurface(P3.normalOnAnchor(surfaceNormal, curve.anchor));\r\n    }\r\n    if (curve instanceof EllipseCurve) {\r\n        const curveDir = flipped ? offset : offset.negated();\r\n        return new CylinderSurface(curve, curveDir.unit(), undefined, undefined);\r\n    }\r\n    if (curve instanceof BezierCurve || curve instanceof XiEtaCurve) {\r\n        const curveDir = offset.times(flipped ? 1 : -1);\r\n        return new ProjectedCurveSurface(curve, curveDir, undefined, undefined, flipped ? 0 : -1, flipped ? 1 : 0);\r\n    }\r\n    throw new Error();\r\n}\r\n/**\r\n * Create a surface by projecting a curve onto a point.\r\n */\r\nexport function projectPointCurve(curve, tMin = curve.tMin, tMax = curve.tMax, p, flipped) {\r\n    if (curve instanceof L3) {\r\n        const up = curve.anchor.to(p).rejectedFrom(curve.dir1);\r\n        return PlaneSurface.forAnchorAndPlaneVectors(curve.anchor, curve.dir1, up.unit(), tMin, tMax, 0, up.length());\r\n    }\r\n    else if (curve instanceof EllipseCurve) {\r\n        // flip f2 by default\r\n        const factor = -1 * (flipped ? -1 : 1);\r\n        return new ConicSurface(p, curve.f1.times(factor), curve.f2, p.to(curve.center), tMin, tMax, 0, 1);\r\n    }\r\n    else {\r\n        throw new Error('projectPointCurve not implemented for ' + curve.constructor.name);\r\n    }\r\n}\r\n/**\r\n * Create a surface by rotating a curve in the XZ-plane, with X > 0, around the Z-axis according to the right-hand rule.\r\n * @param curve The curve to rotate.\r\n * @param rotationAxis The line around which to rotate the curve.\r\n * @param flipped Whether the surface's default orientation (normal = curve tangent cross rotation tangent) should be\r\n * flipped.\r\n */\r\nexport function rotateCurve(curve, tMin = curve.tMin, tMax = curve.tMax, degrees, flipped) {\r\n    assertf(() => new PlaneSurface(P3.ZX).containsCurve(curve));\r\n    if (curve instanceof L3) {\r\n        if (curve.dir1.isParallelTo(V3.Z)) {\r\n            if (eq0(curve.anchor.x)) {\r\n                return undefined;\r\n                //throw new Error('Cannot rotate curve colinear to Z axis.')\r\n            }\r\n            const baseEllipse = new EllipseCurve(V3.O, curve.anchor.xy(), curve.anchor.xy().getPerpendicular(), 0, degrees);\r\n            // if curve.dir1 is going up (+Z), it the cylinder surface should face inwards\r\n            const factor = (curve.dir1.z > 0 ? -1 : 1) * (flipped ? -1 : 1);\r\n            const [zMin, zMax] = [curve.at(tMin).z * factor, curve.at(tMax).z * factor].sort(MINUS);\r\n            return new CylinderSurface(baseEllipse, V3.Z.times(factor), 0, degrees, zMin, zMax);\r\n        }\r\n        if (curve\r\n            .at(tMin)\r\n            .xy()\r\n            .dot(curve.dir1) *\r\n            curve\r\n                .at(tMax)\r\n                .xy()\r\n                .dot(curve.dir1) <\r\n            0) {\r\n            throw new Error('line cannot cross the Z axis in the [tMin, tMax] interval, as conic surfaces cannot have an hourglass shape.');\r\n        }\r\n        if (curve.dir1.isPerpendicularTo(V3.Z)) {\r\n            // if line.dir1 is pointing aways from V3.Z, then the surface should face up\r\n            const factor = (curve.at(lerp(tMin, tMax, 0.5)).dot(curve.dir1) > 0 ? 1 : -1) * (flipped ? -1 : 1);\r\n            return new PlaneSurface(new P3(V3.Z.times(factor), curve.anchor.z * factor));\r\n        }\r\n        else {\r\n            // apex is intersection of segment with Z-axis\r\n            const a = curve.at(tMin), b = curve.at(tMax);\r\n            const apexZ = a.z - a.x * (b.z - a.z) / (b.x - a.x);\r\n            const apex = new V3(0, 0, apexZ);\r\n            const factor = -(a.x > b.x ? -1 : 1) * (flipped ? -1 : 1);\r\n            const s = new ConicSurface(apex, new V3(curve.dir1.lengthXY(), 0, 0), new V3(0, curve.dir1.lengthXY(), 0), new V3(0, 0, (a.x > b.x ? -1 : 1) * curve.dir1.z), 0, degrees, 0, 1);\r\n            return factor > 0 ? s : s.flipped();\r\n        }\r\n    }\r\n    if (curve instanceof EllipseCurve) {\r\n        const a = curve.at(tMin), b = curve.at(tMax);\r\n        const ell = curve.rightAngled();\r\n        const f1Perp = ell.f1.isPerpendicularTo(V3.Z), f2Perp = ell.f2.isPerpendicularTo(V3.Z);\r\n        if (L3.Z.containsPoint(ell.center) && (f1Perp || f2Perp)) {\r\n            flipped = flipped == a.z > b.z;\r\n            let width = ell.f1.length(), height = ell.f2.length();\r\n            if (ell.f1.isParallelTo(V3.Z)) {\r\n                ;\r\n                [width, height] = [height, width];\r\n            }\r\n            return EllipsoidSurface.forABC(width, (!flipped ? 1 : -1) * width, height, ell.center);\r\n        }\r\n        else {\r\n            const s = new RotatedCurveSurface(curve, M4.IDENTITY, tMin, tMax);\r\n            return s;\r\n        }\r\n    }\r\n    throw new Error();\r\n}\r\nexport var B2T;\r\n(function (B2T) {\r\n    /**\r\n     * Create a [BRep] of an axis-aligned box width starting at the origin and extending into +XYZ space.\r\n     * @param width x-direction size.\r\n     * @param height y-direction size.\r\n     * @param depth z-direction size.\r\n     * @param name\r\n     */\r\n    function box(width = 1, height = 1, depth = 1, name = 'box' + getGlobalId()) {\r\n        assertNumbers(width, height, depth);\r\n        assert('string' === typeof name);\r\n        const baseVertices = [new V3(0, 0, 0), new V3(0, height, 0), new V3(width, height, 0), new V3(width, 0, 0)];\r\n        const generator = callsce('B2T.box', width, height, depth, name);\r\n        return B2T.extrudeVertices(baseVertices, P3.XY.flipped(), new V3(0, 0, depth), name, generator);\r\n    }\r\n    B2T.box = box;\r\n    function puckman(radius, rads, height, name = 'puckman' + getGlobalId()) {\r\n        assertf(() => lt(0, radius));\r\n        assertf(() => lt(0, rads) && le(rads, TAU));\r\n        assertf(() => lt(0, height));\r\n        const edges = StraightEdge.chain([V3.O, new V3(radius, 0, 0), new V3(radius, 0, height), new V3(0, 0, height)], true);\r\n        return B2T.rotateEdges(edges, rads, name);\r\n    }\r\n    B2T.puckman = puckman;\r\n    function registerVertexName(map, name, p) {\r\n        // TODO\r\n        if (!Array.from(map.keys()).some(p2 => p2.like(p))) {\r\n            map.set(p, name);\r\n        }\r\n    }\r\n    B2T.registerVertexName = registerVertexName;\r\n    /**\r\n     * Create a [BRep] by projecting a number of edges in a direction.\r\n     * @param baseFaceEdges\r\n     * @param baseFacePlane\r\n     * @param offset\r\n     * @param name\r\n     * @param gen\r\n     * @param infoFactory\r\n     */\r\n    function extrudeEdges(baseFaceEdges, baseFacePlane = P3.XY, offset = V3.Z, name = 'extrude' + getGlobalId(), gen, infoFactory) {\r\n        baseFaceEdges = fixEdges(baseFaceEdges);\r\n        //Array.from(combinations(baseFaceEdges.length)).forEach(({i, j}) => {\r\n        //\tassertf(() => !Edge.edgesIntersect(baseFaceEdges[i], baseFaceEdges[j]), baseFaceEdges[i].sce +\r\n        // baseFaceEdges[j].sce) })\r\n        assertf(() => Edge.isLoop(baseFaceEdges));\r\n        // TODO checks..\r\n        //if (offset.dot(baseFacePlane.normal1) > 0) {\r\n        //\tbaseFacePlane = baseFacePlane.flipped()\r\n        //}\r\n        const vertexNames = new Map();\r\n        const basePlaneSurface = new PlaneSurface(baseFacePlane);\r\n        //assert(basePlaneSurface.edgeLoopCCW(baseFaceEdges), 'edges not CCW on baseFacePlane')\r\n        const translationMatrix = M4.translate(offset);\r\n        const topEdges = baseFaceEdges.map(edge => edge.transform(translationMatrix, 'top'));\r\n        const edgeCount = baseFaceEdges.length;\r\n        const bottomInfo = infoFactory && infoFactory.extrudeBottom(basePlaneSurface, baseFaceEdges);\r\n        const bottomFace = new PlaneFace(basePlaneSurface, baseFaceEdges, [], name + 'Bottom', bottomInfo);\r\n        const topFaceEdges = topEdges.map(edge => edge.flipped()).reverse();\r\n        const topSurface = new PlaneSurface(baseFacePlane.flipped().translated(offset));\r\n        const topInfo = infoFactory && infoFactory.extrudeBottom(topSurface, topFaceEdges);\r\n        const topFace = new PlaneFace(topSurface, topFaceEdges, [], name + 'Top', topInfo);\r\n        baseFaceEdges.forEach(edge => B2T.registerVertexName(vertexNames, edge.name + 'A', edge.a));\r\n        topFaceEdges.forEach(edge => B2T.registerVertexName(vertexNames, edge.name + 'A', edge.a));\r\n        const ribs = arrayFromFunction(edgeCount, i => StraightEdge.throughPoints(baseFaceEdges[i].a, topEdges[i].a, name + 'Rib' + i));\r\n        const faces = baseFaceEdges.map((edge, i) => {\r\n            const faceName = name + 'Wall' + i;\r\n            const j = (i + 1) % edgeCount;\r\n            const faceEdges = [baseFaceEdges[i].flipped(), ribs[i], topEdges[i], ribs[j].flipped()];\r\n            const surface = projectCurve(edge.curve, offset, edge.reversed);\r\n            const info = infoFactory && infoFactory.extrudeWall(i, surface, faceEdges);\r\n            return Face.create(surface, faceEdges, undefined, faceName, info);\r\n        });\r\n        faces.push(bottomFace, topFace);\r\n        gen = gen || callsce('B2T.extrudeEdges', baseFaceEdges, baseFacePlane, offset, name);\r\n        return new BRep(faces, baseFacePlane.normal1.dot(offset) > 0, gen, vertexNames);\r\n    }\r\n    B2T.extrudeEdges = extrudeEdges;\r\n    function cylinder(radius = 1, height = 1, rads = TAU, name = 'cylinder' + getGlobalId()) {\r\n        const vertices = [new V3(0, 0, 0), new V3(radius, 0, 0), new V3(radius, 0, height), new V3(0, 0, height)];\r\n        return rotateEdges(StraightEdge.chain(vertices, true), rads, name);\r\n    }\r\n    B2T.cylinder = cylinder;\r\n    function cone(radius = 1, height = 1, rads = TAU, name = 'cone' + getGlobalId()) {\r\n        const vertices = [new V3(0, 0, 0), new V3(radius, 0, height), new V3(0, 0, height)];\r\n        return rotateEdges(StraightEdge.chain(vertices, true), rads, name);\r\n    }\r\n    B2T.cone = cone;\r\n    function sphere(radius = 1, name = 'sphere' + getGlobalId(), rot = TAU) {\r\n        const ee = PCurveEdge.create(new EllipseCurve(V3.O, new V3(0, 0, -radius), new V3(radius, 0, 0)), new V3(0, 0, -radius), new V3(0, 0, radius), 0, PI, undefined, new V3(radius, 0, 0), new V3(-radius, 0, 0));\r\n        const generator = callsce('B2T.sphere', radius, name, rot);\r\n        return rotateEdges([StraightEdge.throughPoints(ee.b, ee.a), ee], rot, name, generator);\r\n    }\r\n    B2T.sphere = sphere;\r\n    /**\r\n     * Create a [[BRep]] of a menger sponge.\r\n     * @param res 0: just a cube, 1: every cube face has one hole, 2: 9 holes, etc\r\n     * @param name\r\n     */\r\n    function menger(res = 2, name = 'menger' + getGlobalId()) {\r\n        let result = B2T.box(1, 1, 1);\r\n        if (0 == res)\r\n            return result;\r\n        const punch = B2T.box(1 / 3, 1 / 3, 2)\r\n            .translate(1 / 3, 1 / 3, -1 / 2)\r\n            .flipped();\r\n        function recurse(steps, m4) {\r\n            result = result.and(punch.transform(m4));\r\n            if (steps > 1) {\r\n                const scaled = m4.times(M4.scale(1 / 3, 1 / 3, 1));\r\n                for (let i = 0; i < 9; i++) {\r\n                    if (4 == i)\r\n                        continue;\r\n                    recurse(steps - 1, scaled.times(M4.translate(i % 3, (i / 3) | 0, 0)));\r\n                }\r\n            }\r\n        }\r\n        recurse(res, M4.IDENTITY);\r\n        recurse(res, M4.YZX);\r\n        recurse(res, M4.ZXY);\r\n        return result;\r\n    }\r\n    B2T.menger = menger;\r\n    function menger2(res = 2, name = 'menger' + getGlobalId()) {\r\n        if (0 == res)\r\n            return B2T.box(1, 1, 1);\r\n        const punch = B2T.box(1 / 3, 1 / 3, 2)\r\n            .translate(1 / 3, 1 / 3, -1 / 2)\r\n            .flipped();\r\n        const stencilFaces = [];\r\n        function recurse(steps, m4) {\r\n            stencilFaces.push(...punch.transform(m4).faces);\r\n            if (steps > 1) {\r\n                const scaled = m4.times(M4.scale(1 / 3, 1 / 3, 1));\r\n                for (let i = 0; i < 9; i++) {\r\n                    if (4 == i)\r\n                        continue;\r\n                    recurse(steps - 1, scaled.times(M4.translate(i % 3, (i / 3) | 0, 0)));\r\n                }\r\n            }\r\n        }\r\n        recurse(res, M4.IDENTITY);\r\n        const stencil = new BRep(stencilFaces, true);\r\n        return B2T.box()\r\n            .and(stencil)\r\n            .and(stencil.transform(M4.YZX))\r\n            .and(stencil.transform(M4.ZXY));\r\n    }\r\n    B2T.menger2 = menger2;\r\n    /**\r\n     * Create a [BRep] of a torus.\r\n     * @param rSmall The radius to the surface of the torus.\r\n     * @param rLarge The radius from the origin to the inside of the torus.\r\n     * @param rads\r\n     * @param name\r\n     */\r\n    function torus(rSmall, rLarge, rads = TAU, name = 'torus' + getGlobalId()) {\r\n        assertNumbers(rSmall, rLarge, rads);\r\n        assertf(() => rLarge > rSmall);\r\n        const curves = [\r\n            EllipseCurve.semicircle(rSmall, new V3(rLarge, 0, 0)),\r\n            EllipseCurve.semicircle(-rSmall, new V3(rLarge, 0, 0)),\r\n        ];\r\n        const baseEdges = curves.map(c => PCurveEdge.forCurveAndTs(c, 0, Math.PI).rotateX(PI / 2));\r\n        return B2T.rotateEdges(baseEdges, rads, name);\r\n    }\r\n    B2T.torus = torus;\r\n    /**\r\n     * Create a [BRep] by smoothly rotating edges around Z.\r\n     * baseLoop should be CCW on XZ plane for a bounded BRep\r\n     */\r\n    function rotateEdges(baseLoop, totalRads, name = 'rotateEdges' + getGlobalId(), generator, infoFactory) {\r\n        assert(baseLoop.every(e => new PlaneSurface(P3.ZX).containsCurve(e.curve)));\r\n        assert(!eq(PI, totalRads) || PI == totalRads); // URHGJ\r\n        assertf(() => lt(0, totalRads) && le(totalRads, TAU));\r\n        totalRads = snap(totalRads, TAU);\r\n        assertf(() => Edge.isLoop(baseLoop));\r\n        const basePlane = new PlaneSurface(P3.ZX.flipped()).edgeLoopCCW(baseLoop)\r\n            ? new PlaneSurface(P3.ZX.flipped())\r\n            : new PlaneSurface(P3.ZX);\r\n        // const rotationSteps = ceil((totalRads - NLA_PRECISION) / PI)\r\n        // const angles = rotationSteps == 1 ? [-PI, -PI + totalRads] : [-PI, 0, totalRads - PI]\r\n        const open = !eq(totalRads, 2 * PI);\r\n        const baseRibCurves = baseLoop.map(edge => {\r\n            const a = edge.a, radius = a.lengthXY();\r\n            if (!eq0(radius)) {\r\n                return new EllipseCurve(V(0, 0, a.z), V(radius, 0, 0), V(0, radius, 0));\r\n            }\r\n            return undefined;\r\n        });\r\n        const baseSurfaces = baseLoop.map((edge, i) => {\r\n            const s = rotateCurve(edge.curve, edge.minT, edge.maxT, PI, edge.deltaT() > 0);\r\n            const t = lerp(edge.aT, edge.bT, 0.5);\r\n            s &&\r\n                assert(edge\r\n                    .tangentAt(t)\r\n                    .cross(V3.Y)\r\n                    .dot(s.normalP(edge.curve.at(t))) < 0);\r\n            return s;\r\n        });\r\n        let stepStartEdges = baseLoop, stepEndEdges;\r\n        const faces = [];\r\n        for (let rot = 0; rot < totalRads; rot += PI) {\r\n            const aT = 0, bT = min(totalRads - rot, PI);\r\n            const rotation = M4.rotateZ(rot + bT);\r\n            stepEndEdges = rot + bT == TAU ? baseLoop : baseLoop.map(edge => edge.transform(rotation));\r\n            const ribs = arrayFromFunction(baseLoop.length, i => {\r\n                const a = stepStartEdges[i].a, radius = a.lengthXY();\r\n                const b = stepEndEdges[i].a;\r\n                if (!eq0(radius)) {\r\n                    const curve = 0 === rot ? baseRibCurves[i] : baseRibCurves[i].rotateZ(rot);\r\n                    return new PCurveEdge(curve, a, b, aT, bT, undefined, curve.tangentAt(aT), curve.tangentAt(bT), name + 'rib' + i);\r\n                }\r\n                return undefined;\r\n            });\r\n            for (let edgeIndex = 0; edgeIndex < baseLoop.length; edgeIndex++) {\r\n                if (baseSurfaces[edgeIndex]) {\r\n                    const edge = stepStartEdges[edgeIndex];\r\n                    const ipp = (edgeIndex + 1) % baseLoop.length;\r\n                    const faceEdges = [\r\n                        stepStartEdges[edgeIndex].flipped(),\r\n                        !eq0(edge.a.x) && ribs[edgeIndex],\r\n                        stepEndEdges[edgeIndex],\r\n                        !eq0(edge.b.x) && ribs[ipp].flipped(),\r\n                    ].filter((x) => x);\r\n                    const surface = 0 === rot ? baseSurfaces[edgeIndex] : baseSurfaces[edgeIndex].rotateZ(rot);\r\n                    const info = infoFactory && infoFactory.extrudeWall(edgeIndex, surface, faceEdges, undefined);\r\n                    faces.push(Face.create(surface, faceEdges, undefined, name + 'Wall' + edgeIndex, info));\r\n                }\r\n            }\r\n            stepStartEdges = stepEndEdges;\r\n        }\r\n        if (open) {\r\n            const endFaceEdges = Edge.reversePath(stepEndEdges);\r\n            const infoStart = infoFactory && infoFactory.rotationStart(basePlane, baseLoop, undefined);\r\n            const infoEnd = infoFactory && infoFactory.rotationEnd(basePlane.flipped().rotateZ(totalRads), endFaceEdges, undefined);\r\n            faces.push(new PlaneFace(basePlane, baseLoop, undefined, name + 'start', infoStart), new PlaneFace(basePlane.flipped().rotateZ(totalRads), endFaceEdges, undefined, name + 'end', infoEnd));\r\n        }\r\n        const infiniteVolume = new PlaneSurface(P3.ZX).edgeLoopCCW(baseLoop);\r\n        return new BRep(faces, infiniteVolume, generator);\r\n    }\r\n    B2T.rotateEdges = rotateEdges;\r\n    /**\r\n     * loop should be CCW on XZ plane for a bounded BRep\r\n     */\r\n    //export function rotateEdgesUnsplit(loop: Edge[], rads: raddd, name: string): BRep {\r\n    //\tassert(Edge.isLoop(loop))\r\n    //\tconst rotationMatrix = M4.rotateZ(rads)\r\n    //\tconst open = !eq(rads, 2 * PI)\r\n    //\tconst endEdges = open ? loop.map(edge => edge.transform(rotationMatrix)) : loop\r\n    //\tconst edgeCount = loop.length\r\n    //\tconst ribs = arrayFromFunction(edgeCount, i => {\r\n    //\t\tconst a = loop[i].a, radius = a.lengthXY()\r\n    //\t\tconst b = endEdges[i].a\r\n    //\t\tif (!eq0(radius)) {\r\n    //\t\t\tconst curve = new EllipseCurve(V(0, 0, a.z), V(-radius, 0, 0), V(0, -radius, 0))\r\n    //\t\t\tconst aT = -PI, bT = -PI + rads\r\n    //\t\t\treturn new PCurveEdge(curve, a, b, aT, bT, undefined, curve.tangentAt(aT), curve.tangentAt(bT), name\r\n    // + 'rib' + i) } }) const faces = loop.map((edge, i) => { const ipp = (i + 1) % edgeCount console.log('ljl', i,\r\n    // ipp, ribs) const faceEdges = [ edge.flipped(), !eq0(edge.a.x) && ribs[i], endEdges[i], !eq0(edge.b.x) &&\r\n    // ribs[ipp].flipped()].filter(x => x) if (edge instanceof StraightEdge) { const line = edge.curve let surface if\r\n    // (line.dir1.isParallelTo(V3.Z)) { if (eq0(edge.a.x)) { return } let flipped = edge.a.z > edge.b.z surface = new\r\n    // CylinderSurface(ribs[i].curve, !flipped ? V3.Z : V3.Z.negated()) } else if\r\n    // (line.dir1.isPerpendicularTo(V3.Z)) { let flipped = edge.a.x > edge.b.x let surface = new PlaneSurface(new\r\n    // P3(V3.Z, edge.a.z)) if (!flipped) surface = surface.flipped() if (!open) { const hole = flipped ? !eq0(edge.b.x)\r\n    // && ribs[ipp].flipped() : !eq0(edge.a.x) && ribs[i] return new PlaneFace(surface, [flipped ? ribs[i] :\r\n    // ribs[ipp].flipped()], hole && [[hole]]) } return new PlaneFace(surface, faceEdges) } else { // apex is\r\n    // intersection of segment with Z-axis let a = edge.a, b = edge.b let apexZ = a.z - a.x * (b.z - a.z) / (b.x - a.x)\r\n    // let apex = new V3(0, 0, apexZ) let flipped = edge.a.z > edge.b.z surface =\r\n    // ConicSurface.atApexThroughEllipse(apex, ribs[a.x > b.x ? i : ipp].curve as EllipseCurve, !flipped ? 1 : -1)\r\n    // } return Face.create(surface, faceEdges) } if (edge.curve instanceof EllipseCurve) { let flipped = undefined\r\n    // let ell = edge.curve.rightAngled() let f1Perp = ell.f1.isPerpendicularTo(V3.Z), f2Perp =\r\n    // ell.f2.isPerpendicularTo(V3.Z) if (L3.Z.containsPoint(ell.center) && (f1Perp || f2Perp)) { let f3length = f1Perp\r\n    // ? ell.f1.length() : ell.f2.length() if (flipped) { f3length *= -1 } let surface = new\r\n    // EllipsoidSurface(ell.center, ell.f1, ell.f2, ell.f1.cross(ell.f2).toLength(f3length)) return new\r\n    // RotationFace(surface, faceEdges) } } else { assert(false, edge) } }).filter(x => x) if (open) { const\r\n    // endFaceEdges = endEdges.map(edge => edge.flipped()).reverse() faces.push( new PlaneFace(new\r\n    // PlaneSurface(P3.ZX.flipped()), loop), new PlaneFace(new PlaneSurface(P3.ZX.rotateZ(rads)), endFaceEdges)) }\r\n    // return new BRep(faces, undefined) }\r\n    function quaffle() {\r\n        const baseK = B2T.sphere(1)\r\n            .translate(0, 1.7)\r\n            .flipped();\r\n        //const baseK = B2T.box().scale(0.2).translate(0, 0.95).flipped()\r\n        // const vs = B2T.DODECAHEDRON_VERTICES.concat(\r\n        // B2T.DODECAHEDRON_FACE_VERTICES.map(fis => fis\r\n        // .map(vi => B2T.DODECAHEDRON_VERTICES[vi])\r\n        // .reduce((a,b) => a.plus(b), V3.O)\r\n        // .unit()))\r\n        const ss = new BRep(B2T.TETRAHEDRON_VERTICES.flatMap(v => baseK.rotateAB(V3.Y, v).faces), false);\r\n        //return ss\r\n        return B2T.sphere().and(ss);\r\n    }\r\n    B2T.quaffle = quaffle;\r\n    function extrudeFace(face, dir) {\r\n        return new BRep(extrudeEdges(face.contour, face.surface.plane, dir)\r\n            .faces.slice(0, -2)\r\n            .concat(face, face.translate(dir.x, dir.y, dir.z).flipped(), face.holes.flatMap(hole => extrudeEdges(hole, face.surface.plane.flipped(), dir).faces.slice(0, -2))), false);\r\n    }\r\n    B2T.extrudeFace = extrudeFace;\r\n    function loadFonts() {\r\n        return loadFont('fonts/FiraSansMedium.woff').then(font => (B2T.defaultFont = font));\r\n    }\r\n    B2T.loadFonts = loadFonts;\r\n    const loadedFonts = new Map();\r\n    function loadFont(fontPath) {\r\n        return new Promise(function (resolve, reject) {\r\n            const font = loadedFonts.get(fontPath);\r\n            if (font) {\r\n                resolve(font);\r\n            }\r\n            else {\r\n                opentype.load(fontPath, function (err, f) {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        loadedFonts.set(fontPath, f);\r\n                        resolve(f);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    B2T.loadFont = loadFont;\r\n    function loadFontsAsync(callback) {\r\n        if (B2T.defaultFont) {\r\n            callback();\r\n        }\r\n        else {\r\n            opentype.load('fonts/FiraSansMedium.woff', function (err, font) {\r\n                if (err) {\r\n                    throw new Error('Could not load font: ' + err);\r\n                }\r\n                else {\r\n                    B2T.defaultFont = font;\r\n                    callback();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    B2T.loadFontsAsync = loadFontsAsync;\r\n    /**\r\n     * Create the [BRep] of a string rendered in a font.\r\n     * @param text\r\n     * @param size\r\n     * @param depth\r\n     * @param font An opentype.js font.\r\n     */\r\n    function text(text, size, depth = 1, font = B2T.defaultFont) {\r\n        const path = font.getPath(text, 0, 0, size);\r\n        const subpaths = [];\r\n        path.commands.forEach(c => {\r\n            if (c.type == 'M') {\r\n                subpaths.push([]);\r\n            }\r\n            subpaths.last.push(c);\r\n        });\r\n        const loops = subpaths.map(sp => {\r\n            const path = new opentype.Path();\r\n            path.commands = sp;\r\n            const loop = Edge.reversePath(Edge.pathFromSVG(path.toPathData(13))).map(e => e.mirrorY());\r\n            assert(Edge.isLoop(loop));\r\n            return loop;\r\n        });\r\n        const faces = Face.assembleFacesFromLoops(loops, new PlaneSurface(P3.XY), PlaneFace);\r\n        const generator = callsce('B2T.text', text, size, depth);\r\n        return BRep.join(faces.map(face => B2T.extrudeFace(face, V(0, 0, -depth))), generator);\r\n    }\r\n    B2T.text = text;\r\n    function minorityReport() {\r\n        const a = B2T.sphere();\r\n        const b = B2T.text('LEO CROW', 64, 128)\r\n            .scale(0.1 / 32)\r\n            .translate(-0.5, -0.05, 1.2)\r\n            .flipped();\r\n        const c = B2T.sphere(0.98);\r\n        return a.and(b).plus(c);\r\n    }\r\n    B2T.minorityReport = minorityReport;\r\n    function whatever() {\r\n        const iso = icosahedron();\r\n        const numbersBRep = BRep.join(iso.faces.map((face, i) => {\r\n            const numberBRep = text('' + (i + 1), 0.4, -2);\r\n            const centroid = face.contour\r\n                .map(edge => edge.a)\r\n                .reduce((a, b) => a.plus(b), V3.O)\r\n                .div(3);\r\n            const sys = M4.forSys(face.contour[0].aDir, centroid.cross(face.contour[0].aDir), centroid.unit(), centroid);\r\n            return numberBRep.transform(sys.times(M4.translate(-numberBRep.getAABB().size().x / 2, -0.1, -0.04)));\r\n        }));\r\n        const s = sphere(0.9);\r\n        //return iso.and(numbersBRep)\r\n        return iso.and(s).and(numbersBRep);\r\n        //return numbersBRep\r\n    }\r\n    B2T.whatever = whatever;\r\n    function whatever3() {\r\n        const t = B2T.torus(1, 2);\r\n        return B2T.box(5, 5, 2)\r\n            .translate(-2.5, -2.5)\r\n            .minus(t);\r\n    }\r\n    B2T.whatever3 = whatever3;\r\n    function d20() {\r\n        const iso = icosahedron();\r\n        const numbersBRep = BRep.join(iso.faces.map((face, i) => {\r\n            const numberBRep = text('' + (i + 1), 0.4, -2);\r\n            const centroid = face.contour\r\n                .map(edge => edge.a)\r\n                .reduce((a, b) => a.plus(b), V3.O)\r\n                .div(3);\r\n            const sys = M4.forSys(face.contour[0].aDir, centroid.cross(face.contour[0].aDir), centroid.unit(), centroid);\r\n            return numberBRep.transform(sys.times(M4.translate(-numberBRep.getAABB().size().x / 2, -0.1, -0.04)));\r\n        }));\r\n        const s = sphere(0.9);\r\n        //return iso.and(numbersBRep)\r\n        return iso.and(s).and(numbersBRep);\r\n        //return numbersBRep\r\n    }\r\n    B2T.d20 = d20;\r\n    function rotStep(edges, totalRadsOrAngles, countO) {\r\n        const angles = 'number' === typeof totalRadsOrAngles\r\n            ? arrayFromFunction(countO, i => (i + 1) / countO * totalRadsOrAngles)\r\n            : totalRadsOrAngles;\r\n        const count = angles.length;\r\n        const open = !eq(TAU, angles.last);\r\n        const ribs = [\r\n            edges,\r\n            ...angles.map(phi => {\r\n                if (eq(TAU, phi)) {\r\n                    return edges;\r\n                }\r\n                const matrix = M4.rotateZ(phi);\r\n                return edges.map(edge => edge.transform(matrix));\r\n            }),\r\n        ];\r\n        const horizontalEdges = arrayFromFunction(count, i => {\r\n            const ipp = (i + 1) % (count + 1);\r\n            return arrayFromFunction(edges.length, j => {\r\n                if (!eq0(edges[j].a.lengthXY())) {\r\n                    return StraightEdge.throughPoints(ribs[i][j].a, ribs[ipp][j].a);\r\n                }\r\n                return undefined;\r\n            });\r\n        });\r\n        const faces = [];\r\n        let face;\r\n        edges.forEach((edge, i) => {\r\n            const ipp = (i + 1) % edges.length;\r\n            // for straight edges perpendicular to the Z-axis, we only create one face.\r\n            if (edge instanceof StraightEdge && edge.curve.dir1.isPerpendicularTo(V3.Z)) {\r\n                const flipped = edge.a.x > edge.b.x;\r\n                const surface = new PlaneSurface(flipped ? new P3(V3.Z, edge.a.z) : new P3(V3.Z.negated(), -edge.a.z));\r\n                if (open) {\r\n                    const faceEdges = [];\r\n                    if (!eq0(edge.a.x)) {\r\n                        faceEdges.push(...arrayFromFunction(count, j => horizontalEdges[j][i]));\r\n                    }\r\n                    faceEdges.push(ribs[count][i]);\r\n                    if (!eq0(edge.b.x)) {\r\n                        faceEdges.push(...arrayFromFunction(count, j => horizontalEdges[count - j - 1][ipp].flipped()));\r\n                    }\r\n                    faceEdges.push(edge.flipped());\r\n                    face = new PlaneFace(surface, faceEdges);\r\n                }\r\n                else {\r\n                    const contour = flipped\r\n                        ? arrayFromFunction(count, j => horizontalEdges[j][i])\r\n                        : arrayFromFunction(count, j => horizontalEdges[count - j - 1][ipp].flipped());\r\n                    let hole;\r\n                    if (flipped && !eq0(edge.b.x)) {\r\n                        hole = arrayFromFunction(count, j => horizontalEdges[count - j - 1][ipp].flipped());\r\n                    }\r\n                    else if (!flipped && !eq0(edge.a.x)) {\r\n                        hole = arrayFromFunction(count, j => horizontalEdges[j][i]);\r\n                    }\r\n                    face = new PlaneFace(surface, contour, hole ? [hole] : []);\r\n                }\r\n                faces.push(face);\r\n                return;\r\n            }\r\n            else if (edge instanceof StraightEdge) {\r\n                if (eq0(edge.a.lengthXY()) && eq0(edge.b.lengthXY())) {\r\n                    return;\r\n                }\r\n            }\r\n            for (let r = 0; r < count; r++) {\r\n                const rpp = (r + 1) % (count + 1);\r\n                const faceEdges = [\r\n                    ribs[r][i].flipped(),\r\n                    horizontalEdges[r][i],\r\n                    ribs[rpp][i],\r\n                    horizontalEdges[r][ipp] && horizontalEdges[r][ipp].flipped(),\r\n                ].filter(x => x);\r\n                let surface;\r\n                if (edge instanceof StraightEdge) {\r\n                    surface = new PlaneSurface(P3.throughPoints(faceEdges[0].a, faceEdges[1].a, faceEdges[2].a));\r\n                }\r\n                else {\r\n                    const maxX = edges[i].getAABB().max.x;\r\n                    const phi = angles[r], prevPhi = 0 == r ? 0 : angles[r - 1];\r\n                    const offset = V3.polar(maxX, prevPhi).to(V3.polar(maxX, phi));\r\n                    surface = projectCurve(ribs[r][i].curve, offset, false);\r\n                }\r\n                faces.push(Face.create(surface, faceEdges));\r\n            }\r\n        });\r\n        if (open) {\r\n            const endFaceEdges = ribs[count].map(edge => edge.flipped()).reverse();\r\n            const endFace = new PlaneFace(new PlaneSurface(P3.ZX.rotateZ(angles.last)), endFaceEdges);\r\n            faces.push(new PlaneFace(new PlaneSurface(P3.ZX.flipped()), edges), endFace);\r\n        }\r\n        return new BRep(faces, new PlaneSurface(P3.ZX).edgeLoopCCW(edges));\r\n    }\r\n    B2T.rotStep = rotStep;\r\n    function fixEdges(edges) {\r\n        return edges.flatMap(edge => {\r\n            const c = edge.curve;\r\n            if (c instanceof EllipseCurve && c.tMin === -PI && c.tMax === PI) {\r\n                const splitEdges = edge.minT < 0 && edge.maxT > 0 ? edge.split(0) : [edge];\r\n                return splitEdges.map(edge => {\r\n                    if (edge.minT >= 0) {\r\n                        return Edge.create(new EllipseCurve(c.center, c.f1, c.f2, max(0, c.tMin), c.tMax), edge.a, edge.b, edge.aT, edge.bT, undefined, edge.aDir, edge.bDir, edge.name);\r\n                    }\r\n                    else {\r\n                        // \"rotate\" the curve\r\n                        return Edge.create(new EllipseCurve(c.center, c.f1.negated(), c.f2.negated(), c.tMin + PI, min(PI, c.tMax + PI)), edge.a, edge.b, edge.aT + PI, edge.bT + PI, undefined, edge.aDir, edge.bDir, edge.name);\r\n                    }\r\n                });\r\n            }\r\n            if (c instanceof BezierCurve) {\r\n                if (edge.a.like(edge.b)) {\r\n                    return edge.split(lerp(edge.aT, edge.bT, 0.5));\r\n                }\r\n            }\r\n            return edge;\r\n        });\r\n    }\r\n    B2T.fixEdges = fixEdges;\r\n    /**\r\n     * Create a [BRep] by projecting edges created by joining vertices with straight edges.\r\n     * @param baseVertices\r\n     * @param baseFacePlane\r\n     * @param offset\r\n     * @param name\r\n     * @param generator\r\n     */\r\n    function extrudeVertices(baseVertices, baseFacePlane, offset, name, generator) {\r\n        assert(baseVertices.every(v => v instanceof V3), 'baseVertices.every(v => v instanceof V3)');\r\n        assertInst(P3, baseFacePlane);\r\n        assertVectors(offset);\r\n        if (baseFacePlane.normal1.dot(offset) > 0)\r\n            baseFacePlane = baseFacePlane.flipped();\r\n        const edges = StraightEdge.chain(baseVertices, true);\r\n        generator = generator || callsce('B2T.extrudeVertices', baseVertices, baseFacePlane, offset, name);\r\n        return B2T.extrudeEdges(edges, baseFacePlane, offset, name, generator);\r\n    }\r\n    B2T.extrudeVertices = extrudeVertices;\r\n    /**\r\n     * Create a tetrahedron (3 sided pyramid) [BRep].\r\n     * `a`, `b`, `c` and `d` can be in any order. The only constraint is that they cannot be on a common plane.\r\n     * The resulting tetrahedron will always have outwards facing faces.\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     * @param name\r\n     */\r\n    function tetrahedron(a, b, c, d, name = 'tetra' + getGlobalId()) {\r\n        assertVectors(a, b, c, d);\r\n        const dDistance = P3.throughPoints(a, b, c).distanceToPointSigned(d);\r\n        if (eq0(dDistance)) {\r\n            throw new Error('four points are coplanar');\r\n        }\r\n        if (dDistance > 0) {\r\n            ;\r\n            [c, d] = [d, c];\r\n        }\r\n        const ab = StraightEdge.throughPoints(a, b);\r\n        const ac = StraightEdge.throughPoints(a, c);\r\n        const ad = StraightEdge.throughPoints(a, d);\r\n        const bc = StraightEdge.throughPoints(b, c);\r\n        const bd = StraightEdge.throughPoints(b, d);\r\n        const cd = StraightEdge.throughPoints(c, d);\r\n        const faces = [\r\n            new PlaneFace(PlaneSurface.throughPoints(a, b, c), [ab, bc, ac.flipped()], [], name + 'abc'),\r\n            new PlaneFace(PlaneSurface.throughPoints(a, d, b), [ad, bd.flipped(), ab.flipped()], [], name + 'adb'),\r\n            new PlaneFace(PlaneSurface.throughPoints(b, d, c), [bd, cd.flipped(), bc.flipped()], [], name + 'bdc'),\r\n            new PlaneFace(PlaneSurface.throughPoints(c, d, a), [cd, ad.flipped(), ac], [], name + 'cda'),\r\n        ];\r\n        const gen = callsce('B2T.tetrahedron', a, b, c, d);\r\n        return new BRep(faces, false, gen);\r\n    }\r\n    B2T.tetrahedron = tetrahedron;\r\n    const b = 1 / GOLDEN_RATIO, c = 2 - GOLDEN_RATIO;\r\n    B2T.TETRAHEDRON_VERTICES = [\r\n        new V3(1, 0, -SQRT1_2),\r\n        new V3(-1, 0, -SQRT1_2),\r\n        new V3(0, -1, SQRT1_2),\r\n        new V3(0, 1, SQRT1_2),\r\n    ].map(v => v.unit());\r\n    B2T.DODECAHEDRON_VERTICES = [\r\n        new V3(c, 0, 1),\r\n        new V3(-c, 0, 1),\r\n        new V3(-b, b, b),\r\n        new V3(0, 1, c),\r\n        new V3(b, b, b),\r\n        new V3(b, -b, b),\r\n        new V3(0, -1, c),\r\n        new V3(-b, -b, b),\r\n        new V3(c, 0, -1),\r\n        new V3(-c, 0, -1),\r\n        new V3(-b, -b, -b),\r\n        new V3(0, -1, -c),\r\n        new V3(b, -b, -b),\r\n        new V3(b, b, -b),\r\n        new V3(0, 1, -c),\r\n        new V3(-b, b, -b),\r\n        new V3(1, c, 0),\r\n        new V3(-1, c, 0),\r\n        new V3(-1, -c, 0),\r\n        new V3(1, -c, 0),\r\n    ].map(v => v.unit());\r\n    B2T.DODECAHEDRON_FACE_VERTICES = [\r\n        [4, 3, 2, 1, 0],\r\n        [7, 6, 5, 0, 1],\r\n        [12, 11, 10, 9, 8],\r\n        [15, 14, 13, 8, 9],\r\n        [14, 3, 4, 16, 13],\r\n        [3, 14, 15, 17, 2],\r\n        [11, 6, 7, 18, 10],\r\n        [6, 11, 12, 19, 5],\r\n        [4, 0, 5, 19, 16],\r\n        [12, 8, 13, 16, 19],\r\n        [15, 9, 10, 18, 17],\r\n        [7, 1, 2, 17, 18],\r\n    ];\r\n    B2T.OCTAHEDRON_VERTICES = [\r\n        new V3(1, 0, 0),\r\n        new V3(-1, 0, 0),\r\n        new V3(0, 1, 0),\r\n        new V3(0, -1, 0),\r\n        new V3(0, 0, 1),\r\n        new V3(0, 0, -1),\r\n    ];\r\n    B2T.OCTAHEDRON_FACE_VERTICES = [\r\n        [0, 2, 4],\r\n        [2, 1, 4],\r\n        [1, 3, 4],\r\n        [3, 0, 4],\r\n        [2, 0, 5],\r\n        [1, 2, 5],\r\n        [3, 1, 5],\r\n        [0, 3, 5],\r\n    ];\r\n    const { x: s, y: t } = new V3(1, GOLDEN_RATIO, 0).unit();\r\n    B2T.ICOSAHEDRON_VERTICES = [\r\n        new V3(-s, t, 0),\r\n        new V3(s, t, 0),\r\n        new V3(-s, -t, 0),\r\n        new V3(s, -t, 0),\r\n        new V3(0, -s, t),\r\n        new V3(0, s, t),\r\n        new V3(0, -s, -t),\r\n        new V3(0, s, -t),\r\n        new V3(t, 0, -s),\r\n        new V3(t, 0, s),\r\n        new V3(-t, 0, -s),\r\n        new V3(-t, 0, s),\r\n    ];\r\n    B2T.ICOSAHEDRON_FACE_VERTICES = [\r\n        // 5 faces around point 0\r\n        [0, 11, 5],\r\n        [0, 5, 1],\r\n        [0, 1, 7],\r\n        [0, 7, 10],\r\n        [0, 10, 11],\r\n        // 5 adjacent faces\r\n        [1, 5, 9],\r\n        [5, 11, 4],\r\n        [11, 10, 2],\r\n        [10, 7, 6],\r\n        [7, 1, 8],\r\n        // 5 faces around point 3\r\n        [3, 9, 4],\r\n        [3, 4, 2],\r\n        [3, 2, 6],\r\n        [3, 6, 8],\r\n        [3, 8, 9],\r\n        // 5 adjacent faces\r\n        [4, 9, 5],\r\n        [2, 4, 11],\r\n        [6, 2, 10],\r\n        [8, 6, 7],\r\n        [9, 8, 1],\r\n    ];\r\n    /**\r\n     * Create a dodecahedron [BRep]. The vertices are on the unit sphere.\r\n     */\r\n    function dodecahedron() {\r\n        return makePlatonic(B2T.DODECAHEDRON_VERTICES, B2T.DODECAHEDRON_FACE_VERTICES, 'B2T.dodecahedron()');\r\n    }\r\n    B2T.dodecahedron = dodecahedron;\r\n    /**\r\n     * Create an octahedron [BRep]. The vertices are on the unit sphere.\r\n     */\r\n    function octahedron() {\r\n        return makePlatonic(B2T.OCTAHEDRON_VERTICES, B2T.OCTAHEDRON_FACE_VERTICES, 'B2T.octahedron()');\r\n    }\r\n    B2T.octahedron = octahedron;\r\n    /**\r\n     * Create an icosahedron [BRep]. The vertices are on the unit sphere.\r\n     */\r\n    function icosahedron() {\r\n        return makePlatonic(B2T.ICOSAHEDRON_VERTICES, B2T.ICOSAHEDRON_FACE_VERTICES, 'B2T.icosahedron()');\r\n    }\r\n    B2T.icosahedron = icosahedron;\r\n    function makePlatonic(VS, FVIS, generator) {\r\n        const edgeMap = new Map();\r\n        const faces = FVIS.map(faceIndexes => {\r\n            const surface = PlaneSurface.throughPoints(VS[faceIndexes[0]], VS[faceIndexes[1]], VS[faceIndexes[2]]);\r\n            const contour = arrayFromFunction(faceIndexes.length, i => {\r\n                const ipp = (i + 1) % faceIndexes.length;\r\n                const iA = faceIndexes[i], iB = faceIndexes[ipp];\r\n                const iMin = min(iA, iB), iMax = max(iA, iB), edgeID = iMin * VS.length + iMax;\r\n                let edge = edgeMap.get(edgeID);\r\n                !edge && edgeMap.set(edgeID, (edge = StraightEdge.throughPoints(VS[iMin], VS[iMax])));\r\n                return iA < iB ? edge : edge.flipped();\r\n            });\r\n            return new PlaneFace(surface, contour);\r\n        });\r\n        return new BRep(faces, false, generator);\r\n    }\r\n    /**\r\n     * Create a [BRep] by projecting a number of edges onto a point.\r\n     * @param baseEdges The edges forming the base of the pyramid.\r\n     * @param apex The tip of the pyramid.\r\n     * @param name\r\n     */\r\n    function pyramidEdges(baseEdges, apex, name = 'pyramid' + getGlobalId()) {\r\n        assertInst(Edge, ...baseEdges);\r\n        assertVectors(apex);\r\n        const ribs = baseEdges.map(baseEdge => StraightEdge.throughPoints(apex, baseEdge.a));\r\n        const faces = baseEdges.map((baseEdge, i) => {\r\n            const faceName = name + 'Wall' + i;\r\n            const ipp = (i + 1) % baseEdges.length;\r\n            const faceEdges = [ribs[i], baseEdge, ribs[ipp].flipped()];\r\n            const surface = projectPointCurve(baseEdge.curve, baseEdge.minT, baseEdge.maxT, apex, baseEdge.deltaT() < 0);\r\n            return Face.create(surface, faceEdges, undefined, faceName);\r\n        });\r\n        const baseSurface = new PlaneSurface(P3.XY).flipped();\r\n        const bottomFace = Face.create(baseSurface, Edge.reversePath(baseEdges));\r\n        faces.push(bottomFace);\r\n        const generator = callsce('B2T.pyramidEdges', baseEdges, apex, name);\r\n        return new BRep(faces, false, generator);\r\n    }\r\n    B2T.pyramidEdges = pyramidEdges;\r\n    function fromBPT(bpt) {\r\n        const lineRegex = /.+/g;\r\n        const ilog = x => (console.log(x), x);\r\n        const readLine = () => lineRegex.exec(bpt)[0];\r\n        const readLineNumbers = () => readLine()\r\n            .trim()\r\n            .split(/\\s+/)\r\n            .map(s => parseFloat(s));\r\n        const numOfPatches = parseInt(readLine());\r\n        const faces = arrayFromFunction(numOfPatches, () => {\r\n            const [pointsUCount, pointsVCount] = readLineNumbers();\r\n            const points = Array.from({ length: (pointsUCount + 1) * (pointsVCount + 1) }, () => VV(...readLineNumbers(), 1));\r\n            const surface = new NURBSSurface(points, NURBS.bezierKnots(pointsUCount), NURBS.bezierKnots(pointsVCount), pointsUCount, pointsVCount, 0, 1, 0, 1);\r\n            return surface;\r\n            const edges = [\r\n                Edge.forCurveAndTs(surface.isoparametricV(0)),\r\n                Edge.forCurveAndTs(surface.isoparametricU(1)),\r\n                Edge.forCurveAndTs(surface.isoparametricV(1)).flipped(),\r\n                Edge.forCurveAndTs(surface.isoparametricU(0)).flipped(),\r\n            ];\r\n            return Face.create(surface, edges);\r\n        });\r\n        return faces;\r\n        return new BRep(faces, false);\r\n    }\r\n    B2T.fromBPT = fromBPT;\r\n})(B2T || (B2T = {}));\r\n//# sourceMappingURL=BRepGenerators.js.map","import { callsce } from 'ts3dutils';\r\nimport chroma from 'chroma-js';\r\nimport { GL_COLOR_BLACK } from 'tsgl';\r\nimport { getGlobalId, L3, P3, PlaneSurface } from './index';\r\nexport class CustomPlane extends P3 {\r\n    constructor(anchor, right, up, name = 'CustomPlane' + getGlobalId(), color = chroma.random().gl(), rightStart = -500, rightEnd = 500, upStart = -500, upEnd = 500) {\r\n        const { normal1, w } = P3.forAnchorAndPlaneVectors(anchor, right, up);\r\n        super(normal1, w);\r\n        this.up = up;\r\n        this.right = right;\r\n        this.uMin = rightStart;\r\n        this.uMax = rightEnd;\r\n        this.vMin = upStart;\r\n        this.vMax = upEnd;\r\n        this.name = name;\r\n        this.color = color;\r\n    }\r\n    get plane() {\r\n        return this;\r\n    }\r\n    toPlaneSurface() {\r\n        return new PlaneSurface(this, this.right, this.up);\r\n    }\r\n    toSource() {\r\n        return callsce('new CustomPlane', this.anchor, this.right, this.up, this.name, this.color, this.sMin, this.sMax, this.tMin, this.tMax);\r\n    }\r\n    static forPlane(plane, color = GL_COLOR_BLACK, name) {\r\n        //assert(!name)\r\n        const up = plane.normal1.getPerpendicular().unit(), right = up.cross(plane.normal1);\r\n        return new CustomPlane(plane.anchor, right, up, name, color);\r\n    }\r\n    static fromPlaneSurface(surface) {\r\n        return new CustomPlane(surface.plane.anchor, surface.right, surface.up, 'genCustomPlane' + getGlobalId());\r\n    }\r\n    distanceTo(line, mindist) {\r\n        return [\r\n            new L3(this.anchor.plus(this.right.times(this.uMin)), this.up),\r\n            new L3(this.anchor.plus(this.right.times(this.uMax)), this.up),\r\n            new L3(this.anchor.plus(this.up.times(this.vMin)), this.right),\r\n            new L3(this.anchor.plus(this.up.times(this.vMax)), this.right),\r\n        ]\r\n            .map((line2, line2Index) => {\r\n            const info = line2.infoClosestToLine(line);\r\n            if ((isNaN(info.t) || // parallel LINES\r\n                (line2Index < 2 && this.vMin <= info.t && info.t <= this.vMax) ||\r\n                (line2Index >= 2 && this.uMin <= info.t && info.t <= this.uMax)) &&\r\n                info.distance <= mindist) {\r\n                return info.s;\r\n            }\r\n            else {\r\n                return Infinity;\r\n            }\r\n        })\r\n            .min();\r\n    }\r\n    distanceTo2(line, mindist) {\r\n        return [\r\n            new L3(this.anchor.plus(this.right.times(this.uMin)), this.up),\r\n            new L3(this.anchor.plus(this.right.times(this.uMax)), this.up),\r\n            new L3(this.anchor.plus(this.up.times(this.vMin)), this.right),\r\n            new L3(this.anchor.plus(this.up.times(this.vMax)), this.right),\r\n        ]\r\n            .map((line2, line2Index) => {\r\n            const info = line2.infoClosestToLine(line);\r\n            if ((isNaN(info.t) || // parallel LINES\r\n                (line2Index < 2 && this.vMin <= info.t && info.t <= this.vMax) ||\r\n                (line2Index >= 2 && this.uMin <= info.t && info.t <= this.uMax)) &&\r\n                info.distance <= mindist) {\r\n                return info.distance;\r\n            }\r\n            else {\r\n                return Infinity;\r\n            }\r\n        })\r\n            .min();\r\n    }\r\n}\r\n//# sourceMappingURL=CustomPlane.js.map","import { SVGPathData } from 'svg-pathdata';\r\nimport { AABB, arrayFromFunction, arrayRange, assert, assertf, assertInst, assertNumbers, assertVectors, callsce, clamp, DEG, eq, eq0, fuzzyBetween, getIntervals, le, lt, M4, MINUS, mod, newtonIterate, NLA_PRECISION, snap2, TAU, Transformable, V, V3, snap, } from 'ts3dutils';\r\nimport { BezierCurve, Curve, EllipseCurve, L3, ParabolaCurve, PICurve, PlaneSurface } from './index';\r\nimport { abs, ceil, floor, PI, sign } from './math';\r\nexport class Edge extends Transformable {\r\n    constructor(curve, a, b, aT, bT, flippedOf, name) {\r\n        super();\r\n        this.curve = curve;\r\n        this.a = a;\r\n        this.b = b;\r\n        this.aT = aT;\r\n        this.bT = bT;\r\n        this.flippedOf = flippedOf;\r\n        this.name = name;\r\n        assertNumbers(aT, bT);\r\n        assert(!eq(aT, bT));\r\n        assertVectors(a, b);\r\n        assertf(() => curve instanceof Curve, curve);\r\n        assertf(() => !curve.isValidT || (curve.isValidT(aT) && curve.isValidT(bT)), aT, bT, curve);\r\n        //if (curve instanceof PICurve) {\r\n        //    assertf(() => curve.at(aT).to(a).length() < 0.1, ''+curve.at(aT)+a)\r\n        //    assertf(() => curve.at(bT).to(b).length() < 0.1, '' + curve.at(bT) + b)\r\n        //} else {\r\n        assertf(() => curve.at(aT).like(a), () => '' + curve.at(aT) + a + ' aT should have been ' + curve.pointT(a));\r\n        assertf(() => curve.at(bT).like(b), () => '' + curve.at(bT) + b + ' bT should have been ' + curve.pointT(b));\r\n        //}\r\n        assertf(() => fuzzyBetween(aT, curve.tMin, curve.tMax), aT, curve.tMin, curve.tMax);\r\n        assertf(() => fuzzyBetween(bT, curve.tMin, curve.tMax), bT, curve.tMin, curve.tMax);\r\n        this.aT = clamp(aT, curve.tMin, curve.tMax);\r\n        this.bT = clamp(bT, curve.tMin, curve.tMax);\r\n        this.reversed = this.aT > this.bT;\r\n    }\r\n    get minT() {\r\n        return Math.min(this.aT, this.bT);\r\n    }\r\n    get maxT() {\r\n        return Math.max(this.aT, this.bT);\r\n    }\r\n    static forCurveAndTs(curve, aT = curve.tMin, bT = curve.tMax) {\r\n        return Edge.create(curve, curve.at(aT), curve.at(bT), aT, bT, undefined, aT < bT ? curve.tangentAt(aT) : curve.tangentAt(aT).negated(), aT < bT ? curve.tangentAt(bT) : curve.tangentAt(bT).negated());\r\n    }\r\n    static create(curve, a, b, aT, bT, flippedOf, aDir, bDir, name) {\r\n        if (curve instanceof L3) {\r\n            return new StraightEdge(curve, a, b, aT, bT, flippedOf, name);\r\n        }\r\n        else {\r\n            return new PCurveEdge(curve, a, b, aT, bT, flippedOf, aDir, bDir, name);\r\n        }\r\n    }\r\n    static isLoop(loop) {\r\n        return loop.every((edge, i) => edge.b.like(loop[(i + 1) % loop.length].a));\r\n    }\r\n    static edgesIntersect(e1, e2) {\r\n        // TODO: still getting some NaNs here..\r\n        assertNumbers(e1.curve.hlol, e2.curve.hlol);\r\n        assertInst(Edge, e1, e2);\r\n        if (e1.curve.hlol < e2.curve.hlol) {\r\n            ;\r\n            [e2, e1] = [e1, e2];\r\n        }\r\n        const sts = e1.curve.isInfosWithCurve(e2.curve);\r\n        if (sts.some(info => isNaN(info.tThis) || isNaN(info.tOther))) {\r\n            console.log(e1.sce);\r\n            console.log(e2.sce);\r\n            assert(false);\r\n        }\r\n        return sts.some(\r\n        /// (  e1.aT < tThis < e1.bT  )  &&  (  e2.aT < tOther < e2.bT  )\r\n        ({ tThis, tOther }) => {\r\n            return e1.tValueInside(tThis) && e2.tValueInside(tOther);\r\n        });\r\n    }\r\n    static assertLoop(edges) {\r\n        edges.forEach((edge, i) => {\r\n            const j = (i + 1) % edges.length;\r\n            assert(edge.b.like(edges[j].a), `edges[${i}].b != edges[${j}].a (${edges[i].b.sce} != ${edges[j].a.sce})`);\r\n        });\r\n    }\r\n    static ngon(n = 3, radius = 1) {\r\n        return StraightEdge.chain(arrayFromFunction(n, i => V3.polar(radius, TAU * i / n)));\r\n    }\r\n    static star(pointCount = 5, r0 = 1, r1 = 0.5) {\r\n        const vertices = arrayFromFunction(pointCount * 2, i => V3.polar(0 == i % 2 ? r0 : r1, TAU * i / pointCount / 2));\r\n        return StraightEdge.chain(vertices);\r\n    }\r\n    static reversePath(path, doReverse = true) {\r\n        return doReverse ? arrayFromFunction(path.length, i => path[path.length - 1 - i].flipped()) : path;\r\n    }\r\n    /**\r\n     * Create an axis-aligned rectangle of edges on the XY-plane with the bottom-left corner on the origin.\r\n     * @param width\r\n     * @param height\r\n     */\r\n    static rect(width = 1, height = width) {\r\n        const vertices = [new V3(0, 0, 0), new V3(width, 0, 0), new V3(width, height, 0), new V3(0, height, 0)];\r\n        return StraightEdge.chain(vertices);\r\n    }\r\n    static reuleaux(n = 3, radius = 1) {\r\n        assert(3 <= n);\r\n        assert(1 == n % 2);\r\n        const corners = arrayFromFunction(n, i => V3.polar(radius, TAU * i / n));\r\n        return arrayFromFunction(n, i => {\r\n            const aI = (i + floor(n / 2)) % n, bI = (i + ceil(n / 2)) % n;\r\n            const a = corners[aI], b = corners[bI];\r\n            const center = corners[i];\r\n            const f1 = center.to(a), curve = new EllipseCurve(center, f1, V3.Z.cross(f1));\r\n            return Edge.create(curve, a, b, 0, curve.pointT(b), undefined, V3.Z.cross(f1), V3.Z.cross(center.to(b)));\r\n        });\r\n    }\r\n    static round(edges, radius) {\r\n        if (eq0(radius)) {\r\n            return edges;\r\n        }\r\n        const corners = edges.map((edge, i) => {\r\n            const j = (i + 1) % edges.length, nextEdge = edges[j];\r\n            if (!edge.b.like(nextEdge.a))\r\n                return undefined;\r\n            const angleToNext = edge.bDir.angleTo(nextEdge.aDir);\r\n            const c1 = edge.curve, c2 = nextEdge.curve;\r\n            if (c1 instanceof L3 && c2 instanceof L3) {\r\n                const normal = c1.dir1.cross(c2.dir1);\r\n                if (eq0(angleToNext))\r\n                    return undefined;\r\n                const l1inside = normal.cross(c1.dir1), l2inside = normal.cross(c2.dir1);\r\n                const l1offset = c1.transform(M4.translate(l1inside.toLength(radius)));\r\n                const l2offset = c2.transform(M4.translate(l2inside.toLength(radius)));\r\n                const center = l1offset.isInfoWithLine(l2offset);\r\n                if (!center)\r\n                    throw new Error('tangential curves');\r\n                const cornerA = center.plus(l1inside.toLength(-radius));\r\n                const cornerB = center.plus(l2inside.toLength(-radius));\r\n                const f1 = l1inside.toLength(-radius);\r\n                const curve = new EllipseCurve(center, f1, normal.cross(f1).toLength(radius));\r\n                const cornerEdge = Edge.create(curve, cornerA, cornerB, 0, curve.pointT(cornerB), undefined, c1.dir1, c2.dir1);\r\n                return cornerEdge;\r\n            }\r\n            else {\r\n                return Edge.arbitraryCorner(edge, nextEdge, radius);\r\n            }\r\n        });\r\n        const result = edges.flatMap((edge, i) => {\r\n            const h = (i + edges.length - 1) % edges.length;\r\n            const prevCorner = corners[h], nextCorner = corners[i];\r\n            if (!prevCorner && !nextCorner) {\r\n                return edge;\r\n            }\r\n            const [aT, a, aDir] = !prevCorner\r\n                ? [edge.aT, edge.a, edge.aDir]\r\n                : [edge.curve.pointT(prevCorner.b), prevCorner.b, prevCorner.bDir];\r\n            const [bT, b, bDir] = !nextCorner\r\n                ? [edge.bT, edge.b, edge.bDir]\r\n                : [edge.curve.pointT(nextCorner.a), nextCorner.a, nextCorner.aDir];\r\n            const newEdge = Edge.create(edge.curve, a, b, aT, bT, undefined, aDir, bDir);\r\n            return !nextCorner ? newEdge : [newEdge, nextCorner];\r\n        });\r\n        return result;\r\n    }\r\n    static arbitraryCorner(e1, e2, radius) {\r\n        const c1 = e1.curve, c2 = e2.curve;\r\n        function f([t1, t2]) {\r\n            const p1 = c1.at(t1), p2 = c2.at(t2);\r\n            const dp1 = c1.tangentAt(t1), dp2 = c2.tangentAt(t2);\r\n            const virtualPlaneNormal = dp1.cross(dp2);\r\n            const normal1 = virtualPlaneNormal.cross(dp1).unit(), normal2 = virtualPlaneNormal.cross(dp2).unit();\r\n            const dirCross = normal1.cross(normal2);\r\n            if (virtualPlaneNormal.likeO()) {\r\n                assert(false);\r\n            } // lines parallel\r\n            const p1p2 = p1.to(p2);\r\n            // check if distance is zero (see also L3.distanceToLine)\r\n            if (!eq0(p1p2.dot(virtualPlaneNormal))) {\r\n                assert(false);\r\n            }\r\n            const dist1 = p1p2.cross(normal2).dot(dirCross) / dirCross.squared();\r\n            const dist2 = p1p2.cross(normal1).dot(dirCross) / dirCross.squared();\r\n            const g1 = p1.plus(normal1.times(dist1));\r\n            const g2 = p2.plus(normal2.times(dist2));\r\n            assert(g1.like(g2));\r\n            return [abs(dist1) - radius, abs(dist2) - radius];\r\n        }\r\n        const startT1 = e1.bT - radius * sign(e1.deltaT()) / e1.bDir.length();\r\n        const startT2 = e2.aT + radius * sign(e2.deltaT()) / e2.aDir.length();\r\n        const [t1, t2] = newtonIterate(f, [startT1, startT2]);\r\n        const cornerA = e1.curve.at(t1);\r\n        const cornerB = e2.curve.at(t2);\r\n        const dp1 = c1.tangentAt(t1), dp2 = c2.tangentAt(t2);\r\n        const virtualPlaneNormal = dp1.cross(dp2);\r\n        const normal1 = virtualPlaneNormal.cross(dp1).unit();\r\n        const f1 = normal1.toLength(-radius);\r\n        const center = cornerA.minus(f1);\r\n        const curve = new EllipseCurve(center, f1, virtualPlaneNormal.cross(f1).toLength(radius));\r\n        const cornerEdge = Edge.create(curve, cornerA, cornerB, 0, curve.pointT(cornerB), undefined, c1.tangentAt(t1), c2.tangentAt(t2));\r\n        return cornerEdge;\r\n    }\r\n    static pathFromSVG(pathString) {\r\n        let currentPos = undefined;\r\n        const parsed = new SVGPathData(pathString)\r\n            .toAbs()\r\n            .normalizeHVZ()\r\n            .sanitize(NLA_PRECISION)\r\n            .annotateArcs().commands;\r\n        const path = [];\r\n        for (const c of parsed) {\r\n            assert('x' in c && 'y' in c);\r\n            const endPos = new V3(c.x, c.y, 0);\r\n            switch (c.type) {\r\n                case SVGPathData.LINE_TO:\r\n                    path.push(StraightEdge.throughPoints(currentPos, endPos));\r\n                    break;\r\n                case SVGPathData.CURVE_TO: {\r\n                    const c1 = new V3(c.x1, c.y1, 0);\r\n                    const c2 = new V3(c.x2, c.y2, 0);\r\n                    const curve = new BezierCurve(currentPos, c1, c2, endPos, 0, 1);\r\n                    const edge = new PCurveEdge(curve, currentPos, endPos, 0, 1, undefined, curve.tangentAt(0), curve.tangentAt(1));\r\n                    path.push(edge);\r\n                    break;\r\n                }\r\n                case SVGPathData.QUAD_TO: {\r\n                    const c1 = new V3(c.x1, c.y1, 0);\r\n                    const curve = ParabolaCurve.quadratic(currentPos, c1, endPos).rightAngled();\r\n                    const edge = new PCurveEdge(curve, currentPos, endPos, curve.tMin, curve.tMax, undefined, curve.tangentAt(curve.tMin), curve.tangentAt(curve.tMax));\r\n                    path.push(edge);\r\n                    break;\r\n                }\r\n                case SVGPathData.ARC: {\r\n                    const phi1 = c.phi1 * DEG, phi2 = c.phi2 * DEG, [phiMin, phiMax] = [phi1, phi2].sort(MINUS);\r\n                    const stops = arrayRange(-3, 4, 1)\r\n                        .map(n => n * PI)\r\n                        .filter(stop => phiMin <= stop && stop <= phiMax);\r\n                    const center = V(c.cX, c.cY);\r\n                    const f1 = V3.polar(c.rX, c.xRot * DEG);\r\n                    const f2 = V3.polar(c.rY, c.xRot * DEG + Math.PI / 2);\r\n                    const edges = getIntervals(stops, phiMin, phiMax).map(([t1, t2]) => {\r\n                        const deltaT = t2 - t1;\r\n                        const t1_ = mod(t1, TAU);\r\n                        const t2_ = t1_ + deltaT;\r\n                        assert(t1_ >= 0 == t2_ >= 0);\r\n                        const gtPI = t1_ > PI || t2_ > PI;\r\n                        const aT = gtPI ? t1_ - PI : t1_;\r\n                        const bT = gtPI ? t2_ - PI : t2_;\r\n                        const curve = new EllipseCurve(center, gtPI ? f1.negated() : f1, gtPI ? f2.negated() : f2);\r\n                        const a = phi1 == t1 ? currentPos : phi2 == t1 ? endPos : curve.at(aT);\r\n                        const b = phi1 == t2 ? currentPos : phi2 == t2 ? endPos : curve.at(bT);\r\n                        return new PCurveEdge(curve, a, b, aT, bT, undefined, curve.tangentAt(aT), curve.tangentAt(bT));\r\n                    });\r\n                    path.push(...(c.phiDelta > 0 ? edges : Edge.reversePath(edges)));\r\n                    break;\r\n                }\r\n            }\r\n            currentPos = endPos;\r\n        }\r\n        return path;\r\n    }\r\n    toString() {\r\n        return callsce('new ' + this.constructor.name, this.curve, this.a, this.b, this.aT, this.bT, undefined, this.aDir, this.bDir);\r\n    }\r\n    split(t) {\r\n        const p = this.curve.at(t);\r\n        const pDir = this.tangentAt(t);\r\n        return [\r\n            Edge.create(this.curve, this.a, p, this.aT, t, undefined, this.aDir, pDir, this.name + 'left'),\r\n            Edge.create(this.curve, p, this.b, t, this.bT, undefined, pDir, this.bDir, this.name + 'left'),\r\n        ];\r\n    }\r\n    colinearToLine(line) {\r\n        return this.curve instanceof L3 && this.curve.isColinearTo(line);\r\n    }\r\n    tValueInside(t) {\r\n        return this.aT < this.bT ? lt(this.aT, t) && lt(t, this.bT) : lt(this.bT, t) && lt(t, this.aT);\r\n    }\r\n    isValidT(t) {\r\n        return this.aT < this.bT ? le(this.aT, t) && le(t, this.bT) : le(this.bT, t) && le(t, this.aT);\r\n    }\r\n    clampedT(t) {\r\n        return this.aT < this.bT ? clamp(t, this.aT, this.bT) : clamp(t, this.bT, this.aT);\r\n    }\r\n    /**\r\n     * this is equals-equals. \"isColinearTo\" might make more sense but can't be used, because you can't get a\r\n     * consistent hashCode for colinear curves\r\n     * @param obj\r\n     * @returns\r\n     */\r\n    equals(obj) {\r\n        return (this === obj ||\r\n            (this.constructor == obj.constructor &&\r\n                this.a.equals(obj.a) &&\r\n                this.b.equals(obj.b) &&\r\n                this.curve.equals(obj.curve)));\r\n    }\r\n    hashCode() {\r\n        let hashCode = 0;\r\n        hashCode = hashCode * 31 + this.a.hashCode();\r\n        hashCode = hashCode * 31 + this.b.hashCode();\r\n        hashCode = hashCode * 31 + this.curve.hashCode();\r\n        return hashCode | 0;\r\n    }\r\n    like(edge) {\r\n        // TODO this breaks on colinear edges,\r\n        // TODO: what, where?\r\n        return (this === edge ||\r\n            (edge instanceof Edge && this.curve.isColinearTo(edge.curve) && this.a.like(edge.a) && this.b.like(edge.b)));\r\n    }\r\n    isCanon() {\r\n        return !this.reversed;\r\n    }\r\n    getCanon() {\r\n        return this.reversed ? this.flipped() : this;\r\n    }\r\n    overlaps(edge, noback) {\r\n        assert(this.curve.isColinearTo(edge.curve));\r\n        const edgeAT = this.curve.containsPoint(edge.a) && this.curve.pointT(edge.a);\r\n        const edgeBT = this.curve.containsPoint(edge.b) && this.curve.pointT(edge.b);\r\n        if (false === edgeAT && false === edgeBT) {\r\n            return noback ? false : edge.overlaps(this, true);\r\n        }\r\n        return !(le(edge.maxT, this.minT) || le(this.maxT, edge.minT));\r\n    }\r\n    getAABB() {\r\n        const min = [Infinity, Infinity, Infinity], max = [-Infinity, -Infinity, -Infinity];\r\n        this.curve.roots().forEach((ts, dim) => {\r\n            ts.forEach(t => {\r\n                if (lt(this.minT, t) && lt(t, this.maxT)) {\r\n                    min[dim] = Math.min(min[dim], this.curve.at(t).e(dim));\r\n                    max[dim] = Math.max(max[dim], this.curve.at(t).e(dim));\r\n                }\r\n            });\r\n        });\r\n        const aabb = new AABB(V(min), V(max));\r\n        aabb.addPoint(this.a);\r\n        aabb.addPoint(this.b);\r\n        return aabb;\r\n    }\r\n    length(steps = 1) {\r\n        return this.curve.arcLength(this.minT, this.maxT, steps);\r\n    }\r\n    deltaT() {\r\n        return this.bT - this.aT;\r\n    }\r\n    deltaTSign() {\r\n        return sign(this.bT - this.aT);\r\n    }\r\n    atAvgT() {\r\n        return this.curve.at((this.minT + this.maxT) / 2);\r\n    }\r\n    /**\r\n     * Whether two edge loops are equal. Takes into account that two loops need not start with the same edge.\r\n     * @param loop1\r\n     * @param loop2\r\n     */\r\n    static loopsEqual(loop1, loop2) {\r\n        return (loop1.length == loop2.length &&\r\n            arrayRange(0, loop1.length, 1).some(offset => loop1.every((edge, i) => edge.equals(loop2[(offset + i) % loop1.length]))));\r\n    }\r\n}\r\nexport class PCurveEdge extends Edge {\r\n    constructor(curve, a, b, aT, bT, flippedOf, aDir, bDir, name) {\r\n        super(curve, a, b, aT, bT, flippedOf, name);\r\n        this.flippedOf = flippedOf;\r\n        this.aDir = aDir;\r\n        this.bDir = bDir;\r\n        assertVectors(aDir, bDir);\r\n        assertf(() => !aDir.likeO(), curve);\r\n        assertf(() => !bDir.likeO(), curve);\r\n        if (!(curve instanceof PICurve)) {\r\n            // TODO\r\n            assertf(() => curve.tangentAt(aT).likeOrReversed(aDir), '' + aT + curve.tangentAt(aT).sce + ' ' + aDir.sce);\r\n            assertf(() => curve.tangentAt(bT).likeOrReversed(bDir), '' + bT + curve.tangentAt(bT).sce + ' ' + bDir.sce);\r\n        }\r\n        assert(this.reversed === this.aDir.dot(curve.tangentAt(aT)) < 0, aT +\r\n            ' ' +\r\n            bT +\r\n            ' ' +\r\n            curve.constructor.name +\r\n            ' ' +\r\n            this.aDir.sce +\r\n            ' ' +\r\n            this.bDir.sce +\r\n            ' ' +\r\n            curve.tangentAt(aT));\r\n        assert(this.reversed === this.bDir.dot(curve.tangentAt(bT)) < 0, aT +\r\n            ' ' +\r\n            bT +\r\n            ' ' +\r\n            curve.constructor.name +\r\n            ' ' +\r\n            this.aDir.sce +\r\n            ' ' +\r\n            this.bDir.sce +\r\n            ' ' +\r\n            curve.tangentAt(aT));\r\n    }\r\n    static forCurveAndTs(curve, aT, bT, name) {\r\n        return new PCurveEdge(curve, curve.at(aT), curve.at(bT), aT, bT, undefined, aT < bT ? curve.tangentAt(aT) : curve.tangentAt(aT).negated(), aT < bT ? curve.tangentAt(bT) : curve.tangentAt(bT).negated(), name);\r\n    }\r\n    toSource() {\r\n        return callsce('new PCurveEdge', this.curve, this.a, this.b, this.aT, this.bT, undefined, this.aDir, this.bDir, this.name);\r\n    }\r\n    getVerticesNo0() {\r\n        return this.curve.calcSegmentPoints(this.aT, this.bT, this.a, this.b, this.reversed, false);\r\n    }\r\n    pointsCount() {\r\n        return this.points().length;\r\n    }\r\n    points() {\r\n        return this.curve.calcSegmentPoints(this.aT, this.bT, this.a, this.b, this.reversed, true);\r\n    }\r\n    edgeISTsWithSurface(surface) {\r\n        return this.curve\r\n            .isTsWithSurface(surface)\r\n            .map(edgeT => snap2(edgeT, this.aT, this.bT))\r\n            .filter(edgeT => this.minT <= edgeT && edgeT <= this.maxT);\r\n    }\r\n    edgeISTsWithPlane(surface) {\r\n        return this.curve\r\n            .isTsWithPlane(surface)\r\n            .map(edgeT => snap2(edgeT, this.aT, this.bT))\r\n            .filter(edgeT => this.minT <= edgeT && edgeT <= this.maxT);\r\n    }\r\n    tangentAt(t) {\r\n        return !this.reversed ? this.curve.tangentAt(t) : this.curve.tangentAt(t).negated();\r\n    }\r\n    flipped() {\r\n        return (this.flippedOf ||\r\n            (this.flippedOf = new PCurveEdge(this.curve, this.b, this.a, this.bT, this.aT, this, this.bDir.negated(), this.aDir.negated(), this.name)));\r\n    }\r\n    transform(m4, desc) {\r\n        return new PCurveEdge(this.curve.transform(m4), m4.transformPoint(this.a), m4.transformPoint(this.b), this.aT, this.bT, undefined, m4.transformVector(this.aDir), m4.transformVector(this.bDir), '' + this.name + desc);\r\n    }\r\n    transform4(m4, desc) {\r\n        const a_ = m4.transformPoint(this.a);\r\n        const b_ = m4.transformPoint(this.b);\r\n        const curve_ = this.curve.transform4(m4);\r\n        return new PCurveEdge(curve_, a_, b_, snap(curve_.pointT(a_), this.aT), snap(curve_.pointT(b_), this.bT), undefined, m4.transformVector(this.aDir), m4.transformVector(this.bDir), '' + this.name + desc);\r\n    }\r\n    isCoEdge(edge) {\r\n        return (this === edge ||\r\n            this === edge.flippedOf ||\r\n            (this.curve.isColinearTo(edge.curve) &&\r\n                ((this.a.like(edge.a) && this.b.like(edge.b)) || (this.a.like(edge.b) && this.b.like(edge.a)))));\r\n    }\r\n}\r\nexport class StraightEdge extends Edge {\r\n    constructor(line, a, b, aT, bT, flippedOf, name) {\r\n        super(line, a, b, aT, bT, flippedOf, name);\r\n        this.flippedOf = flippedOf;\r\n        assertInst(L3, line);\r\n        !flippedOf || assertInst(StraightEdge, flippedOf);\r\n        !name || assertf(() => 'string' === typeof name, name);\r\n        assert(!a.like(b), '!a.like(b)' + a + b); // don't put in super as it will break full ellipse\r\n        this.tangent = this.aT < this.bT ? this.curve.dir1 : this.curve.dir1.negated();\r\n    }\r\n    get aDir() {\r\n        return this.tangent;\r\n    }\r\n    get bDir() {\r\n        return this.tangent;\r\n    }\r\n    static throughPoints(a, b, name) {\r\n        return new StraightEdge(L3.throughPoints(a, b, 0, a.to(b).length()), a, b, 0, a.to(b).length(), undefined, name);\r\n    }\r\n    /**\r\n     * Create a list of StraightEdges from a list of vertices.\r\n     * @param vertices\r\n     * @param closed Whether to connect the first and last vertices. Defaults to true.\r\n     * @returns\r\n     */\r\n    static chain(vertices, closed = true) {\r\n        const vc = vertices.length;\r\n        return arrayFromFunction(closed ? vc : vc - 1, i => StraightEdge.throughPoints(vertices[i], vertices[(i + 1) % vc]));\r\n    }\r\n    toSource() {\r\n        return callsce('new StraightEdge', this.curve, this.a, this.b, this.aT, this.bT);\r\n    }\r\n    getVerticesNo0() {\r\n        return [this.b];\r\n    }\r\n    pointsCount() {\r\n        return 2;\r\n    }\r\n    points() {\r\n        return [this.a, this.b];\r\n    }\r\n    edgeISTsWithPlane(plane) {\r\n        const edgeT = snap2(this.curve.isTWithPlane(plane), this.aT, this.bT);\r\n        return this.minT <= edgeT && edgeT <= this.maxT ? [edgeT] : [];\r\n    }\r\n    edgeISTsWithSurface(surface) {\r\n        if (surface instanceof PlaneSurface) {\r\n            return this.edgeISTsWithPlane(surface.plane);\r\n        }\r\n        else {\r\n            return surface\r\n                .isTsForLine(this.curve)\r\n                .map(edgeT => snap2(edgeT, this.aT, this.bT))\r\n                .filter(edgeT => this.minT <= edgeT && edgeT <= this.maxT);\r\n        }\r\n    }\r\n    tangentAt() {\r\n        return this.tangent;\r\n    }\r\n    flipped() {\r\n        return (this.flippedOf ||\r\n            (this.flippedOf = new StraightEdge(this.curve, this.b, this.a, this.bT, this.aT, this, this.name)));\r\n    }\r\n    transform(m4, desc) {\r\n        const lineDir1TransLength = m4.transformVector2(this.curve.dir1, this.curve.anchor).length();\r\n        const curve = this.curve.transform(m4);\r\n        const a = m4.transformPoint(this.a);\r\n        const b = m4.transformPoint(this.b);\r\n        return new StraightEdge(curve, a, b, m4.isNoProj() ? this.aT * lineDir1TransLength : curve.pointT(a), m4.isNoProj() ? this.bT * lineDir1TransLength : curve.pointT(b), undefined, '' + this.name + desc);\r\n    }\r\n    transform4(m4, desc) {\r\n        const lineDir1TransLength = m4.transformVector2(this.curve.dir1, this.curve.anchor).length();\r\n        const curve = this.curve.transform4(m4);\r\n        const a = m4.transformPoint(this.a);\r\n        const b = m4.transformPoint(this.b);\r\n        return new StraightEdge(curve, a, b, m4.isNoProj() ? this.aT * lineDir1TransLength : curve.pointT(a), m4.isNoProj() ? this.bT * lineDir1TransLength : curve.pointT(b), undefined, '' + this.name + desc);\r\n    }\r\n    isCoEdge(edge) {\r\n        return (this === edge ||\r\n            this === edge.flippedOf ||\r\n            (edge.constructor === StraightEdge &&\r\n                ((this.a.like(edge.a) && this.b.like(edge.b)) || (this.a.like(edge.b) && this.b.like(edge.a)))));\r\n    }\r\n    getEdgeT(p) {\r\n        assertVectors(p);\r\n        let edgeT = p.minus(this.curve.anchor).dot(this.curve.dir1);\r\n        if (!eq0(this.curve.at(edgeT).distanceTo(p))) {\r\n            return;\r\n        }\r\n        edgeT = snap2(edgeT, this.aT, this.bT);\r\n        return this.minT <= edgeT && edgeT <= this.maxT ? edgeT : undefined;\r\n    }\r\n}\r\n//# sourceMappingURL=Edge.js.map","/**\r\n * Created by aval on 19.04.2017.\r\n */\r\nexport class FaceInfoFactory {\r\n    static makeStatic(staticInfo) {\r\n        return new class extends FaceInfoFactory {\r\n            constructor() {\r\n                super();\r\n            }\r\n            info(surface, contour, holes) {\r\n                return staticInfo;\r\n            }\r\n        }();\r\n    }\r\n    info(surface, contour, holes) {\r\n        throw new Error('no default implementation');\r\n    }\r\n    extrudeBottom(surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    extrudeTop(surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    extrudeWall(index, surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    rotationWall(index, surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    rotationStart(surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    rotationEnd(surface, contour, holes = []) {\r\n        return this.info(surface, contour, holes);\r\n    }\r\n    newSubFace(original, surface, contour, holes = []) {\r\n        return original.info;\r\n    }\r\n    transform(original, m4, desc, surface, contour, holes = []) {\r\n        return original.info;\r\n    }\r\n}\r\n//# sourceMappingURL=FaceInfo.js.map","import { Pair } from 'javasetmap.ts';\r\nimport { AABB, arrayFromFunction, arrayRange, assert, assertf, assertInst, assertVectors, disableConsole, doubleSignedArea, enableConsole, eq, eq0, ge, GOLDEN_RATIO, gt, isCCW, le, lerp, lt, mapPush, MINUS, mod, NLA_PRECISION, snap, TAU, Transformable, V3, } from 'ts3dutils';\r\nimport { Mesh, pushQuad } from 'tsgl';\r\nimport { BRep, ConicSurface, COPLANAR_SAME, dotCurve2, Edge, EllipsoidSurface, EPS, fff, getGlobalId, INSIDE, L3, P3, ParametricSurface, PlaneSurface, PointVsFace, splitsVolumeEnclosingCone2, splitsVolumeEnclosingFaces, splitsVolumeEnclosingFacesP, splitsVolumeEnclosingFacesP2, StraightEdge, triangulateVertices, } from './index';\r\nimport { abs, ceil, floor, max, min, sign } from './math';\r\nexport class Face extends Transformable {\r\n    constructor(surface, contour, holes = [], name, info) {\r\n        super();\r\n        this.surface = surface;\r\n        this.contour = contour;\r\n        this.holes = holes;\r\n        this.name = name;\r\n        this.info = info;\r\n        this.aabb = undefined;\r\n        //assert(name)\r\n        Edge.assertLoop(contour);\r\n        assert(contour.every(f => f instanceof Edge), () => 'contour.every(f => f instanceof Edge)' + contour);\r\n        // contour.forEach(e => !surface.containsCurve(e.curve) &&\r\n        // console.log('FAIL:'+surface.distanceToPoint(e.curve.anchor)))\r\n        //contour.forEach(e => {\r\n        //\tassert(surface.containsCurve(e.curve), 'edge not in surface ' + e + surface)\r\n        //})\r\n        //assert(surface.edgeLoopCCW(contour), surface.toString() + contour.join('\\n'))\r\n        holes && holes.forEach(hole => Edge.assertLoop(hole));\r\n        holes && holes.forEach(hole => assert(!surface.edgeLoopCCW(hole)));\r\n        assert(!holes || holes.constructor == Array, holes && holes.toString());\r\n        this.allEdges = Array.prototype.concat.apply(this.contour, this.holes);\r\n    }\r\n    static assembleFacesFromLoops(loops, surface, faceConstructor) {\r\n        function placeRecursively(newLoopInfo, loopInfos) {\r\n            if (loopInfos.length == 0) {\r\n                loopInfos.push(newLoopInfo);\r\n            }\r\n            else {\r\n                const subLoopInfo = loopInfos.find(loopInfo => BRep.loop1ContainsLoop2(loopInfo.loop, loopInfo.ccw, newLoopInfo.loop, newLoopInfo.ccw, surface));\r\n                if (subLoopInfo) {\r\n                    placeRecursively(newLoopInfo, subLoopInfo.subloops);\r\n                }\r\n                else {\r\n                    // newLoopInfo isnt contained by any other subLoopInfo\r\n                    for (let i = loopInfos.length; --i >= 0;) {\r\n                        const subLoopInfo = loopInfos[i];\r\n                        //console.log('cheving subLoopInfo', surface.loopContainsPoint(newLoopInfo.edges,\r\n                        // subLoopInfo.edges[0].a))\r\n                        if (BRep.loop1ContainsLoop2(newLoopInfo.loop, newLoopInfo.ccw, subLoopInfo.loop, subLoopInfo.ccw, surface)) {\r\n                            newLoopInfo.subloops.push(subLoopInfo);\r\n                            loopInfos.splice(i, 1); // remove it\r\n                        }\r\n                    }\r\n                    loopInfos.push(newLoopInfo);\r\n                }\r\n            }\r\n        }\r\n        function newFacesRecursive(loopInfo) {\r\n            newFaces.push(new faceConstructor(surface, loopInfo.ccw ? loopInfo.loop : Edge.reversePath(loopInfo.loop), loopInfo.subloops.map(sl => (sl.ccw ? Edge.reversePath(sl.loop) : sl.loop))));\r\n            loopInfo.subloops.forEach(sl => sl.subloops.forEach(sl2 => newFacesRecursive(sl2)));\r\n        }\r\n        const newFaces = [];\r\n        const topLevelLoops = [];\r\n        loops.forEach(loop => placeRecursively({\r\n            loop: loop,\r\n            ccw: surface.edgeLoopCCW(loop),\r\n            subloops: [],\r\n        }, topLevelLoops));\r\n        topLevelLoops.forEach(tll => newFacesRecursive(tll));\r\n        return newFaces;\r\n    }\r\n    //fromLoops(loops: Edge[][], surface: Surface) {\r\n    //\ttype LoopInfo = {loop: Edge[], ccw: boolean, subloops: LoopInfo[]}\r\n    //\tfunction placeRecursively(newLoopInfo: LoopInfo, loopInfos: LoopInfo[]) {\r\n    //\t\tif (loopInfos.length == 0) {\r\n    //\t\t\tloopInfos.push(newLoopInfo)\r\n    //\t\t} else {\r\n    //\t\t\tconst subLoopInfo = loopInfos.find(loopInfo => BRep.loop1ContainsLoop2(loopInfo.loop, loopInfo.ccw,\r\n    // newLoopInfo.loop, newLoopInfo.ccw, surface)) if (subLoopInfo) { placeRecursively(newLoopInfo,\r\n    // subLoopInfo.subloops) } else { // newLoopInfo isnt contained by any other subLoopInfo for (let i =\r\n    // loopInfos.length; --i >= 0;) { const subLoopInfo = loopInfos[i] //console.log('cheving subLoopInfo',\r\n    // surface.loopContainsPoint(newLoopInfo.edges, subLoopInfo.edges[0].a)) if\r\n    // (BRep.loop1ContainsLoop2(newLoopInfo.loop, subLoopInfo.loop, surface)) { newLoopInfo.subloops.push(subLoopInfo)\r\n    // loopInfos.splice(i, 1) // remove it } } loopInfos.push(newLoopInfo) } } }  function newFacesRecursive(loopInfo:\r\n    // LoopInfo): void { // CW loops can be top level, if they are holes in the original face not contained in the new\r\n    // face if (loopInfo.ccw) { if (loopInfo.subloops.every(sl => !sl.ccw)) { const newFace = new\r\n    // faceConstructor(surface, loopInfo.loop, loopInfo.subloops.map(sl => sl.loop)) newFaces.push(newFace)\r\n    // loopInfo.subloops.forEach(sl => sl.subloops.forEach(slsl => slsl.ccw && newFacesRecursive(slsl))) } else {\r\n    // loopInfo.subloops.forEach(sl => sl.ccw && newFacesRecursive(sl)) } } }  const newFaces: Face[] = [] const\r\n    // topLevelLoops:LoopInfo[] = [] loops.forEach(loop => placeRecursively({loop: loop, ccw:\r\n    // surface.edgeLoopCCW(loop), subloops: []}, topLevelLoops)) topLevelLoops.forEach(tll => newFacesRecursive(tll))\r\n    // return newFaces }\r\n    static create(surface, faceEdges, holes, faceName, info) {\r\n        return surface instanceof PlaneSurface\r\n            ? new PlaneFace(surface, faceEdges, holes, faceName, info)\r\n            : new RotationFace(surface, faceEdges, holes, faceName, info);\r\n    }\r\n    intersectFace(face2, thisBrep, face2Brep, faceMap, thisEdgePoints, otherEdgePoints, checkedPairs) {\r\n        //thisEdgePoints = {\r\n        //   get(key) {\r\n        //       return _thisEdgePoints.get(key)\r\n        //    },\r\n        //    set(key, value) {\r\n        //       assert(thisBrep.edgeFaces.get(key))\r\n        //        _thisEdgePoints.set(key, value)\r\n        //    }\r\n        //}\r\n        function hasPair(a, b) {\r\n            return checkedPairs.has(new Pair(a, b));\r\n        }\r\n        function addPair(a, b) {\r\n            return checkedPairs.add(new Pair(a, b));\r\n        }\r\n        /**\r\n         * @param newEdge generated segment\r\n         * @param col1 if newEdge is colinear to an edge of this, the edge in question\r\n         * @param col2 same for face2\r\n         * @return whether new edge was added.\r\n         */\r\n        function handleNewEdge(newEdge, col1, col2) {\r\n            if (!col1 && !col2) {\r\n                let correctDir = face.surface.normalP(newEdge.a).cross(face2.surface.normalP(newEdge.a));\r\n                if (correctDir.likeO()) {\r\n                    const t = lerp(newEdge.aT, newEdge.bT, 1 / GOLDEN_RATIO), p = newEdge.curve.at(t);\r\n                    correctDir = face.surface.normalP(p).cross(face2.surface.normalP(p));\r\n                }\r\n                if (!correctDir.likeO()) {\r\n                    if (correctDir.dot(newEdge.aDir) < 0) {\r\n                        newEdge = newEdge.flipped();\r\n                    }\r\n                    mapPush(faceMap, face, newEdge);\r\n                    mapPush(faceMap, face2, newEdge.flipped());\r\n                }\r\n                else {\r\n                    const p = newEdge.a;\r\n                    const plane = P3.normalOnAnchor(newEdge.aDir, p);\r\n                    const up = face.surface.normalP(p);\r\n                    const sameDir = up.dot(face2.surface.normalP(p)) > 0;\r\n                    const canonDir = plane.normal1.cross(up);\r\n                    const curve = face.surface.isCurvesWithPlane(plane)[0], curveT = curve.pointT(p), curveDir = sign(canonDir.dot(curve.tangentAt(curveT)));\r\n                    const curve2 = face2.surface.isCurvesWithPlane(plane)[0], curve2T = curve2.pointT(p), curve2Dir = sign(canonDir.dot(curve.tangentAt(curve2T)));\r\n                    const foo = curve.diff(curveT, EPS * curveDir).dot(up);\r\n                    const foo2 = curve2.diff(curve2T, EPS * curve2Dir).dot(up);\r\n                    if (foo2 < foo) {\r\n                        mapPush(faceMap, face2, sameDir ? newEdge.flipped() : newEdge);\r\n                    }\r\n                    if (up.dot(face2.surface.normalP(p)) < 0 == foo2 < foo) {\r\n                        mapPush(faceMap, face, newEdge.flipped());\r\n                    }\r\n                    const bar = curve.diff(curveT, EPS * curveDir).dot(up);\r\n                    const bar2 = curve2.diff(curve2T, EPS * curve2Dir).dot(up);\r\n                    if (bar2 < bar) {\r\n                        mapPush(faceMap, face2, sameDir ? newEdge : newEdge.flipped());\r\n                    }\r\n                    if (sameDir != bar2 < bar) {\r\n                        mapPush(faceMap, face, newEdge);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            function handleEdgeInFace(col1, col2, face, face2, thisBrep, face2Brep, coplanarSameIsInside, has, add) {\r\n                if (col1 && !col2) {\r\n                    if (hasPair(col1.getCanon(), face2))\r\n                        return false;\r\n                    //add(col1.getCanon(), face2)\r\n                    const surface2 = face2.surface;\r\n                    // NB: a new edge is inserted even though it may be the same as an old one\r\n                    // however it indicates that it intersects the other volume here, i.e. the old edge cannot\r\n                    // be counted as 'inside' for purposes of reconstitution\r\n                    thisBrep.edgeFaces.get(col1.getCanon()).forEach(faceInfo => {\r\n                        //const dot = snap0(surface2.normal1.dot(faceInfo.inside))\r\n                        //if (dot == 0 ? !coplanarSameIsInside : dot < 0) {\r\n                        const pointsInsideFace = fff(faceInfo, face2.surface);\r\n                        const edgeInside = pointsInsideFace == INSIDE || (!coplanarSameIsInside && pointsInsideFace == COPLANAR_SAME);\r\n                        const pushEdge = faceInfo.edge\r\n                            .tangentAt(faceInfo.edge.curve.pointT(newEdge.a))\r\n                            .like(newEdge.aDir)\r\n                            ? newEdge\r\n                            : newEdge.flipped();\r\n                        console.log(newEdge.sce);\r\n                        assert(faceInfo.edge.tangentAt(faceInfo.edge.curve.pointT(pushEdge.a)).like(pushEdge.aDir));\r\n                        edgeInside && mapPush(faceMap, faceInfo.face, pushEdge);\r\n                    });\r\n                    const surface2NormalAtNewEdgeA = surface2.normalP(newEdge.a);\r\n                    const newEdgeInside = surface2NormalAtNewEdgeA.cross(newEdge.aDir);\r\n                    const sVEF1 = splitsVolumeEnclosingFacesP(thisBrep, col1.getCanon(), newEdge.a, newEdgeInside, surface2NormalAtNewEdgeA);\r\n                    let addNewEdge, addNewEdgeFlipped;\r\n                    if ((addNewEdge = sVEF1 == INSIDE || (coplanarSameIsInside && sVEF1 == COPLANAR_SAME))) {\r\n                        mapPush(faceMap, face2, newEdge);\r\n                    }\r\n                    const sVEF2 = splitsVolumeEnclosingFacesP(thisBrep, col1.getCanon(), newEdge.a, newEdgeInside.negated(), surface2NormalAtNewEdgeA);\r\n                    if ((addNewEdgeFlipped = sVEF2 == INSIDE || (coplanarSameIsInside && sVEF2 == COPLANAR_SAME))) {\r\n                        mapPush(faceMap, face2, newEdge.flipped());\r\n                    }\r\n                    if (addNewEdge ||\r\n                        addNewEdgeFlipped ||\r\n                        (sVEF1 == COPLANAR_SAME && sVEF2 == INSIDE) ||\r\n                        (sVEF2 == COPLANAR_SAME && sVEF1 == INSIDE)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n            const c1 = handleEdgeInFace(col1, col2, face, face2, thisBrep, face2Brep, false, hasPair, addPair);\r\n            const c2 = handleEdgeInFace(col2, col1, face2, face, face2Brep, thisBrep, true, (a, b) => hasPair(b, a), (a, b) => addPair(b, a));\r\n            if (c1 || c2)\r\n                return true;\r\n            if (col1 && col2) {\r\n                if (hasPair(col1.getCanon(), col2.getCanon()))\r\n                    return false;\r\n                addPair(col1.getCanon(), col2.getCanon());\r\n                function handleColinearEdgeFaces(col1, col2, thisBrep, face2Brep, coplanarSameIsInside, thisEdgePoints, has, add) {\r\n                    // not entirely sure for what i had the dirInsides in?\r\n                    //const aDirNegatedInside = (newEdge.a.like(col2.a) || newEdge.a.like(col2.b)) &&\r\n                    // splitsVolumeEnclosingCone(face2Brep, newEdge.a, newEdge.aDir.negated()) == INSIDE const\r\n                    // bDirInside = (newEdge.b.like(col2.a) || newEdge.b.like(col2.b)) &&\r\n                    // splitsVolumeEnclosingCone(face2Brep, newEdge.b, newEdge.bDir) == INSIDE\r\n                    for (const faceInfo of thisBrep.edgeFaces.get(col1.getCanon())) {\r\n                        const sVEF = splitsVolumeEnclosingFaces(face2Brep, col2.getCanon(), faceInfo.inside, faceInfo.normalAtCanonA);\r\n                        const edgeInside = sVEF == INSIDE || (coplanarSameIsInside && sVEF == COPLANAR_SAME);\r\n                        const pushEdge = faceInfo.edge.aDir.like(newEdge.aDir) ? newEdge : newEdge.flipped();\r\n                        if (edgeInside) {\r\n                            mapPush(faceMap, faceInfo.face, pushEdge);\r\n                            const aT = col1.getCanon().curve.pointT(newEdge.a);\r\n                            if (!eq(aT, col1.aT) && !eq(aT, col1.bT)) {\r\n                                // newEdge.a is in center of col1\r\n                                if (splitsVolumeEnclosingCone2(face2Brep, newEdge.a, newEdge.curve, newEdge.aT, -Math.sign(newEdge.deltaT())) == INSIDE) {\r\n                                    mapPush(thisEdgePoints, col1.getCanon(), {\r\n                                        p: newEdge.a,\r\n                                        edgeT: aT,\r\n                                    });\r\n                                }\r\n                            }\r\n                            const bT = col1.getCanon().curve.pointT(newEdge.b);\r\n                            if (!eq(bT, col1.aT) && !eq(bT, col1.bT)) {\r\n                                if (splitsVolumeEnclosingCone2(face2Brep, newEdge.b, newEdge.curve, newEdge.bT, Math.sign(newEdge.deltaT())) == INSIDE) {\r\n                                    mapPush(thisEdgePoints, col1.getCanon(), {\r\n                                        p: newEdge.b,\r\n                                        edgeT: bT,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                handleColinearEdgeFaces(col1, col2, thisBrep, face2Brep, true, thisEdgePoints, hasPair, addPair);\r\n                handleColinearEdgeFaces(col2, col1, face2Brep, thisBrep, false, otherEdgePoints, (a, b) => hasPair(b, a), (a, b) => addPair(b, a));\r\n                return false;\r\n            }\r\n            return false;\r\n        }\r\n        // what needs to be generated: new edges on face\r\n        // points on edges where they are cut by faces so that sub edges will be generated for loops\r\n        // points on ends of edges where the edge will be an edge in the new volume where it goes from A to B\r\n        //         you don't want those to be marked as 'inside', otherwise invalid faces will be added\r\n        // if a face cuts a corner, nothing needs to be done, as that alone does not limit what adjacent faces will be\r\n        function handleEndPoint(a, b, newEdge) {\r\n            // ends in the middle of b's face\r\n            if (a && !b) {\r\n                if (!a.colinear && a.edgeT != a.edge.aT && a.edgeT != a.edge.bT) {\r\n                    mapPush(thisEdgePoints, a.edge.getCanon(), a);\r\n                    assert(a.edge.isValidT(a.edgeT));\r\n                }\r\n                // else colinear segment ends in middle of other face, do nothing\r\n            }\r\n            // ends in the middle of a's face\r\n            if (b && !a) {\r\n                if (!b.colinear && b.edgeT != b.edge.aT && b.edgeT != b.edge.bT) {\r\n                    mapPush(otherEdgePoints, b.edge.getCanon(), b);\r\n                    assert(b.edge.isValidT(b.edgeT));\r\n                }\r\n                // else colinear segment ends in middle of other face, do nothing\r\n            }\r\n            if (a && b) {\r\n                assert(a.colinear || b.colinear || eq(a.t, b.t));\r\n                // if a or b is colinear the correct points will already have been added to the edge by handleNewEdge\r\n                // segment starts/ends on edge/edge intersection\r\n                function handleAB(a, b, face, face2, thisPlane, face2Plane, thisBrep, face2Brep, first, thisEdgePoints) {\r\n                    if (!a.colinear && a.edgeT != a.edge.aT && a.edgeT != a.edge.bT) {\r\n                        //if (!hasPair(a.edge.getCanon(), b.edge.getCanon())) {\r\n                        addPair(a.edge.getCanon(), b.edge.getCanon());\r\n                        // ends on a, on colinear segment b bT != a.edge.bT &&\r\n                        // b can be colinear, so edgeT == aT is possible\r\n                        if (a.p.like(b.edge.a) || a.p.like(b.edge.b)) {\r\n                            const corner = a.p.like(b.edge.a) ? b.edge.a : b.edge.b;\r\n                            // face2brep corner on edge\r\n                            const sVEC1 = splitsVolumeEnclosingCone2(face2Brep, corner, a.edge.curve, a.edgeT, 1);\r\n                            const sVEC2 = splitsVolumeEnclosingCone2(face2Brep, corner, a.edge.curve, a.edgeT, -1);\r\n                            // if either of these return ALONG_EDGE_OR_PLANE, then the breps share a colinear edge\r\n                            if (INSIDE == sVEC1 || INSIDE == sVEC2) {\r\n                                mapPush(thisEdgePoints, a.edge.getCanon(), a);\r\n                                assert(a.edge.isValidT(a.edgeT));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // edge / edge center intersection\r\n                            // todo: is this even necessary considering we add edges anyway? i think so...\r\n                            // const testVector =\r\n                            // a.edge.tangentAt(a.edgeT).rejectedFrom(b.edge.tangentAt(b.edge.curve.pointT(a.p)))\r\n                            // assert(!testVector.likeO())\r\n                            const sVEF1 = splitsVolumeEnclosingFacesP2(face2Brep, b.edge.getCanon(), a.p, a.edge.curve, a.edgeT, 1, thisPlane.normalP(a.p));\r\n                            const sVEF2 = splitsVolumeEnclosingFacesP2(face2Brep, b.edge.getCanon(), a.p, a.edge.curve, a.edgeT, -1, thisPlane.normalP(a.p));\r\n                            if (INSIDE == sVEF1 ||\r\n                                (first && COPLANAR_SAME == sVEF1) ||\r\n                                INSIDE == sVEF2 ||\r\n                                (first && COPLANAR_SAME == sVEF2)) {\r\n                                mapPush(thisEdgePoints, a.edge.getCanon(), a);\r\n                                assert(a.edge.isValidT(a.edgeT));\r\n                            }\r\n                        }\r\n                        //}\r\n                    }\r\n                }\r\n                handleAB(a, b, face, face2, surface, surface2, thisBrep, face2Brep, true, thisEdgePoints);\r\n                handleAB(b, a, face2, face, surface2, surface, face2Brep, thisBrep, false, otherEdgePoints);\r\n            }\r\n        }\r\n        assertInst(Face, face2);\r\n        const face = this;\r\n        const surface = face.surface, surface2 = face2.surface;\r\n        if (!this.getAABB().touchesAABBfuzzy(face2.getAABB())) {\r\n            return;\r\n        }\r\n        if (surface.isCoplanarTo(surface2)) {\r\n            return;\r\n        }\r\n        const isCurves = surface.isCurvesWithSurface(surface2);\r\n        if (0 == isCurves.length) {\r\n            return;\r\n        }\r\n        for (const isCurve of isCurves) {\r\n            assert(surface.containsCurve(isCurve));\r\n            assert(surface2.containsCurve(isCurve));\r\n        }\r\n        for (let isCurveIndex = 0; isCurveIndex < isCurves.length; isCurveIndex++) {\r\n            // get intersections of newCurve with other edges of face and face2\r\n            const isCurve = isCurves[isCurveIndex];\r\n            const ps1 = face.edgeISPsWithSurface(isCurve, face2.surface);\r\n            const ps2 = face2.edgeISPsWithSurface(isCurve, face.surface);\r\n            // for non-endless curves, e.g. ellipses, the intersections of the faces can be non-zero, even if one of\r\n            // the faces doesn't register any points on the curve. For example, if a cylinder is cut entirely by a\r\n            // plane face (all its edges around the cylinder), then the face will contain the entire curve and\r\n            // 'ps' for the plane face will be empty\r\n            // TODO: behavior when curves touch face?\r\n            // !! start in does depend on insideDir... TODO\r\n            assertf(() => 0 == ps1.length || !eq0(ps1[0].insideDir.dot(isCurve.tangentAt(ps1[0].t))), () => ps1[0].insideDir.dot(isCurve.tangentAt(ps1[0].t)));\r\n            assertf(() => 0 == ps2.length || !eq0(ps2[0].insideDir.dot(isCurve.tangentAt(ps2[0].t))), () => ps2[0].insideDir.dot(isCurve.tangentAt(ps2[0].t)));\r\n            function startsInside(ps, face) {\r\n                if (0 == ps.length) {\r\n                    return isFinite(isCurve.tMin) && face.containsPoint2(isCurve.at(isCurve.tMin)) == PointVsFace.INSIDE;\r\n                }\r\n                else {\r\n                    return ps[0].insideDir.dot(isCurve.tangentAt(ps[0].t)) < 0;\r\n                }\r\n            }\r\n            // they can't both be empty currently\r\n            // they can't both start 'inside'\r\n            let in1 = startsInside(ps1, face);\r\n            let in2 = startsInside(ps2, face2);\r\n            if ((0 == ps1.length && !in1) || (0 == ps2.length && !in2)) {\r\n                continue;\r\n            }\r\n            //assert(!in1 || !in2)\r\n            let col1, col2;\r\n            let i = 0, j = 0, last;\r\n            let startP = in1 && in2 ? isCurve.at(isCurve.tMin) : undefined, startDir, startT = isCurve.tMin, startA, startB;\r\n            while (i < ps1.length || j < ps2.length) {\r\n                assert(i <= ps1.length);\r\n                assert(j <= ps2.length);\r\n                const a = ps1[i], b = ps2[j];\r\n                assert(a || b);\r\n                if (j == ps2.length || (i < ps1.length && lt(a.t, b.t))) {\r\n                    last = a;\r\n                    in1 = !in1;\r\n                    a.used = true;\r\n                    col1 = a.colinear ? a : undefined;\r\n                    i++;\r\n                }\r\n                else if (i == ps1.length || gt(a.t, b.t)) {\r\n                    last = b;\r\n                    b.used = true;\r\n                    in2 = !in2;\r\n                    col2 = b.colinear ? b : undefined;\r\n                    j++;\r\n                }\r\n                else {\r\n                    last = a;\r\n                    a.used = true;\r\n                    b.used = true;\r\n                    in1 = !in1;\r\n                    in2 = !in2;\r\n                    //if (in1 == in2) {\r\n                    col1 = a.colinear ? a : undefined;\r\n                    col2 = b.colinear ? b : undefined;\r\n                    //}\r\n                    i++;\r\n                    j++;\r\n                }\r\n                if (startP && !(in1 && in2)) {\r\n                    // segment end\r\n                    startDir = isCurve.tangentAt(startT);\r\n                    if (eq(startT, last.t)) {\r\n                        startP = undefined;\r\n                        continue;\r\n                    }\r\n                    assert(lt(startT, last.t));\r\n                    startT > last.t && (startDir = startDir.negated());\r\n                    let endDir = isCurve.tangentAt(last.t);\r\n                    startT > last.t && (endDir = endDir.negated());\r\n                    const newEdge = Edge.create(isCurve, startP, last.p, startT, last.t, undefined, startDir, endDir, 'genseg' + getGlobalId());\r\n                    startP = undefined;\r\n                    if (handleNewEdge(newEdge, col1 && col1.edge, col2 && col2.edge)) {\r\n                        handleEndPoint(startA || col1, startB || col2, newEdge);\r\n                        handleEndPoint((a && a.used && a) || col1, (b && b.used && b) || col2, newEdge);\r\n                    }\r\n                }\r\n                else if (in1 && in2) {\r\n                    // new segment just started\r\n                    startP = last.p;\r\n                    startDir = last.insideDir;\r\n                    startT = last.t;\r\n                    startA = a && a.used ? a : undefined;\r\n                    startB = b && b.used ? b : undefined;\r\n                }\r\n            }\r\n            if (in1 && in2 && startT !== isCurve.tMax) {\r\n                const endT = isCurve.tMax;\r\n                startDir = isCurve.tangentAt(startT);\r\n                startT > endT && (startDir = startDir.negated());\r\n                let endDir = isCurve.tangentAt(endT);\r\n                startT > endT && (endDir = endDir.negated());\r\n                const newEdge = Edge.create(isCurve, startP, isCurve.at(endT), startT, endT, undefined, startDir, endDir, 'genseg' + getGlobalId());\r\n                if (handleNewEdge(newEdge, col1 && col1.edge, col2 && col2.edge)) {\r\n                    handleEndPoint(startA || col1, startB || col2, newEdge);\r\n                }\r\n            }\r\n        }\r\n        face.getAllEdges().forEach(edge => {\r\n            checkedPairs.add(new Pair(edge.getCanon(), face2));\r\n        });\r\n        face2.getAllEdges().forEach(edge => {\r\n            checkedPairs.add(new Pair(edge.getCanon(), face));\r\n        });\r\n    }\r\n    edgeISPsWithSurface(isCurve, surface2) {\r\n        const face = this;\r\n        const surface = face.surface;\r\n        const loops = face.holes.concat([face.contour]);\r\n        const ps = [];\r\n        for (const loop of loops) {\r\n            const colinearEdges = loop.map(edge => edge.curve.isColinearTo(isCurve));\r\n            //const colinearSides = loop.map((edge, edgeIndex) => -1 != colinearEdges[edgeIndex]\r\n            //            && -sign(isCurves[colinearEdges[edgeIndex]].tangentAt(edge.aT).dot(edge.aDir)))\r\n            for (let edgeIndex = 0; edgeIndex < loop.length; edgeIndex++) {\r\n                const edge = loop[edgeIndex];\r\n                const nextEdgeIndex = (edgeIndex + 1) % loop.length, nextEdge = loop[nextEdgeIndex];\r\n                //console.log(edge.toSource()) {p:V3(2, -2.102, 0),\r\n                if (colinearEdges[edgeIndex]) {\r\n                    if (isCurve.containsPoint(edge.a)) {\r\n                        const prevEdgeIndex = (edgeIndex - 1 + loop.length) % loop.length, prevEdge = loop[prevEdgeIndex];\r\n                        const curveAT = isCurve.pointT(edge.a);\r\n                        const colinearOutA = edge.aDir.cross(surface.normalP(edge.a));\r\n                        if (!colinearEdges[prevEdgeIndex] &&\r\n                            dotCurve2(prevEdge.curve, prevEdge.bT, colinearOutA, -sign(prevEdge.deltaT())) > 0) {\r\n                            ps.push({\r\n                                p: prevEdge.b,\r\n                                insideDir: edge.aDir.negated(),\r\n                                t: curveAT,\r\n                                edge: prevEdge,\r\n                                edgeT: prevEdge.bT,\r\n                                colinear: false,\r\n                            });\r\n                        }\r\n                        ps.push({\r\n                            p: edge.a,\r\n                            insideDir: edge.aDir,\r\n                            t: curveAT,\r\n                            edge: edge,\r\n                            edgeT: edge.aT,\r\n                            colinear: true,\r\n                        });\r\n                    }\r\n                    if (isCurve.containsPoint(edge.b)) {\r\n                        const curveBT = isCurve.pointT(edge.b);\r\n                        const colinearOutB = edge.bDir.cross(surface.normalP(edge.b));\r\n                        if (!colinearEdges[nextEdgeIndex] &&\r\n                            dotCurve2(nextEdge.curve, nextEdge.aT, colinearOutB, sign(nextEdge.deltaT())) > 0) {\r\n                            ps.push({\r\n                                p: edge.b,\r\n                                insideDir: edge.bDir,\r\n                                t: curveBT,\r\n                                edge: nextEdge,\r\n                                edgeT: nextEdge.aT,\r\n                                colinear: false,\r\n                            });\r\n                        }\r\n                        ps.push({\r\n                            p: edge.b,\r\n                            insideDir: edge.bDir.negated(),\r\n                            t: curveBT,\r\n                            edge: edge,\r\n                            edgeT: edge.bT,\r\n                            colinear: true,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    const edgeTs = edge.edgeISTsWithSurface(surface2);\r\n                    for (const edgeT of edgeTs) {\r\n                        const p = edge.curve.at(edgeT);\r\n                        if (!isCurve.containsPoint(p))\r\n                            continue;\r\n                        const curveT = isCurve.pointT(p);\r\n                        assert(!isNaN(curveT));\r\n                        const insideDir = edge\r\n                            .tangentAt(edgeT)\r\n                            .cross(surface.normalP(p))\r\n                            .negated();\r\n                        const isTangent = isCurve.tangentAt(curveT);\r\n                        //if(!eq0(insideDir.dot(isTangent))) {\r\n                        // Edge.edgeISTsWithSurface returns snapped values, so comparison with == is ok:\r\n                        if (edgeT == edge.bT) {\r\n                            // endpoint lies on intersection line\r\n                            if (!colinearEdges[nextEdgeIndex]) {\r\n                                if (!eq(curveT, isCurve.tMax)) {\r\n                                    const pointsToInside = this.pointsToInside3(edge.b, isCurve, curveT, 1);\r\n                                    assert(pointsToInside != PointVsFace.ON_EDGE);\r\n                                    if (PointVsFace.INSIDE == pointsToInside) {\r\n                                        ps.push({\r\n                                            p: edge.b,\r\n                                            insideDir: isTangent,\r\n                                            t: curveT,\r\n                                            edge: edge,\r\n                                            edgeT: edge.bT,\r\n                                            colinear: false,\r\n                                        });\r\n                                    }\r\n                                }\r\n                                if (!eq(curveT, isCurve.tMin)) {\r\n                                    const pointsToInside = this.pointsToInside3(edge.b, isCurve, curveT, -1);\r\n                                    assert(pointsToInside != PointVsFace.ON_EDGE);\r\n                                    if (PointVsFace.INSIDE == pointsToInside) {\r\n                                        ps.push({\r\n                                            p: edge.b,\r\n                                            insideDir: isTangent.negated(),\r\n                                            t: curveT,\r\n                                            edge: edge,\r\n                                            edgeT: edge.bT,\r\n                                            colinear: false,\r\n                                        });\r\n                                    }\r\n                                }\r\n                                //let thisSide = -normVector.dot(edge.bDir)\r\n                                //if (eq0(thisSide)) {\r\n                                //    // advanced test\r\n                                //    const dir = -sign(edge.deltaT())\r\n                                //    const iscd = isCurve.at(curveT).to(isCurve.at(curveT + dir * dirFactor *\r\n                                // eps)).dot(normVector) const ecd = edge.curve.at(edgeT).to(edge.curve.at(edgeT + dir\r\n                                // * eps)).dot(normVector) thisSide = sign(ecd - iscd) } let nextSide =\r\n                                // normVector.dot(nextEdge.aDir) if (eq0(nextSide)) { // advanced test const dirFactor\r\n                                // = sign(snap0(isTangent.dot(nextEdge.curve.tangentAt(nextEdge.aT)))) assert(dirFactor\r\n                                // !== 0) const dir = sign(nextEdge.deltaT()) const iscd =\r\n                                // isCurve.at(curveT).to(isCurve.at(curveT + dir * dirFactor * eps)).dot(normVector)\r\n                                // const ecd = nextEdge.curve.at(nextEdge.aT).to(nextEdge.curve.at(nextEdge.aT + dir *\r\n                                // eps)).dot(normVector) nextSide = sign(ecd - iscd) } if (nextSide < 0 || thisSide <\r\n                                // 0) { assert(!eq0(insideDir.dot(isTangent))) // next segment is not colinear and ends\r\n                                // on different side ps.push({ p: edge.b, insideDir: insideDir, t: curveT, edge: edge,\r\n                                // edgeT: edge.bT, colinear: false}) }\r\n                            }\r\n                        }\r\n                        else if (edgeT != edge.aT) {\r\n                            // edge crosses/touches an intersection curve, neither starts nor ends on it\r\n                            if (eq0(insideDir.dot(isTangent))) {\r\n                                const dirFactor = sign(isTangent.dot(edge.curve.tangentAt(edgeT)));\r\n                                const eps = 1e-4;\r\n                                for (const dir of [-1, 1]) {\r\n                                    if ((-1 == dir * dirFactor && edgeT == edge.minT) ||\r\n                                        (1 == dir * dirFactor && edgeT == edge.maxT) ||\r\n                                        (-1 == dir && curveT == isCurve.tMin) ||\r\n                                        (1 == dir && curveT == isCurve.tMax))\r\n                                        continue;\r\n                                    const iscd = isCurve\r\n                                        .at(curveT)\r\n                                        .to(isCurve.at(curveT + dir * eps))\r\n                                        .dot(insideDir);\r\n                                    const ecd = edge.curve\r\n                                        .at(edgeT)\r\n                                        .to(edge.curve.at(edgeT + dir * dirFactor * eps))\r\n                                        .dot(insideDir);\r\n                                    if (iscd - ecd > 0) {\r\n                                        ps.push({\r\n                                            p,\r\n                                            insideDir: isTangent.times(dir),\r\n                                            t: curveT,\r\n                                            edge: edge,\r\n                                            edgeT: edgeT,\r\n                                            colinear: false,\r\n                                        });\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                ps.push({\r\n                                    p: p,\r\n                                    insideDir: insideDir,\r\n                                    t: curveT,\r\n                                    edge: edge,\r\n                                    edgeT: edgeT,\r\n                                    colinear: false,\r\n                                });\r\n                            }\r\n                        }\r\n                        //} else {\r\n                        //\r\n                        //\tconst dirFactor = sign(isTangent.dot(edge.curve.tangentAt(edgeT)))\r\n                        //\tconst eps = 1e-4\r\n                        //\tconst normVector = surface2.normalP(p)\r\n                        //\tfor (const dir of [-1, 1]) {\r\n                        //\t\tif (-1 == dir * dirFactor && edgeT == edge.minT ||\r\n                        //\t\t\t1 == dir * dirFactor && edgeT == edge.maxT ||\r\n                        //\t\t\t-1 == dir && curveT == isCurve.tMin ||\r\n                        //\t\t\t1 == dir && curveT == isCurve.tMax) continue\r\n                        //\t\tconst iscd = isCurve.at(curveT).to(isCurve.at(curveT + dir * eps)).dot(normVector)\r\n                        //\t\tconst ecd = edge.curve.at(edgeT).to(edge.curve.at(edgeT + dir * dirFactor *\r\n                        // eps)).dot(normVector) if (iscd > ecd) { ps.push({p, insideDir: isTangent.times(dir *\r\n                        // dirFactor), t: curveT, edge: edge, edgeT: edgeT, colinear: false}) } }\r\n                        // curveVsSurface(isCurve, curveT, p, surface2) }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // duplicate 't's are ok, as sometimes a segment needs to stop and start again\r\n        // should be sorted so that back facing ones are first\r\n        ps.sort((a, b) => a.t - b.t || a.insideDir.dot(isCurve.tangentAt(a.t)));\r\n        return ps;\r\n    }\r\n    transform(m4) {\r\n        const mirroring = m4.isMirroring();\r\n        const newEdges = Edge.reversePath(this.contour.map(e => e.transform(m4)), mirroring);\r\n        const newHoles = this.holes.map(hole => Edge.reversePath(hole.map(e => e.transform(m4)), mirroring));\r\n        return new this.constructor(this.surface.transform(m4), newEdges, newHoles, this.name, this.info);\r\n    }\r\n    transform4(m4) {\r\n        const mirroring = m4.isMirroring();\r\n        const newEdges = Edge.reversePath(this.contour.map(e => e.transform4(m4)), mirroring);\r\n        const newHoles = this.holes.map(hole => Edge.reversePath(hole.map(e => e.transform4(m4)), mirroring));\r\n        return new this.constructor(this.surface.transform4(m4), newEdges, newHoles, this.name, this.info);\r\n    }\r\n    flipped() {\r\n        const newEdges = this.contour.map(e => e.flipped()).reverse();\r\n        const newHoles = this.holes.map(hole => hole.map(e => e.flipped()).reverse());\r\n        return new this.constructor(this.surface.flipped(), newEdges, newHoles, this.name, this.info);\r\n    }\r\n    toString() {\r\n        return ('new ' +\r\n            this.constructor.name +\r\n            '(' +\r\n            this.surface +\r\n            ', [' +\r\n            this.contour.map(e => '\\n\\t' + e).join() +\r\n            ']' +\r\n            this.holes.map(hole => '\\n\\t\\thole: ' + hole.join()) +\r\n            ')');\r\n    }\r\n    toSource() {\r\n        return ('new ' +\r\n            this.constructor.name +\r\n            '(' +\r\n            this.surface.toSource() +\r\n            ', [' +\r\n            this.contour.map(e => '\\n\\t' + e.toSource() + ',').join('') +\r\n            '], [' +\r\n            this.holes.map(hole => '[' + hole.map(e => '\\n\\t' + e.toSource() + ',').join('') + ']').join(',') +\r\n            '])');\r\n    }\r\n    equals(obj) {\r\n        return (this == obj ||\r\n            (Object.getPrototypeOf(this) == Object.getPrototypeOf(obj) &&\r\n                this.holes.length == obj.holes.length &&\r\n                Edge.loopsEqual(this.contour, obj.contour) &&\r\n                this.holes.every(hole => obj.holes.some(hole2 => Edge.loopsEqual(hole, hole2)))));\r\n    }\r\n    hashCode() {\r\n        function arrayHashCode(array) {\r\n            let hashCode = 0;\r\n            for (const val of array) {\r\n                hashCode = (hashCode * 31 + val) | 0;\r\n            }\r\n            return hashCode;\r\n        }\r\n        function loopHashCode(loop) {\r\n            return arrayHashCode(loop.map(edge => edge.hashCode()).sort(MINUS));\r\n        }\r\n        let hashCode = 0;\r\n        hashCode = (hashCode * 31 + arrayHashCode(this.holes.map(loop => loopHashCode(loop)).sort(MINUS))) | 0;\r\n        hashCode = (hashCode * 31 + loopHashCode(this.contour)) | 0;\r\n        hashCode = (hashCode * 31 + this.surface.hashCode()) | 0;\r\n        return hashCode;\r\n    }\r\n    likeFace(face2) {\r\n        function loopsLike(a, b) {\r\n            return (a.length == b.length &&\r\n                arrayRange(0, a.length, 1).some(offset => a.every((edge, i) => edge.like(b[(offset + i) % a.length]))));\r\n        }\r\n        assertInst(Face, face2);\r\n        return (this.surface.like(face2.surface) &&\r\n            this.holes.length == face2.holes.length &&\r\n            loopsLike(this.contour, face2.contour) &&\r\n            this.holes.every(hole => face2.holes.some(hole2 => loopsLike(hole, hole2))));\r\n    }\r\n    getAllEdges() {\r\n        return this.allEdges;\r\n    }\r\n    addEdgeLines(mesh) {\r\n        assert(false, 'buggy, fix');\r\n        const vertices = this.contour.flatMap(edge => edge.getVerticesNo0()), mvl = mesh.vertices.length;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            mesh.vertices.push(vertices[i]);\r\n            mesh.LINES.push(mvl + i, mvl + (i + 1) % vertices.length);\r\n        }\r\n    }\r\n    containsPoint(p) {\r\n        assertVectors(p);\r\n        return (this.surface.loopContainsPoint(this.contour, p) != PointVsFace.OUTSIDE &&\r\n            !this.holes.some(hole => this.surface.loopContainsPoint(hole, p) != PointVsFace.OUTSIDE));\r\n    }\r\n    containsPoint2(p) {\r\n        assertVectors(p);\r\n        const contourContainsPoint = this.surface.loopContainsPoint(this.contour, p);\r\n        if (contourContainsPoint != PointVsFace.INSIDE)\r\n            return contourContainsPoint;\r\n        for (const hole of this.holes) {\r\n            const loopContainsPoint = this.surface.loopContainsPoint(hole, p);\r\n            if (loopContainsPoint != PointVsFace.OUTSIDE) {\r\n                return loopContainsPoint == PointVsFace.ON_EDGE ? PointVsFace.ON_EDGE : PointVsFace.OUTSIDE;\r\n            }\r\n        }\r\n        return PointVsFace.INSIDE;\r\n    }\r\n    /**\r\n     *\r\n     * @param line\r\n     * @returns t param of the line if there is an intersection, NaN otherwise\r\n     */\r\n    intersectsLine(line) {\r\n        assertInst(L3, line);\r\n        if (!this.getAABB().intersectsLine(line))\r\n            return NaN;\r\n        const containedIntersectionsTs = this.surface.isTsForLine(line).filter(t => this.containsPoint(line.at(t)));\r\n        const nearestPointT = containedIntersectionsTs.withMax(t => -t);\r\n        return undefined != nearestPointT ? nearestPointT : NaN;\r\n    }\r\n    toMesh() {\r\n        const mesh = new Mesh()\r\n            .addIndexBuffer('TRIANGLES')\r\n            .addIndexBuffer('LINES')\r\n            .addVertexBuffer('normals', 'ts_Normal');\r\n        this.addToMesh(mesh);\r\n        //mesh.compile()\r\n        return mesh;\r\n    }\r\n    zDirVolume() {\r\n        return this.surface.zDirVolume(this.getAllEdges());\r\n    }\r\n    calcArea() {\r\n        return this.surface.calculateArea(this.getAllEdges());\r\n    }\r\n    getLoops() {\r\n        return [this.contour, ...this.holes];\r\n    }\r\n    getAABB() {\r\n        return this.aabb || (this.aabb = AABB.forAABBs(this.contour.map(e => e.getAABB())));\r\n    }\r\n    pointsToInside3(p, curve, curveT, dir) {\r\n        const eps = 1e-6;\r\n        const normal = this.surface.normalP(p);\r\n        const curveTangent = curve.tangentAt(curveT).times(dir);\r\n        const up = normal.cross(curveTangent);\r\n        const ecd = curve\r\n            .at(curveT)\r\n            .to(curve.at(curveT + dir * eps))\r\n            .dot(up);\r\n        let minValue = Infinity, result, advanced = false;\r\n        for (const edge of this.getAllEdges()) {\r\n            const aEqP = edge.a.like(p), bEqP = edge.b.like(p);\r\n            assert(aEqP == edge.a.like(p));\r\n            assert(bEqP == edge.b.like(p));\r\n            if (!aEqP && !bEqP)\r\n                continue;\r\n            const edgeTangent = aEqP ? edge.aDir : edge.bDir.negated();\r\n            const angle = curveTangent.angleRelativeNormal(edgeTangent, normal);\r\n            if (eq0(angle)) {\r\n                if (curve.isColinearTo(edge.curve)) {\r\n                    return PointVsFace.ON_EDGE;\r\n                }\r\n                const edgeT = aEqP ? edge.aT : edge.bT;\r\n                const edgeDir = (aEqP ? 1 : -1) * sign(edge.deltaT());\r\n                const iscd = edge.curve.diff(edgeT, edgeDir * eps).dot(up);\r\n                //const iscd = edge.curve.at(edgeT).to(curve.at(edgeT + edgeDir * eps)).dot(up)\r\n                const diff = iscd - ecd;\r\n                if (diff > 0 && (!advanced || diff < minValue)) {\r\n                    advanced = true;\r\n                    minValue = diff;\r\n                    result = aEqP ? PointVsFace.OUTSIDE : PointVsFace.INSIDE;\r\n                }\r\n            }\r\n            else if (!advanced) {\r\n                const angle2 = (angle + TAU) % TAU;\r\n                if (angle2 < minValue) {\r\n                    minValue = angle2;\r\n                    result = aEqP ? PointVsFace.OUTSIDE : PointVsFace.INSIDE;\r\n                }\r\n            }\r\n        }\r\n        if (result == undefined)\r\n            throw new Error();\r\n        return result;\r\n    }\r\n    pointsToInside2(p, dir) {\r\n        return this.pointsToInside3(p, L3.anchorDirection(p, dir), 0, 1);\r\n        //const normal = this.surface.normalP(p)\r\n        //let minAngle = Infinity, inOut = false\r\n        //function test(v, b) {\r\n        //\tconst angle = (dir.angleRelativeNormal(v, normal) + TAU + NLA_PRECISION / 2) % TAU\r\n        //\tif (angle <= 2 * NLA_PRECISION) {\r\n        //\t\treturn true\r\n        //\t}\r\n        //\tif (angle < minAngle) {\r\n        //\t\tminAngle = angle\r\n        //\t\tinOut = b\r\n        //\t}\r\n        //}\r\n        //for (const edge of this.getAllEdges()) {\r\n        //\tassert(edge.a.equals(p) || !edge.a.like(p))\r\n        //\tassert(edge.b.equals(p) || !edge.b.like(p))\r\n        //\tif (edge.a.equals(p) && test(edge.aDir, false)) return PointVsFace.ON_EDGE\r\n        //\tif (edge.b.equals(p) && test(edge.bDir.negated(), true)) return PointVsFace.ON_EDGE\r\n        //}\r\n        //return inOut ? PointVsFace.INSIDE : PointVsFace.OUTSIDE\r\n    }\r\n}\r\nexport class PlaneFace extends Face {\r\n    constructor(p, contour, holes, name, info) {\r\n        assert(p instanceof P3 || p instanceof PlaneSurface);\r\n        super(p instanceof P3 ? new PlaneSurface(p) : p, contour, holes, name, info);\r\n    }\r\n    static forVertices(planeSurface, vs, ...holeVss) {\r\n        const _planeSurface = planeSurface instanceof P3 ? new PlaneSurface(planeSurface) : planeSurface;\r\n        assert(isCCW(vs, _planeSurface.plane.normal1), 'isCCW(vs, planeSurface.plane.normal1)');\r\n        const edges = StraightEdge.chain(vs);\r\n        holeVss.forEach(vs => assert(doubleSignedArea(vs, _planeSurface.plane.normal1) >= 0, 'doubleSignedArea(vs, planeSurface.plane.normal1) >= 0'));\r\n        const holes = holeVss.map(hvs => StraightEdge.chain(hvs));\r\n        return new PlaneFace(planeSurface, edges, holes);\r\n    }\r\n    addToMesh(mesh) {\r\n        const mvl = mesh.vertices.length;\r\n        const normal = this.surface.plane.normal1;\r\n        const vertices = this.contour.flatMap(edge => edge.getVerticesNo0());\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            mesh.LINES.push(mvl + i, mvl + (i + 1) % vertices.length);\r\n        }\r\n        const holeStarts = [];\r\n        this.holes.forEach(hole => {\r\n            holeStarts.push(vertices.length);\r\n            vertices.push(...hole.flatMap(edge => edge.getVerticesNo0()));\r\n        });\r\n        const triangles = triangulateVertices(normal, vertices, holeStarts).map(index => index + mvl);\r\n        Array.prototype.push.apply(mesh.vertices, vertices);\r\n        Array.prototype.push.apply(mesh.TRIANGLES, triangles);\r\n        Array.prototype.push.apply(mesh.normals, arrayFromFunction(vertices.length, () => normal));\r\n    }\r\n    intersectsLine(line) {\r\n        assertInst(L3, line);\r\n        const lambda = line.isTWithPlane(this.surface.plane);\r\n        if (!Number.isFinite(lambda)) {\r\n            return NaN;\r\n        }\r\n        const inside = this.containsPoint(line.at(lambda));\r\n        return inside ? lambda : NaN;\r\n    }\r\n    //intersectPlaneFace(face2: PlaneFace,\r\n    //                   thisBrep: BRep,\r\n    //                   face2Brep: BRep,\r\n    //                   faceMap: Map<Face, Edge[]>,\r\n    //                   thisEdgePoints: CustomMap<Edge, { edge: Edge, edgeT: number, p: V3, passEdge?: Edge }[]>,\r\n    //                   otherEdgePoints: CustomMap<Edge, { edge: Edge, edgeT: number, p: V3, passEdge?: Edge }[]>,\r\n    //                   checkedPairs: CustomSet<Pair<Equalable, Equalable>>) {\r\n    //\tassertInst(CustomMap, thisEdgePoints, otherEdgePoints)\r\n    //\r\n    //\tfunction hasPair(a: Equalable, b: Equalable) {\r\n    //\t\treturn checkedPairs.has(new Pair(a, b))\r\n    //\t}\r\n    //\tfunction addPair(a: Equalable, b: Equalable) {\r\n    //\t\treturn checkedPairs.add(new Pair(a, b))\r\n    //\t}\r\n    //\r\n    //\t/**\r\n    //\t * @param newEdge generated segment\r\n    //\t * @param col1 if newEdge is colinear to an edge of this, the edge in question\r\n    //\t * @param col2 same for face2\r\n    //\t */\r\n    //\tfunction handleNewEdge(newEdge: StraightEdge, col1: Edge, col2: Edge) {\r\n    //\t\tif (!col1 && !col2) {\r\n    //\t\t\tmapPush(faceMap, face, newEdge)\r\n    //\t\t\tmapPush(faceMap, face2, newEdge.flipped())\r\n    //\t\t\treturn true\r\n    //\t\t}\r\n    //\t\tfunction handleEdgeInFace(col1, col2, face, face2, thisBrep, face2Brep, coplanarSameIsInside: boolean,\r\n    // has, add) { if (col1 && !col2) { if (hasPair(col1.getCanon(), face2)) return  //add(col1.getCanon(), face2)\r\n    // const face2Plane = face2.surface.plane  // NB: a new edge is inserted even though it may be the same as an old\r\n    // one // however it indicates that it intersects the other volume here, i.e. the old edge cannot // be counted as\r\n    // 'inside' for purposes of reconstitution thisBrep.edgeFaces.get(col1.getCanon()).forEach(faceInfo => { //const\r\n    // dot = snap0(face2Plane.normal1.dot(faceInfo.inside)) //if (dot == 0 ? !coplanarSameIsInside : dot < 0) { const\r\n    // pointsInsideFace = fff(faceInfo, face2.surface) const edgeInside = pointsInsideFace == INSIDE ||\r\n    // !coplanarSameIsInside && pointsInsideFace == COPLANAR_SAME const pushEdge =\r\n    // (faceInfo.edge.aDir.like(newEdge.aDir)) ? newEdge : newEdge.flipped()\r\n    // assert(faceInfo.edge.aDir.like(pushEdge.aDir)) edgeInside && mapPush(faceMap, faceInfo.face, pushEdge) })  const\r\n    // newEdgeInside = face2Plane.normal1.cross(newEdge.aDir) const sVEF1 = splitsVolumeEnclosingFaces(thisBrep,\r\n    // col1.getCanon(), newEdgeInside, face2Plane.normal1) let addNewEdge, addNewEdgeFlipped if (addNewEdge = sVEF1 ==\r\n    // INSIDE || coplanarSameIsInside && sVEF1 == COPLANAR_SAME) { mapPush(faceMap, face2, newEdge) } const sVEF2 =\r\n    // splitsVolumeEnclosingFaces(thisBrep, col1.getCanon(), newEdgeInside.negated(), face2Plane.normal1) if\r\n    // (addNewEdgeFlipped = sVEF2 == INSIDE || coplanarSameIsInside && sVEF2 == COPLANAR_SAME) { mapPush(faceMap,\r\n    // face2, newEdge.flipped()) } if (addNewEdge || addNewEdgeFlipped || sVEF1 == COPLANAR_SAME && sVEF2 == INSIDE ||\r\n    // sVEF2 == COPLANAR_SAME && sVEF1 == INSIDE) { return true } } } const c1 = handleEdgeInFace(col1, col2, face,\r\n    // face2, thisBrep, face2Brep, false, hasPair, addPair) const c2 = handleEdgeInFace(col2, col1, face2, face,\r\n    // face2Brep, thisBrep, true, (a, b) => hasPair(b, a), (a, b) => addPair(b, a)) if (c1 || c2) return true  if (col1\r\n    // && col2) { if (hasPair(col1.getCanon(), col2.getCanon())) return  addPair(col1.getCanon(), col2.getCanon())\r\n    // function handleColinearEdgeFaces(col1, col2, thisBrep, face2Brep, coplanarSameIsInside: boolean, thisEdgePoints,\r\n    // has, add) { // not entirely sure for what i had the dirInsides in? //const aDirNegatedInside =\r\n    // (newEdge.a.like(col2.a) || newEdge.a.like(col2.b)) && splitsVolumeEnclosingCone(face2Brep, newEdge.a,\r\n    // newEdge.aDir.negated()) == INSIDE //const bDirInside = (newEdge.b.like(col2.a) || newEdge.b.like(col2.b)) &&\r\n    // splitsVolumeEnclosingCone(face2Brep, newEdge.b, newEdge.bDir) == INSIDE\r\n    // thisBrep.edgeFaces.get(col1.getCanon()).forEach(faceInfo => { const sVEF = splitsVolumeEnclosingFaces(face2Brep,\r\n    // col2.getCanon(), faceInfo.inside, faceInfo.normalAtCanonA) const edgeInside = sVEF == INSIDE ||\r\n    // coplanarSameIsInside && sVEF == COPLANAR_SAME const pushEdge = (faceInfo.edge.aDir.like(newEdge.aDir)) ? newEdge\r\n    // : newEdge.flipped() edgeInside && mapPush(faceMap, faceInfo.face, pushEdge) }) } handleColinearEdgeFaces(col1,\r\n    // col2, thisBrep, face2Brep, true, thisEdgePoints, hasPair, addPair) handleColinearEdgeFaces(col2, col1,\r\n    // face2Brep, thisBrep, false, otherEdgePoints, (a, b) => hasPair(b, a), (a, b) => addPair(b, a)) } }   // what\r\n    // needs to be generated: new edges on face // points on edges where they are cut by faces so that sub edges will\r\n    // be generated for loops // points on ends of edges where the edge will be an edge in the new volume where it goes\r\n    // from A to B //         you don't want thos to be marked as 'inside', otherwise invalid faces will be added // if\r\n    // a face cuts a corner, nothings needs to be done, as that alone does not limit what adjacent faces will be\r\n    // function handleEndPoint(a: IntersectionPointInfo, b: IntersectionPointInfo, newEdge: Edge) { // ends in the\r\n    // middle of b's face if (a && !b) { if (!a.colinear && a.edgeT != a.edge.aT && a.edgeT != a.edge.bT) {\r\n    // mapPush(thisEdgePoints, a.edge.getCanon(), a) assert(a.edge.isValidT(a.edgeT)) } // else colinear segment ends\r\n    // in middle of other face, do nothing } // ends in the middle of a's face if (b && !a) { if (!b.colinear &&\r\n    // b.edgeT != b.edge.aT && b.edgeT != b.edge.bT) { mapPush(otherEdgePoints, b.edge.getCanon(), b)\r\n    // assert(b.edge.isValidT(b.edgeT)) } // else colinear segment ends in middle of other face, do nothing } if (a &&\r\n    // b) { // if a or b is colinear the correct points will already have been added to the edge by handleNewEdge //\r\n    // segment starts/ends on edge/edge intersection function foo(a, b, face, face2, thisPlane, face2Plane, thisBrep,\r\n    // face2Brep, first, thisEdgePoints) { if (!a.colinear && a.edgeT != a.edge.aT && a.edgeT != a.edge.bT) { if\r\n    // (!hasPair(a.edge.getCanon(), b.edge.getCanon())) { addPair(a.edge.getCanon(), b.edge.getCanon()) // ends on a,\r\n    // on colinear segment b bT != a.edge.bT && // b can be colinear, so edgeT == aT is possible if (a.p.like(b.edge.a)\r\n    // || a.p.like(b.edge.b)) { const corner = a.p.like(b.edge.a) ? b.edge.a : b.edge.b // face2brep corner on edge\r\n    // const sVEC1 = splitsVolumeEnclosingCone(face2Brep, corner, a.edge.aDir) const sVEC2 =\r\n    // splitsVolumeEnclosingCone(face2Brep, corner, a.edge.aDir.negated()) // if either of these return\r\n    // ALONG_EDGE_OR_PLANE, then the breps share a colinear edge  if (INSIDE == sVEC1 || INSIDE == sVEC2) {\r\n    // mapPush(thisEdgePoints, a.edge.getCanon(), a) assert(a.edge.isValidT(a.edgeT)) } } else { // edge / edge center\r\n    // intersection const aEdgeDir = a.edge.tangentAt(a.edgeT) const bEdgeDir = b.edge.tangentAt(b.edgeT) const\r\n    // testVector = aEdgeDir.rejectedFrom(bEdgeDir) assert(!testVector.likeO()) const sVEF1 =\r\n    // splitsVolumeEnclosingFaces(face2Brep, b.edge.getCanon(), testVector, thisPlane.normal1) const sVEF2 =\r\n    // splitsVolumeEnclosingFaces(face2Brep, b.edge.getCanon(), testVector.negated(), thisPlane.normal1) if (INSIDE ==\r\n    // sVEF1 || INSIDE == sVEF2) { mapPush(thisEdgePoints, a.edge.getCanon(), a) assert(a.edge.isValidT(a.edgeT)) } } }\r\n    // } }  foo(a, b, face, face2, thisPlane, face2Plane, thisBrep, face2Brep, true, thisEdgePoints) foo(b, a, face2,\r\n    // face, face2Plane, thisPlane, face2Brep, thisBrep, false, otherEdgePoints)  } }   assertInst(PlaneFace, face2)\r\n    // const face: PlaneFace = this // get intersection const thisPlane = this.surface.plane, face2Plane =\r\n    // face2.surface.plane if (thisPlane.isParallelToPlane(face2Plane)) { if (thisPlane.like(face2Plane)) { // normal1\r\n    // same and same location in space // addLikeSurfaceFaces(likeSurfaceFaces, this, face2) } return } const isLine =\r\n    // L3.fromPlanes(thisPlane, face2Plane) // get intersections of newCurve with other edges of face and face2 const\r\n    // ps1 = planeFaceEdgeISPsWithPlane(face, isLine, face2Plane) const ps2 = planeFaceEdgeISPsWithPlane(face2, isLine,\r\n    // thisPlane) if (ps1.length == 0 || ps2.length == 0) { // faces to not intersect return }  let col1:\r\n    // IntersectionPointInfo, col2: IntersectionPointInfo let in1 = false, in2 = false let i = 0, j = 0, last let\r\n    // startP, startDir, startT, startA, startB while (i < ps1.length || j < ps2.length) { assert(i <= ps1.length)\r\n    // assert(j <= ps2.length) const a = ps1[i], b = ps2[j] assert(a || b) if (j == ps2.length || i < ps1.length &&\r\n    // lt(a.t, b.t)) { last = a in1 = !in1 a.used = true in1 && (col1 = a.colinear && a) i++ } else if (i == ps1.length\r\n    // || gt(a.t, b.t)) { last = b in2 = !in2 b.used = true in2 && (col2 = b.colinear && b) j++ } else { // TODO: this\r\n    // will break if 3 points on the same t last = a in1 = !in1 in2 = !in2 //if (in1 == in2) { a.used = true b.used =\r\n    // true in1 && (col1 = a.colinear && a) in2 && (col2 = b.colinear && b) //} i++ j++ } if (startP && !(in1 && in2))\r\n    // { // segment end const newEdge = new StraightEdge(isLine, startP, last.p, startT, last.t, undefined, 'genseg' +\r\n    // getGlobalId()) startP = undefined last.used = true if (handleNewEdge(newEdge, col1 && col1.edge, col2 &&\r\n    // col2.edge)) { handleEndPoint(startA || col1, startB || col2, newEdge) handleEndPoint(a && a.used && a || col1, b\r\n    // && b.used && b || col2, newEdge) } } else if (in1 && in2) { // new segment just started startP = last.p startDir\r\n    // = last.insideDir startT = last.t startA = a && a.used && a startB = b && b.used && b } if (!in1 && a && last ==\r\n    // a && a.colinear) { checkedPairs.add(new Pair(a.edge.getCanon(), face2)) } if (!in2 && b && (last == b || b.used)\r\n    // && b.colinear) { checkedPairs.add(new Pair(b.edge.getCanon(), face)) } } }\r\n    withHole(holeEdges) {\r\n        return new PlaneFace(this.surface, this.contour, [holeEdges]);\r\n    }\r\n    pointsToInside(p, dir) {\r\n        return this.containsPoint2(p.plus(dir.times(NLA_PRECISION * 8)));\r\n    }\r\n    edgeISPsWithPlane(isLine, plane2) {\r\n        const face = this;\r\n        assert(face.surface.plane.containsLine(isLine));\r\n        assert(plane2.containsLine(isLine));\r\n        const plane = face.surface.plane;\r\n        const ps = [];\r\n        const loops = [face.contour].concat(face.holes);\r\n        loops.forEach(loop => {\r\n            const colinearEdges = loop.map(edge => edge.colinearToLine(isLine) && -sign(edge.aDir.dot(isLine.dir1)));\r\n            const isLineOut = isLine.dir1.cross(plane.normal1);\r\n            loop.forEach((edge, edgeIndex, edges) => {\r\n                const nextEdgeIndex = (edgeIndex + 1) % edges.length, nextEdge = edges[nextEdgeIndex], colinearEdge = colinearEdges[edgeIndex];\r\n                //console.log(edge.toSource()) {p:V3(2, -2.102, 0),\r\n                if (colinearEdge) {\r\n                    // edge colinear to intersection line\r\n                    const curveAT = isLine.pointT(edge.a), curveBT = isLine.pointT(edge.b);\r\n                    // add interval for colinear segment\r\n                    ps.push({ p: edge.a, insideDir: edge.aDir, t: curveAT, edge: edge, edgeT: edge.aT, colinear: true }, {\r\n                        p: edge.b,\r\n                        insideDir: edge.bDir.negated(),\r\n                        t: curveBT,\r\n                        edge: edge,\r\n                        edgeT: edge.bT,\r\n                        colinear: true,\r\n                    });\r\n                    // open next interval if necessary\r\n                    const nextSide = colinearEdges[nextEdgeIndex] ||\r\n                        dotCurve2(nextEdge.curve, nextEdge.aT, isLineOut, nextEdge.deltaTSign());\r\n                    if (colinearEdge * nextSide < 0) {\r\n                        // side changes\r\n                        ps.push({\r\n                            p: nextEdge.a,\r\n                            insideDir: edge.bDir,\r\n                            t: curveBT,\r\n                            edge: nextEdge,\r\n                            edgeT: nextEdge.aT,\r\n                            colinear: false,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    // not necessarily a straight edge, so multiple intersections are possible\r\n                    const edgeTs = edge.edgeISTsWithPlane(plane2);\r\n                    assert(edgeTs.every(t => plane2.containsPoint(edge.curve.at(t))), edgeTs);\r\n                    for (const edgeT of edgeTs) {\r\n                        if (edgeT == edge.bT) {\r\n                            // endpoint lies on intersection line\r\n                            const side = dotCurve2(edge.curve, edge.bT, isLineOut, -edge.deltaTSign());\r\n                            const nextSide = colinearEdges[nextEdgeIndex] ||\r\n                                dotCurve2(nextEdge.curve, nextEdge.aT, isLineOut, nextEdge.deltaTSign());\r\n                            if (side * nextSide < 0) {\r\n                                // next segment is not colinear and ends on different side\r\n                                ps.push({\r\n                                    p: edge.b,\r\n                                    insideDir: plane2.normal1.negated(),\r\n                                    t: isLine.pointT(edge.b),\r\n                                    edge: edge,\r\n                                    edgeT: edge.bT,\r\n                                    colinear: false,\r\n                                });\r\n                            }\r\n                        }\r\n                        else if (edgeT != edge.aT) {\r\n                            // edge crosses intersection line, neither starts nor ends on it\r\n                            const p = edge.curve.at(edgeT);\r\n                            assert(plane2.containsPoint(p), edge.toString(), p, edgeT, plane2.distanceToPoint(p));\r\n                            assert(isLine.containsPoint(p), edge.toString(), p, edgeT, isLine.distanceToPoint(p));\r\n                            const insideDir = plane2.normal1.negated();\r\n                            ps.push({\r\n                                p: p,\r\n                                insideDir: insideDir,\r\n                                t: isLine.pointT(p),\r\n                                edge: edge,\r\n                                edgeT: edgeT,\r\n                                colinear: false,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        // duplicate 't's are ok, as sometimes a segment needs to stop and start again\r\n        // should be sorted so that back facing ones are first\r\n        ps.sort((a, b) => a.t - b.t || a.insideDir.dot(isLine.dir1));\r\n        return ps;\r\n    }\r\n}\r\nexport class RotationFace extends Face {\r\n    constructor(rot, contour, holes, name, info) {\r\n        super(rot, contour, holes, name, info);\r\n    }\r\n    static loopDoesNotCrossPlane(loop, seamPlane) {\r\n        let side = 0;\r\n        // returns true if d is on the other side as previous calls\r\n        function checkSide(d) {\r\n            if (side == 0) {\r\n                side = d;\r\n            }\r\n            else {\r\n                return !side || side * d < 0;\r\n            }\r\n            return false;\r\n        }\r\n        for (const edge of loop) {\r\n            const ts = edge.edgeISTsWithPlane(seamPlane);\r\n            if (ts.length == 0) {\r\n                if (!(edge.curve instanceof L3) && checkSide(seamPlane.distanceToPointSigned(edge.a)))\r\n                    return false;\r\n            }\r\n            else {\r\n                for (const t of ts) {\r\n                    // TODO: this part probably should be in a separate function\r\n                    // check 'backwards' only if if aT != t\r\n                    if (edge.aT != t) {\r\n                        if (checkSide(dotCurve2(edge.curve, t, seamPlane.normal1, -edge.deltaTSign())))\r\n                            return false;\r\n                    }\r\n                    if (edge.bT != t) {\r\n                        if (checkSide(dotCurve2(edge.curve, t, seamPlane.normal1, edge.deltaTSign())))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getAABB() {\r\n        if (this.aabb)\r\n            return this.aabb;\r\n        this.aabb = AABB.forAABBs(this.contour.map(e => e.getAABB()));\r\n        this.aabb.addPoints(this.surface.getExtremePoints().filter(p => this.containsPoint(p)));\r\n        return this.aabb;\r\n    }\r\n    unrollLoop(edgeLoop) {\r\n        const vs = [];\r\n        const uvP = this.surface.uvPFunc();\r\n        const verticesNo0s = edgeLoop.map(edge => edge.getVerticesNo0());\r\n        const startEdgeIndex = verticesNo0s.findIndex(edgeVertices => !eq(uvP(edgeVertices[0]).x, Math.PI));\r\n        assert(-1 != startEdgeIndex);\r\n        // console.log(startEdgeIndex)\r\n        for (let i = 0; i < edgeLoop.length; i++) {\r\n            const edgeIndex = (i + startEdgeIndex) % edgeLoop.length;\r\n            for (let j = 0; j < verticesNo0s[edgeIndex].length; j++) {\r\n                const p = verticesNo0s[edgeIndex][j];\r\n                const localP = uvP(p);\r\n                // console.log(hint, p.sce, localP.sce)\r\n                vs.push(localP);\r\n            }\r\n        }\r\n        edgeLoop.forEach(edge => {\r\n            edge.getVerticesNo0().forEach(p => {\r\n                vs.push(uvP(p));\r\n            });\r\n        });\r\n        console.log('vs\\n', vs.join('\\n'), vs.length);\r\n        return vs;\r\n    }\r\n    /**\r\n     * f1 cos t + f2 sin t\r\n     * tan(phi) = sin / cos\r\n     *          = (f1x cos t + f2x sin t) / (f1y cos t + f2y sin t)\r\n     *\r\n     *          = (-f1x sin t + f2x cos t) / (-f1y sin t + f2y cos t)\r\n     */\r\n    unrollEllipsoidLoops(edgeLoops) {\r\n        const verticesUV = [], vertices = [], loopStarts = [];\r\n        const ellipsoid = this.surface;\r\n        const ptpf = ellipsoid.uvPFunc();\r\n        const testDegeneratePoint = ellipsoid instanceof EllipsoidSurface\r\n            ? (nextStart) => nextStart.like(ellipsoid.center.plus(ellipsoid.f3)) ||\r\n                nextStart.like(ellipsoid.center.minus(ellipsoid.f3))\r\n            : (nextStart) => nextStart.like(this.surface.center);\r\n        for (const edgeLoop of edgeLoops) {\r\n            loopStarts.push(verticesUV.length);\r\n            // console.log(startEdgeIndex)\r\n            for (let i = 0; i < edgeLoop.length; i++) {\r\n                const ipp = (i + 1) % edgeLoop.length;\r\n                const verticesNo0 = edgeLoop[i].getVerticesNo0();\r\n                vertices.push(...verticesNo0);\r\n                verticesUV.push(...verticesNo0.map(v => ptpf(v)));\r\n                const nextStart = edgeLoop[ipp].a;\r\n                //console.log('BLAH', nextStart.str, ellipsoid.center.plus(ellipsoid.f3).str)\r\n                if (testDegeneratePoint(nextStart)) {\r\n                    const bDirLC = ellipsoid.matrixInverse.transformVector(edgeLoop[i].bDir), aDirLC = ellipsoid.matrixInverse.transformVector(edgeLoop[ipp].aDir);\r\n                    const inAngle = Math.atan2(-bDirLC.y, -bDirLC.x);\r\n                    const outAngle = Math.atan2(aDirLC.y, aDirLC.x);\r\n                    const stLast = verticesUV.pop();\r\n                    verticesUV.push(new V3(inAngle, stLast.y, 0), new V3(outAngle, stLast.y, 0));\r\n                    vertices.push(vertices.last);\r\n                }\r\n                verticesUV.forEach(({ u, v }) => {\r\n                    assert(isFinite(u));\r\n                    assert(isFinite(v));\r\n                });\r\n            }\r\n        }\r\n        let normals;\r\n        if (this.surface instanceof EllipsoidSurface) {\r\n            normals = vertices.map(v => ellipsoid.normalP(v));\r\n        }\r\n        else {\r\n            const normalUV = ellipsoid.normalUVFunc();\r\n            normals = verticesUV.map(({ u, v }) => normalUV(u, v));\r\n        }\r\n        assert(vertices.length == vertices.length);\r\n        //console.log(verticesUV.map(v => v.str).join('\\n'))\r\n        return {\r\n            verticesUV: verticesUV,\r\n            vertices: vertices,\r\n            normals: normals,\r\n            loopStarts: loopStarts,\r\n        };\r\n    }\r\n    unrollCylinderLoops(loops) {\r\n        const vertexLoops = loops.map(loop => loop.flatMap(edge => edge.getVerticesNo0()));\r\n        const surface = this.surface;\r\n        const vertices = vertexLoops.concatenated();\r\n        // this.unrollLoop(loop).map(v => new V3(v.x / uStep, v.y / vStep, 0)))\r\n        const loopStarts = vertexLoops.reduce((arr, loop) => (arr.push(arr.last + loop.length), arr), [0]);\r\n        const uvPFunc = surface.uvPFunc();\r\n        const verticesUV = vertices.map(v => uvPFunc(v));\r\n        const uvN = surface.normalUVFunc();\r\n        const normals = verticesUV.map(({ u, v }) => uvN(u, v));\r\n        return { verticesUV: verticesUV, vertices: vertices, normals: normals, loopStarts: loopStarts };\r\n    }\r\n    /**\r\n     * at(s, t) = new V3(s cos t, s sin t, t + )\r\n     *\r\n     * x = 0\r\n     *\r\n     * s cos t = 0\r\n     * ==> s = 0 || cos t = 0\r\n     * ==> L3.Z || V3(0, +-s, k * 2 pi)\r\n     *\r\n     * x = c\r\n     * s cos t = c\r\n     * ==> V3(c, c sin t / cos t = c tan t, t)\r\n     * ==> V3(c, c t, arctan t)\r\n     *\r\n     *\r\n     * x . n = w\r\n     *      s cos t nx + s sin t ny + t nz = w\r\n     *      s = (w - t nz) / (cos t nx + sub t ny)\r\n     * ==> V3(\r\n     *          cos t (w - t nz) / (cos t nx + sin t ny)\r\n     *          sin t (w - t nz) / (cos t nx + sin t ny)\r\n     *          t)\r\n     *\r\n     *  ==> V3(\r\n     *          (w - z arctan t) / (x + t y)\r\n     *          (w - z arctan t) / (y + x / t)\r\n     *          arctan t)\r\n     *\r\n     *\r\n     *\r\n     */\r\n    addToMesh(mesh, uStep = this.surface.uStep, vStep = this.surface.vStep) {\r\n        assertf(() => uStep > 0 && vStep > 0, uStep, vStep, 'Surface: ' + this.surface);\r\n        const triangles = [];\r\n        const pMN = (m, n) => this.surface.pUVFunc()(m * uStep, n * vStep);\r\n        const normalMN = (m, n) => this.surface.normalUVFunc()(m * uStep, n * vStep);\r\n        const loops = this.getLoops();\r\n        const { vertices, verticesUV, normals, loopStarts } = this.surface instanceof EllipsoidSurface || this.surface instanceof ConicSurface\r\n            ? this.unrollEllipsoidLoops(loops)\r\n            : this.unrollCylinderLoops(loops);\r\n        loopStarts.push(vertices.length);\r\n        const verticesMN = verticesUV.map(({ u, v }) => new V3(u / uStep, v / vStep, 0));\r\n        for (let vertexLoopIndex = 0; vertexLoopIndex < loops.length; vertexLoopIndex++) {\r\n            const vertexLoopStart = loopStarts[vertexLoopIndex];\r\n            const vertexLoopLength = loopStarts[vertexLoopIndex + 1] - vertexLoopStart;\r\n            const base = mesh.vertices.length + loopStarts[vertexLoopIndex];\r\n            for (let i = 0; i < vertexLoopLength; i++) {\r\n                mesh.LINES.push(base + i, base + (i + 1) % vertexLoopLength);\r\n            }\r\n        }\r\n        disableConsole();\r\n        let minM = Infinity, maxM = -Infinity, minN = Infinity, maxN = -Infinity;\r\n        //console.log('surface', this.surface.str)\r\n        //console.log(verticesMN)\r\n        //drPs.push(...verticesMN.map((v, i) => ({p: vertices[i], text: `${i} uv: ${v.toString(x => round10(x,\r\n        // -4))}`})))\r\n        verticesMN.forEach(([m, n]) => {\r\n            assert(isFinite(m));\r\n            assert(isFinite(n));\r\n            minM = min(minM, m);\r\n            maxM = max(maxM, m);\r\n            minN = min(minN, n);\r\n            maxN = max(maxN, n);\r\n        });\r\n        if (ParametricSurface.is(this.surface)) {\r\n            //assert(this.surface.boundsSigned(minM * uStep, minN * vStep) > -NLA_PRECISION)\r\n            //assert(this.surface.boundsSigned(maxM * uStep, maxN * vStep) > -NLA_PRECISION)\r\n        }\r\n        const mOffset = floor(minM + NLA_PRECISION), nOffset = floor(minN + NLA_PRECISION);\r\n        const mRes = ceil(maxM - NLA_PRECISION) - mOffset, nRes = ceil(maxN - NLA_PRECISION) - nOffset;\r\n        console.log(uStep, vStep, mRes, nRes);\r\n        if (mRes == 1 && nRes == 1) {\r\n            // triangulate this face as if it were a plane\r\n            const polyTriangles = triangulateVertices(V3.Z, verticesMN, loopStarts.slice(1, 1 + this.holes.length));\r\n            triangles.push(...polyTriangles);\r\n        }\r\n        else {\r\n            const partss = new Array(mRes * nRes);\r\n            function fixUpPart(part, baseM, baseN) {\r\n                assert(baseM < mRes && baseN < nRes, `${baseM}, ${baseN}, ${mRes}, ${nRes}`);\r\n                console.log('complete part', part, baseM, baseN);\r\n                //console.trace()\r\n                assert(part.length);\r\n                const cellM = baseM + mOffset, cellN = baseN + nOffset;\r\n                for (const index of part) {\r\n                    assert(le(cellM, verticesMN[index].x) && le(verticesMN[index].x, cellM + 1), `${index} ${verticesMN[index].str} ${cellM} ${cellM}`);\r\n                    assert(le(cellN, verticesMN[index].y) && le(verticesMN[index].y, cellN + 1));\r\n                }\r\n                const pos = baseN * mRes + baseM;\r\n                (partss[pos] || (partss[pos] = [])).push(part);\r\n                //const outline = partss[pos] || (partss[pos] = [minM + baseM * uStep, minN + baseN * vStep, minM +\r\n                // (baseM + 1) * uStep, minN + (baseN + 1) * vStep])\r\n            }\r\n            // 'some' instead of forEach so we can return out of the entire function if this.edges crosses no borders\r\n            // and\r\n            for (let vertexLoopIndex = 0; vertexLoopIndex < loops.length; vertexLoopIndex++) {\r\n                let part = undefined, firstPart, firstPartBaseM = -1, firstPartBaseN = -1;\r\n                let lastBaseM = -1, lastBaseN = -1;\r\n                let partCount = 0;\r\n                const vertexLoopStart = loopStarts[vertexLoopIndex];\r\n                const vertexLoopLength = loopStarts[vertexLoopIndex + 1] - vertexLoopStart;\r\n                for (let vlvi = 0; vlvi < vertexLoopLength; vlvi++) {\r\n                    const vx0index = vertexLoopStart + vlvi, vx0 = verticesMN[vx0index];\r\n                    const vx1index = vertexLoopStart + (vlvi + 1) % vertexLoopLength, vx1 = verticesMN[vx1index];\r\n                    //console.log('dask', vx0index, vx1index)\r\n                    const vx01 = vx0.to(vx1);\r\n                    assert(vx0);\r\n                    const di = vx01.x, dj = vx01.y;\r\n                    let vxIndex = vx0index, vx = vx0, currentT = 0;\r\n                    let whileLimit = 400;\r\n                    while (--whileLimit) {\r\n                        // points which are on a grid line are assigned to the cell into which they are going (+\r\n                        // NLA_PRECISION * sign(di)) if they are parallel to the gridline (eq0(di)), they belong the\r\n                        // the cell for which they are a CCW boundary\r\n                        const baseM = floor(vx.u + (!eq0(di) ? sign(di) : -sign(dj)) * NLA_PRECISION) - mOffset;\r\n                        const baseN = floor(vx.v + (!eq0(dj) ? sign(dj) : sign(di)) * NLA_PRECISION) - nOffset;\r\n                        assert(baseM < mRes && baseN < nRes, `${baseM}, ${baseN}, ${mRes}, ${nRes}`);\r\n                        // figure out the next intersection with a gridline:\r\n                        // iNext is the positive horizontal distance to the next vertical gridline\r\n                        const iNext = ceil(sign(di) * vx.u + NLA_PRECISION) - sign(di) * vx.u;\r\n                        const jNext = ceil(sign(dj) * vx.v + NLA_PRECISION) - sign(dj) * vx.v;\r\n                        const iNextT = currentT + iNext / abs(di);\r\n                        const jNextT = currentT + jNext / abs(dj);\r\n                        //console.log(vxIndex, vx.str, 'vij', vx.u, vx.v, 'd', di, dj, 'ijNext', iNext, jNext, 'nextT',\r\n                        // iNextT, jNextT)\r\n                        if (lastBaseM != baseM || lastBaseN != baseN) {\r\n                            if (part) {\r\n                                if (!firstPart) {\r\n                                    firstPart = part;\r\n                                    firstPartBaseM = lastBaseM;\r\n                                    firstPartBaseN = lastBaseN;\r\n                                }\r\n                                else {\r\n                                    partCount++;\r\n                                    fixUpPart(part, lastBaseM, lastBaseN);\r\n                                }\r\n                            }\r\n                            part = [vxIndex];\r\n                        }\r\n                        lastBaseM = baseM;\r\n                        lastBaseN = baseN;\r\n                        currentT = min(iNextT, jNextT);\r\n                        if (ge(currentT, 1)) {\r\n                            //console.log('breaking ', vx1index)\r\n                            part.push(vx1index);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            const nextPoint = vx0.lerp(vx1, currentT);\r\n                            const nextPointIndex = addVertex(nextPoint.x, nextPoint.y);\r\n                            //console.log('pushing ', nextPointIndex)\r\n                            part.push(nextPointIndex);\r\n                            vx = nextPoint;\r\n                            vxIndex = nextPointIndex;\r\n                        }\r\n                    }\r\n                    assert(whileLimit, 'whileLimit');\r\n                }\r\n                if (0 == partCount) {\r\n                    // complete loop\r\n                    assert(false, 'found a hole, try increasing resolution');\r\n                }\r\n                // at this point, the firstPart hasn't been added, and the last part also hasn't been added\r\n                // either they belong to the same cell, or not\r\n                if (firstPartBaseM == lastBaseM && firstPartBaseN == lastBaseN) {\r\n                    part.pop();\r\n                    fixUpPart(part.concat(firstPart), lastBaseM, lastBaseN);\r\n                }\r\n                else {\r\n                    fixUpPart(firstPart, firstPartBaseM, firstPartBaseN);\r\n                    fixUpPart(part, lastBaseM, lastBaseN);\r\n                }\r\n                console.log('firstPart', firstPart);\r\n            }\r\n            console.log('calculated parts', partss);\r\n            const fieldVertexIndices = new Array((mRes + 1) * (nRes + 1));\r\n            function addVertex(m, n) {\r\n                verticesMN.push(new V3(m, n, 0));\r\n                normals.push(normalMN(m, n));\r\n                return vertices.push(pMN(m, n)) - 1;\r\n            }\r\n            function getGridVertexIndex(i, j) {\r\n                const index = j * (mRes + 1) + i;\r\n                return fieldVertexIndices[index] || (fieldVertexIndices[index] = addVertex(i + mOffset, j + nOffset));\r\n            }\r\n            for (let col = 0; col < mRes; col++) {\r\n                let inside = false;\r\n                for (let row = 0; row < nRes; row++) {\r\n                    const pos = row * mRes + col;\r\n                    const fieldU = mOffset + col, fieldV = nOffset + row;\r\n                    const parts = partss[pos];\r\n                    if (!parts) {\r\n                        if (inside) {\r\n                            pushQuad(triangles, false, getGridVertexIndex(col, row), getGridVertexIndex(col + 1, row), getGridVertexIndex(col, row + 1), getGridVertexIndex(col + 1, row + 1));\r\n                        }\r\n                    }\r\n                    else {\r\n                        // assemble the field with segments in in\r\n                        function opos(index) {\r\n                            const p = verticesMN[index], u1 = p.x - fieldU, v1 = p.y - fieldV;\r\n                            assert(-NLA_PRECISION < u1 &&\r\n                                u1 < 1 + NLA_PRECISION &&\r\n                                -NLA_PRECISION < v1 &&\r\n                                v1 < 1 + NLA_PRECISION, 'oob u1 v1 ' +\r\n                                u1 +\r\n                                ' ' +\r\n                                v1 +\r\n                                ' ' +\r\n                                index +\r\n                                ' ' +\r\n                                p.str +\r\n                                'IF THIS FAILS check canonSeamU is correct');\r\n                            return v1 < u1 ? u1 + v1 : 4 - u1 - v1;\r\n                        }\r\n                        while (parts.length) {\r\n                            const outline = [];\r\n                            const startPart = parts[0];\r\n                            assert(startPart.length > 0);\r\n                            let currentPart = startPart;\r\n                            do {\r\n                                outline.push(...currentPart);\r\n                                const currentPartEndOpos = opos(currentPart.last);\r\n                                const nextPartIndex = parts.indexWithMax(part => -mod(opos(part[0]) - currentPartEndOpos, 4));\r\n                                const nextPart = parts.removeIndex(nextPartIndex);\r\n                                let currentOpos = currentPartEndOpos;\r\n                                const nextPartStartOpos = opos(nextPart[0]) > currentOpos ? opos(nextPart[0]) : opos(nextPart[0]) + 4;\r\n                                let nextOpos = ceil(currentOpos + NLA_PRECISION);\r\n                                let flipping = eq0((currentOpos + NLA_PRECISION) % 1 - NLA_PRECISION);\r\n                                //inside = inside != (!eq0(currentOpos % 1) && currentOpos % 2 < 1)\r\n                                while (lt(nextOpos, nextPartStartOpos)) {\r\n                                    switch (nextOpos % 4) {\r\n                                        case 0:\r\n                                            outline.push(getGridVertexIndex(col, row));\r\n                                            break;\r\n                                        case 1:\r\n                                            inside = inside != flipping;\r\n                                            outline.push(getGridVertexIndex(col + 1, row));\r\n                                            break;\r\n                                        case 2:\r\n                                            outline.push(getGridVertexIndex(col + 1, row + 1));\r\n                                            break;\r\n                                        case 3:\r\n                                            inside = inside != flipping;\r\n                                            outline.push(getGridVertexIndex(col, row + 1));\r\n                                            break;\r\n                                    }\r\n                                    flipping = true;\r\n                                    nextOpos++;\r\n                                }\r\n                                // if the next loop would have completed a top or bottom segment\r\n                                inside = inside != (flipping && nextOpos % 2 == 1 && eq(nextOpos, nextPartStartOpos));\r\n                                currentOpos = nextOpos;\r\n                                currentPart = nextPart;\r\n                            } while (currentPart != startPart);\r\n                            // triangulate outline\r\n                            if (outline.length == 3) {\r\n                                // its just a triangle\r\n                                triangles.push(...outline);\r\n                            }\r\n                            else {\r\n                                const polyTriangles = triangulateVertices(V3.Z, outline.map(i => verticesMN[i]), []).map(i => outline[i]);\r\n                                triangles.push(...polyTriangles);\r\n                            }\r\n                            //console.log('outline', col, row, outline)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //console.log('trinagle', triangles.max(), vertices.length, triangles.length, triangles.toSource(),\r\n        // triangles.map(col => vertices[col].$).toSource() ) assert(normals.every(n => n.hasLength(1)), normals.find(n\r\n        // => !n.hasLength(1)).length() +' '+normals.findIndex(n => !n.hasLength(1)))\r\n        Array.prototype.push.apply(mesh.TRIANGLES, triangles.map(index => index + mesh.vertices.length));\r\n        Array.prototype.push.apply(mesh.vertices, vertices);\r\n        Array.prototype.push.apply(mesh.normals, normals);\r\n        //this.addEdgeLines(mesh)\r\n        enableConsole();\r\n    }\r\n    addToMesh2(mesh) {\r\n        const closed = false;\r\n        const zSplit = 8;\r\n        const ribs = [];\r\n        let minZ = Infinity, maxZ = -Infinity;\r\n        //let cmp = (a, b) => a.value - b.value\r\n        const f = this.surface.pUVFunc();\r\n        const normalF = this.surface.normalUVFunc();\r\n        const vertexLoops = this.holes.concat([this.contour]).map(loop => this.unrollLoop(loop));\r\n        vertexLoops.forEach(vertexLoop => {\r\n            vertexLoop.forEach(({ x: d, y: z }) => {\r\n                const index0 = ribs.binaryIndexOf(d, (a, b) => snap(a.value - b, 0));\r\n                if (index0 < 0) {\r\n                    ribs.splice(-index0 - 1, 0, { value: d, left: [], right: [] });\r\n                }\r\n                minZ = min(minZ, z);\r\n                maxZ = max(maxZ, z);\r\n            });\r\n        });\r\n        console.log('zzzs', minZ, maxZ, vertexLoops[0].toSource().replace(/\\), /g, ',\\n'));\r\n        const correction = 1;\r\n        vertexLoops.forEach(vertexLoop => {\r\n            vertexLoop.forEach((v0, i, vs) => {\r\n                let v1 = vs[(i + 1) % vs.length], dDiff = v1.x - v0.x;\r\n                //console.log(v0.sce, v1.sce)\r\n                if (eq0(dDiff)) {\r\n                    return;\r\n                }\r\n                if (dDiff < 0) {\r\n                    ;\r\n                    [v0, v1] = [v1, v0];\r\n                    dDiff = -dDiff;\r\n                }\r\n                const index0 = ribs.binaryIndexOf(v0.x, (a, b) => snap(a.value - b, 0));\r\n                const index1 = ribs.binaryIndexOf(v1.x, (a, b) => snap(a.value - b, 0));\r\n                ribs[index0].right.binaryInsert(v0.y);\r\n                for (let j = (index0 + correction) % ribs.length; j != index1; j = (j + correction) % ribs.length) {\r\n                    const x = ribs[j].value;\r\n                    const part = (x - v0.x) / dDiff;\r\n                    const interpolated = v1.y * part + v0.y * (1 - part);\r\n                    ribs[j].left.binaryInsert(interpolated);\r\n                    ribs[j].right.binaryInsert(interpolated);\r\n                }\r\n                ribs[index1].left.binaryInsert(v1.y);\r\n                // console.log(ribs.map(r=>r.toSource()).join('\\n'))\r\n            });\r\n        });\r\n        const vertices = [], triangles0 = [], normals = [];\r\n        for (let i = 0; i < ribs.length; i++) {\r\n            const ribLeft = ribs[i], ribRight = ribs[(i + 1) % ribs.length];\r\n            assert(ribLeft.right.length == ribRight.left.length);\r\n            for (let j = 0; j < ribLeft.right.length; j++) {\r\n                vertices.push(f(ribLeft.value, ribLeft.right[j]), f(ribRight.value, ribRight.left[j]));\r\n                normals.push(normalF(ribLeft.value, ribLeft.right[j]), normalF(ribRight.value, ribRight.left[j]));\r\n            }\r\n        }\r\n        //console.log(ribs.map(r=>r.toSource()).join('\\n'))\r\n        const vss = vertices.length, detailVerticesStart = vss;\r\n        const zInterval = maxZ - minZ, zStep = zInterval / zSplit;\r\n        const detailZs = arrayFromFunction(zSplit - 1, i => minZ + (1 + i) * zStep);\r\n        console.log('detailsZs', detailZs);\r\n        for (let i = 0; i < ribs.length; i++) {\r\n            const d = ribs[i].value;\r\n            for (let j = 0; j < detailZs.length; j++) {\r\n                vertices.push(f(d, detailZs[j]));\r\n                normals.push(normalF(d, detailZs[j]));\r\n            }\r\n        }\r\n        // console.log('detailVerticesStart', detailVerticesStart, 'vl', vertices.length, vertices.length -\r\n        // detailVerticesStart, ribs.length) finally, fill in the ribs\r\n        let vsStart = 0;\r\n        const flipped2 = true;\r\n        //for (var i = 0; i < 1; i++) {\r\n        const end = closed ? ribs.length : ribs.length - 1;\r\n        for (let i = 0; i < end; i++) {\r\n            const ipp = (i + 1) % ribs.length;\r\n            let inside = false, colPos = 0;\r\n            const ribLeft = ribs[i], ribRight = ribs[(i + 1) % ribs.length];\r\n            for (let j = 0; j < detailZs.length + 1; j++) {\r\n                const detailZ = detailZs[j] || 100000;\r\n                if (!inside) {\r\n                    if (ribLeft.right[colPos] < detailZ && ribRight.left[colPos] < detailZ) {\r\n                        if (ribLeft.right[colPos + 1] < detailZ || ribRight.left[colPos + 1] < detailZ) {\r\n                            pushQuad(triangles0, flipped2, vsStart + colPos * 2, vsStart + (colPos + 1) * 2, vsStart + colPos * 2 + 1, vsStart + (colPos + 1) * 2 + 1);\r\n                            colPos += 2;\r\n                            if (ribLeft.right[colPos] < detailZ || ribRight.left[colPos] < detailZ) {\r\n                                j--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            pushQuad(triangles0, flipped2, vsStart + colPos * 2, vsStart + colPos * 2 + 1, detailVerticesStart + i * detailZs.length + j, detailVerticesStart + ipp * detailZs.length + j);\r\n                            inside = true;\r\n                            colPos++;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (ribLeft.right[colPos] < detailZ || ribRight.left[colPos] < detailZ) {\r\n                        pushQuad(triangles0, flipped2, detailVerticesStart + i * detailZs.length + j - 1, detailVerticesStart + ipp * detailZs.length + j - 1, vsStart + colPos * 2, vsStart + colPos * 2 + 1);\r\n                        inside = false;\r\n                        colPos++;\r\n                        if (ribLeft.right[colPos] < detailZ || ribRight.left[colPos] < detailZ) {\r\n                            j--;\r\n                        }\r\n                    }\r\n                    else {\r\n                        pushQuad(triangles0, flipped2, detailVerticesStart + i * detailZs.length + j, detailVerticesStart + i * detailZs.length + j - 1, detailVerticesStart + ipp * detailZs.length + j, detailVerticesStart + ipp * detailZs.length + j - 1);\r\n                    }\r\n                }\r\n            }\r\n            vsStart += ribLeft.right.length * 2;\r\n        }\r\n        //console.log('trinagle', triangles0.max(), vertices.length, triangles0.length, triangles0.toSource(),\r\n        // triangles0.map(i => vertices[i].$).toSource() )\r\n        const triangles = triangles0.map(index => index + mesh.vertices.length);\r\n        //assert(normals.every(n => n.hasLength(1)), normals.find(n => !n.hasLength(1)).length() +'\r\n        // '+normals.findIndex(n => !n.hasLength(1)))\r\n        Array.prototype.push.apply(mesh.vertices, vertices);\r\n        Array.prototype.push.apply(mesh.TRIANGLES, triangles);\r\n        Array.prototype.push.apply(mesh.normals, normals);\r\n        //this.addEdgeLines(mesh)\r\n    }\r\n}\r\n//# sourceMappingURL=Face.js.map","import earcut from 'earcut';\r\nimport { JavaMap, JavaSet, JavaSet as CustomSet } from 'javasetmap.ts';\r\nimport nerdamer from 'nerdamer';\r\nimport { AABB, assert, assertf, assertInst, assertNever, assertNumbers, assertVectors, eq, eq0, gt, lt, mapPush, newtonIterate2d, newtonIterateWithDerivative, NLA_DEBUG, NLA_PRECISION, SCE, snap, snap0, TAU, Transformable, V, V3, } from 'ts3dutils';\r\nimport { Mesh } from 'tsgl';\r\nimport { curvePointMF, Edge, Face, L3, P3, PlaneFace, PointVsFace, uvInAABB2, } from './index';\r\nimport { abs, sign, sqrt } from './math';\r\nexport const EPS = 1e-5;\r\nlet globalId = 0;\r\nexport function getGlobalId() {\r\n    return globalId++;\r\n}\r\nexport function addLikeSurfaceFaces(likeSurfaceFaces, face1, face2) {\r\n    // There cannot be two subgroups which will later be connected, as the \"graph\" of like surface faces is fully\r\n    // connected\r\n    for (let i = 0; i < likeSurfaceFaces.length; i++) {\r\n        const faceGroup = likeSurfaceFaces[i];\r\n        let foundFace1 = false, foundFace2 = false;\r\n        for (let j = 0; j < faceGroup.length; j++) {\r\n            const face = faceGroup[j];\r\n            if (face == face1) {\r\n                foundFace1 = true;\r\n            }\r\n            if (face == face2) {\r\n                foundFace2 = true;\r\n            }\r\n        }\r\n        if (foundFace1 != foundFace2) {\r\n            faceGroup.push(foundFace1 ? face2 : face1);\r\n            return;\r\n        }\r\n        else if (foundFace1) {\r\n            // found both\r\n            return;\r\n        }\r\n    }\r\n    // nothing found, add a new group\r\n    likeSurfaceFaces.push([face1, face2]);\r\n}\r\nexport function assembleFaceFromLooseEdges(edges, surface, originalFace) {\r\n    const visited = new Set();\r\n    function nextStart() {\r\n        return edges.find(edge => !visited.has(edge));\r\n    }\r\n    const loops = [];\r\n    let startEdge, currentEdge = undefined;\r\n    while ((startEdge = nextStart())) {\r\n        currentEdge = startEdge;\r\n        const loop = [];\r\n        let total = 0;\r\n        do {\r\n            visited.add(currentEdge);\r\n            loop.push(currentEdge);\r\n            const possibleEdges = edges.filter(edge => currentEdge.b.like(edge.a));\r\n            const normalAtCurrentB = surface.normalP(currentEdge.b);\r\n            const nextEdgeIndex = possibleEdges.indexWithMax(edge => currentEdge.bDir.angleRelativeNormal(edge.aDir, normalAtCurrentB));\r\n            currentEdge = possibleEdges[nextEdgeIndex];\r\n        } while (startEdge != currentEdge && total++ < 200);\r\n        assert(total != 201);\r\n        loops.push(loop);\r\n    }\r\n    const assembledFaces = BRep.assembleFacesFromLoops(loops, surface, originalFace);\r\n    assertf(() => 1 == assembledFaces.length);\r\n    return assembledFaces[0];\r\n}\r\n/**\r\n * ## Markdown header\r\n * ![foo](screenshots/Capture.PNG)\r\n * {@link ../screenshots/Capture.PNG}\r\n * find the next edge with the MAXIMUM angle\r\n */\r\nexport function calcNextEdgeIndex(currentEdge, possibleEdges, faceNormalAtCurrentB) {\r\n    let maxValue = -20, advanced = false, result = Number.MAX_SAFE_INTEGER;\r\n    const normVector = currentEdge.bDir.cross(faceNormalAtCurrentB);\r\n    const eps = 1e-4;\r\n    const dir = sign(currentEdge.deltaT());\r\n    const ecd = currentEdge.curve.diff(currentEdge.bT, -dir * eps).dot(normVector);\r\n    for (let i = possibleEdges.length; i--;) {\r\n        const edge = possibleEdges[i];\r\n        const angle1 = currentEdge.bDir.negated().angleRelativeNormal(edge.aDir, faceNormalAtCurrentB);\r\n        const angle = (angle1 + TAU + NLA_PRECISION) % TAU - NLA_PRECISION;\r\n        if (eq0(angle)) {\r\n            // do advanced analysis\r\n            if (currentEdge.curve.isColinearTo(edge.curve)) {\r\n                continue;\r\n            }\r\n            const edgeDir = sign(edge.deltaT());\r\n            const iscd = edge.curve.diff(edge.aT, edgeDir * eps).dot(normVector);\r\n            const diff = iscd - ecd;\r\n            // if diff > 0, the angle is actually ~= 0\r\n            if (diff < 0 && (!advanced || diff > maxValue)) {\r\n                advanced = true;\r\n                maxValue = diff;\r\n                result = i;\r\n            }\r\n        }\r\n        else if (!advanced) {\r\n            if (gt(angle, maxValue)) {\r\n                maxValue = angle;\r\n                result = i;\r\n            }\r\n        }\r\n    }\r\n    return result == Number.MAX_SAFE_INTEGER ? 0 : result;\r\n}\r\nexport class BRep extends Transformable {\r\n    constructor(faces, infiniteVolume, generator, vertexNames) {\r\n        super();\r\n        this.faces = faces;\r\n        assertInst(Face, ...faces);\r\n        this.infiniteVolume = infiniteVolume;\r\n        assert(!this.infiniteVolume || true === this.infiniteVolume);\r\n        this.generator = generator;\r\n        this.vertexNames = vertexNames;\r\n        this.edgeFaces = undefined;\r\n        //this.assertSanity()\r\n    }\r\n    static loop1ContainsLoop2(loop1, ccw1, loop2, ccw2, surface) {\r\n        for (const edge of loop2) {\r\n            const loop1ContainsPoint = surface.loopContainsPoint(loop1, edge.a);\r\n            if (PointVsFace.ON_EDGE != loop1ContainsPoint)\r\n                return PointVsFace.INSIDE == loop1ContainsPoint;\r\n        }\r\n        for (const edge of loop2) {\r\n            const edgePoint = edge.curve.at(edge.aT * 0.2 + edge.bT * 0.8);\r\n            const loop1ContainsPoint = surface.loopContainsPoint(loop1, edgePoint);\r\n            if (PointVsFace.ON_EDGE != loop1ContainsPoint)\r\n                return PointVsFace.INSIDE == loop1ContainsPoint;\r\n        }\r\n        if (ccw1 != ccw2) {\r\n            return ccw2;\r\n        }\r\n        throw new Error(loop1.sce + loop2.sce);\r\n    }\r\n    static assembleFacesFromLoops(loops, surface, originalFace, infoFactory) {\r\n        function placeRecursively(newLoopInfo, loopInfos) {\r\n            if (loopInfos.length == 0) {\r\n                loopInfos.push(newLoopInfo);\r\n            }\r\n            else {\r\n                const subLoopInfo = loopInfos.find(loopInfo => BRep.loop1ContainsLoop2(loopInfo.loop, loopInfo.ccw, newLoopInfo.loop, newLoopInfo.ccw, surface));\r\n                if (subLoopInfo) {\r\n                    placeRecursively(newLoopInfo, subLoopInfo.subloops);\r\n                }\r\n                else {\r\n                    // newLoopInfo isnt contained by any other subLoopInfo\r\n                    for (let i = loopInfos.length; --i >= 0;) {\r\n                        const subLoopInfo = loopInfos[i];\r\n                        //console.log(\"cheving subLoopInfo\", surface.loopContainsPoint(newLoopInfo.edges,\r\n                        // subLoopInfo.edges[0].a))\r\n                        if (BRep.loop1ContainsLoop2(newLoopInfo.loop, newLoopInfo.ccw, subLoopInfo.loop, subLoopInfo.ccw, surface)) {\r\n                            newLoopInfo.subloops.push(subLoopInfo);\r\n                            loopInfos.splice(i, 1); // remove it\r\n                        }\r\n                    }\r\n                    loopInfos.push(newLoopInfo);\r\n                }\r\n            }\r\n        }\r\n        function newFacesRecursive(loopInfo) {\r\n            // CW loops can be top level, if they are holes in the original face not contained in the new face\r\n            if (loopInfo.ccw) {\r\n                if (loopInfo.subloops.every(sl => !sl.ccw)) {\r\n                    const holes = loopInfo.subloops.map(sl => sl.loop);\r\n                    const info = infoFactory && infoFactory.newSubFace(originalFace, surface, loopInfo.loop, holes);\r\n                    const newFace = new originalFace.constructor(surface, loopInfo.loop, holes, 'genface' + getGlobalId(), info);\r\n                    newFaces.push(newFace);\r\n                    loopInfo.subloops.forEach(sl => sl.subloops.forEach(slsl => slsl.ccw && newFacesRecursive(slsl)));\r\n                }\r\n                else {\r\n                    loopInfo.subloops.forEach(sl => sl.ccw && newFacesRecursive(sl));\r\n                }\r\n            }\r\n        }\r\n        const newFaces = [];\r\n        const topLevelLoops = [];\r\n        loops.forEach(loop => placeRecursively({\r\n            loop: loop,\r\n            ccw: surface.edgeLoopCCW(loop),\r\n            subloops: [],\r\n        }, topLevelLoops));\r\n        topLevelLoops.forEach(tll => newFacesRecursive(tll));\r\n        return newFaces;\r\n    }\r\n    /**\r\n     * Create a [BRep] by concatenating the faces of other BReps. Only use this if certain that the faces of the BReps do not intersect.\r\n     * Otherwise, use [BRep.plus].\r\n     * @param bReps\r\n     * @param generator\r\n     */\r\n    static join(bReps, generator) {\r\n        return new BRep(bReps.flatMap(b2 => b2.faces), false, generator);\r\n    }\r\n    containsPoint(p, forceInsideOutside = false) {\r\n        const dirs = [\r\n            V(-0.3920414696448526, -0.12936136783391444, -0.9108068525164064),\r\n            V(0.6520650903544943, -0.07151288645511984, -0.7547827667692488),\r\n            V(0.9433494201061395, -0.2402757256238473, -0.22882186797013926),\r\n            V(0.13678704228501923, -0.04480387361087783, 0.9895867410047372),\r\n            V(0.0662057922721913, -0.5865836917435423, 0.8071780259955845),\r\n            V(-0.7322576567870621, -0.12953393611526787, 0.6685953061989045),\r\n            V(0.6579719127258273, -0.012300218400456116, 0.7529420075219719),\r\n            V(-0.5576497966736425, 0.8006695748324647, 0.2189861552871446),\r\n        ];\r\n        dirLoop: for (const dir of dirs) {\r\n            const testLine = new L3(p, dir);\r\n            let inside = this.infiniteVolume, minT = Infinity;\r\n            for (const face of this.faces) {\r\n                assert(!face.surface.containsCurve(testLine));\r\n                const ists = face.surface.isTsForLine(testLine);\r\n                for (const t of ists) {\r\n                    const p = testLine.at(t);\r\n                    const pvf = face.containsPoint2(p);\r\n                    //assert(pvf != PointVsFace.ON_EDGE)\r\n                    !forceInsideOutside && assert(!eq0(t));\r\n                    if (t > 0) {\r\n                        if (pvf == PointVsFace.ON_EDGE) {\r\n                            continue dirLoop;\r\n                        }\r\n                        if (pvf == PointVsFace.INSIDE) {\r\n                            inside = !inside;\r\n                            if (t < minT) {\r\n                                minT = t;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return inside;\r\n        }\r\n        return false;\r\n    }\r\n    withMergedFaces() {\r\n        const likeSurfaceFaces = [];\r\n        for (let i = 0; i < this.faces.length; i++) {\r\n            let addedToGroup = false;\r\n            for (let j = 0; j < i; j++) {\r\n                if (this.faces[i].surface.isCoplanarTo(this.faces[j].surface)) {\r\n                    const faceGroup = likeSurfaceFaces.find(faceGroup => faceGroup.includes(this.faces[j]));\r\n                    if (faceGroup) {\r\n                        faceGroup.push(this.faces[i]);\r\n                        addedToGroup = true;\r\n                    }\r\n                }\r\n            }\r\n            !addedToGroup && likeSurfaceFaces.push([this.faces[i]]);\r\n        }\r\n        console.log('likeSurfaceFaces', likeSurfaceFaces);\r\n        if (likeSurfaceFaces.every(group => group.length == 1))\r\n            return this;\r\n        const newFaces = [];\r\n        let total = 0;\r\n        for (const faceGroup of likeSurfaceFaces) {\r\n            console.log(faceGroup);\r\n            if (faceGroup.length == 1) {\r\n                newFaces.push(faceGroup[0]);\r\n            }\r\n            else {\r\n                const allEdges = faceGroup.flatMap(face => face.getAllEdges());\r\n                for (let i = allEdges.length; i-- > 0;) {\r\n                    for (let j = 0; j < i; j++) {\r\n                        console.log('blugh', total);\r\n                        assert(i >= 0 && j >= 0 && total++ < 500, i + ' ' + j + ' ' + total);\r\n                        if (allEdges[i].isCoEdge(allEdges[j])) {\r\n                            // remove both\r\n                            allEdges.splice(i, 1);\r\n                            allEdges.splice(j, 1);\r\n                            i--;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                const newFace = assembleFaceFromLooseEdges(allEdges, faceGroup[0].surface, faceGroup[0]);\r\n                newFaces.push(newFace);\r\n            }\r\n        }\r\n        return new BRep(newFaces, this.infiniteVolume, this.generator && this.generator + '.withMergedFaces()', this.vertexNames);\r\n    }\r\n    calculateVolume() {\r\n        return this.faces.map(face => face.zDirVolume().volume).sum();\r\n    }\r\n    toMesh() {\r\n        const mesh = new Mesh()\r\n            .addVertexBuffer('normals', 'ts_Normal')\r\n            .addIndexBuffer('TRIANGLES')\r\n            .addIndexBuffer('LINES');\r\n        mesh.faceIndexes = new Map();\r\n        for (const face of this.faces) {\r\n            const triangleStart = mesh.TRIANGLES.length;\r\n            face.addToMesh(mesh);\r\n            mesh.faceIndexes.set(face, { start: triangleStart, count: mesh.TRIANGLES.length - triangleStart });\r\n        }\r\n        //this.buildAdjacencies()\r\n        //for (const edge of this.edgeFaces.keys()) {\r\n        //\r\n        //}\r\n        return mesh;\r\n    }\r\n    minus(other, infoFactory) {\r\n        const generator = this.generator && other.generator && this.generator + '.minus(' + other.generator + ')';\r\n        return this.intersection(other.flipped(), true, true, generator, infoFactory);\r\n    }\r\n    plus(other, infoFactory) {\r\n        const generator = this.generator && other.generator && this.generator + '.plus(' + other.generator + ')';\r\n        return this.flipped()\r\n            .intersection(other.flipped(), true, true, generator, infoFactory)\r\n            .flipped();\r\n    }\r\n    and(other, infoFactory) {\r\n        const generator = this.generator && other.generator && this.generator + '.and(' + other.generator + ')';\r\n        return this.intersection(other, true, true, generator, infoFactory);\r\n    }\r\n    xor(other, infoFactory) {\r\n        const generator = this.generator && other.generator && this.generator + '.xor(' + other.generator + ')';\r\n        return new BRep(this.minus(other, infoFactory).faces.concat(other.minus(this, infoFactory).faces), this.infiniteVolume != other.infiniteVolume, generator);\r\n    }\r\n    equals(obj) {\r\n        return (this.faces.length == obj.faces.length &&\r\n            this.faces.every(face => obj.faces.some(face2 => face.equals(face2))));\r\n    }\r\n    like(brep) {\r\n        return (this.faces.length == brep.faces.length &&\r\n            this.faces.every(face => brep.faces.some(face2 => face.likeFace(face2))));\r\n    }\r\n    //reconstituteCoplanarFaces(likeSurfacePlanes, edgeLooseSegments, faceMap, newFaces) {\r\n    //    likeSurfacePlanes.forEach(faceGroup => {\r\n    //        // calculate total contours\r\n    //        let surface = faceGroup[0].surface, bag = []\r\n    //        faceGroup.forEach(face => {\r\n    //            Array.prototype.push.apply(bag, faceMap(face))\r\n    //            face.getAllEdges().forEach(edge => {\r\n    //                let edgeSubSegments\r\n    //                if (edgeSubSegments = edgeLooseSegments.get(edge)) {\r\n    //                    Array.prototype.push.apply(bag, edgeSubSegments)\r\n    //                } else {\r\n    //                    bag.push(edge)\r\n    //                }\r\n    //            })\r\n    //        })\r\n    //        let currentEdge, loops = []\r\n    //        while (currentEdge = bag.find(edge => !edge.visited)) {\r\n    //            let path = []\r\n    //            do {\r\n    //                currentEdge.visited = true\r\n    //                path.push(currentEdge)\r\n    //                let possibleNextEdges = bag.filter(edge => currentEdge.b.like(edge.a))\r\n    //                // lowest angle, i.e. the right-most next edge\r\n    //                let nextEdgeIndex = possibleNextEdges.indexWithMax((edge, index) =>\r\n    // -currentEdge.bDir.angleRelativeNormal(edge.aDir, surface.normalP(currentEdge.b))) currentEdge =\r\n    // possibleNextEdges[nextEdgeIndex] } while (!currentEdge.visited) let startIndex = path.find(currentEdge) if (-1\r\n    // != startIndex) { loops.push(path.slice(startIndex)) } } }) }\r\n    toString() {\r\n        return `new BRep([\\n${this.faces.join(',\\n').replace(/^/gm, '\\t')}], ${this.infiniteVolume})`;\r\n    }\r\n    getConstructorParameters() {\r\n        return [this.faces, this.infiniteVolume];\r\n    }\r\n    toSource(useGenerator = true) {\r\n        return ((useGenerator && this.generator) ||\r\n            `new BRep([\\n${this.faces\r\n                .map(SCE)\r\n                .join(',\\n')\r\n                .replace(/^/gm, '\\t')}], ${this.infiniteVolume})`);\r\n    }\r\n    /**\r\n     * Rightmost next segment doesn't work, as the correct next segment isn't obvious from the current corner\r\n     * alone.\r\n     * (at least, not without extensive pre-analysis on the face edges, which shouldn't be necessary, as the\r\n     * correct new faces are defined by the new edges already.) Leftmost edge should work. Holes which touch the\r\n     * edge of the face will be added to the face contour.\r\n     *\r\n     * New segments will always be part left-er than existing ones, so no special check is required.\r\n     *\r\n     */\r\n    reconstituteFaces(oldFaces, edgeSubEdges, faceMap, newFaces, infoFactory) {\r\n        const oldFaceStatuses = new Map();\r\n        // reconstitute faces\r\n        const insideEdges = [];\r\n        for (const face of oldFaces) {\r\n            const usableOldEdges = face.getAllEdges().filter(edge => !edgeSubEdges.get(edge));\r\n            const subEdges = face\r\n                .getAllEdges()\r\n                .mapFilter(edge => edgeSubEdges.get(edge))\r\n                .concatenated();\r\n            const newEdges = faceMap.get(face) || [];\r\n            if (newEdges.length || subEdges.length) {\r\n                oldFaceStatuses.set(face, 'partial');\r\n                const loops = [];\r\n                // new edges are definitely part of a resulting loop\r\n                // old edges (both contour and holes) can either be part of a new loop, in which case they will already\r\n                // have been visited when starting a loop search with a new edge, OR they can be stranded, OR they can\r\n                // remain in their old loop\r\n                function getNextStart() {\r\n                    return (newEdges.find(edge => !visitedEdges.has(edge)) ||\r\n                        subEdges.find(edge => !visitedEdges.has(edge)) ||\r\n                        usableOldEdges.find(edge => !visitedEdges.has(edge)));\r\n                }\r\n                const visitedEdges = new Set();\r\n                // search for a loop:\r\n                let currentEdge;\r\n                while ((currentEdge = getNextStart())) {\r\n                    const startEdge = currentEdge, edges = [];\r\n                    let i = 0;\r\n                    // wether only new edges are used (can include looseSegments)\r\n                    do {\r\n                        visitedEdges.add(currentEdge);\r\n                        edges.push(currentEdge);\r\n                        // find next edge\r\n                        const possibleOldEdges = usableOldEdges.filter(edge => currentEdge.b.like(edge.a));\r\n                        const possibleSubEdges = subEdges.filter(edge => currentEdge.b.like(edge.a));\r\n                        const possibleNewEdges = newEdges.filter(edge => currentEdge.b.like(edge.a));\r\n                        const possibleEdges = possibleOldEdges.concat(possibleSubEdges, possibleNewEdges);\r\n                        if (0 == possibleEdges.length)\r\n                            break;\r\n                        assert(0 < possibleEdges.length, () => face.sce);\r\n                        const faceNormalAtCurrentB = face.surface.normalP(currentEdge.b);\r\n                        const nextEdgeIndex = calcNextEdgeIndex(currentEdge, possibleEdges, faceNormalAtCurrentB);\r\n                        currentEdge = possibleEdges[nextEdgeIndex];\r\n                        if (visitedEdges.has(currentEdge)) {\r\n                            break;\r\n                        }\r\n                        assert(currentEdge);\r\n                        assert(currentEdge != startEdge);\r\n                    } while (++i < 400);\r\n                    if (400 == i) {\r\n                        assert(false, 'too many');\r\n                    }\r\n                    // check if we found a loop\r\n                    if (edges.length > 1 && currentEdge == startEdge) {\r\n                        loops.push(edges);\r\n                    }\r\n                }\r\n                const faceNewFaces = BRep.assembleFacesFromLoops(loops, face.surface, face, infoFactory);\r\n                newFaces.push(...faceNewFaces);\r\n                const faceNewFacesEdges = faceNewFaces.flatMap(face => face.getAllEdges());\r\n                insideEdges.push(...usableOldEdges.filter(edge => faceNewFacesEdges.includes(edge)));\r\n            }\r\n        }\r\n        while (insideEdges.length != 0) {\r\n            const insideEdge = insideEdges.pop();\r\n            const adjacentFaces = this.edgeFaces.get(insideEdge.getCanon());\r\n            adjacentFaces.forEach(info => {\r\n                if (!oldFaceStatuses.has(info.face)) {\r\n                    oldFaceStatuses.set(info.face, 'inside');\r\n                    insideEdges.push.apply(insideEdges, info.face.getAllEdges());\r\n                }\r\n            });\r\n        }\r\n        newFaces.push(...oldFaces.filter(face => oldFaceStatuses.get(face) == 'inside'));\r\n    }\r\n    static getLooseEdgeSegments(edgePointInfoss, edgeFaces) {\r\n        const result = new JavaMap();\r\n        // if there are no point info, the original edge will be kept, so we should return nothing\r\n        // otherwise, something will be returned, even if it a new edge identical to the base edge\r\n        for (const [canonEdge, pointInfos] of edgePointInfoss) {\r\n            if (0 == pointInfos.length)\r\n                continue;\r\n            const allFaces = edgeFaces.get(canonEdge);\r\n            pointInfos.sort((a, b) => snap0(a.edgeT - b.edgeT) || +!!undefined);\r\n            let startP = canonEdge.a, startDir = canonEdge.aDir, startT = canonEdge.aT, startInfo;\r\n            function addNewEdge(startInfo, endInfo, newEdge) {\r\n                for (let i = 0; i < allFaces.length; i++) {\r\n                    const faceInfo = allFaces[i];\r\n                    mapPush(result, !faceInfo.reversed ? canonEdge : canonEdge.flipped(), !faceInfo.reversed ? newEdge : newEdge.flipped());\r\n                }\r\n            }\r\n            for (let i = 0; i < pointInfos.length; i++) {\r\n                const info = pointInfos[i];\r\n                const pDir = canonEdge.tangentAt(info.edgeT);\r\n                if (!eq(info.edgeT, startT)) {\r\n                    const newEdge = Edge.create(canonEdge.curve, startP, info.p, startT, info.edgeT, undefined, startDir, pDir, 'looseSegment' + getGlobalId());\r\n                    addNewEdge(startInfo, info, newEdge);\r\n                }\r\n                startP = info.p;\r\n                startT = info.edgeT;\r\n                startInfo = info;\r\n                startDir = pDir;\r\n            }\r\n            if (startInfo && !eq(startT, canonEdge.bT)) {\r\n                const newEdge = Edge.create(canonEdge.curve, startP, canonEdge.b, startT, canonEdge.bT, undefined, startDir, canonEdge.bDir, 'looseSegment' + getGlobalId());\r\n                addNewEdge(startInfo, undefined, newEdge);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getIntersectionEdges(brep2) {\r\n        const faceMap = new Map(), thisEdgePoints = new JavaMap(), otherEdgePoints = new JavaMap();\r\n        const checkedPairs = new JavaSet();\r\n        this.faces.forEach(face => {\r\n            //console.log('face', face.toString())\r\n            brep2.faces.forEach(face2 => {\r\n                //console.log('face2', face2.toString())\r\n                face.intersectFace(face2, this, brep2, faceMap, thisEdgePoints, otherEdgePoints, checkedPairs);\r\n            });\r\n        });\r\n        return Array.from(faceMap.values()).concatenated();\r\n    }\r\n    shellCount() {\r\n        const foundFaces = new Set();\r\n        let face, result = 0;\r\n        while ((face = this.faces.find(face => !foundFaces.has(face)))) {\r\n            result++;\r\n            const stack = [face];\r\n            while ((face = stack.pop())) {\r\n                // @ts-ignore\r\n                for (const edge of face.getAllEdges()) {\r\n                    // @ts-ignore\r\n                    for (const { face: face2 } of this.edgeFaces.get(edge.getCanon())) {\r\n                        if (face !== face2 && !foundFaces.has(face2)) {\r\n                            foundFaces.add(face2);\r\n                            stack.push(face2);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getAABB() {\r\n        return AABB.forAABBs(this.faces.map(face => face.getAABB()));\r\n    }\r\n    assertSanity() {\r\n        if (!NLA_DEBUG)\r\n            return;\r\n        // const allFaceEdges = this.faces.flatMap(face => face.getAllEdges())\r\n        // for (const { i, j } of combinations(allFaceEdges.length)) {\r\n        // const a = allFaceEdges[i],\r\n        // \tb = allFaceEdges[j]\r\n        // assert(i == j || !a.isCoEdge(b) || a == b || a.flippedOf == b, 'coedges not linked properly', a, b)\r\n        // assert(\r\n        // \ti == j ||\r\n        // \t\t!a.curve.isColinearTo(b.curve) ||\r\n        // \t\t(a.curve.equals(b.curve) && a.isCoEdge(b)) ||\r\n        // \t\t!a.overlaps(b),\r\n        // \t'colinear edges overlap',\r\n        // \ta,\r\n        // \tb,\r\n        // )\r\n        // }\r\n        this.buildAdjacencies();\r\n        for (const [canonEdge, edgeFaceInfos] of this.edgeFaces) {\r\n            // TODO handle curved faces\r\n            assert(edgeFaceInfos.length % 2 == 0, () => canonEdge + edgeFaceInfos.sce);\r\n        }\r\n    }\r\n    //intersection3(other: BRep, buildThis: boolean, buildOther: boolean, name?: string): BRep {\r\n    //    this.assertSanity()\r\n    //    other.assertSanity()\r\n    //    this.buildAdjacencies()\r\n    //    other.buildAdjacencies()\r\n    //\r\n    //    // edge / edge\r\n    //    for (const [edge1, edge1Faces] of this.edgeFaces) {\r\n    //        for (const [edge2, edge2Faces] of other.edgeFaces) {\r\n    //            const curve1 = edge1.curve, curve2 = edge2.curve\r\n    //            if (curve1.isColinearTo(curve2)) {\r\n    //                if (edge1.overlaps(edge2)) {\r\n    //                    // faces have a common edge\r\n    //                    const aT = curve1.pointT(edge2.a), bT = curve1.pointT(edge2.a)\r\n    //                    const minT = min(aT, bT), maxT = max(aT, bT)\r\n    //                    const commonEdge = Edge.create(curve1, min(edge1.minT, minT), min(edge1.maxT, maxT), )\r\n    //                }\r\n    //            } else if (x = curve1.isInfosWithCurve(edge2.curve)) {\r\n    //                // edges intersect in a point\r\n    //            }\r\n    //        }\r\n    //    }\r\n    //\r\n    //    // point / edge\r\n    //    function pointEdge(b1, b2, has, add) {\r\n    //        for (const v1 of this.vertFaces.keys()) {\r\n    //            for (const edge2 of other.edgeFaces.keys()) {\r\n    //                if (edge2.curve.containsPoint(v1)) {\r\n    //                    const edge2T = edge2.curve.pointT(v1)\r\n    //                    if (eq(edge2.aT, edge2T) || eq(edge2.bT, edge2T)) {\r\n    //                        add(v1, eq(edge2.aT, edge2T) ? edge2.a : edge2.b)\r\n    //                    }\r\n    //                }\r\n    //            }\r\n    //        }\r\n    //    }\r\n    //    const pairs: CustomSet<[Equalable, Equalable]> = new CustomSet<[Equalable, Equalable]>()\r\n    //    pointEdge(this, other, (a, b) => pairs.has([a, b]), (a, b) => pairs.add([a, b]))\r\n    //    pointEdge(other, this, (b, a) => pairs.has([a, b]), (b, a) => pairs.add([a, b]))\r\n    //\r\n    //\r\n    //    // point / point\r\n    //    for (const v1 of this.vertFaces.keys()) {\r\n    //        for (const v2 of other.vertFaces.keys()) {\r\n    //            if (v1.like(v2)) {\r\n    //\r\n    //            }\r\n    //        }\r\n    //    }\r\n    //\r\n    //    for (const face1 of this.faces) {\r\n    //        for (const face2 of other.faces) {\r\n    //            face1.intersectFace(face2)\r\n    //        }\r\n    //    }\r\n    //\r\n    //}\r\n    buildAdjacencies() {\r\n        if (this.edgeFaces)\r\n            return this;\r\n        this.edgeFaces = new JavaMap();\r\n        for (const face of this.faces) {\r\n            for (const edge of face.getAllEdges()) {\r\n                const canon = edge.getCanon();\r\n                const normalAtCanonA = face.surface.normalP(canon.a);\r\n                const inside = normalAtCanonA.cross(canon == edge ? edge.aDir : edge.bDir);\r\n                mapPush(this.edgeFaces, canon, {\r\n                    face: face,\r\n                    edge: edge,\r\n                    normalAtCanonA: normalAtCanonA,\r\n                    reversed: canon != edge,\r\n                    inside: inside,\r\n                    angle: 0,\r\n                });\r\n            }\r\n        }\r\n        for (const [canonEdge, edgeFaceInfos] of this.edgeFaces) {\r\n            // TODO handle curved faces\r\n            //assert(edgeFaceInfos.length % 2 == 0, () => canonEdge + edgeFaceInfos.sce)\r\n            const faceInfo0 = edgeFaceInfos.find(faceInfo => faceInfo.reversed);\r\n            if (!faceInfo0) {\r\n                console.warn('invalid brep');\r\n                continue;\r\n            }\r\n            edgeFaceInfos.forEach(faceInfo => {\r\n                if (faceInfo != faceInfo0) {\r\n                    faceInfo.angle = faceInfo0.inside.angleRelativeNormal(faceInfo.inside, canonEdge.aDir.unit());\r\n                    if (faceInfo.angle < 0)\r\n                        faceInfo.angle += 2 * Math.PI;\r\n                }\r\n            });\r\n            edgeFaceInfos.sort((a, b) => snap(a.angle - b.angle, 0)); // TODO  || assertNever()\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Cases for volumes A and B\r\n     *\r\n     *          1.  Volumes do not touch.\r\n     *          2.  face/face Face surfaces intersect each other.\r\n     *              implies edges going through faces.\r\n     *              e.g. box(5, 5, 5) - box(5, 5, 5).translate(1, 1, 1)\r\n     *          3.  face/edge Edge of A lies in a face of B\r\n     *              implies vertices of A lying in face of B\r\n     *              e.g. box(5, 5, 5) - box(3, 3, 3).rotateZ([0, 1, 2] * PI / 2).translate(0, 1, 1)\r\n     *          4.  edge/edge Two edges are colinear.\r\n     *              implies vertex of A lying in edge of B\r\n     *           5.  vertex/edge Vertex of A lies on edge of B (but no edge/edge)\r\n     *          6.  vertex/vertex with/without edge/edge, edge/face and face/face intersections\r\n     *          7.  vertex lies in face\r\n     *\r\n     *\r\n     *\r\n     */\r\n    intersection(other, buildThis, buildOther, generator, infoFactory) {\r\n        this.assertSanity();\r\n        other.assertSanity();\r\n        this.buildAdjacencies();\r\n        other.buildAdjacencies();\r\n        const faceMap = new Map();\r\n        const thisEdgePoints = new JavaMap(), otherEdgePoints = new JavaMap();\r\n        const checkedPairs = new CustomSet();\r\n        for (const thisFace of this.faces) {\r\n            for (const otherFace of other.faces) {\r\n                thisFace.intersectFace(otherFace, this, other, faceMap, thisEdgePoints, otherEdgePoints, checkedPairs);\r\n            }\r\n        }\r\n        for (const edge of thisEdgePoints.keys()) {\r\n            assert(this.edgeFaces.get(edge));\r\n        }\r\n        for (const edge of otherEdgePoints.keys()) {\r\n            assert(other.edgeFaces.get(edge));\r\n        }\r\n        const newFaces = [];\r\n        if (0 == faceMap.size && 0 == thisEdgePoints.size && 0 == otherEdgePoints.size) {\r\n            const thisInOther = other.containsPoint(this.faces[0].contour[0].a, true) !== other.infiniteVolume;\r\n            const otherInThis = !thisInOther && this.containsPoint(other.faces[0].contour[0].a) !== this.infiniteVolume;\r\n            if (thisInOther || otherInThis) {\r\n                const [inside, outside] = thisInOther ? [this, other] : [other, this];\r\n                if (inside.infiniteVolume) {\r\n                    if (outside.infiniteVolume) {\r\n                        return outside;\r\n                    }\r\n                    else {\r\n                        return BRep.join([inside, outside]);\r\n                    }\r\n                }\r\n                else {\r\n                    if (outside.infiniteVolume) {\r\n                        return BRep.EMPTY;\r\n                    }\r\n                    else {\r\n                        return inside;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (this.infiniteVolume) {\r\n                    if (other.infiniteVolume) {\r\n                        return BRep.join([this, other]);\r\n                    }\r\n                    else {\r\n                        other;\r\n                    }\r\n                }\r\n                else {\r\n                    if (other.infiniteVolume) {\r\n                        return this;\r\n                    }\r\n                    else {\r\n                        return BRep.EMPTY;\r\n                    }\r\n                }\r\n            }\r\n            return BRep.EMPTY;\r\n        }\r\n        else {\r\n            if (buildThis) {\r\n                const edgeLooseSegments = BRep.getLooseEdgeSegments(thisEdgePoints, this.edgeFaces);\r\n                // @ts-ignore\r\n                const els = this.faces.map(face => [\r\n                    face,\r\n                    Array.from(edgeLooseSegments.entries()).flatMap(([edge, subs]) => (face.getAllEdges().some(e => e.equals(edge)) ? subs : [])),\r\n                ]);\r\n                this.reconstituteFaces(this.faces, edgeLooseSegments, faceMap, newFaces, infoFactory);\r\n            }\r\n            if (buildOther) {\r\n                const edgeLooseSegments = BRep.getLooseEdgeSegments(otherEdgePoints, other.edgeFaces);\r\n                // @ts-ignore\r\n                const els = other.faces.map(face => [\r\n                    face,\r\n                    Array.from(edgeLooseSegments.entries()).flatMap(([edge, subs]) => (face.getAllEdges().some(e => e.equals(edge)) ? subs : [])),\r\n                ]);\r\n                other.reconstituteFaces(other.faces, edgeLooseSegments, faceMap, newFaces, infoFactory);\r\n            }\r\n        }\r\n        //buildCoplanar && this.reconstituteCoplanarFaces(likeSurfaceFaces, edgeLooseSegments, faceMap, newFaces,\r\n        // this.infiniteVolume, other.infiniteVolume)\r\n        const result = new BRep(newFaces, this.infiniteVolume && other.infiniteVolume, generator);\r\n        //result.buildAdjacencies()\r\n        return result;\r\n    }\r\n    transform(m4, desc) {\r\n        let vertexNames;\r\n        if (this.vertexNames) {\r\n            vertexNames = new Map();\r\n            this.vertexNames.forEach((name, vertex) => vertexNames.set(m4.transformPoint(vertex), name + desc));\r\n        }\r\n        return new BRep(this.faces.map(f => f.transform(m4)), this.infiniteVolume, this.generator && desc && this.generator + desc, // if desc isn't set, the generator will be invalid\r\n        vertexNames);\r\n    }\r\n    transform4(m4, desc) {\r\n        let vertexNames;\r\n        if (this.vertexNames) {\r\n            vertexNames = new Map();\r\n            this.vertexNames.forEach((name, vertex) => vertexNames.set(m4.transformPoint(vertex), name + desc));\r\n        }\r\n        return new BRep(this.faces.map(f => f.transform4(m4)), this.infiniteVolume, this.generator && desc && this.generator + desc, // if desc isn't set, the generator will be invalid\r\n        vertexNames);\r\n    }\r\n    flipped() {\r\n        return new BRep(this.faces.map(f => f.flipped()), !this.infiniteVolume, this.generator && this.generator + '.flipped()', this.vertexNames);\r\n    }\r\n}\r\nBRep.EMPTY = new BRep([], false, 'BRep.EMPTY', new Map()).buildAdjacencies();\r\nBRep.R3 = new BRep([], true, 'BRep.R3', new Map()).buildAdjacencies();\r\nexport function dotCurve(v, cDir, cDDT) {\r\n    let dot = v.dot(cDir);\r\n    if (eq0(dot)) {\r\n        dot = v.dot(cDDT);\r\n    }\r\n    assert(!eq0(dot));\r\n    return dot;\r\n}\r\nexport function dotCurve2(curve, t, normal, sign) {\r\n    assert(sign == 1 || sign == -1, sign);\r\n    const tangentDot = curve.tangentAt(t).dot(normal);\r\n    // if tangentDot != 0 the curve simply crosses the plane\r\n    if (!eq0(tangentDot)) {\r\n        return sign * tangentDot;\r\n    }\r\n    if (curve.ddt) {\r\n        const ddtDot = curve.ddt(t).dot(normal);\r\n        // tangentDot == 0 ==> critical point at t, if ddtDot != 0, then it is a turning point, otherwise we can't be sure\r\n        // and must do a numeric test\r\n        if (!eq0(ddtDot)) {\r\n            return ddtDot;\r\n        }\r\n    }\r\n    const numericDot = curve\r\n        .at(t)\r\n        .to(curve.at(t + sign * 4 * NLA_PRECISION))\r\n        .dot(normal);\r\n    assert(!(curve instanceof L3));\r\n    return numericDot;\r\n}\r\nexport const INSIDE = 0, OUTSIDE = 1, COPLANAR_SAME = 2, COPLANAR_OPPOSITE = 3, ALONG_EDGE_OR_PLANE = 4;\r\n/**\r\n *\r\n * @param brep BREP to check\r\n * @param edge edge to check\r\n * @param dirAtEdgeA the direction vector to check\r\n * @param faceNormal If dirAtEdgeA doesn't split a volume, but is along a face, the returned value depends on\r\n *     wether that faces normal1 points in the same direction as faceNormal\r\n * @returns INSIDE, OUTSIDE, COPLANAR_SAME or COPLANAR_OPPOSITE\r\n */\r\n//function splitsVolumeEnclosingFaces(brep: BRep, edge: Edge, dirAtEdgeA: V3, faceNormal: V3): int {\r\n//    assert(arguments.length == 4)\r\n//    //assert(p.equals(edge.a))\r\n//    const ab1 = edge.aDir.unit()\r\n//    const relFaces = facesWithEdge(edge, brep.faces) as any[]\r\n//    relFaces.forEach(faceInfo => {\r\n//        faceInfo.normalAtEdgeA = faceInfo.face.surface.normalP(edge.a)\r\n//        faceInfo.edgeDirAtEdgeA = !faceInfo.reversed\r\n//            ? faceInfo.edge.aDir\r\n//            : faceInfo.edge.bDir\r\n//        faceInfo.outsideVector = faceInfo.edgeDirAtEdgeA.cross(faceInfo.normalAtEdgeA)\r\n//        faceInfo.angle = (dirAtEdgeA.angleRelativeNormal(faceInfo.outsideVector.negated(), ab1) + 2 * Math.PI +\r\n// NLA_PRECISION / 2) % (2 * Math.PI) }) assert(relFaces.length != 0, edge.toSource()) relFaces.sort((a, b) => a.angle\r\n// - b.angle) // assert(relFaces.length % 2 == 0, edge.toSource()) // even number of touching faces  if\r\n// (eq0(relFaces[0].angle)) { //assert(false) todo const coplanarSame = relFaces[0].normalAtEdgeA.dot(faceNormal) > 0;\r\n// return coplanarSame ? COPLANAR_SAME : COPLANAR_OPPOSITE } else { return !relFaces[0].reversed ? INSIDE : OUTSIDE } }\r\nexport function splitsVolumeEnclosingFaces(brep, canonEdge, dirAtEdgeA, faceNormal) {\r\n    assert(arguments.length == 4);\r\n    assert(canonEdge == canonEdge.getCanon());\r\n    //assert(p.equals(canonEdge.a))\r\n    const edgeFaceInfos = brep.edgeFaces.get(canonEdge);\r\n    assertf(() => edgeFaceInfos.length % 2 == 0);\r\n    assertf(() => brep.edgeFaces);\r\n    const faceInfo0 = edgeFaceInfos[0];\r\n    const aDir1 = canonEdge.aDir.unit();\r\n    const angleToCanon = (faceInfo0.inside.angleRelativeNormal(dirAtEdgeA, aDir1) + 2 * Math.PI + NLA_PRECISION) % (2 * Math.PI) -\r\n        NLA_PRECISION;\r\n    const nearestFaceInfoIndex = edgeFaceInfos.findIndex(faceInfo => lt(angleToCanon, faceInfo.angle));\r\n    const nearestFaceInfo = edgeFaceInfos[nearestFaceInfoIndex == -1 ? edgeFaceInfos.length - 1 : nearestFaceInfoIndex - 1];\r\n    if (eq(nearestFaceInfo.angle, angleToCanon)) {\r\n        //assert(false) todo\r\n        const coplanarSame = nearestFaceInfo.normalAtCanonA.dot(faceNormal) > 0;\r\n        return coplanarSame ? COPLANAR_SAME : COPLANAR_OPPOSITE;\r\n    }\r\n    else {\r\n        return nearestFaceInfo.reversed ? INSIDE : OUTSIDE;\r\n    }\r\n}\r\nexport function splitsVolumeEnclosingFacesP(brep, canonEdge, p, pInside, pFaceNormal) {\r\n    assert(arguments.length == 5);\r\n    assert(canonEdge == canonEdge.getCanon());\r\n    //assert(p.equals(canonEdge.a))\r\n    assertf(() => brep.edgeFaces);\r\n    const edgeFaceInfos = brep.edgeFaces.get(canonEdge);\r\n    assertf(() => edgeFaceInfos.length % 2 == 0);\r\n    const pDir1 = canonEdge.tangentAt(canonEdge.curve.pointT(p)).unit();\r\n    const faceInfoAngleFromPInsideNeg = (faceInfo) => {\r\n        const faceInfoPDir = faceInfo.edge.getCanon() == faceInfo.edge ? pDir1 : pDir1.negated();\r\n        const faceInfoInsideAtP = faceInfo.face.surface.normalP(p).cross(faceInfoPDir);\r\n        const faceInfoAngleAtP = pInside.angleRelativeNormal(faceInfoInsideAtP, pDir1);\r\n        return -((faceInfoAngleAtP + TAU + NLA_PRECISION) % TAU - NLA_PRECISION);\r\n    };\r\n    const nearestFaceInfo = edgeFaceInfos.withMax(faceInfoAngleFromPInsideNeg);\r\n    if (eq0(faceInfoAngleFromPInsideNeg(nearestFaceInfo))) {\r\n        //assert(false) todo\r\n        const coplanarSame = nearestFaceInfo.face.surface.normalP(p).dot(pFaceNormal) > 0;\r\n        return coplanarSame ? COPLANAR_SAME : COPLANAR_OPPOSITE;\r\n    }\r\n    else {\r\n        return nearestFaceInfo.reversed ? OUTSIDE : INSIDE;\r\n    }\r\n}\r\nexport function splitsVolumeEnclosingFacesP2(brep, canonEdge, p, testCurve, curveT, dir, faceNormal) {\r\n    assert(canonEdge == canonEdge.getCanon());\r\n    //assert(p.equals(canonEdge.a))\r\n    assertf(() => brep.edgeFaces);\r\n    const edgeFaceInfos = brep.edgeFaces.get(canonEdge);\r\n    assertf(() => edgeFaceInfos.length % 2 == 0);\r\n    const pDir1 = canonEdge.tangentAt(canonEdge.curve.pointT(p)).unit();\r\n    let pInside = testCurve.tangentAt(curveT).times(dir);\r\n    if (pInside.isParallelTo(pDir1)) {\r\n        pInside = testCurve.diff(curveT, 1e-4 * dir / testCurve.tangentAt(curveT).length()).rejectedFrom(pDir1);\r\n        pInside = pInside.div(pInside.length());\r\n    }\r\n    let minValue = 20, advanced = false, result = OUTSIDE;\r\n    for (const faceInfo of edgeFaceInfos) {\r\n        const faceInfoPDir = faceInfo.edge.getCanon() == faceInfo.edge ? pDir1 : pDir1.negated();\r\n        const faceInfoInsideAtP = faceInfo.face.surface.normalP(p).cross(faceInfoPDir);\r\n        const faceInfoAngleAtP = pInside.angleRelativeNormal(faceInfoInsideAtP, pDir1);\r\n        const angle = (faceInfoAngleAtP + TAU + NLA_PRECISION) % TAU - NLA_PRECISION;\r\n        if (eq0(angle)) {\r\n            // do advanced analysis\r\n            const normVector = faceInfo.face.surface.normalP(p);\r\n            if (faceInfo.face.surface.containsCurve(testCurve)) {\r\n                const coplanarSame = normVector.dot(faceNormal) > 0;\r\n                return coplanarSame ? COPLANAR_SAME : COPLANAR_OPPOSITE;\r\n            }\r\n            const testPlane = P3.normalOnAnchor(pDir1, p);\r\n            const isCurve = faceInfo.face.surface.isCurvesWithPlane(testPlane)[0];\r\n            const isCurvePT = isCurve.pointT(p);\r\n            const dirFactor = sign(isCurve.tangentAt(isCurvePT).dot(pInside));\r\n            const eps = 1e-4;\r\n            const iscd = isCurve\r\n                .at(isCurvePT)\r\n                .to(isCurve.at(isCurvePT + dir * dirFactor * eps))\r\n                .dot(normVector);\r\n            const ecd = testCurve\r\n                .at(curveT)\r\n                .to(testCurve.at(curveT + dir * eps))\r\n                .dot(normVector);\r\n            const diff = (iscd - ecd) * (faceInfo.reversed ? -1 : 1);\r\n            if (diff > 0 && (!advanced || diff < minValue)) {\r\n                advanced = true;\r\n                minValue = diff;\r\n                result = faceInfo.reversed ? OUTSIDE : INSIDE;\r\n            }\r\n        }\r\n        else if (!advanced) {\r\n            if (angle < minValue) {\r\n                minValue = angle;\r\n                result = faceInfo.reversed ? OUTSIDE : INSIDE;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport function splitsVolumeEnclosingCone(brep, p, dir) {\r\n    const testPlane = P3.forAnchorAndPlaneVectors(p, dir, dir.getPerpendicular());\r\n    const rays = [];\r\n    for (let k = 0; k < brep.faces.length; k++) {\r\n        const planeFace = brep.faces[k];\r\n        assertf(() => planeFace instanceof PlaneFace);\r\n        if (planeFace.getAllEdges().some(edge => edge.a.like(p))) {\r\n            if (testPlane.isParallelToPlane(planeFace.surface.plane)) {\r\n                if (planeFace.pointsToInside(p, dir) != PointVsFace.OUTSIDE) {\r\n                    return ALONG_EDGE_OR_PLANE;\r\n                }\r\n            }\r\n            else {\r\n                const isLine = L3.fromPlanes(testPlane, planeFace.surface.plane);\r\n                const ps = planeFace.edgeISPsWithPlane(isLine, testPlane);\r\n                let i = 0;\r\n                while (i < ps.length) {\r\n                    const a = ps[i++], b = ps[i++];\r\n                    const out = a.p.like(p);\r\n                    if (out || b.p.like(p)) {\r\n                        const dir2 = out ? isLine.dir1 : isLine.dir1.negated();\r\n                        const angle = (dir.angleRelativeNormal(dir2, testPlane.normal1) + 2 * Math.PI + NLA_PRECISION / 2) %\r\n                            (2 * Math.PI);\r\n                        rays.push({ angle: angle, out: out });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    rays.sort((a, b) => a.angle - b.angle);\r\n    //console.log(\"testPlane\", testPlane.toSource(), \"rays\", rays.toSource())\r\n    if (eq0(rays[0].angle)) {\r\n        return ALONG_EDGE_OR_PLANE;\r\n    }\r\n    else {\r\n        return rays[0].out ? OUTSIDE : INSIDE;\r\n    }\r\n}\r\nexport function splitsVolumeEnclosingCone2(brep, p, curve, curveT, fb) {\r\n    assert(curve.containsPoint(p));\r\n    const pFaces = brep.faces.filter(face => face.getAllEdges().some(edge => edge.a.like(p)));\r\n    for (let k = 0; k < pFaces.length; k++) {\r\n        const face = pFaces[k];\r\n        if (face.surface.containsCurve(curve)) {\r\n            //assert(false)\r\n            if (face.pointsToInside3(p, curve, curveT, fb) != PointVsFace.OUTSIDE) {\r\n                return ALONG_EDGE_OR_PLANE;\r\n            }\r\n        }\r\n    }\r\n    const EPS = 1e-6;\r\n    return brep.containsPoint(curve.at(curveT + fb * EPS), true) ? INSIDE : OUTSIDE;\r\n}\r\nexport function fff(info, surface) {\r\n    const canonA = info.edge.reversed ? info.edge.b : info.edge.a;\r\n    const surfaceNormalAtCanonA = surface.normalP(canonA);\r\n    const dot = snap0(info.inside.dot(surfaceNormalAtCanonA));\r\n    if (0 !== dot) {\r\n        return 0 < dot ? OUTSIDE : INSIDE;\r\n    }\r\n    if (surface.isCoplanarTo(info.face.surface)) {\r\n        return 0 < info.normalAtCanonA.dot(surfaceNormalAtCanonA) ? COPLANAR_SAME : COPLANAR_OPPOSITE;\r\n    }\r\n    throw new Error();\r\n}\r\nexport function triangulateVertices(normal, vertices, holeStarts) {\r\n    const absMaxDim = normal.maxAbsDim(), factor = sign(normal.e(absMaxDim));\r\n    const contour = new Float64Array(vertices.length * 2);\r\n    let i = vertices.length;\r\n    /*\r\n     var [coord0, coord1] = [['y', 'z'], ['z', 'x'], ['x', 'y']][maxAbsDim]\r\n     while (i--) {\r\n     contour[i * 2    ] = vertices[i][coord0] * factor\r\n     contour[i * 2 + 1] = vertices[i][coord1]\r\n     }\r\n     */\r\n    while (i--) {\r\n        // unroll disambiguation instead of accessing elements by string name ([coord0] etc)\r\n        // as it confuses google closure\r\n        switch (absMaxDim) {\r\n            case 0:\r\n                contour[i * 2] = vertices[i].y * factor;\r\n                contour[i * 2 + 1] = vertices[i].z;\r\n                break;\r\n            case 1:\r\n                contour[i * 2] = vertices[i].z * factor;\r\n                contour[i * 2 + 1] = vertices[i].x;\r\n                break;\r\n            case 2:\r\n                contour[i * 2] = vertices[i].x * factor;\r\n                contour[i * 2 + 1] = vertices[i].y;\r\n                break;\r\n        }\r\n    }\r\n    return earcut(contour, holeStarts);\r\n}\r\n/**\r\n * Solves a quadratic system of equations of the form\r\n *      a * x + b * y = c\r\n *      x² + y² = 1\r\n * This can be understood as the intersection of the unit circle with a line.\r\n *      => y = (c - a x) / b\r\n *      => x² + (c - a x)² / b² = 1\r\n *      => x² b² + c² - 2 c a x + a² x² = b²\r\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\r\n *\r\n * a * b + (b -c) * (b + c)\r\n */\r\nexport function intersectionUnitCircleLine(a, b, c) {\r\n    assertNumbers(a, b, c);\r\n    // TODO: disambiguate on a < b\r\n    const term = sqrt(a * a + b * b - c * c);\r\n    return {\r\n        x1: (a * c + b * term) / (a * a + b * b),\r\n        x2: (a * c - b * term) / (a * a + b * b),\r\n        y1: (b * c - a * term) / (a * a + b * b),\r\n        y2: (b * c + a * term) / (a * a + b * b),\r\n    };\r\n}\r\nexport function intersectionUnitCircleLine2(a, b, c) {\r\n    assertNumbers(a, b, c);\r\n    // TODO: disambiguate on a < b\r\n    // cf. pqFormula\r\n    const termSqr = snap0(a * a + b * b - c * c);\r\n    if (termSqr < 0) {\r\n        return [];\r\n    }\r\n    else if (termSqr == 0) {\r\n        return [[a * c / (a * a + b * b), b * c / (a * a + b * b)]];\r\n    }\r\n    else {\r\n        const term = sqrt(termSqr);\r\n        return [\r\n            [(a * c + b * term) / (a * a + b * b), (b * c - a * term) / (a * a + b * b)],\r\n            [(a * c - b * term) / (a * a + b * b), (b * c + a * term) / (a * a + b * b)],\r\n        ];\r\n    }\r\n}\r\nexport function intersectionCircleLine(a, b, c, r) {\r\n    assertNumbers(a, b, c, r);\r\n    const term = sqrt(r * r * (a * a + b * b) - c * c);\r\n    return {\r\n        x1: (a * c + b * term) / (a * a + b * b),\r\n        x2: (a * c - b * term) / (a * a + b * b),\r\n        y1: (b * c - a * term) / (a * a + b * b),\r\n        y2: (b * c + a * term) / (a * a + b * b),\r\n    };\r\n}\r\n/**\r\n * Solves a quadratic system of equations of the form\r\n *      a * x + b * y = c\r\n *      x^2 - y^2 = 1\r\n * This can be understood as the intersection of the unit hyperbola with a line.\r\n *\r\n * @returns with x1 >= x2 and y1 <= y2\r\n * a * b + (b -c) * (b + c)\r\n */\r\nexport function intersectionUnitHyperbolaLine(a, b, c) {\r\n    assertNumbers(a, b, c);\r\n    const aa = a * a, bb = b * b, cc = c * c;\r\n    // TODO: disambiguate on a < b\r\n    //var xTerm = sqrt(4*cc*aa-4*(bb-aa)*(-cc-bb))\r\n    const xTerm = 2 * sqrt(bb * cc + bb * bb - aa * bb);\r\n    const yTerm = sqrt(4 * cc * bb - 4 * (bb - aa) * (cc - aa));\r\n    return {\r\n        x1: (-2 * a * c + xTerm) / 2 / (bb - aa),\r\n        x2: (-2 * a * c - xTerm) / 2 / (bb - aa),\r\n        y1: (2 * b * c - yTerm) / 2 / (bb - aa),\r\n        y2: (2 * b * c + yTerm) / 2 / (bb - aa),\r\n    };\r\n}\r\nexport function curvePointPP(ps1, ps2, startPoint, dontCheck) {\r\n    const EPS = NLA_PRECISION / 4;\r\n    //if (!dontCheck) {\r\n    //    const p = curvePointPP(ps1, ps2, startPoint, true).p\r\n    //    if (!ps1.containsPoint(p)) {\r\n    //        console.log(\"foo, startPoint was \" + startPoint.sce)\r\n    //        ps1.containsPoint(p)\r\n    //    }\r\n    //}\r\n    let Q = startPoint;\r\n    let st1 = ps1.pointFoot(Q);\r\n    let st2 = ps2.pointFoot(Q);\r\n    let a, b, aNormal, bNormal, abNormalsCross;\r\n    //console.log(\"curvePointPP, startPoint was \" + startPoint.sce)\r\n    //console.log(Q.sce+ ',')\r\n    let i = 16;\r\n    do {\r\n        a = ps1.pUV(st1.x, st1.y);\r\n        b = ps2.pUV(st2.x, st2.y);\r\n        if (eq0(a.distanceTo(b), EPS))\r\n            break;\r\n        // drPs.push({p:a,text:'a'+j+' '+i})\r\n        // drPs.push({p:b,text:'b'+j+' '+i})\r\n        aNormal = ps1.normalUV(st1.x, st1.y);\r\n        bNormal = ps2.normalUV(st2.x, st2.y);\r\n        // next Q is the intersection of the planes\r\n        // (x - a) * aNormal,\r\n        // (x - b) * bNormal and\r\n        // (x - Q) * (aNormal X bNormal)\r\n        abNormalsCross = aNormal.cross(bNormal);\r\n        // drVs.push({anchor: Q, dir: aNormal})\r\n        // drVs.push({anchor: Q, dir: bNormal})\r\n        Q = V3.add(bNormal.cross(abNormalsCross).times(a.dot(aNormal)), abNormalsCross.cross(aNormal).times(b.dot(bNormal)), abNormalsCross.times(abNormalsCross.dot(Q))).div(abNormalsCross.squared());\r\n        //console.log(Q.sce+ ',')\r\n        // feet of Q on ps1 and ps2 (closest points)\r\n        st1 = ps1.pointFoot(Q, st1.x, st1.y);\r\n        st2 = ps2.pointFoot(Q, st2.x, st2.y);\r\n    } while (--i);\r\n    //assert(ps1.containsPoint(Q), Q, ps1)\r\n    //assert(ps2.containsPoint(Q))\r\n    if (!eq0(a.distanceTo(b), EPS)) {\r\n        return undefined;\r\n    }\r\n    return { p: Q, st1: st1, st2: st2 };\r\n}\r\n/**\r\n * Follow the intersection curve of two parametric surfaces starting from a given point.\r\n * @param {ParametricSurface} ps1\r\n * @param {ParametricSurface} ps2\r\n * @param {number} s1Step\r\n * @param {number} t1Step\r\n * @param {number} s2Step\r\n * @param {number} t2Step\r\n * @param {number} curveStepSize\r\n * @return {Curve[]}\r\n */\r\nexport function followAlgorithmPP(ps1, ps2, startPoint, curveStepSize, bounds1 = uvInAABB2.bind(undefined, ps1), bounds2 = uvInAABB2.bind(undefined, ps2)) {\r\n    const points = [];\r\n    const tangents = [];\r\n    const st1s = [];\r\n    const st2s = [];\r\n    let Q = startPoint;\r\n    let st1 = ps1.uvP(Q);\r\n    let st2 = ps2.uvP(Q);\r\n    assert(ps1.pUV(st1.x, st1.y).like(Q));\r\n    assert(st1.like(ps1.pointFoot(Q, st1.x, st1.y)));\r\n    assert(st2.like(ps2.pointFoot(Q, st2.x, st2.y)));\r\n    assert(ps2.pUV(st2.x, st2.y).like(Q));\r\n    for (let i = 0; i < 1000; i++) {\r\n        ;\r\n        ({ p: Q, st1, st2 } = curvePointPP(ps1, ps2, Q));\r\n        assert(ps1.containsPoint(Q), Q, ps1);\r\n        assert(ps2.containsPoint(Q));\r\n        const aNormal = ps1.normalUV(st1.x, st1.y);\r\n        const bNormal = ps2.normalUV(st2.x, st2.y);\r\n        const tangent = aNormal.cross(bNormal).toLength(curveStepSize);\r\n        tangents.push(tangent);\r\n        points.push(Q);\r\n        st1s.push(st1);\r\n        st2s.push(st2);\r\n        if (i > 4) {\r\n            if (!bounds1(st1.x, st1.y) || !bounds2(st2.x, st2.y)) {\r\n                break;\r\n            }\r\n        }\r\n        Q = Q.plus(tangent);\r\n    }\r\n    return { points, tangents, st1s, st2s };\r\n}\r\n/**\r\n * Iteratively calculate points on an implicit 2D curve.\r\n * @param ic The curve in question.\r\n * @param startP The point at which to start.\r\n * @param stepLength The step the algorithm takes. Will be the approximate distance between points.\r\n * @param bounds Bounds function.\r\n * @param endP End point. If undefined, algorithm will continue until out of bounds or back at start point.\r\n * @param startTangent TODO Ignore this.\r\n * @returns Calculated points and tangents. points[0] and tangents[0] will be startP and startTangent.\r\n */\r\nexport function followAlgorithm2d(ic, startP, stepLength = 0.5, bounds, validUV, endP, startTangent) {\r\n    assertNumbers(stepLength, ic(0, 0));\r\n    assertVectors(startP);\r\n    if (!startTangent) {\r\n        startTangent = new V3(-ic.y(startP.x, startP.y), ic.x(startP.x, startP.y), 0).toLength(stepLength);\r\n    }\r\n    assertVectors(startTangent);\r\n    const points = [];\r\n    const tangents = [];\r\n    assert(eq0(ic(startP.x, startP.y), 0.01), 'isZero(implicitCurve(startPoint.x, startPoint.y))', ic(startP.x, startP.y));\r\n    let i = 0, p = startP, tangent = startTangent, fullLoop = false;\r\n    do {\r\n        points.push(p);\r\n        tangents.push(tangent);\r\n        const searchStart = p.plus(tangent);\r\n        assert(searchStart);\r\n        const newP = curvePointMF(ic, searchStart);\r\n        const dfpdx = ic.x(newP.x, newP.y), dfpdy = ic.y(newP.x, newP.y);\r\n        const newTangent = new V3(-dfpdy, dfpdx, 0).toLength(stepLength);\r\n        //const reversedDir = p.minus(prevp).dot(tangent) < 0\r\n        assert(!p.equals(newP));\r\n        // check if we passed a singularity\r\n        if (tangent.dot(newTangent) < 0) {\r\n            const singularity = newtonIterate2d(ic.x, ic.y, p.x, p.y);\r\n            if (eq0(ic(singularity.x, singularity.y)) && singularity.distanceTo(p) < abs(stepLength)) {\r\n                // end on this point\r\n                points.push(singularity);\r\n                tangents.push(p.to(singularity));\r\n                break;\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        }\r\n        // check for endP\r\n        if (endP && p.equals(endP)) {\r\n            break;\r\n        }\r\n        // check if loop\r\n        if (fullLoop) {\r\n            if (p.distanceTo(startP) > abs(stepLength)) {\r\n                points.pop();\r\n                tangents.pop();\r\n                assert(points.last.distanceTo(startP) <= abs(stepLength));\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            if (i > 4 && p.distanceTo(startP) <= abs(stepLength)) {\r\n                fullLoop = true;\r\n            }\r\n        }\r\n        // check if out of bounds\r\n        if (i > 1 && !uvInAABB2(bounds, p.x, p.y)) {\r\n            const endP = figureOutBorderPoint(bounds, p, ic);\r\n            points.pop();\r\n            tangents.pop();\r\n            if (points.last.distanceTo(endP) < abs(stepLength) / 2) {\r\n                points.pop();\r\n                tangents.pop();\r\n            }\r\n            const endTangent = new V3(-ic.y(endP.x, endP.y), ic.x(endP.x, endP.y), 0).toLength(stepLength);\r\n            points.push(endP);\r\n            tangents.push(endTangent);\r\n            break;\r\n        }\r\n        if (i > 4 && !validUV(p.x, p.y)) {\r\n            break;\r\n        }\r\n        assert(eq0(ic(newP.x, newP.y), NLA_PRECISION * 2), p, newP, searchStart, ic(newP.x, newP.y));\r\n        tangent = newTangent;\r\n        p = newP;\r\n    } while (++i < 1000);\r\n    assert(i < 1000);\r\n    //assert(points.length > 6)\r\n    return { points, tangents };\r\n}\r\n/**\r\n * Given a point p just outside the bounds, figure out the nearby intersection of the bounds with the ic.\r\n * @param bounds\r\n * @param p\r\n * @param ic\r\n */\r\nfunction figureOutBorderPoint(bounds, p, ic) {\r\n    if (p.x < bounds.uMin || bounds.uMax < p.x) {\r\n        const u = bounds.uMax < p.x ? bounds.uMax : bounds.uMin;\r\n        const v = newtonIterateWithDerivative(t => ic(u, t), p.y, 4, t => ic.y(u, t));\r\n        if (uvInAABB2(bounds, u, v)) {\r\n            return new V3(u, v, 0);\r\n        }\r\n    }\r\n    if (p.y < bounds.vMin || bounds.vMax < p.y) {\r\n        const v = bounds.vMax < p.y ? bounds.vMax : bounds.vMin;\r\n        const u = newtonIterateWithDerivative(s => ic(s, v), p.x, 4, s => ic.x(s, v));\r\n        assert(uvInAABB2(bounds, u, v));\r\n        return new V3(u, v, 0);\r\n    }\r\n    throw new Error(p + ' ' + bounds);\r\n}\r\nexport function followAlgorithm2dAdjustable(ic, start, stepLength = 0.5, bounds, endp = start) {\r\n    assertNumbers(stepLength, ic(0, 0));\r\n    assertVectors(start);\r\n    //assert (!startDir || startDir instanceof V3)\r\n    const points = [];\r\n    const tangents = [];\r\n    assert(eq0(ic(start.x, start.y), 0.01), 'isZero(implicitCurve(startPoint.x, startPoint.y))');\r\n    let p = start, prevp = p;\r\n    let i = 0;\r\n    do {\r\n        const dfpdx = ic.x(p.x, p.y), dfpdy = ic.y(p.x, p.y);\r\n        const dfpdxx = ic.xx(p.x, p.y), dfpdyy = ic.yy(p.x, p.y), dfpdxy = ic.xy(p.x, p.y);\r\n        const c2factor = abs((Math.pow(dfpdy, 2) * dfpdxx - 2 * dfpdx * dfpdy * dfpdxy + Math.pow(dfpdx, 2) * dfpdyy) / Math.pow((Math.pow(dfpdx, 2) + Math.pow(dfpdy, 2)), 2));\r\n        const c2 = new V3(dfpdx, dfpdy, 0).times(c2factor);\r\n        const s = 1 / 16 / c2.length();\r\n        const tangent = new V3(-dfpdy, dfpdx, 0).unit();\r\n        const newPStart = p.plus(tangent.times(s).plus(c2.times(Math.pow(s, 2) / 2)));\r\n        points.push(p);\r\n        tangents.push(tangent);\r\n        prevp = p;\r\n        const newP = curvePointMF(ic, newPStart);\r\n        if (newP.equals(p)) {\r\n            assertNever();\r\n        }\r\n        console.log(p.to(newP).length());\r\n        p = newP;\r\n        assert(eq0(ic(p.x, p.y)));\r\n    } while (i++ < 1000 && (i < 4 || prevp.distanceTo(endp) > stepLength) && bounds(p.x, p.y));\r\n    assert(i != 1000);\r\n    //assert(bounds(p.x, p.y))\r\n    const end = i < 4 || prevp.distanceTo(endp) > stepLength ? p : endp;\r\n    const endTangent = new V3(-ic.y(end.x, end.y), ic.x(end.x, end.y), 0).toLength(stepLength);\r\n    points.push(end);\r\n    tangents.push(endTangent);\r\n    //assert(points.length > 6)\r\n    // TODO gleichmäßige Verteilung der Punkte\r\n    return { points, tangents };\r\n}\r\n// both curves must be in the same s-t coordinates for this to make sense\r\nexport function intersectionICurveICurve(iCurve1, startParams1, endParams1, startDir, stepLength, iCurve2) {\r\n    assertNumbers(stepLength, iCurve1(0, 0), iCurve2(0, 0));\r\n    assertVectors(startParams1, endParams1);\r\n    assert(!startDir || startDir instanceof V3);\r\n    const vertices = [];\r\n    assert(eq0(iCurve1(startParams1.x, startParams1.y)));\r\n    stepLength = stepLength || 0.5;\r\n    const eps = 1e-5;\r\n    let p = startParams1, prevp = p; // startDir ? p.minus(startDir) : p\r\n    let i = 0;\r\n    while (i++ < 1000 && (i < 4 || p.distanceTo(endParams1) > 1.1 * stepLength)) {\r\n        const fp = iCurve1(p.x, p.y);\r\n        const dfpdx = (iCurve1(p.x + eps, p.y) - fp) / eps, dfpdy = (iCurve1(p.x, p.y + eps) - fp) / eps;\r\n        let tangent = new V3(-dfpdy, dfpdx, 0).toLength(stepLength);\r\n        if (p.minus(prevp).dot(tangent) < 0)\r\n            tangent = tangent.negated();\r\n        prevp = p;\r\n        p = curvePointMF(iCurve1, p.plus(tangent));\r\n        vertices.push(p);\r\n    }\r\n    // TODO gleichmäßige Verteilung der Punkte\r\n    return vertices;\r\n}\r\nexport function intersectionICurveICurve2(iCurve1, loopPoints1, iCurve2) {\r\n    let p = loopPoints1[0], val = iCurve2(p.x, p.y), lastVal;\r\n    const iss = [];\r\n    for (let i = 0; i < loopPoints1.length; i++) {\r\n        lastVal = val;\r\n        p = loopPoints1[i];\r\n        val = iCurve2(p.x, p.y);\r\n        if (val * lastVal <= 0) {\r\n            // TODO < ?\r\n            iss.push(newtonIterate2d(iCurve1, iCurve2, p.x, p.y));\r\n        }\r\n    }\r\n    return iss;\r\n}\r\n// export function intersectionPCurveISurface(\r\n// \tparametricCurve: Curve,\r\n// \tsearchStart: number,\r\n// \tsearchEnd: number,\r\n// \tsearchStep: number,\r\n// \timplicitSurface: ImplicitSurface,\r\n// ) {\r\n// \tassertNumbers(searchStart, searchEnd, searchStep)\r\n// \tconst iss = []\r\n// \tlet val = implicitSurface(parametricCurve(searchStart)),\r\n// \t\tlastVal\r\n// \tfor (let t = searchStart + searchStep; t <= searchEnd; t += searchStep) {\r\n// \t\tlastVal = val\r\n// \t\tval = implicitSurface(parametricCurve(t))\r\n// \t\tif (val * lastVal <= 0) {\r\n// \t\t\tiss.push(newtonIterate1d(t => implicitSurface(parametricCurve(t)), t))\r\n// \t\t}\r\n// \t}\r\n// \treturn iss\r\n// }\r\nexport function cassini(a, c) {\r\n    return (x, y) => (x * x + y * y) * (x * x + y * y) - 2 * c * c * (x * x - y * y) - (Math.pow(a, 4) - Math.pow(c, 4));\r\n}\r\nexport var MathFunctionR2R;\r\n(function (MathFunctionR2R) {\r\n    function forNerdamer(expression, args = ['x', 'y']) {\r\n        const ndf = nerdamer(expression);\r\n        const ndfs = nerdamer.diff(ndf, args[0]);\r\n        const ndft = nerdamer.diff(ndf, args[1]);\r\n        const f = ndf.buildFunction(args);\r\n        f.x = ndfs.buildFunction(args);\r\n        f.y = ndft.buildFunction(args);\r\n        f.xx = nerdamer.diff(ndfs, args[0]).buildFunction(args);\r\n        f.xy = nerdamer.diff(ndfs, args[1]).buildFunction(args);\r\n        f.yy = nerdamer.diff(ndft, args[1]).buildFunction(args);\r\n        return f;\r\n    }\r\n    MathFunctionR2R.forNerdamer = forNerdamer;\r\n    function nerdamerToR2_R(expression, args = ['x', 'y']) {\r\n        return expression.buildFunction(args);\r\n    }\r\n    MathFunctionR2R.nerdamerToR2_R = nerdamerToR2_R;\r\n    function forFFxFy(f, fx, fy) {\r\n        ;\r\n        f.x = fx;\r\n        f.y = fy;\r\n        return f;\r\n    }\r\n    MathFunctionR2R.forFFxFy = forFFxFy;\r\n})(MathFunctionR2R || (MathFunctionR2R = {}));\r\nexport const cas2 = cassini(0.9, 1.02);\r\nexport function arrayLerp(lerp, arr, t) {\r\n    if (0 === t % 1)\r\n        return arr[t];\r\n    return lerp(arr[Math.floor(t)], arr[Math.ceil(t)], t % 1);\r\n}\r\n//# sourceMappingURL=BRep.js.map","import { assert } from 'ts3dutils';\r\nimport { getGlobalId } from './index';\r\nexport function doNotSerialize(target, key) {\r\n    const map = target.__SERIALIZATION_BLACKLIST || (target.__SERIALIZATION_BLACKLIST = {});\r\n    map[key] = 'no';\r\n}\r\nexport class ClassSerializer {\r\n    constructor() {\r\n        this.CLASS_NAMES = new Map();\r\n        this.NAME_CLASSES = new Map();\r\n        this.addClass('Object', Object);\r\n    }\r\n    addClass(name, clazz) {\r\n        if (this.NAME_CLASSES.has(name)) {\r\n            throw new Error(name);\r\n        }\r\n        this.NAME_CLASSES.set(name, clazz);\r\n        this.CLASS_NAMES.set(clazz, name);\r\n        return this;\r\n    }\r\n    addNamespace(namespace, namespaceName) {\r\n        Object.keys(namespace).forEach(symbol => {\r\n            const o = namespace[symbol];\r\n            if ('function' == typeof o && o.name) {\r\n                this.addClass((namespaceName ? namespaceName + '.' : '') + symbol, o);\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n    setUpdater(f) {\r\n        this.updater = f;\r\n        return this;\r\n    }\r\n    serialize(v) {\r\n        return JSON.stringify(this.serializeObj(v));\r\n    }\r\n    serializeObj(v) {\r\n        const path = [];\r\n        const gatherList = (v) => {\r\n            //console.log(path.toString())\r\n            if (undefined !== v && v.hasOwnProperty('constructor') && this.CLASS_NAMES.has(v.constructor)) {\r\n                // do nothing, this is a class/function prototype\r\n            }\r\n            else if (Array.isArray(v)) {\r\n                if (visited.has(v)) {\r\n                    if (!listMap.has(v)) {\r\n                        listMap.set(v, resultList.length);\r\n                        resultList.push(v);\r\n                    }\r\n                }\r\n                else {\r\n                    visited.add(v);\r\n                    for (let i = 0; i < v.length; i++) {\r\n                        path.push('' + i);\r\n                        gatherList(v[i]);\r\n                        path.pop();\r\n                    }\r\n                }\r\n            }\r\n            else if (undefined !== v && 'object' == typeof v) {\r\n                if (visited.has(v)) {\r\n                    if (!listMap.has(v)) {\r\n                        listMap.set(v, resultList.length);\r\n                        resultList.push(v);\r\n                    }\r\n                }\r\n                else {\r\n                    assert(!v.__noxTarget || !visited.has(v.__noxTarget));\r\n                    assert(!v.__noxProxy || !visited.has(v.__noxProxy));\r\n                    visited.add(v);\r\n                    if (!v.getConstructorParameters) {\r\n                        for (const key of Object.keys(v).sort()) {\r\n                            if (key == '__noxProxy' || key == '__noxTarget')\r\n                                continue;\r\n                            if (!v.__SERIALIZATION_BLACKLIST || !v.__SERIALIZATION_BLACKLIST[key]) {\r\n                                path.push(key);\r\n                                gatherList(v[key]);\r\n                                path.pop();\r\n                            }\r\n                        }\r\n                    }\r\n                    path.push('proto');\r\n                    gatherList(Object.getPrototypeOf(v));\r\n                    path.pop();\r\n                }\r\n            }\r\n        };\r\n        const transform = (v, allowLinks, first) => {\r\n            if ('string' == typeof v || 'number' == typeof v || 'boolean' == typeof v || null === v) {\r\n                return v;\r\n            }\r\n            if ('undefined' == typeof v) {\r\n                return { '#REF': -1 };\r\n            }\r\n            if (v.hasOwnProperty('constructor') && this.CLASS_NAMES.has(v.constructor)) {\r\n                return { '#REF': this.CLASS_NAMES.get(v.constructor) };\r\n            }\r\n            let index;\r\n            if (allowLinks && !first && undefined !== (index = listMap.get(v))) {\r\n                return { '#REF': index };\r\n            }\r\n            if (Array.isArray(v)) {\r\n                return v.map(x => transform(x, allowLinks));\r\n            }\r\n            //if (mobx && mobx.isObservableArray(v)) {\r\n            //\tconst result = {'#PROTO': 'ObservableArray'} as any\r\n            //\tv.forEach((val, i) => result[i] = transform(val))\r\n            //\treturn result\r\n            //}\r\n            if ('object' == typeof v) {\r\n                if (v.getConstructorParameters) {\r\n                    return {\r\n                        '#CONSTRUCTOR': this.CLASS_NAMES.get(v.constructor),\r\n                        '#ARGS': transform(v.getConstructorParameters(), false),\r\n                    };\r\n                }\r\n                const result = {};\r\n                if (Object.prototype !== Object.getPrototypeOf(v)) {\r\n                    result['#PROTO'] = transform(Object.getPrototypeOf(v), allowLinks);\r\n                }\r\n                for (const key of Object.keys(v)) {\r\n                    if (key == '__noxProxy' || key == '__noxTarget')\r\n                        continue;\r\n                    if (!v.__SERIALIZATION_BLACKLIST || !v.__SERIALIZATION_BLACKLIST[key]) {\r\n                        result[key] = transform(v[key], allowLinks);\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n            throw new Error('?' + typeof v + v.toString());\r\n        };\r\n        const visited = new Set();\r\n        const listMap = new Map();\r\n        let resultList = [];\r\n        listMap.set(v, 0);\r\n        resultList.push(v);\r\n        gatherList(v);\r\n        resultList = resultList.map(v => transform(v, true, true));\r\n        return resultList;\r\n    }\r\n    unserialize(string) {\r\n        let depth = 0;\r\n        const fixObject = (v, onReady) => {\r\n            depth++;\r\n            if (depth > 100)\r\n                throw new Error();\r\n            if (v && v.constructor === Array) {\r\n                onReady(v);\r\n                for (let i = 0; i < v.length; i++) {\r\n                    fixObject(v[i], x => (v[i] = x));\r\n                }\r\n            }\r\n            else if ('object' == typeof v && undefined != v) {\r\n                if ('#CONSTRUCTOR' in v) {\r\n                    const protoName = v['#CONSTRUCTOR'];\r\n                    const proto = this.NAME_CLASSES.get(protoName);\r\n                    assert(proto, protoName + ' Missing ');\r\n                    let args = undefined;\r\n                    fixObject(v['#ARGS'], x => (args = x));\r\n                    onReady(new proto(...args));\r\n                }\r\n                else if ('#REF' in v) {\r\n                    const ref = v['#REF'];\r\n                    if ('string' == typeof ref) {\r\n                        onReady(this.NAME_CLASSES.get(ref).prototype);\r\n                    }\r\n                    else if ('number' == typeof ref) {\r\n                        if (-1 == ref) {\r\n                            onReady(undefined);\r\n                        }\r\n                        else if (fixedObjects[ref]) {\r\n                            onReady(fixedObjects[ref]);\r\n                        }\r\n                        else {\r\n                            fixObject(tree[ref], x => onReady((fixedObjects[ref] = x)));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    let result;\r\n                    if ('#PROTO' in v) {\r\n                        fixObject(v['#PROTO'], x => {\r\n                            result = Object.create(x);\r\n                            onReady(result);\r\n                        });\r\n                    }\r\n                    else {\r\n                        onReady((result = v));\r\n                    }\r\n                    const keys = Object.keys(v);\r\n                    for (let i = 0; i < keys.length; i++) {\r\n                        //if ('name' == keys[i]) console.log(result)\r\n                        if ('#PROTO' != keys[i]) {\r\n                            fixObject(v[keys[i]], x => (result[keys[i]] = x));\r\n                            //Object.defineProperty(result, keys[i], {\r\n                            //\tvalue: fixObjects(v[keys[i]]),\r\n                            //\tenumerable: true,\r\n                            //\twritable: true,\r\n                            //\tconfigurable: true\r\n                            //})\r\n                        }\r\n                    }\r\n                    Object.defineProperty(result, 'loadID', {\r\n                        value: getGlobalId(),\r\n                        enumerable: false,\r\n                        writable: false,\r\n                    });\r\n                    this.updater && this.updater(result);\r\n                }\r\n            }\r\n            else {\r\n                onReady(v);\r\n            }\r\n            depth--;\r\n        };\r\n        // const linkReferences = (v: any) => {\r\n        // \tif (v && v.constructor === Array) {\r\n        // \t\tfor (let i = 0; i < v.length; i++) {\r\n        // \t\t\tv[i] = linkReferences(v[i])\r\n        // \t\t}\r\n        // \t\treturn v\r\n        // \t} else if ('object' == typeof v && undefined != v) {\r\n        // \t\tif ('#REF' in v) {\r\n        // \t\t\treturn tree[v['#REF']]\r\n        // \t\t} else {\r\n        // \t\t\tconst keys = Object.keys(v)\r\n        // \t\t\tfor (let i = 0; i < keys.length; i++) {\r\n        // \t\t\t\tv[keys[i]] = linkReferences(v[keys[i]])\r\n        // \t\t\t}\r\n        // \t\t\treturn v\r\n        // \t\t}\r\n        // \t} else {\r\n        // \t\treturn v\r\n        // \t}\r\n        // }\r\n        const tree = JSON.parse(string);\r\n        // console.log(tree)\r\n        const fixedObjects = new Array(tree.length);\r\n        fixObject({ '#REF': 0 }, () => { });\r\n        // console.log(tree)\r\n        // linkReferences(tree)\r\n        // console.log(tree)\r\n        return fixedObjects[0];\r\n    }\r\n}\r\n//# sourceMappingURL=ClassSerializer.js.map","export const fragmentShaderLighting = `\r\n\tprecision highp float;\r\n\tuniform vec4 color;\r\n\tuniform vec3 camPos;\r\n\tvarying vec3 normal;\r\n\tvarying vec4 vPosition;\r\n\tvoid main() {\r\n\t\tvec3 normal1 = normalize(normal);\r\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\r\n\t\tvec3 lightDir = normalize(vPosition.xyz - lightPos);\r\n        vec3 reflectionDirection = reflect(lightDir, normal1);\r\n        vec3 eyeDirection = normalize(camPos.xyz-vPosition.xyz);\r\n        float uMaterialShininess = 256.0;\r\n\t\tfloat specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\r\n\t\tfloat lightIntensity = 0.6 + 0.2 * max(0.0, -dot(lightDir, normal1)) + 0.2*specularLightWeighting;\r\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\r\n\t}\r\n`;\r\nexport const vertexShaderLighting = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tuniform mat4 ts_ModelViewMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform mat3 ts_NormalMatrix;\r\n\tattribute vec3 ts_Normal;\r\n\tuniform vec4 color;\r\n\tvarying vec3 normal;\r\n\tvarying vec4 vPosition;\r\n\tvoid main() {\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\r\n        vPosition = ts_ModelViewMatrix * ts_Vertex;\r\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\r\n\t}\r\n`;\r\nexport const vertexShaderWaves = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tuniform mat4 ts_ModelViewMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform mat3 ts_NormalMatrix;\r\n\tattribute vec3 ts_Normal;\r\n\tuniform vec4 color;\r\n\tvarying vec3 normal;\r\n\tvarying vec4 vPosition;\r\n\tvoid main() {\r\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\r\n\t\tfloat offset = mod  (((ts_Vertex.x + ts_Vertex.y + ts_Vertex.z) * 31.0), 20.0) - 10.0;\r\n\t\tvec4 modPos = ts_Vertex + vec4(normal * offset, 0);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * modPos;\r\n        vPosition = ts_ModelViewMatrix * modPos;\r\n\t}\r\n`;\r\nexport const vertexShader = `\r\n\tvarying vec4 pos;\r\n\tvoid main() {\r\n\t\tpos = vec4(position,1.0);\r\n\t\tgl_Position = projectionMatrix *\r\n\t\t\tmodelViewMatrix *\r\n\t\t\tvec4(position,1.0);\r\n\t}\r\n`;\r\nexport const fragmentShader = `\r\n\tprecision highp float;\r\n\tuniform vec3 color;\r\n\tvarying vec4 pos;\r\n\tvoid main() {\r\n\t\tfloat distance = pos.x * pos.x + pos.y * pos.y;\r\n\t\tif (distance <= 0.98) {\r\n\t\t\tgl_FragColor = vec4(color, 1.0);\r\n\t\t} else if (distance <= 1.0) {\r\n\t\t\tgl_FragColor = vec4(color, 0.5);\r\n\t\t} else {\r\n\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t precision mediump float;\r\n\r\n\t varying vec4 pos;\r\n\r\n\r\n\t void main() {\r\n\t float inside = pos.r * pos.r + pos.g * pos.g;\r\n\t if (inside <= 1) {\r\n\t gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n\t } else {\r\n\t gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n\t }\r\n\t }\r\n\t */\r\n`;\r\nexport const vertexShaderBasic = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tvoid main() {\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\r\n\t}\r\n`;\r\nexport const vertexShaderColor = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tattribute vec4 ts_Color;\r\n\tvarying vec4 fragColor;\r\n\tvoid main() {\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\r\n\t\tfragColor = ts_Color;\r\n\t}\r\n`;\r\nexport const vertexShaderArc = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform float step, offset;\r\n\tuniform float radius, width;\r\n\tvoid main() {\r\n\t\tfloat r = radius;\r\n\t\tfloat t = offset + ts_Vertex.x * step;\r\n\t\tfloat pRadius = r - ts_Vertex.y * width;\r\n\t\tvec4 p = vec4(pRadius * cos(t), pRadius * sin(t), 0, 1);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\r\n}\r\n`;\r\nexport const vertexShaderConic3d = `\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform float startT, endT, scale;\r\n\tuniform vec3 center, f1, f2;\r\n\tuniform int mode;\r\n\tfloat sinh(float x) { return (exp(x) - exp(-x)) / 2.0; }\r\n\tfloat cosh(float x) { return (exp(x) + exp(-x)) / 2.0; }\r\n\tvoid main() {\r\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\r\n\r\n\t\tvec3 normal = normalize(cross(f1, f2));\r\n\r\n\t\tvec3 p, tangent;\r\n\t\tif (0 == mode) { // ellipse\r\n\t\t\tp = center + f1 * cos(t) + f2 * sin(t);\r\n\t\t\ttangent = f1 * -sin(t) + f2 * cos(t);\r\n\t\t}\r\n\t\tif (1 == mode) { // parabola\r\n\t\t\tp = center + f1 * t + f2 * t * t;\r\n\t\t\ttangent = f1 + 2.0 * f2 * t;\r\n\t\t}\r\n\t\tif (2 == mode) { // hyperbola\r\n\t\t\tp = center + f1 * cosh(t) + f2 * sinh(t);\r\n\t\t\ttangent = f1 * sinh(t) + f2 * cosh(t);\r\n\t\t}\r\n\t\tvec3 outDir = normalize(cross(normal, tangent));\r\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + normal * ts_Vertex.z);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\r\n\t}\r\n`;\r\nexport const vertexShaderNURBS = `#version 300 es\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tin vec4 ts_Vertex;\r\n\tuniform float startT, endT, scale;\r\n\tuniform vec4 points[32];\r\n\tuniform int pointCount, degree;\r\n\tuniform float knots[40];\r\n\tuniform vec3 normal;\r\n\tconst int MIN_DEGREE = 1;\r\n\tconst int MAX_DEGREE = 6;\r\n\t\r\n\tint tInterval(float t) {\r\n\t\tfor (int s = degree; s < 40 - 1 - degree; s++) {\r\n\t\t\tif (t >= knots[s] && t <= knots[s + 1]) {\r\n\t\t\t\treturn s;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tvec4 stepp(int k, int i, vec4 dkMinus1iMinus1, vec4 dkMinus1i) {\r\n\t    return dkMinus1i - dkMinus1iMinus1 * float(k) / (knots[i + degree - k] - knots[i - 1]);\r\n\t}\r\n\t\r\n\tvoid main() {\r\n\t\t// ts_Vertex.x is in [0, 1]\r\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\r\n\t\t\r\n\t\tint s = tInterval(t);\r\n\t\t\r\n\t\tvec4 v[MAX_DEGREE + 1];\r\n\t\tfor (int i = 0; i < degree + 1; i++) {\r\n\t\t    v[i] = points[s - degree + i];\r\n\t\t}\r\n\t\t\r\n\t\tvec4 pTangent4, ddt4 = vec4(0, 0, 1, 0);\r\n\t\tfor (int level = 0; level < degree; level++) {\r\n\t\t\tif (level == degree - 2) {\r\n\t\t\t\t// see https://www.globalspec.com/reference/61012/203279/10-8-derivatives\r\n\t\t\t\tvec4 a = v[degree];\r\n\t\t\t\tvec4 b = v[degree - 1];\r\n\t\t\t\tvec4 c = v[degree - 2];\r\n\t\t\t\tddt4 = stepp(degree, s + 1, stepp(degree - 1, s + 1, a, b), stepp(degree - 1, s, b, c));\r\n\t\t\t}\r\n\t\t\tif (level == degree - 1) {\r\n\t\t\t\tvec4 a = v[degree];\r\n\t\t\t\tvec4 b = v[degree - 1];\r\n\t\t\t\tpTangent4 = (b - a) * (float(degree) / (knots[s] - knots[s + 1]));\r\n\t\t\t}\r\n\t\t\tfor (int i = degree; i > level; i--) {\r\n\t\t\t\tfloat alpha = (t - knots[i + s - degree]) / (knots[i + s - level] - knots[i + s - degree]);\r\n\r\n\t\t\t\t// interpolate each component\r\n                v[i] = (1.0 - alpha) * v[i - 1] + alpha * v[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvec4 p4 = v[degree];\r\n\t\t\r\n\t\tvec3 p = p4.xyz / p4.w;\r\n\t\tvec3 pTangent = ((pTangent4.xyz * p4.w) - (p4.xyz * pTangent4.w)) / (p4.w * p4.w);\r\n\t\tvec3 ddt = (\r\n\t\t    p4.xyz * (-p4.w * ddt4.w + 2.0 * pow(pTangent4.w, 2.0))\r\n\t\t    + pTangent4.xyz * (-2.0 * p4.w * pTangent4.w) \r\n\t\t    + ddt4.xyz * pow(p4.w, 2.0)\r\n        ) / pow(p4.w, 3.0);\r\n\t\t\r\n\t\tvec3 outDir = normalize(cross(ddt, pTangent));\r\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\r\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\r\n    }\r\n`;\r\nexport const vertexShaderBezier = `\r\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform float width, startT, endT;\r\n\tuniform vec3 p0, p1, p2, p3;\r\n\tvoid main() {\r\n\t\t// ts_Vertex.x is in [0, 1]\r\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT), s = 1.0 - t;\r\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\r\n\t\tvec3 pPos = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\r\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\r\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\r\n\t\tvec3 pNormal = normalize(vec3(pTangent.y, -pTangent.x, 0));\r\n\t\tvec4 p = vec4(pPos - ts_Vertex.y * width * pNormal, 1);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\r\n\t}\r\n`;\r\nexport const vertexShaderBezier3d = `\r\n    precision highp float;\r\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\r\n\tuniform float scale, startT, endT;\r\n\tuniform vec3 ps[4];\r\n\tuniform vec3 p0, p1, p2, p3, normal;\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tvoid main() {\r\n\t\t// ts_Vertex.y is in [0, 1]\r\n\t\tvec3 p5 = ps[0];\r\n\t\tfloat t = startT * (1.0 - ts_Vertex.x) + endT * ts_Vertex.x, s = 1.0 - t;\r\n\t\tfloat c0 = s * s * s, \r\n\t\t      c1 = 3.0 * s * s * t, \r\n\t\t      c2 = 3.0 * s * t * t, c3 = t * t * t;\r\n\t\tvec3 p = (p0 * c0 + p1 * c1) + (p2 * c2 + p3 * c3);\r\n\t\tfloat c01 = 3.0 * s * s, \r\n\t\t      c12 = 6.0 * s * t, \r\n\t\t      c23 = 3.0 * t * t;\r\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\r\n\t\tvec3 outDir = normalize(cross(normal, pTangent));\r\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\r\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\r\n\t}\r\n`;\r\nexport const vertexShaderGeneric = `\r\n\tuniform float scale;\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform mat3 ts_NormalMatrix;\r\n\tattribute vec3 ts_Normal;\r\n\tvoid main() {\r\n\t\tvec3 normal = normalize(ts_NormalMatrix * ts_Normal);\r\n\t\tvec4 vertexPos = ts_Vertex + vec4(normal * scale, 0);\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vertexPos;\r\n\t}\r\n`;\r\nexport const vertexShaderRing = `\r\n\t#define M_PI 3.1415926535897932384626433832795\r\n\tuniform float step;\r\n\tuniform float innerRadius, outerRadius;\r\n\tattribute float index;\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tattribute vec4 ts_Vertex;\r\n\tvoid main() {\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(index, index, index, 1);\r\n\t\tfloat id = atan(ts_Vertex.x, ts_Vertex.y) / M_PI  * 32.0;\r\n\t\tfloat radius = mod(id, 2.0) < 1.0 ? outerRadius : innerRadius;\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(radius * cos(index * step), radius * sin(index * step), 0, 1);\r\n\t}\r\n`;\r\nexport const fragmentShaderColor = `\r\n\tprecision highp float;\r\n\tuniform vec4 color;\r\n\tvoid main() {\r\n\t\tgl_FragColor = color;\r\n\t}\r\n`;\r\nexport const fragmentShaderColor3 = `#version 300 es\r\n\tprecision highp float;\r\n\tuniform vec4 color;\r\n\tout vec4 fragColor;\r\n\tvoid main() {\r\n\t\tfragColor = color;\r\n\t}\r\n`;\r\nexport const fragmentShaderVaryingColor = `\r\n\tprecision highp float;\r\n\tvarying vec4 fragColor;\r\n\tvoid main() {\r\n\t\tgl_FragColor = fragColor;\r\n\t}\r\n`;\r\nexport const fragmentShaderColorHighlight = `\r\n\tprecision highp float;\r\n\tuniform vec4 color;\r\n\tvoid main() {\r\n\t\tfloat diagonal = (gl_FragCoord.x + 2.0 * gl_FragCoord.y);\r\n\t\tif (mod(diagonal, 50.0) > 40.0) { // mod(diagonal, 2.0) > 1.0\r\n\t\t\tdiscard;\r\n\t\t\t//gl_FragColor = color + vec4(0.2,0.2,0.2,0);\r\n\t\t} else {\r\n\t\t\tgl_FragColor = color - vec4(0.2,0.2,0.2,0);\r\n\t\t}\r\n\t}\r\n`;\r\nexport const vertexShaderTexture = `\r\n\tvarying vec2 texturePos;\r\n\tattribute vec4 ts_Vertex;\r\n\tuniform mat4 ts_ModelViewProjectionMatrix;\r\n\tvoid main() {\r\n\t\ttexturePos = ts_Vertex.xy;\r\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\r\n\t}\r\n`;\r\nexport const fragmentShaderTextureColor = `\r\n\tprecision highp float;\r\n\tvarying vec2 texturePos;\r\n\tuniform vec4 color;\r\n\tuniform sampler2D texture;\r\n\tvoid main() {\r\n\t\tgl_FragColor = texture2D(texture, texturePos) * color;\r\n\t}\r\n`;\r\nexport const fragmentShaderTexture = `\r\n\tprecision highp float;\r\n\tvarying vec2 texturePos;\r\n\tuniform sampler2D texture;\r\n\tvoid main() {\r\n\t\tgl_FragColor = texture2D(texture, texturePos);\r\n\t}\r\n`;\r\n//# sourceMappingURL=shaders.js.map","import chroma from 'chroma-js';\r\nimport { addOwnProperties, arrayFromFunction, DEG, M4, TAU, V, V3, Vector } from 'ts3dutils';\r\nimport { GL_COLOR_BLACK, Mesh, Shader } from 'tsgl';\r\nimport { B2T, BezierCurve, EllipseCurve, HyperbolaCurve, ImplicitCurve, L3, NURBS, ParabolaCurve, PICurve, PPCurve, } from './index';\r\nimport { ceil, floor, pow, sign } from './math';\r\nimport * as shaders from './shaders';\r\nexport function parseGetParams(str) {\r\n    const result = {};\r\n    str.split('&').forEach(function (item) {\r\n        const splitIndex = item.indexOf('=');\r\n        if (-1 == splitIndex) {\r\n            result[item] = item;\r\n        }\r\n        else {\r\n            result[item.substr(0, splitIndex)] = decodeURI(item.substr(splitIndex + 1));\r\n        }\r\n    });\r\n    return result;\r\n}\r\nexport const COLORS = {\r\n    RD_FILL: chroma('#9EDBF9'),\r\n    RD_STROKE: chroma('#77B0E0'),\r\n    TS_FILL: chroma('#D19FE3'),\r\n    TS_STROKE: chroma('#A76BC2'),\r\n    PP_FILL: chroma('#F3B6CF'),\r\n    PP_STROKE: chroma('#EB81B4'),\r\n};\r\nexport class BREPGLContext {\r\n    constructor(gl) {\r\n        this.cachedMeshes = new WeakMap();\r\n        this.shaders = initShaders(gl);\r\n        initMeshes((this.meshes = {}), gl);\r\n    }\r\n    static create(gl) {\r\n        addOwnProperties(gl, BREPGLContext.prototype);\r\n        addOwnProperties(gl, new BREPGLContext(gl));\r\n        return gl;\r\n    }\r\n    drawPoint(p, color = GL_COLOR_BLACK, size = 5) {\r\n        this.pushMatrix();\r\n        this.translate(p);\r\n        this.scale(size / 2, size / 2, size / 2);\r\n        this.shaders.singleColor.uniforms({ color: color }).draw(this.meshes.sphere1);\r\n        this.popMatrix();\r\n    }\r\n    drawEdge(edge, color = GL_COLOR_BLACK, width = 2) {\r\n        CURVE_PAINTERS[edge.curve.constructor.name](this, edge.curve, color, edge.minT, edge.maxT, width);\r\n    }\r\n    drawCurve(curve, color = GL_COLOR_BLACK, width = 2, tStart, tEnd) {\r\n        CURVE_PAINTERS[curve.constructor.name](this, curve, color, tStart, tEnd, width);\r\n    }\r\n    drawVector(vector, anchor, color = GL_COLOR_BLACK, size = 1) {\r\n        if (vector.likeO())\r\n            return;\r\n        this.pushMatrix();\r\n        const headLength = size * 4;\r\n        if (headLength > vector.length())\r\n            return;\r\n        const vT = vector.getPerpendicular().unit();\r\n        this.multMatrix(M4.forSys(vector.unit(), vT, vector.cross(vT).unit(), anchor));\r\n        this.scale(vector.length() - headLength, size / 2, size / 2);\r\n        this.shaders.singleColor\r\n            .uniforms({\r\n            color: color,\r\n        })\r\n            .draw(this.meshes.vectorShaft);\r\n        this.scale(1 / (vector.length() - headLength), 1, 1);\r\n        this.translate(vector.length() - headLength, 0, 0);\r\n        this.scale(headLength / 2, 1, 1);\r\n        this.shaders.singleColor.draw(this.meshes.vectorHead);\r\n        this.popMatrix();\r\n    }\r\n    drawVectors(drVs, size = undefined) {\r\n        this.drawVector(V3.X, V3.O, chroma('red').gl(), size);\r\n        this.drawVector(V3.Y, V3.O, chroma('green').gl(), size);\r\n        this.drawVector(V3.Z, V3.O, chroma('blue').gl(), size);\r\n        drVs.forEach(vi => this.drawVector(vi.v, vi.anchor, vi.color, size));\r\n    }\r\n    drawPlane(customPlane, color, dotted = false) {\r\n        this.pushMatrix();\r\n        this.multMatrix(M4.forSys(customPlane.right, customPlane.up, customPlane.normal1));\r\n        this.translate(customPlane.uMin, customPlane.vMin, customPlane.w);\r\n        this.scale(customPlane.uMax - customPlane.uMin, customPlane.vMax - customPlane.vMin, 1);\r\n        const mesh = dotted ? this.meshes.xyDottedLinePlane : this.meshes.xyLinePlane;\r\n        this.shaders.singleColor.uniforms({ color: color }).draw(mesh, this.LINES);\r\n        this.popMatrix();\r\n    }\r\n    drawBox(m4, color) {\r\n        this.pushMatrix();\r\n        this.multMatrix(m4);\r\n        if (color) {\r\n            this.shaders.singleColor.uniforms({ color: color }).draw(this.meshes.cube, this.LINES);\r\n        }\r\n        else {\r\n            this.shaders.multiColor.draw(this.meshes.cube, this.LINES);\r\n        }\r\n        this.popMatrix();\r\n    }\r\n}\r\nfunction conicPainter(mode, gl, ellipse, color, startT, endT, width = 2) {\r\n    gl.shaders.ellipse3d\r\n        .uniforms({\r\n        f1: ellipse.f1,\r\n        f2: ellipse.f2,\r\n        center: ellipse.center,\r\n        color: color,\r\n        startT: startT,\r\n        endT: endT,\r\n        scale: width,\r\n        mode: mode,\r\n    })\r\n        .draw(gl.meshes.pipe);\r\n}\r\nexport const CURVE_PAINTERS = {\r\n    [EllipseCurve.name]: conicPainter.bind(undefined, 0),\r\n    [ParabolaCurve.name]: conicPainter.bind(undefined, 1),\r\n    [HyperbolaCurve.name]: conicPainter.bind(undefined, 2),\r\n    [ImplicitCurve.name](gl, curve, color, startT, endT, width = 2) {\r\n        let mesh = gl.cachedMeshes.get(curve);\r\n        const RES = 4;\r\n        if (!mesh) {\r\n            mesh = new Mesh().addIndexBuffer('TRIANGLES').addVertexBuffer('normals', 'ts_Normal');\r\n            curve.addToMesh(mesh, RES);\r\n            mesh.compile();\r\n            gl.cachedMeshes.set(curve, mesh);\r\n        }\r\n        const startIndex = ceil(startT);\r\n        const endIndex = floor(endT);\r\n        if (startIndex <= endIndex) {\r\n            const indexFactor = 2 * // no of triangles per face\r\n                RES * // no of faces\r\n                3; // no of indexes per triangle\r\n            gl.shaders.generic3d\r\n                .uniforms({\r\n                color: color,\r\n                scale: width,\r\n            })\r\n                .draw(mesh, gl.TRIANGLES, startIndex * indexFactor, (floor(endT) - startIndex) * indexFactor);\r\n            if (startT % 1 !== 0) {\r\n                const p = curve.at(startT);\r\n                gl.pushMatrix();\r\n                const m = M4.forSys(p.to(curve.points[startIndex]), mesh.normals[startIndex * RES].toLength(width), mesh.normals[startIndex * RES + 1].toLength(width), p);\r\n                gl.multMatrix(m);\r\n                gl.shaders.singleColor.uniforms({ color: color }).draw(gl.meshes.pipeSegmentForICurve);\r\n                console.log(gl.meshes.pipeSegmentForICurve);\r\n                gl.popMatrix();\r\n            }\r\n            if (endT % 1 !== 0) {\r\n                const p = curve.at(endT);\r\n                gl.pushMatrix();\r\n                const m = M4.forSys(curve.points[endIndex].to(p), mesh.normals[endIndex * RES].toLength(width), mesh.normals[endIndex * RES + 1].toLength(width), curve.points[endIndex]);\r\n                gl.multMatrix(m);\r\n                gl.shaders.singleColor.uniforms({ color: color }).draw(gl.meshes.pipeSegmentForICurve);\r\n                gl.popMatrix();\r\n            }\r\n        }\r\n        else {\r\n            const p1 = curve.at(startT);\r\n            const p2 = curve.at(endT);\r\n            gl.pushMatrix();\r\n            const v0 = p1.to(p2), v1 = v0.getPerpendicular().toLength(width), v2 = v0.cross(v1).toLength(width);\r\n            const m = M4.forSys(v0, v1, v2, p1);\r\n            gl.multMatrix(m);\r\n            gl.shaders.singleColor.uniforms({ color: color }).draw(gl.meshes.pipeSegmentForICurve);\r\n            gl.popMatrix();\r\n        }\r\n    },\r\n    [BezierCurve.name](gl, curve, color, startT, endT, width = 2, normal = V3.Z) {\r\n        gl.shaders.bezier3d\r\n            .uniforms({\r\n            p0: curve.p0,\r\n            p1: curve.p1,\r\n            p2: curve.p2,\r\n            p3: curve.p3,\r\n            color: color,\r\n            startT: startT,\r\n            endT: endT,\r\n            scale: width,\r\n            normal: normal,\r\n        })\r\n            .draw(gl.meshes.pipe);\r\n    },\r\n    [NURBS.name](gl, curve, color, startT, endT, width = 2, normal = V3.Z) {\r\n        gl.shaders.nurbs\r\n            .uniforms({\r\n            'points[0]': Vector.pack(curve.points),\r\n            degree: curve.degree,\r\n            'knots[0]': curve.knots,\r\n            color: color,\r\n            startT: startT,\r\n            endT: endT,\r\n            scale: width,\r\n            normal: normal,\r\n        })\r\n            .draw(gl.meshes.pipe);\r\n    },\r\n    [L3.name](gl, curve, color, startT, endT, width = 2, normal = V3.Z) {\r\n        gl.pushMatrix();\r\n        const a = curve.at(startT), b = curve.at(endT);\r\n        const ab = b.minus(a), abT = ab.getPerpendicular().unit();\r\n        const m = M4.forSys(ab, abT, ab.cross(abT).unit(), a);\r\n        gl.multMatrix(m);\r\n        gl.scale(1, width, width);\r\n        gl.shaders.singleColor\r\n            .uniforms({\r\n            color: color,\r\n        })\r\n            .draw(gl.meshes.pipe);\r\n        gl.popMatrix();\r\n    },\r\n};\r\nCURVE_PAINTERS[PICurve.name] = CURVE_PAINTERS[ImplicitCurve.name];\r\nCURVE_PAINTERS[PPCurve.name] = CURVE_PAINTERS[ImplicitCurve.name];\r\nexport function initMeshes(_meshes, _gl) {\r\n    _gl.makeCurrent();\r\n    _meshes.cube = (() => {\r\n        const cube = B2T.box()\r\n            .toMesh()\r\n            .addVertexBuffer('colors', 'ts_Color');\r\n        cube.colors = cube.vertices.map(p => [p.x, p.y, p.z, 1].map(x => x * 0.9));\r\n        cube.compile();\r\n        return cube;\r\n    })();\r\n    _meshes.sphere1 = Mesh.sphere(2);\r\n    _meshes.segment = Mesh.plane({ startY: -0.5, height: 1, detailX: 128 });\r\n    _meshes.text = Mesh.plane();\r\n    _meshes.vector = Mesh.rotation([V3.O, V(0, 0.05, 0), V(0.8, 0.05), V(0.8, 0.1), V(1, 0)], L3.X, TAU, 16, true);\r\n    _meshes.vectorShaft = Mesh.rotation([V3.O, V3.Y, V3.XY], L3.X, TAU, 8, true);\r\n    _meshes.vectorHead = Mesh.rotation([V3.Y, V(0, 2, 0), V(2, 0, 0)], L3.X, TAU, 8, true);\r\n    _meshes.pipe = Mesh.rotation(arrayFromFunction(512, (i, l) => new V3(i / (l - 1), -0.5, 0)), L3.X, TAU, 8, true);\r\n    _meshes.xyLinePlane = Mesh.plane();\r\n    _meshes.xyDottedLinePlane = makeDottedLinePlane();\r\n    _meshes.pipeSegmentForICurve = Mesh.offsetVertices(M4.rotateY(90 * DEG).transformedPoints(arrayFromFunction(4, i => V3.polar(1, TAU * i / 4))), V3.X, true);\r\n}\r\nexport function initShaders(_gl) {\r\n    _gl.makeCurrent();\r\n    return {\r\n        singleColor: Shader.create(shaders.vertexShaderBasic, shaders.fragmentShaderColor),\r\n        multiColor: Shader.create(shaders.vertexShaderColor, shaders.fragmentShaderVaryingColor),\r\n        singleColorHighlight: Shader.create(shaders.vertexShaderBasic, shaders.fragmentShaderColorHighlight),\r\n        textureColor: Shader.create(shaders.vertexShaderTexture, shaders.fragmentShaderTextureColor),\r\n        arc: Shader.create(shaders.vertexShaderRing, shaders.fragmentShaderColor),\r\n        arc2: Shader.create(shaders.vertexShaderArc, shaders.fragmentShaderColor),\r\n        ellipse3d: Shader.create(shaders.vertexShaderConic3d, shaders.fragmentShaderColor),\r\n        generic3d: Shader.create(shaders.vertexShaderGeneric, shaders.fragmentShaderColor),\r\n        bezier3d: Shader.create(shaders.vertexShaderBezier3d, shaders.fragmentShaderColor),\r\n        nurbs: Shader.create(shaders.vertexShaderNURBS, shaders.fragmentShaderColor3),\r\n        bezier: Shader.create(shaders.vertexShaderBezier, shaders.fragmentShaderColor),\r\n        lighting: Shader.create(shaders.vertexShaderLighting, shaders.fragmentShaderLighting),\r\n        waves: Shader.create(shaders.vertexShaderWaves, shaders.fragmentShaderLighting),\r\n    };\r\n}\r\nfunction makeDottedLinePlane(count = 128) {\r\n    const mesh = new Mesh().addIndexBuffer('LINES');\r\n    const OXvertices = arrayFromFunction(count, i => new V3(i / count, 0, 0));\r\n    mesh.vertices.push(...OXvertices);\r\n    mesh.vertices.push(...M4.forSys(V3.Y, V3.O, V3.O, V3.X).transformedPoints(OXvertices));\r\n    mesh.vertices.push(...M4.forSys(V3.X.negated(), V3.O, V3.O, new V3(1, 1, 0)).transformedPoints(OXvertices));\r\n    mesh.vertices.push(...M4.forSys(V3.Y.negated(), V3.O, V3.O, V3.Y).transformedPoints(OXvertices));\r\n    mesh.LINES = arrayFromFunction(count * 4, i => i - (i >= count * 2 ? 1 : 0));\r\n    mesh.compile();\r\n    return mesh;\r\n}\r\nexport function initNavigationEvents(_gl, eye, paintScreen) {\r\n    const canvas = _gl.canvas;\r\n    let lastPos = V3.O;\r\n    //_gl.onmousedown.push((e) => {\r\n    //\te.preventDefault()\r\n    //\te.stopPropagation()\r\n    //})\r\n    //_gl.onmouseup.push((e) => {\r\n    //\te.preventDefault()\r\n    //\te.stopPropagation()\r\n    //})\r\n    canvas.addEventListener('mousemove', (e) => {\r\n        const pagePos = V(e.pageX, e.pageY);\r\n        const delta = lastPos.to(pagePos);\r\n        //noinspection JSBitwiseOperatorUsage\r\n        if (e.buttons & 4) {\r\n            // pan\r\n            const moveCamera = V(-delta.x * 2 / _gl.canvas.width, delta.y * 2 / _gl.canvas.height);\r\n            const inverseProjectionMatrix = _gl.projectionMatrix.inversed();\r\n            const worldMoveCamera = inverseProjectionMatrix.transformVector(moveCamera);\r\n            eye.pos = eye.pos.plus(worldMoveCamera);\r\n            eye.focus = eye.focus.plus(worldMoveCamera);\r\n            setupCamera(eye, _gl);\r\n            paintScreen();\r\n        }\r\n        // scene rotation\r\n        //noinspection JSBitwiseOperatorUsage\r\n        if (e.buttons & 2) {\r\n            const rotateLR = -delta.x / 6.0 * DEG;\r\n            const rotateUD = -delta.y / 6.0 * DEG;\r\n            // rotate\r\n            let matrix = M4.rotateLine(eye.focus, eye.up, rotateLR);\r\n            //let horizontalRotationAxis = focus.minus(pos).cross(up)\r\n            const horizontalRotationAxis = eye.up.cross(eye.pos.minus(eye.focus));\r\n            matrix = matrix.times(M4.rotateLine(eye.focus, horizontalRotationAxis, rotateUD));\r\n            eye.pos = matrix.transformPoint(eye.pos);\r\n            eye.up = matrix.transformVector(eye.up);\r\n            setupCamera(eye, _gl);\r\n            paintScreen();\r\n        }\r\n        lastPos = pagePos;\r\n    });\r\n    canvas.addEventListener('wheel', (e) => {\r\n        // zoom\r\n        const wheelY = -sign(e.deltaY) * 2;\r\n        // console.log(e.deltaY, e.deltaX)\r\n        eye.zoomFactor *= pow(0.9, -wheelY);\r\n        const mouseCoordsOnCanvas = getPosOnTarget(e);\r\n        const mousePosFrustrum = V(mouseCoordsOnCanvas.x * 2 / _gl.canvas.offsetWidth - 1, -mouseCoordsOnCanvas.y * 2 / _gl.canvas.offsetHeight + 1, 0);\r\n        const moveCamera = mousePosFrustrum.times(1 - 1 / pow(0.9, -wheelY));\r\n        const inverseProjectionMatrix = _gl.projectionMatrix.inversed();\r\n        const worldMoveCamera = inverseProjectionMatrix.transformVector(moveCamera);\r\n        //console.log(\"moveCamera\", moveCamera)\r\n        //console.log(\"worldMoveCamera\", worldMoveCamera)\r\n        eye.pos = eye.pos.plus(worldMoveCamera);\r\n        eye.focus = eye.focus.plus(worldMoveCamera);\r\n        // tilt\r\n        const mousePosWC = inverseProjectionMatrix.transformPoint(mousePosFrustrum);\r\n        const tiltMatrix = M4.rotateLine(mousePosWC, eye.pos.to(eye.focus), -sign(e.deltaX) * 10 * DEG);\r\n        eye.up = tiltMatrix.transformVector(eye.up);\r\n        eye.pos = tiltMatrix.transformPoint(eye.pos);\r\n        eye.focus = tiltMatrix.transformPoint(eye.focus);\r\n        setupCamera(eye, _gl);\r\n        paintScreen();\r\n        e.preventDefault();\r\n    });\r\n}\r\n/**\r\n * Transforms position on the screen into a line in world coordinates.\r\n */\r\nexport function getMouseLine(pos, _gl) {\r\n    const ndc1 = V(pos.x * 2 / _gl.canvas.width - 1, -pos.y * 2 / _gl.canvas.height + 1, 0);\r\n    const ndc2 = V(pos.x * 2 / _gl.canvas.width - 1, -pos.y * 2 / _gl.canvas.height + 1, 1);\r\n    //console.log(ndc)\r\n    const inverseProjectionMatrix = _gl.projectionMatrix.inversed();\r\n    const s = inverseProjectionMatrix.transformPoint(ndc1);\r\n    const dir = inverseProjectionMatrix.transformPoint(ndc2).minus(s);\r\n    return L3.anchorDirection(s, dir);\r\n}\r\nexport function getPosOnTarget(e) {\r\n    const target = e.target;\r\n    const targetRect = target.getBoundingClientRect();\r\n    const mouseCoordsOnElement = {\r\n        x: e.clientX - targetRect.left,\r\n        y: e.clientY - targetRect.top,\r\n    };\r\n    return mouseCoordsOnElement;\r\n}\r\nexport function setupCamera(_eye, _gl, suppressEvents = false) {\r\n    const { pos, focus, up, zoomFactor } = _eye;\r\n    //console.log(\"pos\", pos.$, \"focus\", focus.$, \"up\", up.$)\r\n    _gl.matrixMode(_gl.PROJECTION);\r\n    _gl.loadIdentity();\r\n    //_gl.perspective(70, _gl.canvas.width / _gl.canvas.height, 0.1, 1000);\r\n    const lr = _gl.canvas.width / 2 / zoomFactor;\r\n    const bt = _gl.canvas.height / 2 / zoomFactor;\r\n    _gl.ortho(-lr, lr, -bt, bt, -1e4, 1e4);\r\n    _gl.lookAt(pos, focus, up);\r\n    _gl.matrixMode(_gl.MODELVIEW);\r\n    !suppressEvents && cameraChangeListeners.forEach(l => l(_eye));\r\n}\r\nexport const cameraChangeListeners = [];\r\nexport const SHADERS_TYPE_VAR = false && initShaders(0);\r\n// let shaders: typeof SHADERS_TYPE_VAR\r\n// declare let a: BRep, b: BRep, c: BRep, d: BRep, edges: Edge[] = [], hovering: any,\r\n// \t, normallines: boolean = false, b2s: BRep[] = []\r\n// const\r\n//# sourceMappingURL=BREPGLContext.js.map"],"names":["Curve","EPS","uvInAABB2","PlaneSurface","ProjectedCurveSurface","P3","EllipsoidSurface","followAlgorithm2d","breakDownPPCurves","curvePointPP","PPCurve","followAlgorithmPP","AABB2","curvePoint","curvePointMF","XiEtaCurve","L3","BezierCurve","ConicSurface","parabola4Projection","HyperbolaCurve","ParabolaCurve","EllipseCurve","ImplicitCurve","PICurve","surfaceIsICurveIsInfosWithLine","CylinderSurface","intersectionUnitHyperbolaLine","min","max","ImplicitSurface","ParametricSurface","intersectionUnitCircleLine2","intersectionUnitCircleLine","NURBS","Surface","dotCurve2","ZDirVolumeVisitor","CalculateAreaVisitor","PointVsFace","PointProjectedSurface","RotatedCurveSurface","getExtremePointsHelper","NURBSSurface","OUTSIDE","Edge","glqV3","glqArray","sign","projectCurve","projectPointCurve","rotateCurve","B2T","getGlobalId","StraightEdge","PlaneFace","Face","BRep","PCurveEdge","opentype.load","opentype.Path","CustomPlane","RotationFace","fff","INSIDE","COPLANAR_SAME","splitsVolumeEnclosingFacesP","splitsVolumeEnclosingFaces","splitsVolumeEnclosingCone2","splitsVolumeEnclosingFacesP2","triangulateVertices","addLikeSurfaceFaces","assembleFaceFromLooseEdges","calcNextEdgeIndex","CustomSet","dotCurve","COPLANAR_OPPOSITE","ALONG_EDGE_OR_PLANE","splitsVolumeEnclosingCone","intersectionCircleLine","followAlgorithm2dAdjustable","intersectionICurveICurve","intersectionICurveICurve2","cassini","MathFunctionR2R","cas2","arrayLerp","lerp","doNotSerialize","ClassSerializer","parseGetParams","COLORS","BREPGLContext","initShaders","initMeshes","CURVE_PAINTERS","shaders.vertexShaderBasic","shaders.fragmentShaderColor","shaders.vertexShaderColor","shaders.fragmentShaderVaryingColor","shaders.fragmentShaderColorHighlight","shaders.vertexShaderTexture","shaders.fragmentShaderTextureColor","shaders.vertexShaderRing","shaders.vertexShaderArc","shaders.vertexShaderConic3d","shaders.vertexShaderGeneric","shaders.vertexShaderBezier3d","shaders.vertexShaderNURBS","shaders.fragmentShaderColor3","shaders.vertexShaderBezier","shaders.vertexShaderLighting","shaders.fragmentShaderLighting","shaders.vertexShaderWaves","initNavigationEvents","setupCamera","getPosOnTarget","getMouseLine","cameraChangeListeners","SHADERS_TYPE_VAR"],"mappings":"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AAQ,CAAC,CAAC,CAAC;gBACtB,MAAM,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC;gBACtB,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClG,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC5F,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC5F,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC5F,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC5F,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MA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"}