import{load,Path}from"opentype.js";import{SVGPathData}from"svg-pathdata";import earcut from"earcut";import{Pair,JavaMap,JavaSet}from"javasetmap.ts";import nerdamer from"nerdamer";import chroma from"chroma-js";import{AABB,arrayFromFunction,assert,assertNumbers,callsce,clamp,eq,eq0,fuzzyUniquesF,getIntervals,glqInSteps,hasConstructor,le,newtonIterate1d,newtonIterate2dWithDerivatives,newtonIterateWithDerivative,NLA_PRECISION,Transformable,V,V3,assertInst,assertVectors,M4,snap0,solveCubicReal2,TAU,DEG,arrayRange,bisect,assertf,assertNever,between,combinations,fuzzyUniques,lerp,MINUS,lt,VV,newtonIterate,pqFormula,checkDerivate,fuzzyBetween,newtonIterateSmart,arraySamples,newtonIterateWithDerivative2,snap,vArrGet,Vector,floatHashCode,isCCW,gaussLegendreQuadrature24,getRoots,toSource,gaussLegendre24Weights,gaussLegendre24Xs,GOLDEN_RATIO,mod,snap2,disableConsole,doubleSignedArea,enableConsole,ge,gt,mapPush,newtonIterate2d,NLA_DEBUG,SCE,addOwnProperties}from"ts3dutils";import{pushQuad,Mesh,GL_COLOR_BLACK,Shader}from"tsgl";const{abs:abs,acos:acos,acosh:acosh,asin:asin,asinh:asinh,atan:atan,atanh:atanh,atan2:atan2,ceil:ceil,cbrt:cbrt,expm1:expm1,clz32:clz32,cos:cos,cosh:cosh,exp:exp,floor:floor,fround:fround,hypot:hypot,imul:imul,log:log,log1p:log1p,log2:log2,log10:log10,max:max,min:min,pow:pow,random:random,round:round,sign:sign,sin:sin,sinh:sinh,sqrt:sqrt,tan:tan,tanh:tanh,trunc:trunc,E:E,LN10:LN10,LN2:LN2,LOG10E:LOG10E,LOG2E:LOG2E,PI:PI,SQRT1_2:SQRT1_2,SQRT2:SQRT2}=Math;let insideIsInfosWithCurve=!1;class Curve$$1 extends Transformable{constructor(t,e){super(),this.tMin=t,this.tMax=e,assertNumbers(t,e),assert("number"==typeof t&&!isNaN(t)),assert("number"==typeof e&&!isNaN(e)),assert(t<e,"tMin < tMax "+t+" < "+e)}static integrate(t,e,s,r){const n=(s-e)/r;let i=0,o=t.at(e),a=0,c=e+n;for(;a<r;a++,c+=n){const e=t.at(c);i+=o.distanceTo(e),o=e}return i}static ispsRecursive(t,e,s,r,n,i){const o=[];return function e(s,n,i,a,c,h,u=0){const l=NLA_PRECISION;if(c.touchesAABBfuzzy(h)){const c=(s+n)/2,h=(i+a)/2;if(Math.abs(n-s)<l||Math.abs(a-i)<l)return function(e,s){if(!o.some(t=>eq(t.tThis,e)&&eq(t.tOther,s))){const n=(t,e,s,r)=>t.ddt(s).dot(t.at(s).minus(e.at(r)))+t.tangentAt(s).squared(),i=(t,e,s,r)=>-t.tangentAt(s).dot(e.tangentAt(r)),a=newtonIterate2dWithDerivatives((e,s)=>t.tangentAt(e).dot(t.at(e).minus(r.at(s))),(e,s)=>r.tangentAt(s).dot(t.at(e).minus(r.at(s))),e,s,16,n.bind(void 0,t,r),i.bind(void 0,t,r),(e,s)=>-i(r,t,s,e),(e,s)=>-n(r,t,s,e));assert(isFinite(a.x)),assert(isFinite(a.y)),void 0==a&&console.log(e,s,t.sce,r.sce),o.push({tThis:a.x,tOther:a.y,p:t.at(a.x)})}}(c,h),!0;{const o=t.getAABB(s,c),l=r.getAABB(i,h);let f,p;e(s,c,i,h,o,l,u+1)||e(s,c,h,a,o,p=r.getAABB(h,a),u+1)||e(c,n,i,h,f=t.getAABB(c,n),l,u+1)||e(c,n,h,a,f,p,u+1)}}return!1}(e,s,n,i,t.getAABB(e,s),r.getAABB(n,i)),fuzzyUniquesF(o,t=>t.tThis)}static breakDownIC(t,e,s,r,n,i){const{uMin:o,uMax:a,vMin:c,vMax:h}=e,u=h-c,l=ceil((a-o)/s),f=ceil(u/r),p=new Array(l*f).fill(0),d=(t,e)=>p[e*l+t],m=(t,e)=>0<=t&&t<l&&0<=e&&e<f&&(p[e*l+t]=1),$=[],g=[];for(let a=0;a<l;a++)t:for(let h=0;h<f;h++){if(d(a,h))continue;m(a,h);let u=o+(a+.5)*s,l=c+(h+.5)*r;const f=u,p=l;for(let e=0;e<8;e++){const e=t(u,l),s=t.x(u,l),r=t.y(u,l);if(0===Math.pow(s,2)+Math.pow(r,2))continue t;const n=e/(Math.pow(s,2)+Math.pow(r,2));u-=n*s,l-=n*r}const v=floor((u-o)/s),P=floor((l-c)/r);if(g.push({i:a,j:h,li:v,lj:P,startS:f,startT:p,u:u,v:l,"bounds(u, v)":uvInAABB2$$1(e,u,l),"ic(s,t)":t(u,l)}),(a==v&&h==P||!d(v,P))&&(m(v,P),uvInAABB2$$1(e,u,l)&&i(u,l)&&eq0(t(u,l)))){const a=mkcurves(t,u,l,n,e,i);for(const t of a){assert(t.points.length>2);for(const{x:e,y:n}of t.points){const t=(e-o)/s,i=(n-c)/r;m(t-.5|0,i-.5|0),m(t-.5|0,i+.5|0),m(t+.5|0,i-.5|0),m(t+.5|0,i+.5|0)}}$.push(...a)}}for(const{points:t}of $)for(let e=0;e<t.length-1;e++)assert(!t[e].equals(t[e+1]));return $}toString(){return this.toSource()}toSource(t=(t=>t)){return callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters(),this.tMin,this.tMax)}withBounds(t=this.tMin,e=this.tMax){return new this.constructor(...this.getConstructorParameters(),t,e)}closestPointToPoint(t){return this.at(this.closestTToPoint(t))}isValidT(t){return le(this.tMin,t)&&le(t,this.tMax)}diff(t,e){return this.at(t).to(this.at(t+e))}closestTToPoint(t,e,s=this.tMin,r=this.tMax){return void 0===e&&(e=arrayFromFunction(32,t=>s+(r-s)*t/31).withMax(e=>-this.at(e).distanceTo(t))),newtonIterateWithDerivative(e=>this.at(e).minus(t).dot(this.tangentAt(e)),e,16,e=>this.tangentAt(e).squared()+this.at(e).minus(t).dot(this.ddt(e)))}calcSegmentPoints(t,e,s,r,n,i){assert(this.tIncrement,"tIncrement not defined on "+this);const o=this.tIncrement,a=[];if(i&&a.push(s),assert(n!=t<e),t<e){const s=Math.ceil((t+NLA_PRECISION)/o),r=Math.floor((e-NLA_PRECISION)/o);for(let t=s;t<=r;t++)a.push(this.at(t*o))}else{const s=Math.floor((t-NLA_PRECISION)/o),r=Math.ceil((e+NLA_PRECISION)/o);for(let t=s;t>=r;t--)a.push(this.at(t*o))}return a.push(r),a}calcSegmentTs(t,e,s,r){assert(this.tIncrement,"tIncrement not defined on "+this);const n=this.tIncrement,i=[];if(r&&i.push(t),assert(s!=t<e),t<e){const s=Math.ceil((t+NLA_PRECISION)/n),r=Math.floor((e-NLA_PRECISION)/n);for(let t=s;t<=r;t++)i.push(t*n)}else{const s=Math.floor((t-NLA_PRECISION)/n),r=Math.ceil((e+NLA_PRECISION)/n);for(let t=s;t>=r;t--)i.push(t*n)}return i.push(e),i}distanceToPoint(t,e,s){const r=this.closestTToPoint(t,e,s);return this.at(r).distanceTo(t)}asSegmentDistanceToPoint(t,e,s){let r=this.closestTToPoint(t,e,s);return r=clamp(r,e,s),this.at(r).distanceTo(t)}isInfosWithCurve(t){if(insideIsInfosWithCurve)return Curve$$1.ispsRecursive(this,this.tMin,this.tMax,t,t.tMin,t.tMax);try{return insideIsInfosWithCurve=!0,t.isInfosWithCurve(this).map(t=>{assert(t);const{tThis:e,tOther:s,p:r}=t;return{tOther:e,tThis:s,p:r}})}finally{insideIsInfosWithCurve=!1}}isTsWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isTsWithPlane(t.plane);if(t instanceof ProjectedCurveSurface$$1){const e=new P3$$1(t.dir.unit(),0),s=this.project(e);return t.baseCurve.project(e).isInfosWithCurve(s).map(t=>t.tOther)}if(t instanceof EllipsoidSurface$$1){const e=this.transform(t.matrixInverse);if(!e.getAABB().touchesAABBfuzzy(new AABB(V3.XYZ.negated(),V3.XYZ)))return[];const s=t=>e.at(t).length()-1,r=t=>e.at(t).unit().dot(e.tangentAt(t)),n=1/2048,i=[];for(let t=this.tMin;t<=this.tMax;t+=n){const o=n*e.tangentAt(t).length();if(abs(s(t))<=o){let e=newtonIterateWithDerivative(s,t,16,r);eq0(s(e))&&!eq0(r(e))||(e=newtonIterate1d(r,t,16)),eq0(s(e))&&!i.some(t=>eq(t,e))&&i.push(e)}}return i.filter(e=>t.containsPoint(this.at(e)))}throw new Error}arcLength(t,e,s=1){return assert(t<e,"startT < endT"),glqInSteps(t=>this.tangentAt(t).length(),t,e,s)}equals(t){return this===t||hasConstructor(t,this.constructor)&&this.getConstructorParameters().equals(t.getConstructorParameters())}hashCode(){return this.getConstructorParameters().hashCode()}getAABB(t=this.tMin,e=this.tMax){t=isFinite(t)?t:this.tMin,e=isFinite(e)?e:this.tMax;const s=this.at(t),r=this.at(e),n=this.roots(),i=new Array(3),o=new Array(3);for(let a=0;a<3;a++){const c=n[a];i[a]=Math.min(s.e(a),r.e(a)),o[a]=Math.max(s.e(a),r.e(a));for(const s of c)t<s&&s<e&&(i[a]=Math.min(i[a],this.at(s).e(a)),o[a]=Math.max(o[a],this.at(s).e(a)))}return new AABB(V3.fromArray(i),V3.fromArray(o))}reversed(){throw new Error}clipPlane(t){const e=this.isTsWithPlane(t).filter(t=>this.tMin<=t&&t<=this.tMax);return getIntervals(e,this.tMin,this.tMax).mapFilter(([e,s])=>{const r=(e+s)/2;return!eq(e,s)&&t.distanceToPointSigned(this.at(r))<0&&this.withBounds(e,s)})}}function mkcurves(t,e,s,r,n,i){const o=V(e,s);assert(r>0);const{points:a,tangents:c}=followAlgorithm2d$$1(t,o,r,n,i);if(a.length>4&&a[0].distanceTo(a.last)<=abs(r)){for(let t=0;t<a.length-1;t++)assert(!a[t].equals(a[t+1]));const t=floor(a.length/2),e=a.slice(0,t),s=a.slice(t-1,a.length),r=c.slice(0,t),n=c.slice(t-1,c.length);for(let t=0;t<e.length-1;t++)assert(!e[t].equals(e[t+1]));for(let t=0;t<s.length-1;t++)assert(!s[t].equals(s[t+1]));return[{points:e,tangents:r},{points:s,tangents:n}]}{const{points:e,tangents:s}=followAlgorithm2d$$1(t,o,-r,n,i),a=followAlgorithm2d$$1(t,e.last,r,n,i,void 0,s.last.negated());return assert(a.points.length>2),[a]}}function breakDownPPCurves$$1(t,e,s,r,n){const{uMin:i,uMax:o,vMin:a,vMax:c}=t,h=uvInAABB2$$1.bind(void 0,t),u=uvInAABB2$$1.bind(void 0,e),l=c-a,f=ceil((o-i)/s),p=ceil(l/r),d=new Array(f*p).fill(0),m=(t,e)=>d[e*f+t],$=(t,e)=>0<=t&&t<f&&0<=e&&e<p&&(d[e*f+t]=1),g=[],v=[];for(let o=0;o<f;o++)t:for(let c=0;c<p;c++){if(m(o,c))continue;$(o,c);const l=i+(o+.5)*s,f=a+(c+.5)*r,p=curvePointPP$$1(t,e,t.pUV(l,f));if(void 0===p)continue t;const{p:d,st1:{x:P,y:C},st2:{x:x,y:M}}=p,w=floor((P-i)/s),S=floor((C-a)/r);if(v.push({i:o,j:c,li:w,lj:S,startU:l,startV:f,u:P,v:C,"bounds(u, v)":h(P,C)}),(o==w&&c==S||!m(w,S))&&($(w,S),h(P,C)&&u(x,M))){console.log(V(P,C).sce);const o=mkPPCurves(t,e,d,n,h,u);for(const t of o){assert(t.st1s.length>2);for(const{x:e,y:n}of t.st1s){const t=(e-i)/s,o=(n-a)/r;$(t-.5|0,o-.5|0),$(t-.5|0,o+.5|0),$(t+.5|0,o-.5|0),$(t+.5|0,o+.5|0)}}g.push(...o)}}console.table(v);for(const{points:t}of g)for(let e=0;e<t.length-1;e++)assert(!t[e].equals(t[e+1]));return g.map(({points:s,tangents:r,st1s:i})=>new PPCurve$$1(s,r,t,e,i,void 0,n,1))}function mkPPCurves(t,e,s,r,n,i){const{points:o,tangents:a,st1s:c}=followAlgorithmPP$$1(t,e,s,r,n,i);if(o[0].distanceTo(o.last)<r&&o.length>2){for(let t=0;t<o.length-1;t++)assert(!o[t].equals(o[t+1]));const t=floor(o.length/2),e=o.slice(0,t),s=o.slice(t-1,o.length),r=a.slice(0,t),n=a.slice(t-1,a.length),i=c.slice(0,t),h=c.slice(t-1,a.length);n[n.length-1]=r[0],s[n.length-1]=e[0],h[n.length-1]=i[0];for(let t=0;t<e.length-1;t++)assert(!e[t].equals(e[t+1]));for(let t=0;t<s.length-1;t++)assert(!s[t].equals(s[t+1]));return[{points:e,tangents:r,st1s:i},{points:s,tangents:n,st1s:h}]}{const{points:o}=followAlgorithmPP$$1(t,e,s,-r,n,i),a=followAlgorithmPP$$1(t,e,o.last,r,n,i);return assert(a.points.length>2),[a]}}function AABB2$$1(t,e,s,r){return{uMin:t,uMax:e,vMin:s,vMax:r}}function uvInAABB2$$1(t,e,s){return t.uMin<=e&&e<=t.uMax&&t.vMin<=s&&s<=t.vMax}function curvePoint$$1(t,e,s,r){let n=e;for(let e=0;e<8;e++){const e=t(n.x,n.y),i=s(n.x,n.y),o=r(n.x,n.y),a=e/(i*i+o*o);n=n.minus(new V3(a*i,a*o,0))}return n}function curvePointMF$$1(t,e,s=8,r=1/(1<<30)){let n=e;for(let e=0;e<s;e++){const e=t(n.x,n.y),s=t.x(n.x,n.y),i=t.y(n.x,n.y),o=e/(s*s+i*i);if(n=n.minus(new V3(o*s,o*i,0)),abs(e)<=r)break}return n}Curve$$1.hlol=0;class XiEtaCurve$$1 extends Curve$$1{constructor(t,e,s,r,n){if(super(r,n),this.center=t,this.f1=e,this.f2=s,this.tMin=r,this.tMax=n,assertVectors(t,e,s),this.normal=e.cross(s),this.normal.likeO()){this.matrix=M4.forSys(e,s,e.unit(),t);const r=e.getPerpendicular();this.matrixInverse=new M4(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1).times(M4.forSys(e,r,e.cross(r),t).inversed())}else this.normal=this.normal.unit(),this.matrix=M4.forSys(e,s,this.normal,t),this.matrixInverse=this.matrix.inversed()}static intersectionUnitLine(t,e,s,r,n){throw new Error("abstract")}static forAB(t,e,s=V3.O){return new this(s,V(t,0,0),V(0,e,0))}static XYLCValid(t){throw new Error("abstract")}static XYLCPointT(t,e,s){throw new Error("abstract")}static unitIsInfosWithLine(t,e,s,r,n,i){throw new Error("abstract")}addToMesh(t,e=4,s=0,r=1){const n=arrayFromFunction(e,t=>V3.polar(1,TAU*t/e)),i=arrayFromFunction(e,t=>V3.polar(s,TAU*t/e)),o=this.tIncrement,a=Math.ceil((this.tMin+NLA_PRECISION)/o),c=Math.floor((this.tMax-NLA_PRECISION)/o);for(let s=a;s<=c;s+=r){const r=s*o,a=t.vertices.length;if(0!==s)for(let s=0;s<e;s++)pushQuad(t.TRIANGLES,!0,a-e+s,a+s,a-e+(s+1)%e,a+(s+1)%e);const c=this.at(r),h=this.tangentAt(r),u=M4.forSys(this.normal,h.cross(this.normal),h,c);t.normals.push(...u.transformedVectors(n)),t.vertices.push(...u.transformedPoints(i))}}getConstructorParameters(){return[this.center,this.f1,this.f2]}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1,this.tMin,this.tMax,t.tMin,t.tMax):t instanceof BezierCurve$$1?this.isInfosWithBezier(t):t instanceof XiEtaCurve$$1&&!this.normal.isParallelTo(t.normal)?this.isTsWithPlane(t.getPlane()).mapFilter(e=>{const s=this.at(e);if(t.containsPoint(s))return{tThis:e,tOther:t.pointT(s),p:s}}):super.isInfosWithCurve(t)}transform(t){return new this.constructor(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),this.tMin,this.tMax)}equals(t){return this==t||void 0!=t&&this.constructor==t.constructor&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.center.hashCode())+this.f1.hashCode())+this.f2.hashCode())}likeCurve(t){return hasConstructor(t,this.constructor)&&this.center.like(t.center)&&this.f1.like(t.f1)&&this.f2.like(t.f2)}normalP(t){return this.tangentAt(t).cross(this.normal)}getPlane(){return P3$$1.normalOnAnchor(this.normal,this.center)}isTsWithPlane(t){if(assertInst(P3$$1,t),t.normal1.isParallelTo(this.normal))return[];const e=t.normal1,s=t.w,r=this.center,n=this.f1,i=this.f2,o=e.dot(n),a=e.dot(i),c=s-e.dot(r);return this.constructor.intersectionUnitLine(o,a,c,this.tMin,this.tMax)}pointT(t){assertVectors(t);const e=this.matrixInverse.transformPoint(t);return this.constructor.XYLCPointT(e)}containsPoint(t){const e=this.matrixInverse.transformPoint(t);return eq0(e.z)&&this.isValidT(this.constructor.XYLCPointT(e,this.tMin,this.tMax))}isInfosWithLine(t,e,s=this.tMin,r=this.tMax,n=-1e5,i=1e5){const o=this.matrixInverse.transformPoint(t),a=this.matrixInverse.transformVector(e);if(eq0(a.z)){if(eq0(o.z))return this.constructor.unitIsInfosWithLine(o,a,t,e,s,r)}else{const s=o.z/a.z,r=a.times(s).plus(o);if(this.constructor.XYLCValid(r))return[{tThis:this.constructor.XYLCPointT(r),tOther:s,p:t.plus(e.times(s))}]}return[]}isTsWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isTsWithPlane(t.plane);if(t instanceof EllipsoidSurface$$1){return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).filter(e=>t.containsPoint(e.p)).map(t=>t.tThis)}if(t instanceof ProjectedCurveSurface$$1||t instanceof ConicSurface$$1)return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).map(t=>t.tThis);throw new Error}isInfosWithBezier(t){const e=t.transform(this.matrixInverse);if(new PlaneSurface$$1(P3$$1.XY).containsCurve(e))return this.isInfosWithBezier2D(t);return e.isTsWithPlane(P3$$1.XY).mapFilter(s=>{const r=e.at(s);if(this.constructor.XYLCValid(r))return{tOther:s,p:t.at(s),tThis:this.constructor.XYLCPointT(r)}})}isInfosWithBezier2D(t,e=t.tMin,s=t.tMax){return Curve$$1.ispsRecursive(this,this.tMin,this.tMax,t,e,s)}isOrthogonal(){return this.f1.isPerpendicularTo(this.f2)}at2(t,e){return assertNumbers(t,e),this.center.plus(this.f1.times(t)).plus(this.f2.times(e))}debugInfo(){return{points:[this.center,this.at2(.5,0),this.at2(0,1/3),this.at2(0,2/3)],lines:[this.center,this.at2(0,1),this.center,this.at2(1,0)]}}}function parabola4Projection$$1(t,e,s){return HyperbolaCurve$$1.XY.rotateZ(45*DEG)}class ImplicitCurve$$1 extends Curve$$1{constructor(t,e,s=1,r,n=(1==s?0:-(t.length-1)),i=(1==s?t.length-1:0)){super(n,i),this.points=t,this.tangents=e,this.dir=s,this.generator=r,assert(t.length>2),assert(0<=n&&n<=t.length-1,n,t.length),assert(0<=i&&i<=t.length-1,i,t.length)}likeCurve(t){throw new Error("Method not implemented.")}toSource(t=(t=>t)){return this.generator||super.toSource(t)}containsPoint(t){return assertVectors(t),!isNaN(this.pointT(t))}equals(t){return this==t||Object.getPrototypeOf(t)==PICurve$$1.prototype&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])}hashCode(){return[this.points[0],this.tangents[0]].hashCode()}tangentP(t){assertVectors(t),assert(this.containsPoint(t),"this.containsPoint(pWC)"+this.containsPoint(t));const e=this.pointT(t);return this.tangentAt(e)}tangentAt(t){return t=clamp(t,this.tMin,this.tMax),V3.lerp(this.tangents[floor(t)],this.tangents[ceil(t)],t%1)}at(t){return assert(isFinite(t)),V3.lerp(this.points[floor(t)],this.points[ceil(t)],t%1)}getConstructorParameters(){throw new Error}roots(){const t=arrayRange(0,this.points.length);return[t,t,t]}addToMesh(t,e=4,s=0,r=1){const n=arrayFromFunction(e,t=>V3.polar(1,TAU*t/e)),i=arrayFromFunction(e,t=>V3.polar(s,TAU*t/e));let o=V3.Z,a=M4.IDENTITY;for(let s=0;s<this.points.length;s+=r){const r=t.vertices.length;if(0!==s)for(let s=0;s<e;s++)pushQuad(t.TRIANGLES,!0,r-e+s,r+s,r-e+(s+1)%e,r+(s+1)%e);const c=this.points[s],h=this.tangents[s],u=M4.rotateAB(o,h).times(a);t.normals.push(...u.transformedVectors(n));const l=M4.translate(c).times(u);t.vertices.push(...l.transformedPoints(i)),o=h,a=u}}rootsApprox(){const t=[[],[],[]],e=this.points;let s=e[1].minus(e[0]);for(let r=2;r<e.length;r++){const n=e[r].minus(e[r-1]);for(let e=0;e<3;e++)Math.sign(s.e(e))!=Math.sign(n.e(e))&&t[e].push(r);s=n}return t}pointT(t){const e=arrayRange(floor(this.tMin),ceil(this.tMax),1).withMax(e=>-t.distanceTo(this.points[e]));if(void 0===e)throw new Error;if(this.points[e].like(t))return e;const s=max(0,e-1),r=min(this.points.length-1,e+1),n=this.tangentAt(e),i=bisect(e=>this.at(e).to(t).dot(n),s,r,32);return isFinite(i)&&eq0(this.at(i).distanceTo(t))?i:NaN}}function surfaceIsICurveIsInfosWithLine$$1(t,e,s,r,n,i,o,a){const c=new L3$$1(s,r.unit()),h=t.isTsForLine(c),u=e.isTsForLine(c);h.filter(t=>u.some(e=>eq(t,e))).map(t=>({tThis:0,tOther:t/r.length(),p:c.at(t)})).filter(t=>this.containsPoint(t.p)).forEach(t=>t.tThis=this.pointT(t.p))}ImplicitCurve$$1.prototype.tIncrement=1;class BezierCurve$$1 extends Curve$$1{constructor(t,e,s,r,n=-.1,i=1.1){super(n,i),assertVectors(t,e,s,r),assert(isFinite(n)&&isFinite(i)),this.p0=t,this.p1=e,this.p2=s,this.p3=r}get points(){return[this.p0,this.p1,this.p2,this.p3]}static graphXY(t,e,s,r,n,i){const o=s/3+r,a=e/3-r+2*o,c=t+r-3*o+3*a;return new BezierCurve$$1(V(0,r),V(1/3,o),V(2/3,a),V(1,c),n,i)}static quadratic(t,e,s,r=0,n=1){const i=L3$$1.throughPoints(t,s);return i.containsPoint(e)?i:new BezierCurve$$1(t,e.times(2).plus(t).div(3),e.times(2).plus(s).div(3),s,r,n)}static approximateUnitArc(t){const e=4/3*Math.tan(t/4);return new BezierCurve$$1(V3.X,new V3(1,e,0),new V3(cos(t)+e*sin(t),sin(t)-e*cos(t),0),V3.sphere(t,0),0,1)}getConstructorParameters(){return[this.p0,this.p1,this.p2,this.p3]}at(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=1-t,o=i*i*i,a=3*i*i*t,c=3*i*t*t,h=t*t*t;return new V3(e.x*o+s.x*a+r.x*c+n.x*h,e.y*o+s.y*a+r.y*c+n.y*h,e.z*o+s.z*a+r.z*c+n.z*h)}tangentAt(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=1-t,o=3*i*i,a=6*i*t,c=3*t*t;return new V3((s.x-e.x)*o+(r.x-s.x)*a+(n.x-r.x)*c,(s.y-e.y)*o+(r.y-s.y)*a+(n.y-r.y)*c,(s.z-e.z)*o+(r.z-s.z)*a+(n.z-r.z)*c)}ddt(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=6*(1-t),o=6*t;return new V3((r.x-2*s.x+e.x)*i+(n.x-2*r.x+s.x)*o,(r.y-2*s.y+e.y)*i+(n.y-2*r.y+s.y)*o,(r.z-2*s.z+e.z)*i+(n.z-2*r.z+s.z)*o)}normalP(t){const e=this.tangentAt(t);return e.cross(this.ddt(t)).cross(e)}isTsWithPlane(t){assertInst(P3$$1,t);const{p0:e,p1:s,p2:r,p3:n}=this,i=t.normal1,o=s.minus(r).times(3).minus(e).plus(n),a=e.plus(r).times(3).minus(s.times(6)),c=s.minus(e).times(3),h=e;return solveCubicReal2(o.dot(i),a.dot(i),c.dot(i),h.dot(i)-t.w).filter(t=>between(t,this.tMin,this.tMax))}isTsWithSurface(t){if(t instanceof CylinderSurface$$1){const e=new P3$$1(t.dir.unit(),0),s=this.project(e);return t.baseCurve.project(e).isInfosWithBezier2D(s).map(t=>t.tOther)}return super.isTsWithSurface(t)}likeCurve(t){return this==t||hasConstructor(t,BezierCurve$$1)&&this.p0.like(t.p0)&&this.p1.like(t.p1)&&this.p2.like(t.p2)&&this.p3.like(t.p3)}equals(t){return this==t||hasConstructor(t,BezierCurve$$1)&&this.p0.equals(t.p0)&&this.p1.equals(t.p1)&&this.p2.equals(t.p2)&&this.p3.equals(t.p3)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.p0.hashCode())+this.p1.hashCode())+this.p2.hashCode())+this.p3.hashCode())}isColinearTo(t){if(this===t||this.likeCurve(t))return!0;if(!(t instanceof BezierCurve$$1))return!1;let e,s,r;if(isNaN(e=this.pointT(t.p0))||isNaN(s=this.pointT(t.p3)))return!1;if(eq(1,e))r=this.split(s)[1].reversed();else{const t=(s-e)/(1-e);r=this.split(e)[1].split(t)[0]}return t.likeCurve(r)}selectPart(t,e){const s=(e-t)/(1-t);return this.split(t)[1].split(s)[0]}reversed(){return new BezierCurve$$1(this.p3,this.p2,this.p1,this.p0,1-this.tMax,1-this.tMin)}getCoefficients(){const{p0:t,p1:e,p2:s,p3:r}=this;return[e.minus(s).times(3).minus(t).plus(r),t.plus(s).times(3).minus(e.times(6)),e.minus(t).times(3),t]}tangentCoefficients(){const{p0:t,p1:e,p2:s,p3:r}=this,n=e.minus(t),i=s.minus(e),o=r.minus(s),a=n.plus(o).times(3).minus(i.times(6)),c=i.minus(n).times(6),h=n.times(3);return[V3.O,a,c,h]}pointT2(t,e=this.tMin,s=this.tMax){const r=this.closestTToPoint(t,void 0,e,s);return assert(this.at(r).like(t)),r}pointT(t){const{p0:e,p1:s,p2:r,p3:n}=this,i=s.minus(r).times(3).minus(e).plus(n),o=e.plus(r).times(3).minus(s.times(6)),a=s.minus(e).times(3),c=e.minus(t),h=NLA_PRECISION<i.maxAbsElement()?i.maxAbsDim():NLA_PRECISION<o.maxAbsElement()?o.maxAbsDim():NLA_PRECISION<a.maxAbsElement()?a.maxAbsDim():assertNever(),u=solveCubicReal2(i.e(h),o.e(h),a.e(h),c.e(h)).filter(e=>this.at(e).like(t));if(0==u.length)return NaN;if(1==u.length)return u[0];throw new Error("multiple intersection "+this.toString()+t.sce)}pointT3(t){const{p0:e,p1:s,p2:r,p3:n}=this,i=s.minus(r).times(3).minus(e).plus(n).els(),o=e.plus(r).times(3).minus(s.times(6)).els(),a=s.minus(e).times(3).els(),c=e.minus(t).els();let h=void 0;for(let t=0;t<3;t++)if(eq0(i[t])&&eq0(o[t])&&eq0(a[t])){if(!eq0(c[t]))return NaN}else{const e=solveCubicReal2(i[t],o[t],a[t],c[t]);if(0==e.length)return NaN;if(1==e.length)return e[0];if(h){if(0==(h=h.filter(t=>e.some(e=>eq(t,e)))).length)return NaN;if(1==h.length)return h[0]}else h=e}throw new Error("multiple intersection "+h+this.toString()+t.sce)}transform(t){return assert(t.isNoProj(),t.str),new BezierCurve$$1(t.transformPoint(this.p0),t.transformPoint(this.p1),t.transformPoint(this.p2),t.transformPoint(this.p3),this.tMin,this.tMax)}isClosed(){return this.p0.like(this.p3)}isQuadratic(){return this.p0.lerp(this.p1,1.5).like(this.p3.lerp(this.p2,1.5))}debugInfo(){return{lines:[0,1,1,2,2,3].map(t=>this.points[t]),points:this.points}}split(t){const e=1-t,{p0:s,p1:r,p2:n,p3:i}=this,o=s.times(e).plus(r.times(t)),a=r.times(e).plus(n.times(t)),c=n.times(e).plus(i.times(t)),h=o.times(e).plus(a.times(t)),u=a.times(e).plus(c.times(t)),l=h.times(e).plus(u.times(t));return[new BezierCurve$$1(s,o,h,l),new BezierCurve$$1(l,u,c,i)]}containsPoint(t){return isFinite(this.pointT(t))}roots(){const{p0:t,p1:e,p2:s,p3:r}=this,n=e.minus(t),i=s.minus(e),o=r.minus(s),a=n.plus(o).times(3).minus(i.times(6)),c=i.minus(n).times(6),h=n.times(3);return arrayFromFunction(3,t=>solveCubicReal2(0,a.e(t),c.e(t),h.e(t)))}isInfosWithLine(t,e,s,r,n=-1e5,i=1e5){const{p0:o,p1:a,p2:c,p3:h}=this,u=a.minus(c).times(3).minus(o).plus(h),l=V3.UNITS[u.minAbsDim()],f=P3$$1.forAnchorAndPlaneVectors(t,e,l.isParallelTo(e)?u:l);return this.isTsWithPlane(f).map(s=>{const r=this.at(s);return{tThis:s,tOther:L3$$1.pointT(t,e,r),p:r}}).filter(s=>L3$$1.containsPoint(t,e,s.p))}closestPointToLine(t,e,s){e=isFinite(e)?e:this.tMin,s=isFinite(s)?s:this.tMax;const r=t.anchor.dot(t.dir1),n=e=>{const s=this.at(e);return s.minus(t.at(s.dot(t.dir1)-r)).dot(this.tangentAt(e))},i=arrayFromFunction(32,t=>e+(s-e)*t/32).withMax(t=>-n(t));return newtonIterate1d(n,i,8)}isInfosWithBezier3(t,e,s,r,n){const i=(e,s)=>{if(!a.some(t=>eq(t.tThis,e)&&eq(t.tOther,s))){const r=(t,e,s,r)=>t.ddt(s).dot(t.at(s).minus(e.at(r)))+t.tangentAt(s).squared(),n=(t,e,s,r)=>-t.tangentAt(s).dot(e.tangentAt(r)),i=newtonIterate2dWithDerivatives((e,s)=>this.tangentAt(e).dot(this.at(e).minus(t.at(s))),(e,s)=>t.tangentAt(s).dot(this.at(e).minus(t.at(s))),e,s,16,r.bind(void 0,this,t),n.bind(void 0,this,t),(e,s)=>-n(t,this,s,e),(e,s)=>-r(t,this,s,e));a.push({tThis:i.x,tOther:i.y,p:this.at(i.x)})}},o=[e=void 0!==e?e:this.tMin,s=void 0!==s?s:this.tMax,r=void 0!==r?r:t.tMin,n=void 0!==n?n:t.tMax],a=[];for(;o.length;){const e=o.length-4,s=o[e],r=o[e+1],n=o[e+2],a=o[e+3];o.length-=4;const c=this.getAABB(s,r),h=t.getAABB(n,a);if(c&&h&&c.intersectsAABB2d(h)){const t=(s+r)/2,e=(n+a)/2,u=1e-5;r-s<u||a-n<u?(console.log(s,r,n,a),console.log(c.sce),console.log(h.sce),console.log(t,e),i(t,e)):o.push(s,t,n,e,s,t,e,a,t,r,n,e,t,r,e,a)}}return a}isInfosWithBezier(t,e,s,r,n){e=void 0!==e?e:this.tMin,s=void 0!==s?s:this.tMax,r=void 0!==r?r:t.tMin,n=void 0!==n?n:t.tMax,assertf(()=>e<s),assertf(()=>r<n);const i=[],o=this.likeCurve(t),a=this.isColinearTo(t);if(!o&&!a)return Curve$$1.ispsRecursive(this,e,s,t,r,n);{o||(r=this.pointT(t.at(r)),n=this.pointT(t.at(n))),e=Math.min(e,r),s=Math.max(s,n);const a=fuzzyUniques(this.roots().concatenated().filter(isFinite).concat([e,s])).sort(MINUS);Array.from(combinations(a.length-1)).forEach(({i:e,j:s})=>{Math.abs(e-s)>2&&i.push(...Curve$$1.ispsRecursive(this,a[e],a[e+1],t,a[s],a[s+1]))})}return i}selfIntersectionsInfo(){return this.isInfosWithBezier(this)}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1,t.tMin,t.tMax):t instanceof BezierCurve$$1?this.isInfosWithBezier(t):t.isInfosWithCurve(this).map(({tThis:t,tOther:e,p:s})=>({tThis:e,tOther:t,p:s}))}circleApprox(t=this.tMin,e=this.tMax,s=1/1024,r=[]){const n=this.at(t),i=this.at(e),o=(t+e)/2,a=this.at(o),c=L3$$1.throughPoints(n,i);if(!c.containsPoint(a)&&between(c.pointT(a),0,c.pointT(i))){const o=EllipseCurve$$1.circleThroughPoints(n,a,i),c=o.f1.length(),h=this.at(lerp(t,e,.25)),u=this.at(lerp(t,e,.75));if(abs(o.center.distanceTo(h)/c-1)<=s&&abs(o.center.distanceTo(u)/c-1)<=s)return r.push(o),r}return this.circleApprox(t,o,s,r),this.circleApprox(o,e,s,r),r}}BezierCurve$$1.EX2D=BezierCurve$$1.graphXY(2,-3,-3,2),BezierCurve$$1.EX3D=new BezierCurve$$1(V3.O,V(-.1,-1,1),V(1.1,1,1),V3.X),BezierCurve$$1.QUARTER_CIRCLE=BezierCurve$$1.approximateUnitArc(PI/2),BezierCurve$$1.prototype.hlol=Curve$$1.hlol++,BezierCurve$$1.prototype.tIncrement=1/80;class HyperbolaCurve$$1 extends XiEtaCurve$$1{constructor(t,e,s,r=-7,n=7){super(t,e,s,r,n)}static XYLCValid(t){return t.x>0&&eq(1,t.x*t.x-t.y*t.y)}static XYLCPointT(t){return Math.asinh(t.y)}static intersectionUnitLine(t,e,s){if(eq0(e)){const e=snap0(Math.pow(s,2)/Math.pow(t,2)-1);if(e<0||s*t<0)return[];if(0==e)return[0];const r=Math.sqrt(e);return[-Math.asinh(r),Math.asinh(r)]}if(eq(abs(t),abs(e))){if(le(s*t,0))return[];const r=sign(t*e)*(Math.pow(s,2)-Math.pow(t,2))/2/t/s;return[Math.asinh(r)]}{const r=snap0(Math.pow(e,2)*(-Math.pow(t,2)+Math.pow(e,2)+Math.pow(s,2)));if(r<0)return[];const n=(t*s-Math.sqrt(r))/(Math.pow(t,2)-Math.pow(e,2)),i=(t*s+Math.sqrt(r))/(Math.pow(t,2)-Math.pow(e,2)),o=(Math.pow(e,2)*s-t*Math.sqrt(r))/(e*(Math.pow(e,2)-Math.pow(t,2))),a=(Math.pow(e,2)*s+t*Math.sqrt(r))/(e*(Math.pow(e,2)-Math.pow(t,2)));return[n>0&&Math.asinh(o),i>0&&Math.asinh(a)].filter(t=>!1!==t)}}at(t){return assertNumbers(t),this.center.plus(this.f1.times(Math.cosh(t))).plus(this.f2.times(Math.sinh(t)))}toString(){return`${this.center} + ${this.f1} * cosh(t) + ${this.f2} * sinh(t)`}tangentAt(t){return assertNumbers(t),this.f1.times(Math.sinh(t)).plus(this.f2.times(Math.cosh(t)))}tangentAt2(t,e){return assertNumbers(t,e),this.f1.times(e).plus(this.f2.times(t))}ddt(t){return assertNumbers(t),this.f1.times(Math.cosh(t)).plus(this.f2.times(Math.sinh(t)))}isColinearTo(t){if(!hasConstructor(t,HyperbolaCurve$$1))return!1;if(!t.center||!this.center.like(t.center))return!1;if(this===t)return!0;const{f1:e,f2:s}=this.rightAngled(),{f1:r,f2:n}=t.rightAngled();return eq(e.squared(),Math.abs(e.dot(r)))&&eq(s.squared(),Math.abs(s.dot(n)))}reversed(){return new HyperbolaCurve$$1(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e),r=e.squared()+t.squared();if(eq0(s))return this;const n=2*s,i=r+Math.sqrt(r*r-4*s*s),{x1:o,y1:a}=intersectionUnitHyperbolaLine$$1(n,i,0);return new HyperbolaCurve$$1(this.center,t.times(o).plus(e.times(a)),t.times(a).plus(e.times(o)))}eccentricity(){const t=this.rightAngled(),e=t.f1.length(),s=t.f1.length(),[r,n]=e>s?[e,s]:[s,e];return Math.sqrt(1+n*n/r/r)}roots(){return arrayFromFunction(3,t=>{const e=this.f2.e(t),s=this.f1.e(t);return HyperbolaCurve$$1.intersectionUnitLine(e,s,0)})}transform4(t){const e=t=>sign(t)*min(10,sqrt(-(1-cosh(t))/(1+cosh(t)))),s=new M4(0,1,0,1,2,0,0,0,0,0,1,0,0,-1,0,1);return parabola4Projection$$1(M4.product(t,this.matrix,s),e(this.tMin),e(this.tMax))}}HyperbolaCurve$$1.XY=new HyperbolaCurve$$1(V3.O,V3.X,V3.Y),HyperbolaCurve$$1.prototype.tIncrement=PI/16;class L3$$1 extends Curve$$1{constructor(t,e,s=-4096,r=4096){super(s,r),this.anchor=t,this.dir1=e,assertVectors(t,e),assert(e.hasLength(1),"dir must be unit"+e),assertf(()=>!Number.isNaN(t.x))}isTsWithSurface(t){return t.isTsForLine(this)}static throughPoints(t,e,s=0,r){const n=e.minus(t);return new L3$$1(t,n.unit(),s,void 0!==r?r:n.length())}static anchorDirection(t,e,s=0,r=e.length()){const n=e.unit();return new L3$$1(t,n,"number"==typeof s?s:s.minus(t).dot(n),"number"==typeof r?r:r.minus(t).dot(n))}static pointT(t,e,s){return assertVectors(t,e,s),s.minus(t).dot(e)/e.squared()}static at(t,e,s){return t.plus(e.times(s))}static fromPlanes(t,e){if(assertInst(P3$$1,t,e),t.normal1.cross(e.normal1).length()<1e-10)throw new Error("Parallel planes");return t.intersectionWithPlane(e)}static containsPoint(t,e,s){const r=L3$$1.pointT(t,e,s),n=L3$$1.at(t,e,r).distanceTo(s);return eq0(n)}roots(){return[[],[],[]]}containsPoint(t){assertVectors(t);const e=this.distanceToPoint(t);return assertNumbers(e),eq0(e)}likeCurve(t){return this==t||hasConstructor(t,L3$$1)&&this.anchor.like(t.anchor)&&this.dir1.like(t.dir1)}equals(t){return this==t||Object.getPrototypeOf(t)==L3$$1.prototype&&this.anchor.equals(t.anchor)&&this.dir1.equals(t.dir1)}isColinearTo(t){return t instanceof L3$$1&&this.containsPoint(t.anchor)&&eq(1,Math.abs(this.dir1.dot(t.dir1)))}distanceToLine(t){if(assertInst(L3$$1,t),this.isParallelToLine(t))return this.distanceToPoint(t.anchor);const e=this.dir1.cross(t.dir1).unit(),s=this.anchor.minus(t.anchor);return Math.abs(s.dot(e))}distanceToPoint(t){assertVectors(t);const e=t.minus(this.anchor).dot(this.dir1);return this.at(e).distanceTo(t)}asSegmentDistanceToPoint(t,e,s){let r=t.minus(this.anchor).dot(this.dir1);return r=clamp(r,e,s),this.at(r).minus(t).length()}asSegmentDistanceToLine(t,e,s){assertInst(L3$$1,t);const r=this.dir1.cross(t.dir1),n=r.squared();if(eq0(n))return;const i=t.anchor.minus(this.anchor);if(!eq0(i.dot(r.unit())))return;let o=this.infoClosestToLine(t).t;return o=clamp(o,e,s),this.at(clamp(o,e,s))}at(t){return assertNumbers(t),this.anchor.plus(this.dir1.times(t))}pointT(t){return assertVectors(t),t.minus(this.anchor).dot(this.dir1)}isParallelToLine(t){return assertInst(L3$$1,t),eq(1,Math.abs(this.dir1.dot(t.dir1)))}angleToLine(t){return assertInst(L3$$1,t),this.dir1.angleTo(t.dir1)}intersectsLine(t){return eq0(this.distanceToLine(t))}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1):super.isInfosWithCurve(t)}isInfosWithLine(t,e){const s=this.dir1.cross(e),r=s.squared();if(eq0(r))return[];const n=t.minus(this.anchor);if(eq0(n.dot(s))){const t=n.cross(e).dot(s)/r;return[{tThis:t,tOther:n.cross(this.dir1).dot(s)/r,p:this.at(t)}]}return[]}isInfoWithLine(t){assertInst(L3$$1,t);const e=this.dir1.cross(t.dir1),s=e.squared();if(eq0(s))return;const r=t.anchor.minus(this.anchor);if(!eq0(r.dot(e.unit())))return;const n=r.cross(t.dir1).dot(e)/s;return this.at(n)}intersectionLineST(t){assertInst(L3$$1,t);const e=this.dir1.cross(t.dir1),s=e.squared(),r=t.anchor.minus(this.anchor);return{s:r.cross(this.dir1).dot(e)/s,t:r.cross(t.dir1).dot(e)/s}}ddt(){return V3.O}getConstructorParameters(){return[this.anchor,this.dir1]}closestTToPoint(t){return t.minus(this.anchor).dot(this.dir1)}infoClosestToLine(t){if(this.isParallelToLine(t))return{t:NaN,s:NaN,distance:this.distanceToLine(t)};const e=t.anchor,s=t.dir1,r=this.anchor,n=this.dir1,i=s.dot(n),o=s.squared(),a=n.squared(),c=e.minus(r),h=i*i-a*o,u=(c.dot(s)*i-c.dot(n)*o)/h,l=(c.dot(s)*a-c.dot(n)*i)/h;return{t:u,s:l,closest:this.at(u),closest2:t.at(l),distance:this.at(u).distanceTo(t.at(l))}}intersectionWithPlane(t){const e=(t.w-t.normal1.dot(this.anchor))/t.normal1.dot(this.dir1);return this.anchor.plus(this.dir1.times(e))}tangentAt(){return this.dir1}isTWithPlane(t){const e=t.normal1.dot(this.dir1);return eq0(e)?NaN:(t.w-t.normal1.dot(this.anchor))/e}reversed(){return new L3$$1(this.anchor,this.dir1.negated(),-this.tMax,-this.tMin)}isTsWithPlane(t){const e=this.isTWithPlane(t);return isNaN(e)?[]:[e]}flipped(){return new L3$$1(this.anchor,this.dir1.negated())}transform(t){const e=t.transformPoint(this.anchor),s=t.transformVector(this.dir1);return new L3$$1(e,s.unit(),this.tMin*s.length(),this.tMax*s.length())}transform4(t){const e=P3$$1.vanishingPlane(t);if(!e)return this.transform(t);const s=this.at(this.tMin),r=this.at(this.tMax);if(le(e.distanceToPointSigned(s),0)||le(e.distanceToPointSigned(r),0))throw new Error("line must be in front of vanishingPlane in [tMin, tMax]");const n=lt(0,e.distanceToPointSigned(this.anchor))?this.anchor:this.at((this.tMin+this.tMax)/2),i=t.timesVector(VV(n.x,n.y,n.z,1)),o=t.timesVector(VV(this.dir1.x,this.dir1.y,this.dir1.z,0)),a=o.times(i.w).minus(i.times(o.w)).V3(),c=i.p3();return L3$$1.anchorDirection(c,a,t.transformPoint(s),t.transformPoint(r))}hashCode(){return 31*this.anchor.hashCode()+this.dir1.hashCode()}}L3$$1.X=new L3$$1(V3.O,V3.X),L3$$1.Y=new L3$$1(V3.O,V3.Y),L3$$1.Z=new L3$$1(V3.O,V3.Z),L3$$1.prototype.hlol=Curve$$1.hlol++,L3$$1.prototype.tIncrement=256;class PICurve$$1 extends ImplicitCurve$$1{constructor(t,e,s,r,n,i,o,a=1,c,h,u){super(t,e,a,c,h,u),this.parametricSurface=s,this.implicitSurface=r,this.pmPoints=n,this.pmTangents=i,this.stepSize=o,assert(Array.isArray(n)),assert(1==a),assert(o<=1);const l=s.pUVFunc(),f=s.dpdu(),p=s.dpdv(),d=r.didp.bind(r);this.didu=((t,e)=>d(l(t,e)).dot(f(t,e))),this.didv=((t,e)=>d(l(t,e)).dot(p(t,e)));for(let e=0;e<t.length-1;e++)assert(!t[e].equals(t[e+1]));{const t=this.parametricSurface,e=r,s=t.pUVFunc(),n=e.implicitFunction(),i=t.dpdu(),a=t.dpdv(),c=e.didp.bind(e),h=MathFunctionR2R.forFFxFy((t,e)=>n(s(t,e)),(t,e)=>c(s(t,e)).dot(i(t,e)),(t,e)=>c(s(t,e)).dot(a(t,e))),{points:u}=followAlgorithm2d$$1(h,this.pmPoints[0],o,t,(t,r)=>e.containsPoint(s(t,r)),this.pmPoints.last,this.pmTangents[0]);u.length!==this.points.length&&followAlgorithm2d$$1(h,this.pmPoints[0],o,t,(t,r)=>e.containsPoint(s(t,r)),this.pmPoints.last,this.pmTangents[0]),assert(u.length==this.points.length,u.length,this.points.length)}}static forParametricStartEnd(t,e,s,r,n=.02,i,o,a){const c=t.pUVFunc(),h=e.implicitFunction(),u=t.dpdu(),l=t.dpdv(),f=e.didp.bind(e),p=MathFunctionR2R.forFFxFy((t,e)=>h(c(t,e)),(t,e)=>f(c(t,e)).dot(u(t,e)),(t,e)=>f(c(t,e)).dot(l(t,e))),{points:d,tangents:m}=followAlgorithm2d$$1(p,s,n,t,(t,s)=>e.containsPoint(c(t,s)),r,i);return PICurve$$1.forParametricPointsTangents(t,e,d,m,n,1,o,a)}static forStartEnd(t,e,s,r,n=.02,i,o,a){const c=t.uvP(s),h=t.dpdu()(c.x,c.y),u=t.dpdv()(c.x,c.y),l=i&&M4.forSys(h,u).inversed().transformVector(i),f=PICurve$$1.forParametricStartEnd(t,e,c,t.uvP(r),n,l);return f.withBounds(o&&f.pointT(o),a&&f.pointT(a))}static forParametricPointsTangents(t,e,s,r,n,i=1,o,a){const c=t.pUVFunc(),h=t.dpdu(),u=t.dpdv(),l=s.map(({x:t,y:e})=>c(t,e)),f=s.map(({x:t,y:e},s)=>{const n=h(t,e),i=u(t,e);return n.times(r[s].x).plus(i.times(r[s].y))});return new PICurve$$1(l,f,t,e,s,r,n,i,void 0,o,a)}getConstructorParameters(){return[this.points,this.tangents,this.parametricSurface,this.implicitSurface,this.pmPoints,this.pmTangents,this.stepSize,this.dir,this.generator]}implicitCurve(){const t=this.parametricSurface.pUVFunc(),e=this.implicitSurface.implicitFunction();return(s,r)=>e(t(s,r))}isColinearTo(t){return t instanceof PICurve$$1&&(!!this.equals(t)||(this.parametricSurface.isCoplanarTo(t.parametricSurface)&&this.implicitSurface.isCoplanarTo(t.implicitSurface),!1))}containsPoint(t){assertVectors(t);const e=this.pointT(t);return!isNaN(e)&&this.isValidT(e)}equals(t){return Object.getPrototypeOf(t)==PICurve$$1.prototype&&this.parametricSurface.equals(t.parametricSurface)&&this.implicitSurface.equals(t.implicitSurface)&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])&&this.dir===t.dir}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.parametricSurface.hashCode())+this.implicitSurface.hashCode())+this.points[0].hashCode())+this.tangents[0].hashCode())}tangentP(t){assertVectors(t),assert(this.containsPoint(t),"this.containsPoint(point)");const e=this.pointT(t);return this.tangentAt(e)}tangentAt(t){if(assert(!isNaN(t)),0==t%1)return this.tangents[t];const e=this.uvT(t),s=new V3(-this.didv(e.x,e.y),this.didu(e.x,e.y),0).toLength(this.stepSize),r=this.parametricSurface.dpdu()(e.x,e.y),n=this.parametricSurface.dpdv()(e.x,e.y);return r.times(s.x).plus(n.times(s.y))}at(t){if(assert(!isNaN(t)),0==t%1)return this.points[t];const e=V3.lerp(this.pmPoints[floor(t)],this.pmPoints[ceil(t)],t%1);return this.closestPointToParams(e)}uvT(t){if(assert(!isNaN(t)),0==t%1)return this.pmPoints[t];const e=V3.lerp(this.pmPoints[floor(t)],this.pmPoints[ceil(t)],t%1);return curvePoint$$1(this.implicitCurve(),e,this.didu,this.didv)}closestTToPoint(t,e){return 0}closestPointToParams(t){const e=curvePoint$$1(this.implicitCurve(),t,this.didu,this.didv);return this.parametricSurface.pUVFunc()(e.x,e.y)}isTsWithSurface(t){if(t instanceof EllipsoidSurface$$1){const e=this.parametricSurface,s=this.implicitSurface;if(e instanceof ProjectedCurveSurface$$1&&s instanceof EllipsoidSurface$$1){const r=s.isCurvesWithSurface(t).flatMap(t=>t.isTsWithSurface(e).map(e=>t.at(e)));return fuzzyUniques(r.map(t=>this.pointT(t))).filter(t=>!isNaN(t)&&this.isValidT(t))}}else if(ImplicitSurface$$1.is(t)){const e=[],s=t.implicitFunction();let r=s(this.points[0]);for(let n=1;n<this.points.length;n++){const i=this.points[n],o=s(i);if(r*o<=0){const i=this.parametricSurface.pUVFunc(),a=this.parametricSurface.dpdu(),c=this.parametricSurface.dpdv(),h=this.pmPoints[abs(r)<abs(o)?n-1:n],u=newtonIterate2dWithDerivatives(this.implicitCurve(),(t,e)=>s(i(t,e)),h.x,h.y,4,this.didu,this.didv,(e,s)=>a(e,s).dot(t.didp(i(e,s))),(e,s)=>c(e,s).dot(t.didp(i(e,s))));e.push(this.pointT(this.parametricSurface.pUV(u.x,u.y)))}r=o}return e}throw new Error}isTsWithPlane(t){return this.isTsWithSurface(new PlaneSurface$$1(t))}pointT(t){if(assertVectors(t),!this.parametricSurface.containsPoint(t)||!this.implicitSurface.containsPoint(t))return NaN;const e=this.parametricSurface.uvPFunc()(t),s=this.points,r=this.pmPoints;let n=0,i=e.distanceTo(r[0]);for(;i>abs(this.stepSize)&&n<s.length-1;)n=min(r.length-1,n+max(1,Math.round(i/abs(this.stepSize)/2/2))),i=e.distanceTo(r[n]);if(i>1.1*abs(this.stepSize))return NaN;if(n==s.length-1&&n--,s[n].like(t))return n;if(s[n+1].like(t))return n+1;const o=arrayRange(floor(this.tMin),ceil(this.tMax),1).withMax(t=>-e.distanceTo(r[t]));if(void 0===o)throw new Error;if(s[o].like(t))return o;const a=max(0,o-1),c=min(this.points.length-1,o+1),h=this.tangentAt(o);return n=bisect(e=>this.at(clamp(e,0,this.points.length-1)).to(t).dot(h),a,c,32),!isFinite(n)||this.at(n).distanceTo(t)>abs(this.stepSize)?NaN:n}transform(t){const e=t.isMirroring()?-1:1;return PICurve$$1.forStartEnd(this.parametricSurface.transform(t),this.implicitSurface.transform(t),t.transformPoint(this.points[0]),t.transformPoint(this.points.last),this.stepSize*e,t.transformVector(this.tangents[0]),t.transformPoint(this.at(this.tMin)),t.transformPoint(this.at(this.tMax)))}roots(){const t=arrayRange(0,this.points.length);return[t,t,t]}isInfosWithLine(t,e,s,r,n,i){return surfaceIsICurveIsInfosWithLine$$1.call(this,t,e,s,r,n,i)}toSource(t=(t=>t)){return callsce("PICurve.forParametricStartEnd",this.parametricSurface,this.implicitSurface,this.pmPoints[0],this.pmPoints.last,this.stepSize,this.pmTangents[0],this.tMin,this.tMax)}}PICurve$$1.prototype.tIncrement=1;class PPCurve$$1 extends ImplicitCurve$$1{constructor(t,e,s,r,n,i,o,a=1,c,h,u){super(t,e,a,c,h,u),this.parametricSurface1=s,this.parametricSurface2=r,this.st1s=n,this.pmTangents=i,this.stepSize=o,assert(ParametricSurface$$1.is(s)),assert(ParametricSurface$$1.is(r)),assert(Array.isArray(n)),assert(1==a),assert(o<=1)}at(t){if(assert(!isNaN(t)),0==t%1)return this.points[t];const e=V3.lerp(this.points[floor(t)],this.points[ceil(t)],t%1);return curvePointPP$$1(this.parametricSurface1,this.parametricSurface2,e).p}isColinearTo(t){return t instanceof PPCurve$$1&&(!!this.equals(t)||(this.parametricSurface1.isCoplanarTo(t.parametricSurface1)&&this.parametricSurface1.isCoplanarTo(t.parametricSurface2),!1))}containsPoint(t){return assertVectors(t),this.parametricSurface1.containsPoint(t)&&this.parametricSurface2.containsPoint(t)&&!isNaN(this.pointT(t))}rootPoints(){const t=this.parametricSurface1.pUVFunc(),e=this.parametricSurface2.pUVFunc(),s=this.parametricSurface1.normalUVFunc(),r=this.parametricSurface2.normalUVFunc(),n=this.rootsApprox(),i=[[],[],[]];for(let a=0;a<3;a++)for(let c=0;c<n[a].length;c++){const h=n[a][c],u=this.at(h);assert(this.parametricSurface1.containsPoint(u));const l=this.parametricSurface1.uvP(u),{x:f,y:p}=this.parametricSurface2.uvP(u),d=[l.x,l.y,f,p];function o(n){const[i,o,c,h]=n,u=t(i,o).minus(e(c,h)),l=s(i,o),f=r(c,h),p=l.cross(f);return[u.x,u.y,u.z,p.e(a)]}const m=newtonIterate(o,d,8),$=t(m[0],m[1]);i[a].push($)}return i}roots(){return this.rootPoints().map(t=>t.map(t=>this.pointT(t)))}pointTangent(t){assertVectors(t),assert(this.containsPoint(t),"this.containsPoint(pWC)");const e=this.parametricSurface1.normalP(t),s=this.parametricSurface2.normalP(t);return e.cross(s)}transform(t){return new PPCurve$$1(t.transformedPoints(this.points),t.transformedVectors(this.tangents),this.parametricSurface1.transform(t),this.parametricSurface2.transform(t),this.st1s,void 0,this.stepSize,this.dir,void 0)}toSource(){return callsce("PPCurve.forStartEnd",this.parametricSurface1,this.parametricSurface2,this.points[0],this.points.last,this.stepSize)}static forStartEnd(t,e,s,r,n=.02){const{points:i,tangents:o,st1s:a}=followAlgorithmPP$$1(t,e,s,n);return new PPCurve$$1(i,o,t,e,a,void 0,n,1)}isInfosWithLine(t,e,s,r,n,i){return surfaceIsICurveIsInfosWithLine$$1.call(this,t,e,s,r,n,i)}isTsWithSurface(t){if(ImplicitSurface$$1.is(t)){const e=[],s=t.implicitFunction(),r=this.parametricSurface1.pUVFunc(),n=this.parametricSurface2.pUVFunc();let i=s(this.points[0]);for(let t=1;t<this.points.length;t++){const o=this.points[t],a=s(o);if(i*a<=0){const o=abs(i)<abs(a)?t-1:t,c=this.points[o],h=this.st1s[o],u=this.parametricSurface2.uvP(c),l=newtonIterate(([t,e,i,o])=>{const a=r(t,e),c=n(i,o);return[...a.to(c),s(a)]},[h.x,h.y,u.x,u.y]);e.push(this.pointT(this.parametricSurface1.pUV(l[0],l[1])))}i=a}return e}throw new Error("Method not implemented.")}isTsWithPlane(t){return this.isTsWithSurface(new PlaneSurface$$1(t))}}class ParabolaCurve$$1 extends XiEtaCurve$$1{constructor(t,e,s,r=-10,n=10){super(t,e,s,r,n)}static eccentricity(){return 1}static unitIsInfosWithLine(t,e,s,r){const n=Math.pow(e.x,2);return pqFormula((t.x*e.x+e.y)/n,(Math.pow(t.x,2)+t.y)/n).filter(s=>le(0,t.y+s*e.y)).map(n=>({tThis:e.x*n+t.x,tOther:n,p:L3$$1.at(s,r,n)}))}static intersectionUnitLine(t,e,s){return pqFormula(t/e,-s/e)}static XYLCValid(t){return eq(Math.pow(t.x,2),t.y)}static XYLCPointT(t){return t.x}static quadratic(t,e,s){const r=t.plus(s).minus(e.times(2)),n=e.minus(t).times(2);return new ParabolaCurve$$1(t,n,r,0,1)}at(t){return this.center.plus(this.f1.times(t)).plus(this.f2.times(t*t))}tangentAt(t){return assertNumbers(t),this.f1.plus(this.f2.times(2*t))}ddt(t){return assertNumbers(t),this.f2.times(2)}tangentAt2(t,e){return assertNumbers(t,e),this.f1.plus(this.f2.times(2*e))}reversed(){return new this.constructor(this.center,this.f1.negated(),this.f2,-this.tMax,-this.tMin)}roots(){return arrayFromFunction(3,t=>eq0(this.f2.e(t))?[]:[-this.f1.e(t)/2/this.f2.e(t)])}isColinearTo(t){if(!hasConstructor(t,ParabolaCurve$$1))return!1;const e=this.rightAngled(),s=t.rightAngled();return e.center.like(s.center)&&e.f2.like(s.f2)&&e.f1.likeOrReversed(s.f1)}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e);if(eq0(s)&&t.hasLength(1))return this;const r=-s/e.squared()/2,n=this.at(r),i=this.tangentAt(r),o=i.length(),a=i.unit(),c=t=>this.at(t).minus(n).dot(a);return new ParabolaCurve$$1(n,a,e.div(Math.pow(o,2)),c(this.tMin),c(this.tMax))}arcLength(t,e){let s=this.f1;const r=this.f2,n=s.dot(r);let i=0;eq0(n)||(i=-n/r.squared()/2,s=s.plus(r.times(2*i)));const o=s.length(),a=r.length()/o;function c(t){return Math.asinh(2*a*t)/4/a+t*Math.sqrt(1+a*a*4*t*t)/2}return o*(c(e-i)-c(t-i))}transform4(t){return parabola4Projection$$1(this.matrix.transform(t),this.tMin,this.tMax)}asBezier(){return BezierCurve$$1.quadratic(this.at(-1),new L3$$1(this.at(-1),this.tangentAt(-1).unit()).isInfoWithLine(new L3$$1(this.at(1),this.tangentAt(1).unit())),this.at(1))}recenter(t){return new ParabolaCurve$$1(this.at(t),this.f1.plus(this.f2.times(2*t)),this.f2)}}ParabolaCurve$$1.XY=new ParabolaCurve$$1(V3.O,V3.X,V3.Y),ParabolaCurve$$1.YZ=new ParabolaCurve$$1(V3.O,V3.Y,V3.Z),ParabolaCurve$$1.ZX=new ParabolaCurve$$1(V3.O,V3.Z,V3.X),ParabolaCurve$$1.prototype.tIncrement=1/32;class EllipseCurve$$1 extends XiEtaCurve$$1{constructor(t,e,s,r=0,n=PI){super(t,e,s,r,n),assert(-PI<=this.tMin&&this.tMin<PI),assert(-PI<this.tMax&&this.tMax<=PI)}static andFixTs(t,e,s,r=0,n=PI){if(-PI<=r&&n<=PI)return new EllipseCurve$$1(t,e,s,r,n);if(0<=r&&n<=TAU)return new EllipseCurve$$1(t,e.negated(),s.negated(),r-PI,n-PI);if(-TAU<=r&&n<=0)return new EllipseCurve$$1(t,e.negated(),s.negated(),r+PI,n+PI);throw new Error("Method not implemented.")}static XYLCValid(t){const{x:e,y:s}=t;return eq0(Math.pow(e,2)+Math.pow(s,2)-1)}static XYLCPointT(t,e,s){assertNumbers(e,s);const r=atan2(t.y,t.x);return r<lerp(e,s-TAU,.5)?r+TAU:r>lerp(s,e+TAU,.5)?r-TAU:r}static intersectionUnitLine(t,e,s,r,n){const i=intersectionUnitCircleLine2$$1(t,e,s),o=[];for(const[t,e]of i){const s=EllipseCurve$$1.XYLCPointT(new V3(t,e,0),r,n);fuzzyBetween(s,r,n)&&o.push(s)}return o}static unitIsInfosWithLine(t,e,s,r,n,i){const o=e.squared();return pqFormula(2*e.dot(t)/o,(t.squared()-1)/o).filter(s=>le(0,t.y+s*e.y)).map(o=>({tThis:EllipseCurve$$1.XYLCPointT(e.times(o).plus(t),n,i),tOther:o,p:L3$$1.at(s,r,o)}))}static semicircle(t,e=V3.O,s,r){return new EllipseCurve$$1(e,new V3(t,0,0),new V3(0,t,0),s,r)}static circleForCenter2P(t,e,s,r,n,i){const o=t.to(e),a=o.cross(t.to(s)).cross(o).toLength(o.length());return new EllipseCurve$$1(t,o,a,void 0!==n?n:0,void 0!==i?i:o.angleTo(t.to(s)))}split(t=this.tMin,e=this.tMax){const s=[];return t<0&&s.push(new EllipseCurve$$1(this.center,this.f1.negated(),this.f2.negated(),t+PI,min(0,e)+PI)),e>0&&s.push(new EllipseCurve$$1(this.center,this.f1,this.f2,max(0,t),e)),s}static forAB(t,e,s=V3.O){return super.forAB(t,e,s)}static circleThroughPoints(t,e,s,r=0,n){assertf(()=>!L3$$1.throughPoints(t,s).containsPoint(e));const i=t.to(e).cross(e.to(s)),o=new L3$$1(t.lerp(e,.5),i.cross(t.to(e)).unit()).isInfoWithLine(new L3$$1(e.lerp(s,.5),i.cross(e.to(s)).unit())),a=o.to(t).negated();return new EllipseCurve$$1(o,a,i.unit().cross(a),-PI,void 0===n?a.angleRelativeNormal(o.to(s),i.unit()):n)}getAreaInDir(t,e,s,r){assertf(()=>t.isPerpendicularTo(this.normal)),assertf(()=>e.isPerpendicularTo(this.normal));const n=this.matrixInverse.transformVector(e),i=n.cross(V3.Z),o=s-i.angleXY(),a=r-i.angleXY(),c=this.matrixInverse.getTranslation().dot(n.unit());function h(t){return(t-Math.sin(t)*Math.cos(t))/2}function u(t){return Math.pow(Math.sin(t),3)/3}function l(t){return(Math.cos(3*t)-9*Math.cos(t))/24}const f=-c*(-Math.cos(a)+Math.cos(o)),p=h(a)-h(o)+f,d=(u(a)-u(o)+-c*(-Math.cos(a)-Math.cos(o))/2*f)/p,m=(l(a)-l(o)- -c/2*f)/p,$=this.matrix.xyAreaFactor();return assert(!eq0($)),{area:p*$,centroid:this.matrix.transformPoint(M4.rotateZ(i.angleXY()).transformPoint(new V3(d,m,0)))}}at(t){return assertNumbers(t),this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return assertNumbers(t),assert(this.isValidT(t)),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}tangentAt2(t,e){return this.f2.times(t).minus(this.f1.times(e))}isCircular(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}isColinearTo(t){if(!hasConstructor(t,EllipseCurve$$1))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:e,f2:s}=this.rightAngled(),{f1:r,f2:n}=t.rightAngled();return e.length()>s.length()&&([e,s]=[s,e]),r.length()>n.length()&&([r,n]=[n,r]),eq(e.squared(),Math.abs(e.dot(r)))&&eq(s.squared(),Math.abs(s.dot(n)))}}pointT(t){assertVectors(t),assert(this.containsPoint(t));const e=this.matrixInverse.transformPoint(t),s=EllipseCurve$$1.XYLCPointT(e,this.tMin,this.tMax);return assert(this.isValidT(s)),s}reversed(){return new EllipseCurve$$1(this.center,this.f1.negated(),this.f2,PI-this.tMax,PI-this.tMin)}eccentricity(){const t=this.rightAngled(),e=t.f1.length(),s=t.f1.length(),[r,n]=e>s?[e,s]:[s,e];return Math.sqrt(1-n*n/r/r)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t=this.tMin,e=this.tMax,s=2){assert(t<e,"startT < endT");const r=this.f1.length();return eq(r,this.f2.length())?r*(e-t):super.arcLength(t,e,s)}circumferenceApproximate(){const{f1:t,f2:e}=this.rightAngled(),s=t.length(),r=e.length(),n=Math.pow(s-r,2)/Math.pow(s+r,2);return Math.PI*(s+r)*(1+3*n/(10+Math.sqrt(4-3*n)))}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e),r=e.squared()-t.squared();if(eq0(s))return this;const n=2*s,i=r+Math.sqrt(r*r+4*s*s),{x1:o,y1:a}=intersectionUnitCircleLine$$1(n,i,0),c=t.times(o).plus(e.times(a)),h=t.times(-a).plus(e.times(o));return new EllipseCurve$$1(this.center,c,h,-PI,PI)}isInfosWithEllipse(t){if(this.normal.isParallelTo(t.normal)&&eq0(this.center.minus(t.center).dot(t.normal))){const e=t.transform(this.matrixInverse).rightAngled(),s=e.f1.lengthXY(),r=e.f2.lengthXY(),n=e.center.lengthXY(),i=min(s,r),o=max(s,r);if(lt(n+o,1)||lt(1,n-o)||lt(1,i-n)||eq(1,s)&&eq(1,r)&&eq0(n))return[];const a=t=>e.at(t).lengthXY()-1,c=t=>e.at(t).xy().dot(e.tangentAt(t))/e.at(t).lengthXY();checkDerivate(a,c,-PI,PI,1);const h=[];for(let t=-.8*PI;t<PI;t+=PI/4){let e=newtonIterateSmart(a,t,16,c,1e-4);le(e,-PI)&&(e+=TAU),assert(!isNaN(e)),between(e,-PI,PI)&&eq0(a(e))&&!h.some(t=>eq(e,t))&&h.push(e)}const u=[];for(const s of h){const r=this.matrix.transformPoint(e.at(s));this.containsPoint(r)&&t.containsPoint(r)&&u.push({tThis:this.pointT(r),tOther:t.pointT(r),p:r})}return u}return this.isTsWithPlane(P3$$1.normalOnAnchor(t.normal.unit(),t.center)).mapFilter(e=>{const s=this.at(e);if(t.containsPoint(s))return{tThis:e,tOther:t.pointT(s),p:s}})}isInfosWithCurve(t){return t instanceof EllipseCurve$$1?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}transform4(t){const e=t=>sign(t)*sqrt((1-cos(t))/(1+cos(t))),s=new M4(0,-1,0,1,2,0,0,0,0,0,1,0,0,1,0,1);return parabola4Projection$$1(M4.product(t,this.matrix,s),e(this.tMin),e(this.tMax))}roots(){return arrayFromFunction(3,t=>{return intersectionUnitCircleLine2$$1(this.f2.e(t),-this.f1.e(t),0).map(([t,e])=>Math.atan2(e,t)).filter(t=>this.isValidT(t))})}closestTToPoint(t,e){e=e||this.matrixInverse.transformPoint(t).angleXY();const s=t.minus(this.center);return newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(s)),e,8)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const e=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.matrixInverse.transformVector(e).angleXY()}}EllipseCurve$$1.UNIT=new EllipseCurve$$1(V3.O,V3.X,V3.Y),EllipseCurve$$1.prototype.hlol=Curve$$1.hlol++,EllipseCurve$$1.prototype.tIncrement=2*Math.PI/128;class NURBS$$1 extends Curve$$1{constructor(t,e,s=NURBS$$1.openUniformKnots(t.length,e),r=s[e],n=s[s.length-e-1]){super(r,n),this.points=t,this.degree=e,this.knots=s;const i=t.length+e+1;assert(s.length===i,"bad knot vector length: expected "+i+" (degree = "+e+" pcount = "+t.length+"), but was "+s.length),assert(s[e]<=r),assert(n<=s[s.length-e-1]);for(let e=0;e<t.length;e++)assert(4==t[e].dim());assert(e>=1,"degree must be at least 1 (linear)"),assert(e%1==0),assert(-1==s.firstUnsorted(MINUS),"knot values must be in ascending order")}getConstructorParameters(){return[this.points,this.degree,this.knots]}at4(t){assert(between(t,this.tMin,this.tMax),t);const{points:e,degree:s,knots:r}=this,n=this.tInterval(t),i=Vector.pack(e,new Float64Array(4*(s+1)),n-s,0,s+1);for(let e=0;e<s;e++)for(let o=s;o>e;o--){const a=(t-r[o+n-s])/(r[o+n-e]-r[o+n-s]);for(let t=0;t<4;t++)i[4*o+t]=(1-a)*i[4*(o-1)+t]+a*i[4*o+t]}return new Vector(i.slice(4*s,4*(s+1)))}at(t){return this.at4(t).p3()}ptDtDdt4(t){const{points:e,degree:s,knots:r}=this,n=this.tInterval(t),i=Vector.pack(e,new Float64Array(4*(s+1)),n-s,0,s+1);let o,a=Vector.Zero(4);for(let e=0;e<s;e++){if(e==s-2){const t=new Vector(i.slice(4*s,4*(s+1))),e=new Vector(i.slice(4*(s-1),4*s)),o=new Vector(i.slice(4*(s-2),4*(s-1)));function c(t,e,n,i){return i.minus(n).times(t/(r[e+s-t]-r[e-1]))}a=c(s,n+1,c(s-1,n+1,t,e),c(s-1,n,e,o))}if(e==s-1){const t=new Vector(i.slice(4*s,4*(s+1)));o=new Vector(i.slice(4*(s-1),4*s)).minus(t).times(s/(r[n]-r[n+1]))}for(let o=s;o>e;o--){const a=(t-r[o+n-s])/(r[o+n-e]-r[o+n-s]);for(let t=0;t<4;t++)i[4*o+t]=(1-a)*i[4*(o-1)+t]+a*i[4*o+t]}}return[new Vector(i.slice(4*s,4*s+4)),o,a]}tangentAt(t){const[e,s]=this.ptDtDdt4(t);return s.times(e.w).minus(e.times(s.w)).div(Math.pow(e.w,2)).V3()}ddt(t){const[e,s,r]=this.ptDtDdt4(t);return Vector.add(e.times(-e.w*r.w+2*Math.pow(s.w,2)),s.times(-2*e.w*s.w),r.times(Math.pow(e.w,2))).div(Math.pow(e.w,3)).V3()}ptDtDdt(t){const[e,s,r]=this.ptDtDdt4(t);return[e.p3(),s.times(e.w).minus(e.times(s.w)).div(Math.pow(e.w,2)).V3(),Vector.add(e.times(-e.w*r.w+2*Math.pow(s.w,2)),s.times(-2*e.w*s.w),r.times(Math.pow(e.w,2))).div(Math.pow(e.w,3)).V3()]}pointT(t){return this.closestTToPoint(t)}closestTToPoint(t,e,s=this.tMin,r=this.tMax){return void 0===e&&(e=arraySamples(s,r,32).withMax(e=>-this.at(e).distanceTo(t))),newtonIterateWithDerivative2(e=>{const[s,r,n]=this.ptDtDdt(e);return[s.minus(t).dot(r),r.squared()+s.minus(t).dot(n)]},e,8,this.tMin,this.tMax)}containsPoint(t){const e=this.closestTToPoint(t);return void 0!==e&&this.at(e).like(t)}derivate(){const t=this.degree,e=arrayFromFunction(this.points.length-1,e=>this.points[e].to(this.points[e+1]).times(t/(this.knots[e+t+1]-this.knots[e+1])));return new NURBS$$1(e,this.degree-1,this.knots.slice(1,-1),this.tMin,this.tMax)}withKnot(t,e=1){assert(between(t,this.tMin,this.tMax));const s=this.tInterval(t),{knots:r,points:n,degree:i}=this,o=arrayFromFunction(this.degree,e=>{const o=s-i+1+e,a=t-r[o],c=0==a?0:a/(r[o+i]-r[o]);return assert(between(c,0,1)),Vector.lerp(n[o-1],n[o],c)}),a=n.slice();a.splice(s-i+1,i-1,...o);const c=r.slice();return c.splice(s+1,0,t),new NURBS$$1(a,i,c,this.tMin,this.tMax)}removeKnot(t){const{knots:e,points:s,degree:r}=this;let n=this.tInterval(t),i=0;for(;e[n+1]==t;)n++,i++;if(0==i)throw new Error("There is no knot "+t+"!");const o=[s[n-r-1]],a=e.slice();a.splice(n,1);for(let e=n-r;e<=n-i;e++){const n=(a[e+r]-a[e])/(t-a[e]),i=Vector.lerp(o.last,s[e],n);o.push(i)}if(o.last.like(s[n+1-i])){const t=s.slice();return t.splice(n-r-1,r-i+3,...o),new NURBS$$1(t,r,a)}}static openUniformKnots(t,e,s=0,r=1){const n=t+e+1;return arrayFromFunction(n,t=>t<=e?s:t>=n-e-1?r:lerp(s,r,(t-e)/(n-2*e-1)))}static bezierKnots(t,e=0,s=1){const r=new Array(2*(t+1));for(let n=0;n<t+1;n++)r[n]=e,r[t+1+n]=s;return r}static fromBezier(t){const e=t.selectPart(t.tMin,t.tMax);return NURBS$$1.Bezier(e.points)}static Bezier(t,e=0,s=1){return new NURBS$$1(t.map(t=>t instanceof V3?new Vector(new Float64Array([t.x,t.y,t.z,1])):t),t.length-1,arrayFromFunction(2*t.length,e=>e<t.length?0:1),e,s)}static fromHyperbola(t,e=t.tMin,s=t.tMax){const r=HyperbolaCurve$$1.XY.at(e),n=HyperbolaCurve$$1.XY.at(s),i=new V3((sinh(e)-sinh(s))/sinh(e-s),(cosh(e)-cosh(s))/sinh(e-s),0),o=r.lerp(n,.5),a=1/sqrt(1-Math.pow(o.y/o.x,2)),c=(a-o.x)/(i.x-a);return NURBS$$1.fromV3s([r,i,n],2,void 0,[1,c,1]).transform(t.matrix)}static fromParabola(t){return NURBS$$1.fromBezier(t.asBezier())}static fromEllipse(t){return new NURBS$$1([VV(1,0,0,1),VV(1,1,0,1).times(SQRT1_2),VV(0,1,0,1),VV(-1,1,0,1).times(SQRT1_2),VV(-1,0,0,1),VV(-1,-1,0,1).times(SQRT1_2),VV(0,-1,0,1)],2,[0,0,0,PI/2,PI/2,PI,PI,3*PI/2,3*PI/2,2*PI]).transform(t.matrix)}static fromV3s(t,e,s,r=arrayFromFunction(t.length,()=>1)){return assert(t.length==r.length),new NURBS$$1(t.map((t,e)=>Vector.fromV3AndWeight(t,r[e])),e,s)}isUniform(t=0){const e=arrayFromFunction(this.knots.length-1,t=>this.knots[t+1]-this.knots[t]),[s,r]=minAndMax(e);return eq(s,r,t)}isBSpline(t=0){const[e,s]=minAndMax(this.points.map(t=>t.w));return eq(e,s,t)}isBezier(t=0){if(this.degree+1!=this.points.length)return!1;const[e,s]=minAndMax(this.knots,0,this.degree+1);if(!eq(e,s,t))return!1;const[r,n]=minAndMax(this.knots,this.degree+1);return!!eq(r,n,t)}getSegments(){const{knots:t,points:e,degree:s}=this,r=[],n=Vector.pack(e,new Float64Array(4*e.length)),i=t=>new Vector(n.slice(4*t,4*(t+1)));let o=s+1;for(;o<t.length-s-1;){const e=t[o],a=t[o-1];let c=1;for(;t[o+1]==e;)o++,c++;const h=new Array(s+1);for(let t=0;t<c+1;t++)h[t]=i(o-s-c+t);for(let r=1;r<=s-c;r++){for(let i=o-s;i<=o-c-r;i++){const r=(e-a)/(t[i+s+1]-a);for(let t=0;t<4;t++)n[4*i+t]=(1-r)*n[4*i+t]+r*n[4*(i+1)+t]}h[c+r]=i(o-s)}const u=arrayFromFunction(2*(s+1),r=>r<s+1?t[o-c]:e);r.push(new NURBS$$1(h,s,u)),o++}const a=arrayFromFunction(s+1,t=>i(e.length-s-1+t)),c=arrayFromFunction(2*(s+1),e=>e<s+1?t[o-1]:t[o]);return r.push(new NURBS$$1(a,s,c)),r}split(t){const{knots:e,points:s,degree:r}=this;assert(le(this.tMin,t)&&le(t,this.tMax));let n=this.tInterval(t),i=0;for(;e[n+1]==t;)n++,i++;const o=t=>new Vector(h.slice(4*t,4*(t+1))),a=new Array(n+1-i);for(let t=0;t<n+i-r+1;t++)a[t]=this.points[t];const c=s.length-(n-r),h=Vector.pack(s,new Float64Array(4*c),n-r);for(let s=1;s<=r-i;s++){for(let o=n-r;o<=n-i-s;o++){const i=(t-e[o+s])/(e[o+r+1]-e[o+s]),a=o-(n-r);for(let t=0;t<4;t++)h[4*a+t]=(1-i)*h[4*a+t]+i*h[4*(a+1)+t]}a[n-r+s]=o(0)}const u=e.slice(0,n+r+2-i);for(let e=0;e<r-i+1;e++)u[n-i+1+e]=t;const l=e.slice(n-r);for(let e=0;e<r+1;e++)l[e]=t;const f=arrayFromFunction(c,t=>vArrGet(h,4,t));return[new NURBS$$1(a,r,u),new NURBS$$1(f,r,l)]}simplify(){if(assert(this.isBezier()),3==this.degree&&this.isBSpline())return new BezierCurve$$1(this.points[0].p3(),this.points[1].p3(),this.points[2].p3(),this.points[3].p3(),this.tMin,this.tMax);if(2==this.degree){const[t,e,s]=this.points,[r,n,i]=this.points.map(t=>t.p3()),o=NURBS$$1.simplifyUnit2(t.w,e.w,s.w).transform(M4.forSys(n.to(r),n.to(i),void 0,n)),[a,c]=[o.pointT(r),o.pointT(i)].sort();return o.withBounds(snap(a,o.tMin),snap(c,o.tMax))}return 1==this.degree?L3$$1.throughPoints(this.points[0].p3(),this.points[1].p3()):this}static simplifyUnit2(t,e,s){const r=t*s-Math.pow(e,2),n=t*s/2/r,i=new V3(n,n,0),o=(Math.pow(e,2)+r-2*e*sqrt(abs(r)))/2/r,a=V3.X,c=new V3(o,n,0);return eq0(r)?new ParabolaCurve$$1(new V3(.25,.25,0),new V3(1,-1,0),new V3(1,1,0),-.5,.5):r<0?new HyperbolaCurve$$1(i,i.to(a),i.to(c)):new EllipseCurve$$1(i,i.to(a),i.to(c),0)}elevateDegreeBezier(){assert(this.isBezier());const t=new Array(this.points.length+1);t[0]=this.points[0],t[this.points.length]=this.points[this.points.length-1];for(let e=1;e<this.points.length;e++)t[e]=Vector.lerp(this.points[e],this.points[e-1],e/(this.degree+1));const e=NURBS$$1.bezierKnots(this.degree+1,this.knots[0],this.knots[this.degree+1]);return new NURBS$$1(t,this.degree+1,e,this.tMin,this.tMax)}elevateDegree(){const t=this.getSegments().map(t=>t.elevateDegreeBezier()),e=new Array(2+t.length*this.degree);e[0]=t[0].points[0],e.last=t.last.points.last;for(let s=0;s<t.length;s++)for(let r=1;r<t[s].points.length-1;r++)e[s*(t[0].points.length-2)+r]=t[s].points[r];const s=new Array(e.length+this.degree+2);for(let t=0;t<this.degree+2;t++)s[t]=this.knots[0];for(let e=0;e<t.length;e++)for(let r=1;r<t[e].points.length-1;r++)s[e*(t[0].points.length-2)+r+this.degree+1]=t[e].knots.last;s[s.length-1]=this.knots.last,s[s.length-2]=this.knots.last;let r=new NURBS$$1(e,this.degree+1,s,this.tMin,this.tMax);for(let e=0;e<t.length-1;e++){let s;for(;s=r.removeKnot(t[e].knots.last);)r=s}return r}transform(t){return this.transform4(t)}transform4(t){return new NURBS$$1(this.points.map(e=>t.timesVector(e)),this.degree,this.knots,this.tMin,this.tMax)}tInterval(t){const{degree:e,knots:s}=this;for(let r=e;r<s.length-1-e;r++)if(t>=s[r]&&t<=s[r+1])return r;throw new Error(t+" "+s)}static UnitCircle(t=2,e=0,s=PI){const r=(s-e)/t,n=sin(PI/2-r/2);console.log(r/2/DEG);const i=1/cos(r/2),o=arrayFromFunction(2*t+1,r=>{const o=lerp(e,s,r/2/t);return r%2==0?VV(cos(o),sin(o),0,1):VV(i*n*cos(o),i*n*sin(o),0,n)}),a=[];a.push(e,e,e);for(let r=0;r<t-1;r++){const n=lerp(e,s,(r+1)/t);a.push(n,n)}return a.push(s,s,s),new NURBS$$1(o,2,a)}debugInfo(){return{points:[...this.knots.slice(this.degree,-this.degree).map(t=>this.at(t)),...this.points.map(t=>t.p3())],lines:this.points.flatMap((t,e,s)=>s[e+1]?[t.p3(),s[e+1].p3()]:[])}}isTsWithPlane(t){const{knots:e,degree:s,points:r}=this,n=[e[s],...r.slice(1,-1).map((t,r)=>this.closestTToPoint(t.p3(),void 0,e[r+3],e[r+s])),e[e.length-s-1]],i=[];for(let e=0;e<this.points.length-1;e++){const s=e=>{console.log("startT",e);const s=e=>{const[s,r]=this.ptDtDdt(e);return[t.distanceToPointSigned(s),t.normal1.dot(r)]};let r=newtonIterateWithDerivative2(s,e,8,this.tMin,this.tMax),[n,o]=void 0===r?[]:s(r);void 0!==r&&eq0(n)&&!eq0(o)||(r=newtonIterateWithDerivative2(e=>{const[,s,r]=this.ptDtDdt(e);return[t.normal1.dot(s),t.normal1.dot(r)]},e,8,this.tMin,this.tMax)),[n,o]=void 0===r?[]:s(r),void 0!==r&&eq0(n)&&!i.some(t=>eq(t,r))&&i.push(r)},r=this.points[e].p3(),o=this.points[e+1].p3(),a=snap0(t.distanceToPointSigned(r)),c=snap0(t.distanceToPointSigned(o));if(a*c<0){s(lerp(n[e],n[e+1],a/(a-c)))}else 0==c&&s(this.closestTToPoint(o,n[e+1]))}return i}isInfosWithCurve(t){return t instanceof L3$$1?this.isInfosWithLine(t.anchor,t.dir1):super.isInfosWithCurve(t)}isInfosWithLine(t,e){const s=P3$$1.fromPoints(this.points.map(t=>t.p3())),r=L3$$1.anchorDirection(t,e),n=this.points.map(t=>s.distanceToPoint(t.p3())).max(),i=eq0(n);if(i&&!s.containsLine(r)){const[n]=r.isTsWithPlane(s);if(void 0===n)return[];const i=r.at(n);return this.containsPoint(i)?[{tThis:this.pointT(i),tOther:L3$$1.pointT(t,e,i),p:i}]:[]}{const r=this.isTsWithPlane(P3$$1.normalOnAnchor(s.normal1.cross(e),t)).map(s=>{const r=this.at(s);return{tThis:s,tOther:L3$$1.pointT(t,e,r),p:r}});return i?r:r.filter(s=>L3$$1.containsPoint(t,e,s.p))}}roots(){console.log(this.tMin,this.tMax),arraySamples(this.tMin,this.tMax,30).forEach(t=>{console.log(t+","+this.tangentAt(t).z)});const t=[[],[],[]];for(let e=0;e<this.points.length-1;e++){const s=(e,s)=>{console.log("d",s,"startT",e);const r=newtonIterateWithDerivative2(t=>{const[,e,r]=this.ptDtDdt(t);return[e.e(s),r.e(s)]},e,8,this.tMin,this.tMax);void 0!==r&&t[s].push(r),console.log("d",s,"startT",e,"root",r)},r=this.points[e].p3(),n=this.points[e+1].p3(),i=r.to(n);for(let t=0;t<3;t++)if(0!==e&&eq0(i.e(t))){s(lerp(this.knots[e],this.knots[e+this.degree+2],.5),t)}else if(e<this.points.length-2){const r=n.to(this.points[e+2].p3());!eq0(r.e(t))&&i.e(t)*r.e(t)<0&&s(this.closestTToPoint(n,this.guessTClosestToControlPoint(e+1)),t)}}return console.log(t),t}guessTClosestToControlPoint(t){return lerp(this.knots[t],this.knots[t+this.degree+1],.5)}likeCurve(t){return this==t||hasConstructor(t,NURBS$$1)&&this.degree===t.degree&&this.points.every((e,s)=>e.like(t.points[s]))&&this.knots.every((e,s)=>eq(e,t.knots[s]))}isColinearTo(t){throw new Error("This doesn't even make sense.")}}function minAndMax(t,e=0,s=t.length){let r=1/0,n=-1/0;for(let i=e;i<s;i++)r>t[i]&&(r=t[i]),n<t[i]&&(n=t[i]);return[r,n]}NURBS$$1.EX2D=NURBS$$1.fromV3s([V(51,141),V(11,76),V(29,32),V(46,102),V(74,148),V(189,107),V(56,10),V(206,10),V(211,98),V(195,141),V(139,148)],4),NURBS$$1.EX3D=new NURBS$$1([VV(94,0,-34,1),VV(69,57,45,.5),VV(-20,44,91,1),VV(-89,-13,47,.5),VV(-56,-97,-7,1),VV(34,-83,-54,.5),VV(112,-53,16,1),VV(79,30,70,.5),VV(-2,-9,141,1),VV(-80,-40,72,.5),VV(-38,-150,43,1),VV(43,-110,-29,.5),VV(130,-106,65,1)],2,[-12,-12,-12,-8,-8,-4,-4,0,0,4,4,8,8,12,12,12]),NURBS$$1.prototype.tIncrement=1/128;class P3$$1 extends Transformable{constructor(t,e=0){super(),this.normal1=t,this.w=e,assertVectors(t),assertNumbers(e),assert(t.hasLength(1),"normal1.hasLength(1)"+t)}get anchor(){return this.normal1.times(this.w)}static throughPoints(t,e,s){assertVectors(t,e,s);const r=e.minus(t).cross(s.minus(t)).unit();return new P3$$1(r,r.dot(t))}static normalOnAnchor(t,e){assertVectors(t,e);const s=t.unit();return new this(s,s.dot(e))}static forAxisIntercepts(t,e,s){assertNumbers(t,e,s);const r=new V3(1/t,1/e,1/s);return new P3$$1(r.unit(),r.length())}static forAnchorAndPlaneVectors(t,e,s){return assertVectors(t,e,s),assert(!e.isParallelTo(s)),this.normalOnAnchor(e.cross(s),t)}static forPointAndLine(t,e){return this.forAnchorAndPlaneVectors(e.anchor,e.dir1,e.anchor.to(t))}static forABCD(t,e,s,r){const n=Math.hypot(t,e,s);if(!eq0(n))return new P3$$1(new V3(t/n,e/n,s/n),-r/n)}static vanishingPlane(t){return P3$$1.forABCD(t.m[12],t.m[13],t.m[14],t.m[15])}static forAABB(t,e=0){return[new P3$$1(V3.X,t.max.x+e),new P3$$1(V3.X.negated(),-t.min.x-e),new P3$$1(V3.Y,t.max.y+e),new P3$$1(V3.Y.negated(),-t.min.y-e),new P3$$1(V3.Z,t.max.z+e),new P3$$1(V3.Z.negated(),-t.min.z-e)]}static fromPoints(t){const e=t.length;if(e<3)return;const s=V3.add(...t).div(e);let r=0,n=0,i=0,o=0,a=0,c=0;for(const e of t){const t=e.minus(s);r+=t.x*t.x,n+=t.x*t.y,i+=t.x*t.z,o+=t.y*t.y,a+=t.y*t.z,c+=t.z*t.z}r/=e,n/=e,i/=e,o/=e,a/=e,c/=e;let h=V3.O;{const t=o*c-a*a,e=new V3(t,i*a-n*c,n*a-i*o);let s=t*t;h.dot(e)<0&&(s=-s),h=h.plus(e.times(s))}{const t=r*c-i*i,e=new V3(i*a-n*c,t,n*i-a*r);let s=t*t;h.dot(e)<0&&(s=-s),h=h.plus(e.times(s))}{const t=r*o-n*n,e=new V3(n*a-i*o,n*i-a*r,t);let s=t*t;h.dot(e)<0&&(s=-s),h=h.plus(e.times(s))}const u=h.unit();return P3$$1.normalOnAnchor(u,s)}axisIntercepts(){const t=this.w,e=this.normal1;return new V3(t/e.x,t/e.y,t/e.z)}isCoplanarToPlane(t){return assertInst(P3$$1,t),this.like(t)||this.likeFlipped(t)}like(t){return assertInst(P3$$1,t),eq(this.w,t.w)&&this.normal1.like(t.normal1)}likeFlipped(t){return assertInst(P3$$1,t),eq(this.w,-t.w)&&this.normal1.like(t.normal1.negated())}isParallelToPlane(t){return assertInst(P3$$1,t),eq(1,Math.abs(this.normal1.dot(t.normal1)))}isParallelToLine(t){return assertInst(L3$$1,t),eq0(this.normal1.dot(t.dir1))}isPerpendicularToLine(t){return assertInst(L3$$1,t),eq(1,Math.abs(this.normal1.dot(t.dir1)))}isPerpendicularToPlane(t){return assertInst(P3$$1,t),eq0(this.normal1.dot(t.normal1))}toSource(){return callsce("new P3",this.normal1,this.w)}translated(t){return new P3$$1(this.normal1,this.w+t.dot(this.normal1))}transform(t){const e=M4.transpose(M4.inverse(t,M4.temp0),M4.temp1),[s,r,n]=this.normal1,i=e.timesVector(VV(s,r,n,-this.w));return P3$$1.forABCD(i.x,i.y,i.z,i.w)}distanceToLine(t){return assertInst(L3$$1,t),this.isParallelToLine(t)?0:this.distanceToPoint(t.anchor)}containsPoint(t){return assertVectors(t),eq(this.w,this.normal1.dot(t))}containsLine(t){return assertInst(L3$$1,t),this.containsPoint(t.anchor)&&this.isParallelToLine(t)}distanceToPointSigned(t){return assertInst(V3,t),this.normal1.dot(t)-this.w}distanceToPoint(t){return assertInst(V3,t),Math.abs(this.normal1.dot(t)-this.w)}intersectionWithLine(t){return t.intersectionWithPlane(this)}intersectionWithPlane(t){if(assertInst(P3$$1,t),this.isParallelToPlane(t))return;const e=this.normal1,s=t.normal1,r=e.cross(s).unit(),n=M4.forRows(e,s,r).inversed().transformVector(new V3(this.w,t.w,0));return new L3$$1(n,r)}projectedPoint(t){return t.minus(this.normal1.times(t.minus(this.anchor).dot(this.normal1)))}projectedVector(t){return t.minus(this.normal1.times(t.dot(this.normal1)))}flipped(){return new P3$$1(this.normal1.negated(),-this.w)}containsCurve(t){if(t instanceof L3$$1)return this.containsLine(t);if(t instanceof EllipseCurve$$1||t instanceof HyperbolaCurve$$1||t instanceof ParabolaCurve$$1)return this.containsPoint(t.center)&&this.normal1.isParallelTo(t.normal);if(t instanceof BezierCurve$$1)return t.points.every(t=>this.containsPoint(t));throw new Error(""+t)}equals(t){return hasConstructor(t,P3$$1)&&this.normal1.equals(t.normal1)&&this.w==t.w}hashCode(){return 31*this.normal1.hashCode()|0+floatHashCode(this.w)}}P3$$1.YZ=new P3$$1(V3.X,0),P3$$1.ZX=new P3$$1(V3.Y,0),P3$$1.XY=new P3$$1(V3.Z,0);class Surface$$1 extends Transformable{static loopContainsPointGeneral(t,e,s,r){const n=P3$$1.normalOnAnchor(r,e),i=t.map(t=>t.colinearToLine(s));let o=!1;function a(t){const e=s.pointT(t);return!!eq0(e)||(e>0&&(o=!o),!1)}for(let o=0;o<t.length;o++){const c=t[o],h=(o+1)%t.length,u=t[h];if(i[o]){const t=s.pointT(c.a),e=s.pointT(c.b);if(Math.min(t,e)<=NLA_PRECISION&&-NLA_PRECISION<=Math.max(t,e))return PointVsFace.ON_EDGE;if(!(i[h]||dotCurve2$$1(u.curve,u.aT,r,sign(u.deltaT()))<0)&&a(c.b))return PointVsFace.ON_EDGE}else for(const t of c.edgeISTsWithPlane(n))if(t==c.bT){if(!s.containsPoint(c.b))continue;if(c.b.like(e))return PointVsFace.ON_EDGE;if(dotCurve2$$1(c.curve,c.bT,r,-sign(c.deltaT()))<0!=(i[h]||dotCurve2$$1(u.curve,u.aT,r,sign(u.deltaT()))<0)&&a(c.b))return PointVsFace.ON_EDGE}else if(t!=c.aT){const e=c.curve.at(t);if(!s.containsPoint(e))continue;if(a(e))return PointVsFace.ON_EDGE}}return o?PointVsFace.INSIDE:PointVsFace.OUTSIDE}static loopContainsPointEllipse(t,e,s,r){const n=s.normal,i=P3$$1.normalOnAnchor(s.normal,e),o=t.map(t=>s.isColinearTo(t.curve));let a=!1;void 0===r&&(r=s.pointT(e));const c=r;function h(t){const e=s.pointT(t);return!!eq(c,e)||(c<e&&le(e,PI)&&(a=!a),!1)}for(let r=0;r<t.length;r++){const a=t[r],c=(r+1)%t.length,u=t[c];if(o[r]){let t;if(a.curve.containsPoint(e)&&le(a.minT,t=a.curve.pointT(e))&&le(t,a.maxT))return PointVsFace.ON_EDGE;if(!(o[c]||dotCurve2$$1(u.curve,u.aT,n,sign(u.deltaT()))<0)&&s.containsPoint(a.b)&&h(a.b))return PointVsFace.ON_EDGE}else for(const t of a.edgeISTsWithPlane(i))if(t==a.bT){if(!s.containsPoint(a.b))continue;if(dotCurve2$$1(a.curve,a.bT,n,-sign(a.deltaT()))<0!=(o[c]||dotCurve2$$1(u.curve,u.aT,n,sign(u.deltaT()))<0)&&h(a.b))return PointVsFace.ON_EDGE}else if(t!=a.aT){const e=a.curve.at(t);if(!s.containsPoint(e))continue;if(h(e))return PointVsFace.ON_EDGE}}return a?PointVsFace.INSIDE:PointVsFace.OUTSIDE}toString(){return this.toSource()}toSource(t=(t=>t)){return callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}getExtremePoints(){return[]}isCurvesWithSurface(t){return t.isCurvesWithSurface(this)}containsCurve(t){if(t instanceof PPCurve$$1&&(this.equals(t.parametricSurface1)||this.equals(t.parametricSurface2)))return!0;if(t instanceof ImplicitCurve$$1){for(let e=ceil(t.tMin)+1;e<=floor(t.tMax)-1;e++)if(!this.containsPoint(t.points[e]))return!1;return!0}return!1}flipped2(t){return t?this.flipped():this}clipCurves(t){return t}equals(t){return this===t||this.constructor===t.constructor&&this.getConstructorParameters().equals(t.getConstructorParameters())}hashCode(){return this.getConstructorParameters().hashCode()}zDirVolume(t){return this.visit(ZDirVolumeVisitor$$1,t)}calculateArea(t){return this.visit(CalculateAreaVisitor$$1,t)}}var PointVsFace;!function(t){t[t.INSIDE=0]="INSIDE",t[t.OUTSIDE=1]="OUTSIDE",t[t.ON_EDGE=2]="ON_EDGE"}(PointVsFace||(PointVsFace={}));class ImplicitSurface$$1 extends Surface$$1{static is(t){return t.implicitFunction&&t.didp}}class ParametricSurface$$1 extends Surface$$1{constructor(t,e,s,r){super(),this.uMin=t,this.uMax=e,this.vMin=s,this.vMax=r,assertNumbers(t,e,s,r),assert(t<e),assert(s<r),assert((t=>t[t.length-4])(this.getConstructorParameters())==this.uMin,this.getConstructorParameters(),this.uMin)}static isCurvesParametricImplicitSurface(t,e,s,r=s,n){const i=t.pUVFunc(),o=e.implicitFunction(),a=t.dpdu(),c=t.dpdv(),h=e.didp.bind(e),u=MathFunctionR2R.forFFxFy((t,e)=>o(i(t,e)),(t,e)=>h(i(t,e)).dot(a(t,e)),(t,e)=>h(i(t,e)).dot(c(t,e)));return Curve$$1.breakDownIC(u,t,s,r,n,(t,s)=>e.containsPoint(i(t,s))).map(({points:s,tangents:r},i)=>PICurve$$1.forParametricPointsTangents(t,e,s,r,n))}static isCurvesParametricParametricSurface(t,e,s,r=s,n){return breakDownPPCurves$$1(t,e,s,r,n)}static is(t){return t.pUVFunc}pUV(t,e){return this.pUVFunc()(t,e)}pUVFunc(){return this.pUV.bind(this)}uvP(t){return this.uvPFunc()(t)}uvPFunc(){return this.uvP.bind(this)}bounds(t,e){return this.uMin<=t&&t<=this.uMax&&this.vMin<=e&&e<=this.vMax}boundsSigned(t,e){return min(t-this.uMin,this.uMax-t,e-this.vMin,this.vMax-e)}normalP(t){const e=this.uvPFunc()(t);return this.normalUV(e.x,e.y)}normalUVFunc(){return this.normalUV.bind(this)}normalUV(t,e){return this.normalUVFunc()(t,e)}parametersValid(t,e){return between(t,this.uMin,this.uMax)&&between(e,this.vMin,this.vMax)}toMesh(t=this.uStep,e=this.vStep){return assert(isFinite(this.vMin)&&isFinite(this.vMax)&&isFinite(this.uMin)&&isFinite(this.uMax)),assert(isFinite(t)&&isFinite(e)),Mesh.parametric(this.pUVFunc(),this.normalUVFunc(),this.uMin,this.uMax,this.vMin,this.vMax,ceil((this.uMax-this.uMin)/t),ceil((this.vMax-this.vMin)/e))}isCurvesWithImplicitSurface(t,e,s,r){return ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,e,s,r)}edgeLoopCCW(t){const e=this.uvPFunc();return isCCW(t.flatMap(t=>t.getVerticesNo0()).map(t=>e(t)),V3.Z)}like(t){if(!this.isCoplanarTo(t))return!1;const e=this.pUVFunc()(this.uMin,this.vMin),s=this.normalUVFunc()(this.uMin,this.vMin),r=t.normalP(e);return 0<s.dot(r)}getApproxAABB(){const t=new AABB;t.addPoints(this.getExtremePoints());const e=[V(0,0),V(0,1),V(1,0),V(1,1),V(.5,.5)].map(t=>this.pUV(lerp(this.uMin,this.uMax,t.x),lerp(this.vMin,this.vMax,t.y)));return t.addPoints(e),t}}class ConicSurface$$1 extends ParametricSurface$$1{constructor(t,e,s,r,n=0,i=PI,o=0,a=16){super(n,i,o,a),this.center=t,this.f1=e,this.f2=s,this.dir=r,assertVectors(t,e,s,r),assert(0<=o),this.matrix=M4.forSys(e,s,r,t),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.f1.cross(this.f2).dot(this.dir)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}pointFoot(t,e,s){if(void 0===e||void 0===s){const r=this.matrixInverse.transformPoint(t),n=r.angleXY();void 0===e&&(e=n<-PI/2?n+TAU:n),void 0===s&&(s=r.z+(r.lengthXY()-r.z)*SQRT1_2)}const{0:r,1:n}=newtonIterate(([e,s])=>{const r=this.pUV(e,s).to(t);return[this.dpdu()(e,s).dot(r),this.dpdv()(e).dot(r)]},[e,s]);return new V3(r,n,0)}get apex(){return this.center}static atApexThroughEllipse(t,e,s,r,n,i){return assertVectors(t),assertInst(EllipseCurve$$1,e),new ConicSurface$$1(t,e.f1,e.f2,t.to(e.center),s,r,n,i)}static unitISLineTs(t,e){const{x:s,y:r,z:n}=t,{x:i,y:o,z:a}=e,c=i*i+o*o-a*a;return pqFormula(2*(s*i+r*o-n*a)/c,(s*s+r*r-n*n)/c).filter(t=>0<n+t*a)}static unitISPlane(t,e,s){if(eq0(e)){if(assert(!eq0(t)),eq0(s))return[new L3$$1(V3.O,new V3(0,-SQRT1_2,-SQRT1_2),void 0,0),new L3$$1(V3.O,new V3(0,-SQRT1_2,SQRT1_2),0)];{const e=new V3(s/t,0,0),r=new V3(0,0,abs(s/t)),n=new V3(0,s/t,0);return[new HyperbolaCurve$$1(e,r,n)]}}{const r=t*t,n=e*e;if(eq0(s)){if(eq(r,n))return[new L3$$1(V3.O,new V3(e,0,-t).unit())];if(r<n)throw new Error("intersection is single point V3.O");if(r>n)return[new L3$$1(V3.O,new V3(e,sqrt(r-n),-t).unit()),new L3$$1(V3.O,new V3(e,-sqrt(r-n),-t).unit())]}else{if(eq(r,n)){const r=new V3(s/2/t,0,s/2/e),n=new V3(s/2/t,s/e,s/2/e),i=new V3(0,0,s/e).minus(r);return[new ParabolaCurve$$1(r,n.minus(r),i.z<0?i.negated():i)]}if(r<n){const i=new V3(-t*s/(n-r),0,s*e/(n-r));if(i.z<0)return[];const o=new V3(s/(t-e),0,-s/(t-e)),a=new V3(-t*s/(n-r),s/sqrt(n-r),s*e/(n-r));return[new EllipseCurve$$1(i,i.to(o),i.to(a),-PI,PI)]}if(r>n){const i=new V3(-t*s/(n-r),0,s*e/(n-r)),o=new V3(s*e/(r-n),0,-s*t/(r-n)),a=new V3(0,s/sqrt(r-n),0);return[new HyperbolaCurve$$1(i,o.z>0?o:o.negated(),a)]}}}throw new Error("???")}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)&&this.dir.equals(t.dir)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}getVectors(){return[{anchor:this.center,dir1:this.dir},{anchor:this.center.plus(this.dir),dir1:this.f1},{anchor:this.center.plus(this.dir),dir1:this.f2}]}getSeamPlane(){return P3$$1.forAnchorAndPlaneVectors(this.center,this.f1,this.dir)}loopContainsPoint(t,e){assertVectors(e);const s=this.center.like(e)?new L3$$1(e,this.matrix.transformVector(new V3(0,1,1)).unit()):L3$$1.throughPoints(e,this.apex),r=s.dir1.cross(this.dir);return Surface$$1.loopContainsPointGeneral(t,e,s,r)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.dir,this.uMin,this.uMax,this.vMin,this.vMax]}isTsForLine(t){const e=this.matrixInverse.transformPoint(t.anchor),s=this.matrixInverse.transformVector(t.dir1);return ConicSurface$$1.unitISLineTs(e,s)}isCoplanarTo(t){return this===t||!!(t instanceof ConicSurface$$1&&this.apex.like(t.apex))&&this.containsEllipse(new EllipseCurve$$1(t.center.plus(t.dir),t.f1,t.f2))}containsEllipse(t){const e=t.transform(this.matrixInverse);if(e.center.z<0)return!1;const{f1:s,f2:r}=e.rightAngled(),n=e.center.plus(s),i=e.center.plus(r);return eq(Math.pow(n.x,2)+Math.pow(n.y,2),Math.pow(n.z,2))&&eq(Math.pow(i.x,2)+Math.pow(i.y,2),Math.pow(i.z,2))&&(eq0(s.z)||eq0(r.z))}containsLine(t){const e=t.transform(this.matrixInverse),s=e.dir1;return e.containsPoint(V3.O)&&eq(s.x*s.x+s.y*s.y,s.z*s.z)}containsParabola(t){assertInst(ParabolaCurve$$1,t);const e=t.transform(this.matrixInverse);if(e.center.z<0||e.f2.z<0)return!1;const{center:s,f1:r,f2:n}=e.rightAngled();return eq(s.x*s.x+s.y*s.y,s.z*s.z)&&eq0(r.z)&&eq(n.x*n.x+n.y*n.y,n.z*n.z)}containsHyperbola(t){assertInst(HyperbolaCurve$$1,t);const e=t.transform(this.matrixInverse).rightAngled(),s=e.center.xy();if(s.likeO())return!1;const r=s.angleXY(),{center:n,f1:i,f2:o}=e.rotateZ(-r);return i.z>0&&eq(n.x,i.z)&&eq(n.z,i.x)&&eq0(n.y)&&eq0(i.y)&&eq(sqrt(abs(Math.pow(n.x,2)-Math.pow(n.z,2))),abs(o.y))&&eq0(o.x)&&eq0(o.z)}containsCurve(t){return t instanceof EllipseCurve$$1?this.containsEllipse(t):t instanceof L3$$1?this.containsLine(t):t instanceof HyperbolaCurve$$1?this.containsHyperbola(t):t instanceof ParabolaCurve$$1?this.containsParabola(t):super.containsCurve(t)}transform(t){return new ConicSurface$$1(t.transformPoint(this.center),t.transformVector(this.f1).times(t.isMirroring()?-1:1),t.transformVector(this.f2),t.transformVector(this.dir),this.uMin,this.uMax,this.vMin,this.vMax)}transform4(t){const e=t.timesVector(Vector.fromV3AndWeight(this.center,1)),s=t=>new EllipseCurve$$1(new V3(0,0,t),new V3(t,0,0),new V3(0,t,0));if(eq0(e.w)){const r=e.V3(),n=s(this.vMin).transform4(t.times(this.matrix)),i=M4.forSys(n.f1,n.f2,r.unit(),n.center).inversed(),o=s(this.vMax).transform4(i.times(t.times(this.matrix))).getAABB();return new CylinderSurface$$1(n,r.unit(),this.uMin,this.uMax,min(0,o.min.z,o.max.z),max(0,o.min.z,o.max.z))}{const e=t.transformPoint(this.center),r=t.transformVector2(this.f1,this.center).times(t.isMirroring()?-1:1),n=t.transformVector2(this.f2,this.center),i=t.transformVector2(this.dir,this.center),o=M4.forSys(r,n,i,e).inversed(),a=s(this.vMin).transform4(o.times(t.times(this.matrix))).getAABB().addAABB(s(this.vMax).transform4(o.times(t.times(this.matrix))).getAABB());return new ConicSurface$$1(e,r,n,i,this.uMin,this.uMax,a.min.z,a.max.z)}}flipped(){return new ConicSurface$$1(this.center,this.f1.negated(),this.f2,this.dir)}normalUVFunc(){const{f1:t,f2:e}=this,s=this.dir;return(r,n)=>e.cross(t).plus(e.cross(s.times(Math.cos(r)))).plus(s.cross(t.times(Math.sin(r)))).unit()}normalP(t){const e=this.matrixInverse.transformPoint(t);return this.normalUVFunc()(e.angleXY(),e.z)}pUVFunc(){return(t,e)=>{const s=new V3(e*cos(t),e*sin(t),e);return this.matrix.transformPoint(s)}}dpdu(){return(t,e)=>{const s=new V3(e*-sin(t),e*cos(t),0);return this.matrix.transformVector(s)}}dpdv(){return t=>{const e=new V3(cos(t),sin(t),1);return this.matrix.transformVector(e)}}implicitFunction(){return t=>{const e=this.matrixInverse.transformPoint(t),s=e.lengthXY();return this.normalDir*(s-e.z)}}didp(t){const e=this.matrixInverse.transformPoint(t);return this.pLCNormalWCMatrix.transformVector(e.xy().unit().withElement("z",-1).times(this.normalDir))}containsPoint(t){return eq0(this.implicitFunction()(t))}uvP(t){const e=this.matrixInverse.transformPoint(t),s=e.angleXY();return new V3(s<-PI/2?s+TAU:s,e.z,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):ImplicitSurface$$1.is(t)?ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/this.dir.length(),.02):super.isCurvesWithSurface(t)}getCenterLine(){return new L3$$1(this.center,this.dir)}isCurvesWithPlane(t){assertInst(P3$$1,t);const e=t.transform(this.matrixInverse),s=e.normal1,r=s.z,n=s.lengthXY(),i=e.w,o=M4.rotateZ(s.angleXY()),a=eq0(s.lengthXY())?this.matrix:this.matrix.times(o);return ConicSurface$$1.unitISPlane(n,r,i).flatMap(e=>{const s=e.transform(a);if(e instanceof EllipseCurve$$1){const t=e.transform(o),r=t.isTsWithPlane(P3$$1.ZX);return getIntervals(r,-PI,PI).filter(([e,s])=>t.at((e+s)/2).y>0).flatMap(([t,e])=>s.split(t,e))}const r=s.at(.2);return this.normalP(r).cross(t.normal1).dot(s.tangentAt(.2))>0?s:s.reversed()})}debugInfo(){return{ps:[this.center],lines:[this.center,this.center.plus(this.f1),this.center.plus(this.f2),this.center.plus(this.dir)]}}}ConicSurface$$1.UNIT=new ConicSurface$$1(V3.O,V3.X,V3.Y,V3.Z),ConicSurface$$1.prototype.uStep=PI/16,ConicSurface$$1.prototype.vStep=256;class ProjectedCurveSurface$$1 extends ParametricSurface$$1{constructor(t,e,s=t.tMin,r=t.tMax,n=-100,i=100){super(s,r,n,i),this.baseCurve=t,this.dir=e,assertInst(Curve$$1,t),assertInst(V3,e),assert(s<r),assert(n<i)}getConstructorParameters(){return[this.baseCurve,this.dir,this.uMin,this.uMax,this.vMin,this.vMax]}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.dir.equals(t.dir)&&this.baseCurve.equals(t.baseCurve)}hashCode(){return[this.dir,this.baseCurve].hashCode()}containsLine(t){return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor)}dpdu(){return(t,e)=>this.baseCurve.tangentAt(t)}dpdv(){return(t,e)=>this.dir}normalUV(t,e){return this.baseCurve.tangentAt(t).cross(this.dir).unit()}pUV(t,e){return this.baseCurve.at(t).plus(this.dir.times(e))}pointFoot(t,e){const s=new P3$$1(this.dir.unit(),0),r=this.baseCurve.project(s),n=s.projectedPoint(t),i=r.closestTToPoint(n,e,this.uMin,this.uMax),o=L3$$1.pointT(this.baseCurve.at(i),this.dir,t);return new V3(i,o,0)}uvPFunc(){const t=new P3$$1(this.dir.unit(),0),e=this.baseCurve.project(t);return s=>{const r=t.projectedPoint(s);assertNumbers(this.uMin);const n=e.pointT(r,this.uMin,this.uMax),i=L3$$1.pointT(this.baseCurve.at(n),this.dir,s);return new V3(n,i,0)}}isCurvesWithPlane(t){if(assertInst(P3$$1,t),this.dir.isPerpendicularTo(t.normal1)){return this.baseCurve.isTsWithPlane(t).map(e=>{const s=0<this.baseCurve.tangentAt(e).dot(t.normal1)?this.dir:this.dir.negated();return new L3$$1(this.baseCurve.at(e),s.unit())})}{let e=this.baseCurve.transform(M4.project(t,this.dir));return this.dir.dot(t.normal1)>0&&(e=e.reversed()),[e]}}isCurvesWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isCurvesWithPlane(t.plane);if(t instanceof ProjectedCurveSurface$$1){const e=t.dir;if(this.dir.isParallelTo(e)){return t.baseCurve.isTsWithSurface(this).map(s=>{const r=t.baseCurve.at(s),n=this.normalP(r).cross(t.normalP(r));return new L3$$1(r,e.times(sign(n.dot(e))))})}if(ImplicitSurface$$1.is(t)){let e=ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/t.dir.length(),.05);return e=t.clipCurves(e)}{let e=ParametricSurface$$1.isCurvesParametricParametricSurface(this,t,.05,.1/t.dir.length(),.05);return e=this.clipCurves(e),e=t.clipCurves(e)}}return t instanceof EllipsoidSurface$$1?t.isCurvesWithSurface(this):super.isCurvesWithSurface(t)}containsPoint(t){const e=this.uvPFunc()(t);return this.pUVFunc()(e.x,e.y).like(t)}containsCurve(t){if(t instanceof L3$$1)return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor);if(t instanceof ImplicitCurve$$1)return super.containsCurve(t);const e=new P3$$1(this.dir.unit(),0),s=this.baseCurve.project(e),r=t.project(e);return s.isColinearTo(r)}isCoplanarTo(t){return this==t||hasConstructor(t,ProjectedCurveSurface$$1)&&this.dir.isParallelTo(t.dir)&&this.containsCurve(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;const e=this.pUVFunc()(0,0),s=this.normalUVFunc()(0,0),r=t.normalP(e);return 0<s.dot(r)}loopContainsPoint(t,e){assertVectors(e),assert(isFinite(e.x),e.y,e.z);const s=new L3$$1(e,this.dir.unit()),r=this.uvPFunc()(e);isNaN(r.x)&&(console.log(this.sce,e.sce),assert(!1));const n=this.baseCurve.tangentAt(r.x).rejectedFrom(this.dir);return Surface$$1.loopContainsPointGeneral(t,e,s,n)}transform(t){const e=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform(t),t.transformVector(this.dir).times(e),this.uMin,this.uMax,1==e?this.vMin:-this.vMax,1==e?this.vMax:-this.vMin)}transform4(t){const e=t.vanishingPoint(this.dir);if(!e){const e=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform4(t),t.normalized().transformVector(this.dir).times(e),void 0,void 0,1==e?this.tMin:-this.tMax,1==e?this.tMax:-this.tMin)}const s=this.baseCurve.transform4(t);return s instanceof EllipseCurve$$1?(console.log(e.sce,s.sce),ConicSurface$$1.atApexThroughEllipse(e,t.isMirroring()?s:s.reversed(),this.sMin,this.sMax,1,2)):new PointProjectedSurface$$1(s,e,P3$$1.throughPoints(s.at(s.tMin),s.at((s.tMin+s.tMax)/2),s.at(s.tMax)),1,this.sMin,this.sMax,1,2)}isTsForLine(t){assertInst(L3$$1,t);const e=new P3$$1(this.dir.unit(),0),s=e.projectedVector(t.dir1);if(s.likeO())return[];const r=e.projectedPoint(t.anchor);return this.baseCurve.project(e).isInfosWithLine(r,s,this.uMin,this.uMax,t.tMin,t.tMax).map(t=>t.tOther)}flipped(){return new this.constructor(this.baseCurve,this.dir.negated(),this.uMin,this.uMax,-this.vMax,-this.vMin)}}ProjectedCurveSurface$$1.prototype.uStep=1/128,ProjectedCurveSurface$$1.prototype.vStep=256;class RotatedCurveSurface$$1 extends ParametricSurface$$1{constructor(t,e=M4.IDENTITY,s=0,r=PI,n=t.tMin,i=t.tMax){super(s,r,n,i),this.curve=t,this.matrix=e,assertInst(M4,e),assert(e.isNoProj()),assert(eq0(t.at(n).y)),this.matrixInverse=e.inversed(),this.vStep=this.curve.tIncrement}getConstructorParameters(){return[this.curve,this.matrix,this.uMin,this.uMax,this.vMin,this.vMax]}flipped(){return new RotatedCurveSurface$$1(this.curve,this.matrix.times(M4.mirror(P3$$1.YZ)),this.uMin,this.uMax,this.vMin,this.vMax)}transform(t){return new RotatedCurveSurface$$1(this.curve,t.isMirroring()?t.times(this.matrix).times(M4.mirror(P3$$1.YZ)):t.times(this.matrix),this.uMin,this.uMax,this.vMin,this.vMax)}containsPoint(t){const e=this.matrixInverse.transformPoint(t),s=e.lengthXY();return this.curve.containsPoint(new V3(s,0,e.z))}pUVFunc(){return(t,e)=>{const{x:s,z:r}=this.curve.at(e);return this.matrix.transformPoint(V3.polar(s,t,r))}}dpdu(){return(t,e)=>{const s=this.curve.at(e).x,r=new V3(s*-sin(t),s*cos(t),0);return this.matrix.transformVector(r)}}dpdv(){return(t,e)=>{const{x:s,z:r}=this.curve.tangentAt(e);return this.matrix.transformVector(V3.polar(s,t,r))}}normalUVFunc(){const t=this.matrix.inversed().transposed().as3x3(),e=this.matrix.isMirroring()?-1:1;return(s,r)=>{const{x:n,z:i}=this.curve.tangentAt(r);return t.transformVector(V3.polar(i,s,-n)).toLength(e)}}uvPFunc(){return t=>{const e=this.matrixInverse.transformPoint(t),s=EllipseCurve$$1.XYLCPointT(e,this.uMin,this.uMax),r=e.lengthXY();return new V3(s,this.curve.pointT(new V3(r,0,e.z)),0)}}pointFoot(t,e,s){const r=this.matrixInverse.transformPoint(t),n=abs(r.angleXY()),i=r.lengthXY();return new V3(n,this.curve.closestTToPoint(new V3(i,0,r.z)),0)}isTsForLine(t){const e=this.matrixInverse.transformPoint(t.anchor),s=this.matrixInverse.transformVector(t.dir1);if(s.isParallelTo(V3.Z))return fuzzyBetween(e.angleXY(),this.uMin,this.uMax)?this.curve.isInfosWithLine(new V3(e.lengthXY(),0,e.z),s).map(t=>t.tOther):[];if(L3$$1.containsPoint(e.xy(),s.xy(),V3.O)){const t=s.xy().unit();return[...this.curve.isInfosWithLine(new V3(t.dot(e),0,e.z),new V3(t.dot(s),0,s.z)),...this.curve.isInfosWithLine(new V3(-t.dot(e),0,e.z),new V3(-t.dot(s),0,s.z))].map(t=>t.tOther).filter(t=>fuzzyBetween(L3$$1.at(e,s,t).angleXY(),this.uMin,this.uMax))}if(s.isPerpendicularTo(V3.Z)){const t=this.isCurvesWithPlaneLC(new P3$$1(V3.Z,e.z));return t?t.flatMap(t=>t.isInfosWithLine(e,s).map(t=>t.tOther)):[]}{const t=-e.xy().dot(s.xy())/s.xy().squared(),r=L3$$1.at(e,s,t),n=r.lengthXY(),i=n*(s.z/s.lengthXY());return HyperbolaCurve$$1.XY.transform(M4.rotateX(90*DEG).scale(n,0,i).translate(0,0,r.z)).isInfosWithCurve(this.curve).map(t=>(t.p.z-e.z)/s.z).filter(t=>fuzzyBetween(L3$$1.at(e,s,t).angleXY(),this.uMin,this.uMax))}}isCurvesWithPlaneLC(t){return t.normal1.isParallelTo(V3.Z)?this.curve.isTsWithPlane(t).map(e=>{const{x:s}=this.curve.at(e);return new EllipseCurve$$1(new V3(0,0,t.w),new V3(s,0,0),new V3(0,s,0),this.uMin,this.uMax).transform(this.matrix)}):t.normal1.isPerpendicularTo(V3.Z)&&t.containsPoint(V3.O)?[this.curve.rotateZ(V3.Y.angleRelativeNormal(t.normal1,V3.Z)).transform(this.matrix)]:void 0}isCurvesWithPlane(t){const e=t.transform(this.matrixInverse),s=this.isCurvesWithPlaneLC(e);return s?s.map(t=>t.transform(this.matrix)):ParametricSurface$$1.isCurvesParametricImplicitSurface(this,new PlaneSurface$$1(t),.05,.05,.02)}loopContainsPoint(t,e){const s=this.matrixInverse.transformPoint(e),r=EllipseCurve$$1.XYLCPointT(s,this.uMin,this.uMax),n=EllipseCurve$$1.semicircle(s.lengthXY(),new V3(0,0,s.z)).transform(this.matrix);return Surface$$1.loopContainsPointEllipse(t,e,n,r)}isCoplanarTo(t){if(this===t)return!0;if(!hasConstructor(t,RotatedCurveSurface$$1))return!1;const e=this.matrixInverse.times(t.matrix);assert(!e.X.xy().likeO());const s=e.X.angleXY();return t.curve.transform(M4.rotateZ(-s).times(e)).isColinearTo(this.curve)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}containsCurve(t){if(t.constructor==this.curve.constructor){const e=t.transform(this.matrixInverse),s=[0,.5,1].map(t=>lerp(e.tMin,e.tMax,t)).withMax(t=>e.at(t).lengthXY()),r=e.at(s).angleXY(),n=e.rotateZ(-r);if(this.curve.isColinearTo(n))return!0}if(t instanceof EllipseCurve$$1){const e=t.transform(this.matrixInverse);return!!e.normal.isParallelTo(V3.Z)&&(e.isCircular()&&this.curve.containsPoint(new V3(e.f1.length(),0,e.center.z)))}return super.containsCurve(t)}getExtremePoints(){return getExtremePointsHelper$$1.call(this,this.curve)}asNURBSSurface(){const t=NURBS$$1.fromEllipse(this.curve),e=NURBS$$1.UnitCircle(2,this.tMin,this.tMax);return new NURBSSurface$$1(e.points.flatMap(e=>t.points.map(t=>this.matrix.timesVector(VV(e.x*t.x,e.y*t.x,t.z*e.w,e.w*t.w)))),t.knots,e.knots,t.degree,e.degree,t.tMin,t.tMax,e.tMin,e.tMax)}}function getExtremePointsHelper$$1(t){const e=this.matrix.X,s=this.matrix.Y;return[0,1,2].flatMap(r=>{const n=s.e(r),i=-e.e(r);return(eq0(n)&&eq0(i)?[[1,0]]:intersectionUnitCircleLine2$$1(n,i,0)).flatMap(([e,s])=>{const n=Math.atan2(s,e);return lt(this.uMin,n)&&lt(n,this.uMax)?t.transform(this.matrix.times(M4.rotateZ(n))).roots()[r].map(t=>this.pUV(n,t)):[]})})}RotatedCurveSurface$$1.prototype.uStep=EllipseCurve$$1.prototype.tIncrement;class CylinderSurface$$1 extends ProjectedCurveSurface$$1{constructor(t,e,s=t.tMin,r=t.tMax,n=-1/0,i=1/0){super(t,e,s,r,n,i),this.baseCurve=t,assertInst(EllipseCurve$$1,t),this.matrix=M4.forSys(t.f1,t.f2,e,t.center),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.baseCurve.normal.dot(this.dir)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.matrixInverse)}static semicylinder(t,e,s,r,n){return new CylinderSurface$$1(new EllipseCurve$$1(V3.O,new V3(t,0,0),new V3(0,t,0)),V3.Z,e,s,r,n)}static unitISLineTs(t,e){const{x:s,y:r}=t,{x:n,y:i}=e,o=Math.pow(n,2)+Math.pow(i,2),a=2*(s*n+r*i),c=Math.pow(s,2)+Math.pow(r,2)-1;return pqFormula(a/o,c/o).filter(t=>EllipseCurve$$1.XYLCValid(new V3(s+n*t,r+i*t,0)))}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(t).xy()).unit()}loopContainsPoint(t,e){if(assertVectors(e),!this.containsPoint(e))return OUTSIDE$$1;const s=new L3$$1(e,this.dir.unit()),r=this.dir.cross(this.normalP(e));return Surface$$1.loopContainsPointGeneral(t,e,s,r)}isTsForLine(t){assertInst(L3$$1,t);const e=this.matrixInverse.transformVector(t.dir1);if(e.isParallelTo(V3.Z))return[];const s=this.matrixInverse.transformPoint(t.anchor);return assert(!CylinderSurface$$1.unitISLineTs(s,e).length||!isNaN(CylinderSurface$$1.unitISLineTs(s,e)[0]),"sad "+e),CylinderSurface$$1.unitISLineTs(s,e)}isCoplanarTo(t){return this==t||hasConstructor(t,CylinderSurface$$1)&&this.dir.isParallelTo(t.dir)&&this.containsEllipse(t.baseCurve,!1)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsEllipse(t,e=!0){const s=t.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(s)}containsCurve(t){return t instanceof L3$$1?this.containsLine(t):t instanceof EllipseCurve$$1?this.containsEllipse(t):!(t instanceof BezierCurve$$1)&&super.containsCurve(t)}implicitFunction(){return t=>{return(this.matrixInverse.transformPoint(t).lengthXY()-1)*this.normalDir}}didp(t){const e=this.matrixInverse.transformPoint(t),s=e.lengthXY(),r=new V3(e.x/s,e.y/s,0);return this.pLCNormalWCMatrix.transformVector(r)}containsPoint(t){const e=this.matrixInverse.transformPoint(t);return this.baseCurve.isValidT(EllipseCurve$$1.XYLCPointT(e,this.uMin,this.uMax))}uvP(t){assert(1==arguments.length);const e=this.matrixInverse.transformPoint(t),s=EllipseCurve$$1.XYLCPointT(e,this.vMin,this.vMax);return new V3(s,e.z,0)}isCurvesWithSurface(t){if(t instanceof ProjectedCurveSurface$$1&&t.dir.isParallelTo(this.dir)){const e=t.baseCurve.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithCurve(e).map(e=>{const s=sign(this.normalP(e.p).cross(t.normalP(e.p)).dot(this.dir))||1;return new L3$$1(e.p,this.dir.times(s))})}if(t instanceof CylinderSurface$$1&&eq0(this.getCenterLine().distanceToLine(t.getCenterLine())))throw new Error;return super.isCurvesWithSurface(t)}getCenterLine(){return new L3$$1(this.baseCurve.center,this.dir)}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){let t=this.baseCurve.f1.cross(this.dir);return t=t.times(-sign(t.dot(this.baseCurve.f2))),P3$$1.normalOnAnchor(t,this.baseCurve.center)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}}CylinderSurface$$1.UNIT=new CylinderSurface$$1(EllipseCurve$$1.UNIT,V3.Z,void 0,void 0,0,1),CylinderSurface$$1.prototype.uStep=TAU/32,CylinderSurface$$1.prototype.vStep=256;class EllipsoidSurface$$1 extends ParametricSurface$$1{constructor(t,e,s,r,n=0,i=PI,o=-PI/2,a=PI/2){super(n,i,o,a),this.center=t,this.f1=e,this.f2=s,this.f3=r,assert(0<=n&&n<=PI),assert(0<=i&&i<=PI),assert(-PI/2<=o&&o<=PI/2),assert(-PI/2<=a&&a<=PI/2),assertVectors(t,e,s,r),this.matrix=M4.forSys(e,s,r,t),this.matrixInverse=this.matrix.inversed(),this.normalDir=sign(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.matrixInverse)}static unitArea(t){return t.map(t=>{if(t.curve instanceof PICurve$$1){const e=t.curve.calcSegmentPoints(t.aT,t.bT,t.a,t.b,t.aT>t.bT,!0);let s=0;for(let t=0;t<e.length-1;t++){const r=e[t],n=e[t+1];s+=(abs(r.angleXY())+abs(n.angleXY()))/2*(n.z-r.z)}return s}if(t.curve instanceof EllipseCurve$$1){return glqInSteps(e=>{const s=t.curve.at(e),r=t.curve.tangentAt(e);return abs(s.angleXY())*r.z},t.aT,t.bT,1)}throw new Error}).sum()}static unitISTsWithLine(t,e){const s=e.dot(e),r=2*t.dot(e),n=t.dot(t)-1;return pqFormula(r/s,n/s).filter(s=>le(0,t.y+s*e.y))}static unitISCurvesWithPlane(t){const e=Math.abs(t.w);if(lt(e,1)){const s=Math.sqrt(1-Math.pow(e,2)),r=t.normal1.y*t.w,n=abs(e*s);if(le(r,-n)&&!eq0(e))return[];if(le(r,0)&&!t.normal1.isParallelTo(V3.Y)){const e=t.normal1.isParallelTo(V3.Y)?V3.Z:t.normal1.cross(V3.Y).toLength(s),n=e.cross(t.normal1),i=-r/n.y,o=max(0,Math.asin(i));return[new EllipseCurve$$1(t.anchor,e,n,o,PI-o)]}{const e=(t.normal1.isParallelTo(V3.Y)?V3.X:t.normal1.cross(V3.Y)).toLength(s),n=e.cross(t.normal1),i=eq0(n.y)?-1:-r/n.y,o=Math.acos(max(-1,i-NLA_PRECISION));return[new EllipseCurve$$1(t.anchor,n.negated(),e,PI-o,PI),new EllipseCurve$$1(t.anchor,n,e.negated(),0,o)]}}return[]}static unitISCurvesWithEllipsoidSurface(t){if(t.isSphere()){const e=t.f1.length(),s=t.center.length();if(le(1,s-e)||le(s+e,1)||le(s-e,-1))return[];{const r=2*function(t,e,s){const r=(t+e+s)/2;return sqrt(r*(r-t)*(r-e)*(r-s))}(1,e,s)/s,n=sign(1+Math.pow(s,2)-Math.pow(e,2))*sqrt(1-Math.pow(r,2)),i=new P3$$1(t.center.unit(),n);return EllipsoidSurface$$1.unitISCurvesWithPlane(i.flipped())}}throw new Error}static unitISCurvesWithCylinderSurface(t){if(new L3$$1(t.baseCurve.center,t.dir).containsPoint(V3.O)){const e=t.baseCurve.transform(M4.project(new P3$$1(t.dir,0))),s=e.f1.length(),r=e.f2.length();if(lt(1,min(s,r)))return[];if(e.isCircular()){const r=Math.sqrt(1-Math.pow(min(1,s),2)),n=(t.dir.y<0?t.dir.negated():t.dir).times(r);return[new EllipseCurve$$1(n,e.f1,e.f2)]}}throw new Error}static sphere(t,e=V3.O){return assertNumbers(t),new EllipsoidSurface$$1(e,new V3(t,0,0),new V3(0,t,0),new V3(0,0,t))}static forABC(t,e,s,r=V3.O){return new EllipsoidSurface$$1(r,new V3(t,0,0),new V3(0,e,0),new V3(0,0,s))}static calculateAreaSpheroid(t,e,s,r){assertf(()=>t.isPerpendicularTo(e)),assertf(()=>e.isPerpendicularTo(s)),assertf(()=>s.isPerpendicularTo(t));const n=M4.forSys(t,e,s).inversed(),i=t.length(),o=s.unit();return r.map(t=>{if(t.curve instanceof EllipseCurve$$1){return glqInSteps(e=>{const s=t.curve.at(e),r=t.tangentAt(e),a=n.transformPoint(s);return a.angleXY()*i*Math.sqrt(1+Math.pow(a.z,2))*Math.sqrt(1+Math.pow(o.dot(r),2))},t.aT,t.bT,1)}throw new Error}).sum()}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3,this.uMin,this.uMax,this.vMin,this.vMax]}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}edgeLoopCCW(t){return EllipsoidSurface$$1.unitArea(t.map(t=>t.transform(this.matrixInverse)))>0}like(t){return!!this.isCoplanarTo(t)&&this.matrix.determinant3()*t.matrix.determinant3()>0}rootPoints(){}toMesh(){return ParametricSurface$$1.prototype.toMesh.call(this)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}dpdu(){return(t,e)=>this.matrix.transformVector(new V3(cos(e)*-sin(t),cos(e)*cos(t),0))}dpdv(){return(t,e)=>this.matrix.transformVector(new V3(-sin(e)*cos(t),-sin(e)*sin(t),cos(e)))}isCurvesWithPCS(t){let e=ParametricSurface$$1.isCurvesParametricImplicitSurface(t,this,.1,.1/t.dir.length(),.05);return e=this.clipCurves(e)}isCurvesWithPCSSmart(t){const e=t.transform(this.matrixInverse),s=e.baseCurve.project(new P3$$1(e.dir,0)),r=s.isTsWithSurface(EllipsoidSurface$$1.UNIT),n=getIntervals(r,s.tMin,s.tMax).filter(([t,e])=>s.at((t+e)/2).length()<1),i=[0,1].map(t=>r=>{const n=snap(s.at(r).squared(),1),i=sqrt(1-n);return eq0(i)?s.at(r):s.at(r).plus(e.dir.times(sign(t-.5)*i))}),o=[0,1].map(t=>r=>{const n=snap(s.at(r).squared(),1),i=s.at(r).times(-1/sqrt(1-n)).dot(s.tangentAt(r));return s.tangentAt(r).plus(e.dir.times(sign(t-.5)*i))}),a=[];for(const[e,s]of n)for(const r of[0,1]){const n=t=>i[r](t).y,c=t=>o[r](t).y;checkDerivate(n,c,e+.1,s-.1);const h=getRoots(n,e+NLA_PRECISION,s-NLA_PRECISION,1/2048,c),u=getIntervals(h,e,s).filter(([t,e])=>n((t+e)/2)>0);for(const[e,s]of u){let n=i[r](e),o=i[r](s);0===r&&([n,o]=[o,n]),assert(EllipsoidSurface$$1.UNIT.containsPoint(n)),assert(EllipsoidSurface$$1.UNIT.containsPoint(o)),a.push(PICurve$$1.forStartEnd(t,this,this.matrix.transformPoint(o),this.matrix.transformPoint(n),void 0))}}return t.clipCurves(a)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$$1)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface$$1)return this.isCurvesWithCylinderSurface(t);if(t instanceof EllipsoidSurface$$1){const e=t.transform(this.matrixInverse),s=EllipsoidSurface$$1.unitISCurvesWithEllipsoidSurface(e).map(t=>t.transform(this.matrix));return t.clipCurves(s)}if(t instanceof ProjectedCurveSurface$$1)return this.isCurvesWithPCS(t);if(t instanceof ParametricSurface$$1){let e=ParametricSurface$$1.isCurvesParametricImplicitSurface(t,this,.1,.1,.05);return e=this.clipCurves(e),e=t.clipCurves(e)}throw new Error}isCurvesWithPlane(t){const e=t.transform(this.matrixInverse);return EllipsoidSurface$$1.unitISCurvesWithPlane(e).map(t=>t.transform(this.matrix))}isCurvesWithCylinderSurface(t){if(L3$$1.containsPoint(t.baseCurve.center,t.dir,this.center)){assert(this.isSphere());const e=t.baseCurve.transform(M4.project(t.baseCurve.getPlane(),t.dir));if(e.isCircular()){const t=this.f1.length(),s=e.f1.length();eq(t,s),assert(!1)}}return this.isCurvesWithPCS(t)}isTsForLine(t){assertInst(L3$$1,t);const e=this.matrixInverse.transformPoint(t.anchor),s=this.matrixInverse.transformVector(t.dir1);return EllipsoidSurface$$1.unitISTsWithLine(e,s)}isCoplanarTo(t){if(this===t)return!0;if(!hasConstructor(t,EllipsoidSurface$$1))return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&eq(this.f1.length(),this.f2.length());const e=this.matrixInverse.times(t.matrix);return e.like3x3()&&e.isOrthogonal()}containsEllipse(t){const e=t.transform(this.matrixInverse),s=e.center.length(),r=Math.sqrt(1-Math.pow(s,2));return lt(s,1)&&e.isCircular()&&e.f1.hasLength(r)}containsCurve(t){return t instanceof EllipseCurve$$1?this.containsEllipse(t):super.containsCurve(t)}transform(t){return assert(t.isNoProj(),()=>t.sce),new EllipsoidSurface$$1(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3).times(t.isMirroring()?-1:1))}transform4(t){console.log("transform4");const e=t.times(this.matrix);console.log(e.toString());const s=V(e.m[12],e.m[13],e.m[14]),r=this.pLCNormalWCMatrix.inversed().transformPoint(s),n=r.angleXY(),i=Math.asin(clamp(r.z,-1,1)),o=e.transformPoint(s.unit()),a=e.transformPoint(s.unit().negated()),c=V3.lerp(o,a,.5);return console.log(s.sce,n,i,o,a,"newCenter",c.sce),new EllipsoidSurface$$1(c,t.transformVector2(this.f1,this.center),t.transformVector2(this.f2,this.center),t.transformVector2(this.f3,this.center).times(t.isMirroring()?-1:1))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new EllipsoidSurface$$1(this.center,this.f1,this.f2,this.f3.negated(),this.uMin,this.uMax,-this.vMax,-this.vMin)}normalUVFunc(){return(t,e)=>{const{f1:s,f2:r,f3:n}=this;return r.cross(n).times(Math.cos(e)*Math.cos(t)).plus(n.cross(s).times(Math.cos(e)*Math.sin(t))).plus(s.cross(r).times(Math.sin(e))).unit()}}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.matrixInverse.transformPoint(t)).unit()}normalUV(t,e){return this.pLCNormalWCMatrix.transformVector(V3.sphere(t,e)).unit()}uvPFunc(){return t=>{const e=this.matrixInverse.transformPoint(t),s=abs(e.angleXY()),r=Math.asin(clamp(e.z,-1,1));return assert(isFinite(s)),assert(isFinite(r)),new V3(s,r,0)}}pUVFunc(){return(t,e)=>this.matrix.transformPoint(V3.sphere(t,e))}isSphere(){return eq(this.f1.length(),this.f2.length())&&eq(this.f2.length(),this.f3.length())&&eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}mainAxes(){const{f1:t,f2:e,f3:s}=this;if(eq0(t.dot(e))&&eq0(e.dot(s))&&eq0(s.dot(t)))return this;const{U:r,SIGMA:n}=this.matrix.svd3();assert(n.isDiagonal()),assert(r.isOrthogonal());const i=r.times(n),[o,a,c]=arrayFromFunction(3,t=>new V3(i.m[t],i.m[t+4],i.m[t+8]));return new EllipsoidSurface$$1(this.center,o,a,c)}containsPoint(t){return eq0(this.implicitFunction()(t))}boundsFunction(){return(t,e)=>between(t,0,PI)&&between(e,-PI,PI)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,e){if(!this.containsPoint(e))return PointVsFace.OUTSIDE;assertVectors(e),assert(Edge$$1.isLoop(t));const s=this.matrixInverse.transformPoint(e).xy(),r=new EllipseCurve$$1(this.center,this.f3,s.likeO()?this.f2:this.matrix.transformVector(s.unit()));return P3$$1.normalOnAnchor(this.f2.unit(),this.center).containsPoint(e)?t.some(t=>t.curve.containsPoint(e)&&fuzzyBetween(t.curve.pointT(e),t.minT,t.maxT))?PointVsFace.ON_EDGE:PointVsFace.OUTSIDE:Surface$$1.loopContainsPointEllipse(t,e,r)}surfaceAreaApprox(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),n=1.6075;return 4*PI*Math.pow((Math.pow(e*s,n)+Math.pow(s*r,n)+Math.pow(r*e,n))/3,1/n)}surfaceArea(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),[n,i,o]=[e,s,r].sort(MINUS);function a(t,e){if(e<t){const s=1-Math.pow(e,2)/Math.pow(t,2),r=Math.sqrt(s);return 2*PI*Math.pow(t,2)*(1+(1-s)/Math.sqrt(r)*Math.atanh(r))}{const s=Math.sqrt(1-Math.pow(t,2)/Math.pow(e,2));return 2*PI*Math.pow(t,2)*(1+e/t/s*Math.asin(s))}}if(eq(o,i))return a(o,n);if(eq(i,n))return a(i,o);if(eq(n,o))return a(n,i);const c=Math.acos(n/o),h=Math.pow(o,2)*(Math.pow(i,2)-Math.pow(n,2))/(Math.pow(i,2)*(Math.pow(o,2)-Math.pow(n,2))),u=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),-.5),0,c),l=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),.5),0,c);return(2*PI*Math.pow(n,2)+2*PI*o*i/Math.sin(c))*(l*Math.pow(Math.sin(c),2)+u*Math.pow(Math.cos(c),2))}getSeamPlane(){const t=P3$$1.forAnchorAndPlaneVectors(this.center,this.f1,this.f3);return t.normal1.dot(this.f2)<0?t:t.flipped()}getExtremePoints(){return getExtremePointsHelper$$1.call(this,new EllipseCurve$$1(V3.O,V3.X,V3.Z,-PI/2,PI/2))}pointFoot(t,e,s){if(console.log(t.sce),void 0===e||void 0===s){let r=this.matrixInverse.transformPoint(t).unit();r.y<0&&(r=r.negated()),({x:e,y:s}=EllipsoidSurface$$1.UNIT.uvP(r))}const r=this.dpdu(),n=this.dpdv(),[i,o]=newtonIterate(([e,s])=>{const i=this.pUV(e,s);console.log([i,i.plus(r(e,s)),i,i.plus(n(e,s))].map(toSource).join()+",");const o=this.pUV(e,s).to(t);return[o.dot(r(e,s)),o.dot(n(e,s))]},[e,s],8,void 0,.1);return new V3(i,o,0)}implicitFunction(){return t=>{return(this.matrixInverse.transformPoint(t).length()-1)*this.normalDir}}didp(t){const e=this.matrixInverse.transformPoint(t);return this.pLCNormalWCMatrix.transformVector(e.unit())}static unitTransform4(t){1!==t.m[15]&&(t=t.divScalar(t.m[15]));const e=new M4(1,0,0,0,0,1,0,0,0,0,1,0,-t.m[12],-t.m[13],-t.m[14],1),s=new V3(t.m[12],t.m[13],t.m[14]),r=t.m[15],n=Math.pow(r,2)-s.squared();if(lt(n,0))throw new Error("vanishing plane intersects unit sphere");const i=s.div(-n),o=(s.times(r*s.length()/(s.squared()*-n)),r/-n),a=1/sqrt(n),c=M4.forSys(s.unit(),s.getPerpendicular().unit());return M4.product(t,e,M4.translate(i),c,M4.scale(o,a,a),c.transposed())}}EllipsoidSurface$$1.UNIT=new EllipsoidSurface$$1(V3.O,V3.X,V3.Y,V3.Z),EllipsoidSurface$$1.prototype.uStep=PI/32,EllipsoidSurface$$1.prototype.vStep=PI/32;class PlaneSurface$$1 extends ParametricSurface$$1{constructor(t,e=t.normal1.getPerpendicular().unit(),s=t.normal1.cross(e).unit(),r=-100,n=100,i=-100,o=100){super(r,n,i,o),this.plane=t,this.right=e,this.up=s,assertInst(P3$$1,t),assert(this.right.cross(this.up).like(this.plane.normal1)),this.matrix=M4.forSys(e,s,t.normal1,t.anchor)}toSource(t=(t=>t)){return callsce.call(void 0,"new PlaneSurface",...this.getConstructorParameters())}static throughPoints(t,e,s){return new PlaneSurface$$1(P3$$1.throughPoints(t,e,s))}static forAnchorAndPlaneVectors(t,e,s,r,n,i,o){return new PlaneSurface$$1(P3$$1.forAnchorAndPlaneVectors(t,e,s),e,s,r,n,i,o)}isCoplanarTo(t){return hasConstructor(t,PlaneSurface$$1)&&this.plane.isCoplanarToPlane(t.plane)}isTsForLine(t){return t.isTsWithPlane(this.plane)}like(t){return hasConstructor(t,PlaneSurface$$1)&&this.plane.like(t.plane)}pUV(t,e){return this.matrix.transformPoint(new V3(t,e,0))}implicitFunction(){return t=>this.plane.distanceToPointSigned(t)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){const e=this.plane.intersectionWithPlane(t);return e?[e]:[]}edgeLoopCCW(t){return assert(Edge$$1.isLoop(t),"isLoop"),isCCW(t.flatMap(t=>t.points()),this.plane.normal1)}loopContainsPoint(t,e){const s=this.right.plus(this.up.times(.123)).unit(),r=new L3$$1(e,s),n=s.cross(this.plane.normal1);return Surface$$1.loopContainsPointGeneral(t,e,r,n)}uvPFunc(){const t=this.matrix.inversed();return function(e){return t.transformPoint(e)}}pointFoot(t){return this.uvP(t)}normalP(t){return this.plane.normal1}containsPoint(t){return this.plane.containsPoint(t)}containsCurve(t){return t instanceof ImplicitCurve$$1?super.containsCurve(t):this.plane.containsCurve(t)}transform(t){return new PlaneSurface$$1(this.plane.transform(t))}transform4(t){return new PlaneSurface$$1(this.plane.transform(t))}flipped(){return new PlaneSurface$$1(this.plane.flipped(),this.right,this.up.negated())}getConstructorParameters(){return[this.plane,this.right,this.up,this.uMin,this.uMax,this.vMin,this.vMax]}dpdu(){return()=>this.right}dpdv(){return()=>this.up}didp(t){return this.plane.normal1}normalUV(){return this.plane.normal1}}PlaneSurface$$1.prototype.uStep=1e6,PlaneSurface$$1.prototype.vStep=1e6;class PointProjectedSurface$$1 extends ParametricSurface$$1{constructor(t,e,s,r=1,n=t.tMin,i=t.tMax,o=0,a=16){super(n,i,o,a),this.curve=t,this.apex=e,this.curvePlane=s,this.normalDir=r,assertInst(Curve$$1,t),assert(!(t instanceof L3$$1),"use PlaneSurface instead"),assert(!(t instanceof EllipseCurve$$1),"use ConicSurface instead"),assert(!(t instanceof ImplicitCurve$$1),"this just seems like a terrible idea"),assert(new PlaneSurface$$1(s).containsCurve(t)),assertVectors(e),assert(0<=o),this.planeProjectionMatrix=M4.projectPlanePoint(e,s),this.uStep=t.tIncrement}pointFoot(t,e,s){void 0!==e&&void 0!==s||(void 0===e&&(e=t.like(this.apex)?0:this.curve.closestTToPoint(this.planeProjectionMatrix.transformPoint(t))*this.normalDir),void 0===s&&(s=V3.inverseLerp(this.apex,this.curve.at(e),t)));const{0:r,1:n}=newtonIterate(([e,s])=>{const r=this.pST(e,s).to(t);return[this.dpds()(e,s).dot(r),this.dpdt()(e).dot(r)]},[e,s]);return new V3(r,n,0)}getConstructorParameters(){return[this.curve,this.apex,this.curvePlane,this.normalDir,this.sMin,this.sMax,this.tMin,this.tMax]}static unitISLineTs(t,e){const{x:s,y:r,z:n}=t,{x:i,y:o,z:a}=e,c=i*i+o*o-a*a;return pqFormula(2*(s*i+r*o-n*a)/c,(s*s+r*r-n*n)/c).filter(t=>0<n+t*a)}equals(t){return this==t||hasConstructor(t,PointProjectedSurface$$1)&&this.curve.equals(t.curve)&&this.apex.equals(this.apex)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}loopContainsPoint(t,e){assertVectors(e);const s=this.apex.like(e)?new L3$$1(e,this.apex.to(this.curve.at(this.curve.tMin)).unit()):L3$$1.throughPoints(e,this.apex),r=s.dir1.cross(this.curvePlane.normal1);return Surface$$1.loopContainsPointGeneral(t,e,s,r)}isTsForLine(t){const e=this.planeProjectionMatrix.transformPoint(t.anchor),s=this.planeProjectionMatrix.transformPoint(t.anchor.plus(t.dir1));return e.like(s)?[]:this.curve.isInfosWithLine(e,e.to(s),void 0,void 0,t.tMin,t.tMax).map(t=>t.tOther)}isCoplanarTo(t){return this===t||!!(t instanceof PointProjectedSurface$$1&&this.apex.like(t.apex))&&this.containsCurve(t.curve)}containsLine(t){if(this.curvePlane.isParallelToLine(t))return!1;if(!t.containsPoint(this.apex))return!1;const e=this.curvePlane.intersectionWithLine(t);return this.curve.containsPoint(e)}containsCurve(t){if(t instanceof L3$$1)return this.containsLine(t);if(t instanceof ImplicitCurve$$1)return super.containsCurve(t);{const e=t.transform(this.planeProjectionMatrix);return this.curve.isColinearTo(e)}}transform(t){return new PointProjectedSurface$$1(this.curve.transform(t),t.transformPoint(this.apex),this.curvePlane.transform(t),(t.isMirroring()?-1:1)*this.normalDir,this.sMin,this.sMax,this.tMin,this.tMax)}flipped(){return new PointProjectedSurface$$1(this.curve,this.apex,this.curvePlane,-this.normalDir,-this.sMax,-this.sMin,this.tMin,this.tMax)}normalSTFunc(){const t=this.dpdt();return(e,s)=>this.curve.tangentAt(e*this.normalDir).times(this.normalDir).cross(t(e)).unit()}pSTFunc(){return(t,e)=>this.apex.lerp(this.curve.at(t*this.normalDir),e)}dpds(){return(t,e)=>this.curve.tangentAt(t*this.normalDir).times(e*this.normalDir)}dpdt(){return t=>this.apex.to(this.curve.at(t*this.normalDir))}containsPoint(t){return this.apex.like(t)||this.curve.containsPoint(this.planeProjectionMatrix.transformPoint(t))}stP(t){const e=t.like(this.apex)?0:this.curve.pointT(this.planeProjectionMatrix.transformPoint(t)),s=V3.inverseLerp(this.apex,this.curve.at(e),t);return new V3(e*this.normalDir,s,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$$1?this.isCurvesWithPlane(t.plane):ImplicitSurface$$1.is(t)?ParametricSurface$$1.isCurvesParametricImplicitSurface(this,t,.1,.1/this.curvePlane.distanceToPoint(this.apex),.02):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){return t.containsPoint(this.apex)?t.isParallelToPlane(this.curvePlane)?[]:this.curve.isTsWithPlane(t).map(t=>L3$$1.throughPoints(this.apex,this.curve.at(t))):[this.curve.transform(M4.projectPlanePoint(this.apex,t))]}}PointProjectedSurface$$1.prototype.vStep=256;class NURBSSurface$$1 extends ParametricSurface$$1{constructor(t,e,s,r,n,i=e[r],o=e[e.length-r-1],a=s[n],c=s[s.length-n-1]){super(i,o,a,c),this.points=t,this.knotsU=e,this.knotsV=s,this.degreeU=r,this.degreeV=n;const h=e.length-1-r,u=s.length-1-n;assert(h*u==t.length),assert(r<=n,"degreeU <= degreeV"),assert(-1==e.firstUnsorted(MINUS),"knot values must be in ascending order"),assert(-1==s.firstUnsorted(MINUS),"knot values must be in ascending order")}getConstructorParameters(){return[this.points,this.knotsU,this.knotsV,this.degreeU,this.degreeV,this.uMin,this.uMax,this.vMin,this.vMax]}transform(t){return this.transform4(t)}transform4(t){return new NURBSSurface$$1(this.points.map(e=>t.timesVector(e)),this.knotsU,this.knotsV,this.degreeU,this.degreeV,this.uMin,this.uMax,this.vMin,this.vMax)}pUV(t,e){return this.isoparametricU(t).at(e)}dpdu(){return(t,e)=>this.isoparametricV(e).tangentAt(t)}dpdv(){return(t,e)=>this.isoparametricU(t).tangentAt(e)}normalUV(t,e){const s=this.dpdu()(t,e).cross(this.dpdv()(t,e));return s.likeO()?V3.X:s.unit()}isoparametricU(t){const e=this.knotsU.length-1-this.degreeU,s=this.knotsV.length-1-this.degreeV;return new NURBS$$1(arrayFromFunction(s,s=>deBoor(this.points.slice(s*e,(s+1)*e),this.degreeU,this.knotsU,t)),this.degreeV,this.knotsV,this.vMin,this.vMax)}isoparametricV(t){const e=this.knotsU.length-1-this.degreeU;return new NURBS$$1(arrayFromFunction(e,s=>deBoor(this.points.sliceStep(s,this.points.length,e,1),this.degreeV,this.knotsV,t)),this.degreeU,this.knotsU,this.uMin,this.uMax)}debugInfo(){const t=this.knotsU.length-1-this.degreeU,e=this.knotsV.length-1-this.degreeV,s=[];for(let r=0;r<t;r++)for(let n=0;n<e;n++){const i=n*t+r;if(r<t-1){const e=n*t+r+1;s.push(this.points[i].p3(),this.points[e].p3())}if(n<e-1){const e=(n+1)*t+r;s.push(this.points[i].p3(),this.points[e].p3())}}return{points:this.points.map(t=>t.p3()),lines:s}}flipped(){const t=this.knotsU.length-1-this.degreeU;return new NURBSSurface$$1(arrayFromFunction(this.points.length,e=>{const s=e%t;return this.points[e-s+(t-s-1)]}),this.knotsU.map(t=>-t).reverse(),this.knotsV,this.degreeU,this.degreeV,-this.uMax,-this.uMin,this.vMin,this.vMax)}}function getInterval(t,e,s){for(let r=t;r<e.length-1-t;r++)if(s>=e[r]&&s<=e[r+1])return r;throw new Error(s+" "+e)}function deBoor(t,e,s,r){const n=getInterval(e,s,r),i=Vector.pack(t,new Float64Array(4*t.length));for(let t=1;t<=e;t++)for(let o=n;o>n-e-1+t;o--){const n=(r-s[o])/(s[o+e+1-t]-s[o]);for(let t=0;t<4;t++)i[4*o+t]=(1-n)*i[4*(o-1)+t]+n*i[4*o+t]}return new Vector(i.slice(4*n,4*n+4))}NURBSSurface$$1.prototype.uStep=1/8,NURBSSurface$$1.prototype.vStep=1/8;const ZDirVolumeVisitor$$1={[ConicSurface$$1.name](t){console.log(this);const e=this.dpdu(),s=this.dpdv(),r=t.map(t=>{const r=t.curve;if(r instanceof EllipseCurve$$1||r instanceof HyperbolaCurve$$1||r instanceof ParabolaCurve$$1){return glqInSteps(t=>{const n=r.at(t),i=r.tangentAt(t),o=this.uvP(n),a=-M4.forSys(e(o.x,o.y),s(o.x)).inversed().transformVector(i).x,c=Math.pow(o.y,3)/3*(this.pUV(o.x,1).z-this.center.z)+Math.pow(o.y,2)/2*this.center.z;return e(o.x,c).cross(s(o.x)).z*a},t.aT,t.bT,1)}if(r instanceof L3$$1)return 0;throw new Error}).sum(),n=t.map(t=>{const r=t.curve;if(r instanceof EllipseCurve$$1||r instanceof HyperbolaCurve$$1||r instanceof ParabolaCurve$$1){return glqV3$$1(t=>{const n=r.at(t),i=r.tangentAt(t),o=this.uvP(n),a=this.pUV(o.x,1).minus(this.center),c=V3.add(a.times(.25*Math.pow(o.y,4)*a.z+1/3*Math.pow(o.y,3)*this.center.z),this.center.times(1/3*Math.pow(o.y,3)*a.z+.5*Math.pow(o.y,2)*this.center.z)).times(e(o.x,1).cross(s(o.x)).z),h=-M4.forSys(e(o.x,o.y),s(o.x)).inversed().transformVector(i).x;return c.times(h)},t.aT,t.bT)}if(r instanceof L3$$1)return V3.O;throw new Error});return{volume:r,centroid:V3.add(...n).schur(new V3(1,1,.5)).div(r)}},[PlaneSurface$$1.name](t){const e=this.right,s=this.up,r=this.plane.anchor;return assert(e.hasLength(1)),assert(s.hasLength(1)),assert(e.isPerpendicularTo(s)),mergeVolumeAndCentroidZX2Parts(t.map(t=>{const n=t.curve;if(n instanceof L3$$1){function i(t,e,s){const r=e.minus(t),n=s.minus(t),i=r.cross(n);return[V3.add(t,e,s).div(3).z*i.z/2,V3.add(t.times(2*t.z+e.z+s.z),e.times(t.z+2*e.z+s.z),s.times(t.z+e.z+2*s.z)).times(i.z)]}const s=t.a,r=t.b,n=s.dot(e),o=r.dot(e),a=this.pUV(n,0),c=this.pUV(o,0),[h,u]=i(s,r,a),[l,f]=i(c,a,r);return[h+l,u.plus(f).div(24)]}if(n instanceof ImplicitCurve$$1)throw new Error;{const i=t=>{const i=n.at(t),o=i.dot(e),a=i.dot(s),c=a*r.z+o*a*e.z+.5*Math.pow(a,2)*s.z,h=-n.tangentAt(t).dot(e);return[c*h,...V3.add(r.times(c),e.times(r.z*o*a+e.z*Math.pow(o,2)*a+.5*o*Math.pow(a,2)*s.z),s.times(.5*r.z*Math.pow(a,2)+.5*e.z*o*Math.pow(a,2)+1/3*Math.pow(a,3)*s.z)).times(h)]},[o,a,c,h]=glqArray$$1(i,t.aT,t.bT,4);return[o*this.plane.normal1.z,new V3(a,c,h).times(this.plane.normal1.z)]}}))},[ParametricSurface$$1.name](t){const e=this.dpdu(),s=this.dpdv();return mergeVolumeAndCentroidZX2Parts(t.map(t=>{const r=t.curve;if(r instanceof ImplicitCurve$$1)throw new Error;{const n=t=>{const n=r.at(t),i=r.tangentAt(t),o=this.uvP(n),a=glqInSteps(t=>{const r=this.pUV(o.x,t),n=e(o.x,t).cross(s(o.x,t));return r.z*n.z},0,o.y,1),c=-M4.forSys(e(o.x,o.y),s(o.x,o.y)).inversed().transformVector(i).x;return[a*c,...glqV3$$1(t=>{const r=this.pUV(o.x,t),n=e(o.x,t).cross(s(o.x,t));return r.times(r.z*n.z)},0,o.y).times(c).toArray()]},[i,o,a,c]=glqArray$$1(n,t.aT,t.bT,4);return[i,new V3(o,a,c)]}}))},[ProjectedCurveSurface$$1.name](t){if(V3.Z.cross(this.dir).likeO())return{volume:0,centroid:V3.O};const e=this.dir.toLength(Math.sign(this.dir.z)||1),s=V3.Z.cross(e).unit(),r=e.rejectedFrom(V3.Z).unit();return mergeVolumeAndCentroidZX2Parts(t.map(t=>{if(t.curve instanceof L3$$1)return[0,V3.O];if(t.curve instanceof ImplicitCurve$$1)return[0,V3.O];{const n=n=>{const i=t.curve.at(n),o=t.curve.tangentAt(n),a=i.rejectedFrom1(e),c=i.z*a.to(i).dot(r)/2+a.z*a.to(i).dot(r)/2,h=V3.add(i.xy(),a,i).times(i.z*a.to(i).dot(r)/2/3),u=V3.add(i.xy(),a,a.xy()).times(a.z*a.to(i).dot(r)/2/3),l=o.dot(s);return[c*l,...h.plus(u).times(l).schur(V(1,1,2))]},[i,o,a,c]=glqArray$$1(n,t.aT,t.bT,4);return[i,new V3(o,a,c)]}}))},[RotatedCurveSurface$$1.name](t){const e=this.dpdu(),s=this.dpdv(),r=t.map(t=>{const r=t.curve;return gaussLegendreQuadrature24(t=>{const n=r.at(t),i=r.tangentAt(t),o=this.uvP(n),a=this.matrixInverse.transformPoint(n),c=this instanceof RotatedCurveSurface$$1?this.curve.tangentAt(o.y):V(-a.z,0,a.lengthXY()),h=a.lengthXY(),u=a.z,l=c.x,f=c.z,p=this.matrix.X.z*h,d=this.matrix.Y.z*h,m=this.matrix.Z.z*u+this.matrix.O.z,$=(this.matrix.X.x*this.matrix.Y.y-this.matrix.X.y*this.matrix.Y.x)*h*l,g=(this.matrix.Y.x*this.matrix.X.y-this.matrix.Y.y*this.matrix.X.x)*h*l,v=(this.matrix.X.x*this.matrix.X.y-this.matrix.X.y*this.matrix.X.x)*h*l,P=(this.matrix.Y.x*this.matrix.Y.y-this.matrix.Y.y*this.matrix.Y.x)*h*l,C=(this.matrix.Y.x*this.matrix.Z.y-this.matrix.Y.y*this.matrix.Z.x)*h*f,x=(this.matrix.X.x*this.matrix.Z.y-this.matrix.X.y*this.matrix.Z.x)*h*f,M=M4.forSys(e(o.x,o.y),s(o.x,o.y)).inversed().transformVector(i).y;return(t=>(6*(m*(-$+g)+p*C-d*x)*t+3*(3*d*$-d*g+p*(v-P)+4*m*x)*cos(t)+3*(3*p*g-p*$-d*(v-P)+4*m*C)*sin(t)+3*(p*x-d*C+m*(v-P))*cos(2*t)+3*(p*C+d*x+m*($+g))*sin(2*t)+(p*(v-P)-d*($+g))*cos(3*t)+(p*($+g)+d*(v-P))*sin(3*t))/12)(o.x)*M},t.aT,t.bT)}).sum(),n=t.map(t=>{return glqV3$$1(r=>{const n=t.curve,i=n.at(r),o=n.tangentAt(r),a=this.uvP(i),c=glqV3$$1(t=>{const r=this.pUV(t,a.y),n=e(t,a.y).cross(s(t,a.y));return r.times(r.z*n.z)},0,a.x),h=M4.forSys(e(a.x,a.y),s(a.x,a.y)).inversed().transformVector(o).y;return c.times(h)},t.aT,t.bT)});return{volume:r,centroid:V3.add(...n).schur(new V3(1,1,.5)).div(r)}}};function glqV3$$1(t,e,s){return gaussLegendre24Xs.reduce((r,n,i)=>{const o=e+(n+1)/2*(s-e);return r.plus(t(o).times(gaussLegendre24Weights[i]))},V3.O).times((s-e)/2)}function glqArray$$1(t,e,s,r=3){const n=new Array(r).fill(0);for(let i=0;i<24;i++){const o=t(e+(gaussLegendre24Xs[i]+1)/2*(s-e));for(let t=0;t<r;t++)n[t]+=o[t]*gaussLegendre24Weights[i]}for(let t=0;t<r;t++)n[t]*=(s-e)/2;return n}function mergeVolumeAndCentroidZX2Parts(t){const e=t.reduce((t,[e])=>t+e,0);return{volume:e,centroid:V3.add(...t.map(([,t])=>t)).schur(new V3(1,1,.5)).div(e)}}ZDirVolumeVisitor$$1[EllipsoidSurface$$1.name]=ZDirVolumeVisitor$$1[RotatedCurveSurface$$1.name];const CalculateAreaVisitor$$1={[ConicSurface$$1.name](t){const e=this.dpdu(),s=this.dpdv();return t.map(t=>{if(t.curve instanceof EllipseCurve$$1||t.curve instanceof HyperbolaCurve$$1||t.curve instanceof ParabolaCurve$$1){return glqInSteps(r=>{const n=t.curve.at(r),i=t.tangentAt(r),o=this.uvP(n),a=-M4.forSys(e(o.x,o.y),s(o.x)).inversed().transformVector(i).x;return e(o.x,Math.pow(o.y,2)/2).cross(s(o.x)).length()*a},t.aT,t.bT,1)}if(t.curve instanceof L3$$1)return 0;throw new Error}).sum()*this.normalDir},[PlaneSurface$$1.name](t){let e=0;const s=this.right,r=this.up;for(const i of t){let t;const o=i.curve;if(o instanceof L3$$1)t=(i.a.dot(r)+i.b.dot(r))/2*i.b.to(i.a).dot(s);else if(o instanceof EllipseCurve$$1){const{f1:e,f2:a,center:c}=o,h=r.dot(e),u=r.dot(a),l=r.dot(c),f=s.dot(e),p=s.dot(a);function n(t){return.25*(2*(-u*f+h*p)*t+4*l*f*cos(t)+4*l*p*sin(t)+(h*f-u*p)*cos(2*t)+(u*f+h*p)*sin(2*t))}t=-(n(i.bT)-n(i.aT))}else{if(o instanceof ImplicitCurve$$1)throw new Error("implement for implicitCurve");{const e=r;assertf(()=>e.hasLength(1)),t=glqInSteps(t=>{const e=o.at(t),n=o.tangentAt(t);return s.dot(n)*r.dot(e)},i.aT,i.bT,3)}}e+=t}return assert(isFinite(e)),e},[RotatedCurveSurface$$1.name](t,e=!0){const s=this.matrix.X,r=this.matrix.Y,n=this.matrix.Z,i=eq(s.length(),r.length())&&s.isPerpendicularTo(r)&&r.isPerpendicularTo(n)&&n.isPerpendicularTo(s);return t.map((t,e)=>{console.log("edge",e,t.sce);const s=t.curve;if(t.curve instanceof ImplicitCurve$$1)throw new Error;if(i){return glqInSteps(t=>{const e=s.at(t),r=s.tangentAt(t),n=this.matrixInverse.transformPoint(e),{x:i,y:o}=this.uvP(e);return i*this.matrix.transformVector(n.xy()).length()*this.dpdv()(i,o).unit().dot(r)},t.aT,t.bT,1)}{const e=this.dpdu(),r=this.dpdv();return glqInSteps(t=>{const n=s.at(t),i=s.tangentAt(t),o=this.uvP(n),a=M4.forSys(e(o.x,o.y),r(o.x,o.y)).inversed().transformVector(i).y;return glqInSteps(t=>e(t,o.y).cross(r(t,o.y)).length(),0,o.x,1)*a},t.aT,t.bT,1)}}).sum()},[ProjectedCurveSurface$$1.name](t){const e=this.dir.unit(),s=t.map(t=>{if(t.curve instanceof L3$$1)return 0;if(t.curve instanceof ImplicitCurve$$1){const{points:s,tangents:r}=t.curve,n=t.minT,i=t.maxT;let o=0;const a=ceil(n+NLA_PRECISION),c=floor(i-NLA_PRECISION);for(let t=a;t<=c;t++){const n=s[t],i=r[t],a=this.normalP(n).cross(e).unit().dot(i);o+=n.dot(e)*a}const h=s=>{const r=t.curve.at(s),n=t.curve.tangentAt(s),i=this.normalP(r).cross(e).unit().dot(n);return r.dot(e)*i};return o+=h(n)*(a-n-.5),(o+=h(i)*(i-c-.5))*sign(t.deltaT())}{const s=glqInSteps(s=>{const r=t.curve.at(s),n=t.tangentAt(s).rejected1Length(e);return r.dot(e)*n},t.aT,t.bT,1),r=Math.sign(this.normalP(t.a).cross(this.dir).dot(t.curve.tangentAt(t.aT)));return assert(0!==r),s*r}}).sum();return console.log("totalArea",s),s}};function projectCurve$$1(t,e,s){if(t instanceof L3$$1){const r=e.cross(t.dir1).toLength(s?-1:1);return new PlaneSurface$$1(P3$$1.normalOnAnchor(r,t.anchor))}if(t instanceof EllipseCurve$$1){const r=s?e:e.negated();return new CylinderSurface$$1(t,r.unit(),void 0,void 0)}if(t instanceof BezierCurve$$1||t instanceof XiEtaCurve$$1){const r=e.times(s?1:-1);return new ProjectedCurveSurface$$1(t,r,void 0,void 0,s?0:-1,s?1:0)}throw new Error}function projectPointCurve$$1(t,e=t.tMin,s=t.tMax,r,n){if(t instanceof L3$$1){const n=t.anchor.to(r).rejectedFrom(t.dir1);return PlaneSurface$$1.forAnchorAndPlaneVectors(t.anchor,t.dir1,n.unit(),e,s,0,n.length())}if(t instanceof EllipseCurve$$1){const i=-1*(n?-1:1);return new ConicSurface$$1(r,t.f1.times(i),t.f2,r.to(t.center),e,s,0,1)}throw new Error("projectPointCurve not implemented for "+t.constructor.name)}function rotateCurve$$1(t,e=t.tMin,s=t.tMax,r,n){if(assertf(()=>new PlaneSurface$$1(P3$$1.ZX).containsCurve(t)),t instanceof L3$$1){if(t.dir1.isParallelTo(V3.Z)){if(eq0(t.anchor.x))return;const i=new EllipseCurve$$1(V3.O,t.anchor.xy(),t.anchor.xy().getPerpendicular(),0,r),o=(t.dir1.z>0?-1:1)*(n?-1:1),[a,c]=[t.at(e).z*o,t.at(s).z*o].sort(MINUS);return new CylinderSurface$$1(i,V3.Z.times(o),0,r,a,c)}if(t.at(e).xy().dot(t.dir1)*t.at(s).xy().dot(t.dir1)<0)throw new Error("line cannot cross the Z axis in the [tMin, tMax] interval, as conic surfaces cannot have an hourglass shape.");if(t.dir1.isPerpendicularTo(V3.Z)){const r=(t.at(lerp(e,s,.5)).dot(t.dir1)>0?1:-1)*(n?-1:1);return new PlaneSurface$$1(new P3$$1(V3.Z.times(r),t.anchor.z*r))}{const i=t.at(e),o=t.at(s),a=i.z-i.x*(o.z-i.z)/(o.x-i.x),c=new V3(0,0,a),h=-(i.x>o.x?-1:1)*(n?-1:1),u=new ConicSurface$$1(c,new V3(t.dir1.lengthXY(),0,0),new V3(0,t.dir1.lengthXY(),0),new V3(0,0,(i.x>o.x?-1:1)*t.dir1.z),0,r,0,1);return h>0?u:u.flipped()}}if(t instanceof EllipseCurve$$1){const r=t.at(e),i=t.at(s),o=t.rightAngled(),a=o.f1.isPerpendicularTo(V3.Z),c=o.f2.isPerpendicularTo(V3.Z);if(L3$$1.Z.containsPoint(o.center)&&(a||c)){n=n==r.z>i.z;let t=o.f1.length(),e=o.f2.length();return o.f1.isParallelTo(V3.Z)&&([t,e]=[e,t]),EllipsoidSurface$$1.forABC(t,(n?-1:1)*t,e,o.center)}return new RotatedCurveSurface$$1(t,M4.IDENTITY,e,s)}throw new Error}var B2T;CalculateAreaVisitor$$1[EllipsoidSurface$$1.name]=CalculateAreaVisitor$$1[RotatedCurveSurface$$1.name],function(t){function e(e,s=P3$$1.XY,r=V3.Z,n="extrude"+getGlobalId$$1(),i,o){e=a(e),assertf(()=>Edge$$1.isLoop(e));const c=new Map,h=new PlaneSurface$$1(s),u=M4.translate(r),l=e.map(t=>t.transform(u,"top")),f=e.length,p=o&&o.extrudeBottom(h,e),d=new PlaneFace$$1(h,e,[],n+"Bottom",p),m=l.map(t=>t.flipped()).reverse(),$=new PlaneSurface$$1(s.flipped().translated(r)),g=o&&o.extrudeBottom($,m),v=new PlaneFace$$1($,m,[],n+"Top",g);e.forEach(e=>t.registerVertexName(c,e.name+"A",e.a)),m.forEach(e=>t.registerVertexName(c,e.name+"A",e.a));const P=arrayFromFunction(f,t=>StraightEdge$$1.throughPoints(e[t].a,l[t].a,n+"Rib"+t)),C=e.map((t,s)=>{const i=n+"Wall"+s,a=(s+1)%f,c=[e[s].flipped(),P[s],l[s],P[a].flipped()],h=projectCurve$$1(t.curve,r,t.reversed),u=o&&o.extrudeWall(s,h,c);return Face$$1.create(h,c,void 0,i,u)});return C.push(d,v),i=i||callsce("B2T.extrudeEdges",e,s,r,n),new BRep$$1(C,s.normal1.dot(r)>0,i,c)}function s(t=1,e="sphere"+getGlobalId$$1(),s=TAU){const n=PCurveEdge$$1.create(new EllipseCurve$$1(V3.O,new V3(0,0,-t),new V3(t,0,0)),new V3(0,0,-t),new V3(0,0,t),0,PI,void 0,new V3(t,0,0),new V3(-t,0,0)),i=callsce("B2T.sphere",t,e,s);return r([StraightEdge$$1.throughPoints(n.b,n.a),n],s,e,i)}function r(t,e,s="rotateEdges"+getGlobalId$$1(),r,n){assert(t.every(t=>new PlaneSurface$$1(P3$$1.ZX).containsCurve(t.curve))),assert(!eq(PI,e)||PI==e),assertf(()=>lt(0,e)&&le(e,TAU)),e=snap(e,TAU),assertf(()=>Edge$$1.isLoop(t));const i=new PlaneSurface$$1(P3$$1.ZX.flipped()).edgeLoopCCW(t)?new PlaneSurface$$1(P3$$1.ZX.flipped()):new PlaneSurface$$1(P3$$1.ZX),o=!eq(e,2*PI),a=t.map(t=>{const e=t.a,s=e.lengthXY();if(!eq0(s))return new EllipseCurve$$1(V(0,0,e.z),V(s,0,0),V(0,s,0))}),c=t.map((t,e)=>{const s=rotateCurve$$1(t.curve,t.minT,t.maxT,PI,t.deltaT()>0),r=lerp(t.aT,t.bT,.5);return s&&assert(t.tangentAt(r).cross(V3.Y).dot(s.normalP(t.curve.at(r)))<0),s});let h,u=t;const l=[];for(let r=0;r<e;r+=PI){const i=0,o=min(e-r,PI),f=M4.rotateZ(r+o);h=r+o==TAU?t:t.map(t=>t.transform(f));const p=arrayFromFunction(t.length,t=>{const e=u[t].a,n=e.lengthXY(),c=h[t].a;if(!eq0(n)){const n=0===r?a[t]:a[t].rotateZ(r);return new PCurveEdge$$1(n,e,c,i,o,void 0,n.tangentAt(i),n.tangentAt(o),s+"rib"+t)}});for(let e=0;e<t.length;e++)if(c[e]){const i=u[e],o=(e+1)%t.length,a=[u[e].flipped(),!eq0(i.a.x)&&p[e],h[e],!eq0(i.b.x)&&p[o].flipped()].filter(t=>t),f=0===r?c[e]:c[e].rotateZ(r),d=n&&n.extrudeWall(e,f,a,void 0);l.push(Face$$1.create(f,a,void 0,s+"Wall"+e,d))}u=h}if(o){const r=Edge$$1.reversePath(h),o=n&&n.rotationStart(i,t,void 0),a=n&&n.rotationEnd(i.flipped().rotateZ(e),r,void 0);l.push(new PlaneFace$$1(i,t,void 0,s+"start",o),new PlaneFace$$1(i.flipped().rotateZ(e),r,void 0,s+"end",a))}const f=new PlaneSurface$$1(P3$$1.ZX).edgeLoopCCW(t);return new BRep$$1(l,f,r)}t.box=function(e=1,s=1,r=1,n="box"+getGlobalId$$1()){assertNumbers(e,s,r),assert("string"==typeof n);const i=[new V3(0,0,0),new V3(0,s,0),new V3(e,s,0),new V3(e,0,0)],o=callsce("B2T.box",e,s,r,n);return t.extrudeVertices(i,P3$$1.XY.flipped(),new V3(0,0,r),n,o)},t.puckman=function(e,s,r,n="puckman"+getGlobalId$$1()){assertf(()=>lt(0,e)),assertf(()=>lt(0,s)&&le(s,TAU)),assertf(()=>lt(0,r));const i=StraightEdge$$1.chain([V3.O,new V3(e,0,0),new V3(e,0,r),new V3(0,0,r)],!0);return t.rotateEdges(i,s,n)},t.registerVertexName=function(t,e,s){Array.from(t.keys()).some(t=>t.like(s))||t.set(s,e)},t.extrudeEdges=e,t.cylinder=function(t=1,e=1,s=TAU,n="cylinder"+getGlobalId$$1()){const i=[new V3(0,0,0),new V3(t,0,0),new V3(t,0,e),new V3(0,0,e)];return r(StraightEdge$$1.chain(i,!0),s,n)},t.cone=function(t=1,e=1,s=TAU,n="cone"+getGlobalId$$1()){const i=[new V3(0,0,0),new V3(t,0,e),new V3(0,0,e)];return r(StraightEdge$$1.chain(i,!0),s,n)},t.sphere=s,t.menger=function(e=2,s="menger"+getGlobalId$$1()){let r=t.box(1,1,1);if(0==e)return r;const n=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped();function i(t,e){if(r=r.and(n.transform(e)),t>1){const s=e.times(M4.scale(1/3,1/3,1));for(let e=0;e<9;e++)4!=e&&i(t-1,s.times(M4.translate(e%3,e/3|0,0)))}}return i(e,M4.IDENTITY),i(e,M4.YZX),i(e,M4.ZXY),r},t.menger2=function(e=2,s="menger"+getGlobalId$$1()){if(0==e)return t.box(1,1,1);const r=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped(),n=[];!function t(e,s){if(n.push(...r.transform(s).faces),e>1){const r=s.times(M4.scale(1/3,1/3,1));for(let s=0;s<9;s++)4!=s&&t(e-1,r.times(M4.translate(s%3,s/3|0,0)))}}(e,M4.IDENTITY);const i=new BRep$$1(n,!0);return t.box().and(i).and(i.transform(M4.YZX)).and(i.transform(M4.ZXY))},t.torus=function(e,s,r=TAU,n="torus"+getGlobalId$$1()){assertNumbers(e,s,r),assertf(()=>s>e);const i=[EllipseCurve$$1.semicircle(e,new V3(s,0,0)),EllipseCurve$$1.semicircle(-e,new V3(s,0,0))].map(t=>PCurveEdge$$1.forCurveAndTs(t,0,Math.PI).rotateX(PI/2));return t.rotateEdges(i,r,n)},t.rotateEdges=r,t.quaffle=function(){const e=t.sphere(1).translate(0,1.7).flipped(),s=new BRep$$1(t.TETRAHEDRON_VERTICES.flatMap(t=>e.rotateAB(V3.Y,t).faces),!1);return t.sphere().and(s)},t.extrudeFace=function(t,s){return new BRep$$1(e(t.contour,t.surface.plane,s).faces.slice(0,-2).concat(t,t.translate(s.x,s.y,s.z).flipped(),t.holes.flatMap(r=>e(r,t.surface.plane.flipped(),s).faces.slice(0,-2))),!1)},t.loadFonts=function(){return i("fonts/FiraSansMedium.woff").then(e=>t.defaultFont=e)};const n=new Map;function i(t){return new Promise(function(e,s){const r=n.get(t);r?e(r):load(t,function(r,i){r?s(r):(n.set(t,i),e(i))})})}function o(e,s,r=1,n=t.defaultFont){const i=[];n.getPath(e,0,0,s).commands.forEach(t=>{"M"==t.type&&i.push([]),i.last.push(t)});const o=i.map(t=>{const e=new Path;e.commands=t;const s=Edge$$1.reversePath(Edge$$1.pathFromSVG(e.toPathData(13))).map(t=>t.mirrorY());return assert(Edge$$1.isLoop(s)),s}),a=Face$$1.assembleFacesFromLoops(o,new PlaneSurface$$1(P3$$1.XY),PlaneFace$$1),c=callsce("B2T.text",e,s,r);return BRep$$1.join(a.map(e=>t.extrudeFace(e,V(0,0,-r))),c)}function a(t){return t.flatMap(t=>{const e=t.curve;if(e instanceof EllipseCurve$$1&&e.tMin===-PI&&e.tMax===PI){return(t.minT<0&&t.maxT>0?t.split(0):[t]).map(t=>t.minT>=0?Edge$$1.create(new EllipseCurve$$1(e.center,e.f1,e.f2,max(0,e.tMin),e.tMax),t.a,t.b,t.aT,t.bT,void 0,t.aDir,t.bDir,t.name):Edge$$1.create(new EllipseCurve$$1(e.center,e.f1.negated(),e.f2.negated(),e.tMin+PI,min(PI,e.tMax+PI)),t.a,t.b,t.aT+PI,t.bT+PI,void 0,t.aDir,t.bDir,t.name))}return e instanceof BezierCurve$$1&&t.a.like(t.b)?t.split(lerp(t.aT,t.bT,.5)):t})}t.loadFont=i,t.loadFontsAsync=function(e){t.defaultFont?e():load("fonts/FiraSansMedium.woff",function(s,r){if(s)throw new Error("Could not load font: "+s);t.defaultFont=r,e()})},t.text=o,t.minorityReport=function(){const e=t.sphere(),s=t.text("LEO CROW",64,128).scale(.1/32).translate(-.5,-.05,1.2).flipped(),r=t.sphere(.98);return e.and(s).plus(r)},t.whatever=function(){const t=f(),e=BRep$$1.join(t.faces.map((t,e)=>{const s=o(""+(e+1),.4,-2),r=t.contour.map(t=>t.a).reduce((t,e)=>t.plus(e),V3.O).div(3),n=M4.forSys(t.contour[0].aDir,r.cross(t.contour[0].aDir),r.unit(),r);return s.transform(n.times(M4.translate(-s.getAABB().size().x/2,-.1,-.04)))})),r=s(.9);return t.and(r).and(e)},t.whatever3=function(){const e=t.torus(1,2);return t.box(5,5,2).translate(-2.5,-2.5).minus(e)},t.d20=function(){const t=f(),e=BRep$$1.join(t.faces.map((t,e)=>{const s=o(""+(e+1),.4,-2),r=t.contour.map(t=>t.a).reduce((t,e)=>t.plus(e),V3.O).div(3),n=M4.forSys(t.contour[0].aDir,r.cross(t.contour[0].aDir),r.unit(),r);return s.transform(n.times(M4.translate(-s.getAABB().size().x/2,-.1,-.04)))})),r=s(.9);return t.and(r).and(e)},t.rotStep=function(t,e,s){const r="number"==typeof e?arrayFromFunction(s,t=>(t+1)/s*e):e,n=r.length,i=!eq(TAU,r.last),o=[t,...r.map(e=>{if(eq(TAU,e))return t;const s=M4.rotateZ(e);return t.map(t=>t.transform(s))})],a=arrayFromFunction(n,e=>{const s=(e+1)%(n+1);return arrayFromFunction(t.length,r=>{if(!eq0(t[r].a.lengthXY()))return StraightEdge$$1.throughPoints(o[e][r].a,o[s][r].a)})}),c=[];let h;if(t.forEach((e,s)=>{const u=(s+1)%t.length;if(e instanceof StraightEdge$$1&&e.curve.dir1.isPerpendicularTo(V3.Z)){const t=e.a.x>e.b.x,r=new PlaneSurface$$1(t?new P3$$1(V3.Z,e.a.z):new P3$$1(V3.Z.negated(),-e.a.z));if(i){const t=[];eq0(e.a.x)||t.push(...arrayFromFunction(n,t=>a[t][s])),t.push(o[n][s]),eq0(e.b.x)||t.push(...arrayFromFunction(n,t=>a[n-t-1][u].flipped())),t.push(e.flipped()),h=new PlaneFace$$1(r,t)}else{const i=arrayFromFunction(n,t?t=>a[t][s]:t=>a[n-t-1][u].flipped());let o;t&&!eq0(e.b.x)?o=arrayFromFunction(n,t=>a[n-t-1][u].flipped()):t||eq0(e.a.x)||(o=arrayFromFunction(n,t=>a[t][s])),h=new PlaneFace$$1(r,i,o?[o]:[])}c.push(h)}else if(!(e instanceof StraightEdge$$1&&eq0(e.a.lengthXY())&&eq0(e.b.lengthXY())))for(let i=0;i<n;i++){const h=(i+1)%(n+1),l=[o[i][s].flipped(),a[i][s],o[h][s],a[i][u]&&a[i][u].flipped()].filter(t=>t);let f;if(e instanceof StraightEdge$$1)f=new PlaneSurface$$1(P3$$1.throughPoints(l[0].a,l[1].a,l[2].a));else{const e=t[s].getAABB().max.x,n=r[i],a=0==i?0:r[i-1],c=V3.polar(e,a).to(V3.polar(e,n));f=projectCurve$$1(o[i][s].curve,c,!1)}c.push(Face$$1.create(f,l))}}),i){const e=o[n].map(t=>t.flipped()).reverse(),s=new PlaneFace$$1(new PlaneSurface$$1(P3$$1.ZX.rotateZ(r.last)),e);c.push(new PlaneFace$$1(new PlaneSurface$$1(P3$$1.ZX.flipped()),t),s)}return new BRep$$1(c,new PlaneSurface$$1(P3$$1.ZX).edgeLoopCCW(t))},t.fixEdges=a,t.extrudeVertices=function(e,s,r,n,i){assert(e.every(t=>t instanceof V3),"baseVertices.every(v => v instanceof V3)"),assertInst(P3$$1,s),assertVectors(r),s.normal1.dot(r)>0&&(s=s.flipped());const o=StraightEdge$$1.chain(e,!0);return i=i||callsce("B2T.extrudeVertices",e,s,r,n),t.extrudeEdges(o,s,r,n,i)},t.tetrahedron=function(t,e,s,r,n="tetra"+getGlobalId$$1()){assertVectors(t,e,s,r);const i=P3$$1.throughPoints(t,e,s).distanceToPointSigned(r);if(eq0(i))throw new Error("four points are coplanar");i>0&&([s,r]=[r,s]);const o=StraightEdge$$1.throughPoints(t,e),a=StraightEdge$$1.throughPoints(t,s),c=StraightEdge$$1.throughPoints(t,r),h=StraightEdge$$1.throughPoints(e,s),u=StraightEdge$$1.throughPoints(e,r),l=StraightEdge$$1.throughPoints(s,r),f=[new PlaneFace$$1(PlaneSurface$$1.throughPoints(t,e,s),[o,h,a.flipped()],[],n+"abc"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(t,r,e),[c,u.flipped(),o.flipped()],[],n+"adb"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(e,r,s),[u,l.flipped(),h.flipped()],[],n+"bdc"),new PlaneFace$$1(PlaneSurface$$1.throughPoints(s,r,t),[l,c.flipped(),a],[],n+"cda")],p=callsce("B2T.tetrahedron",t,e,s,r);return new BRep$$1(f,!1,p)};const c=1/GOLDEN_RATIO,h=2-GOLDEN_RATIO;t.TETRAHEDRON_VERTICES=[new V3(1,0,-SQRT1_2),new V3(-1,0,-SQRT1_2),new V3(0,-1,SQRT1_2),new V3(0,1,SQRT1_2)].map(t=>t.unit()),t.DODECAHEDRON_VERTICES=[new V3(h,0,1),new V3(-h,0,1),new V3(-c,c,c),new V3(0,1,h),new V3(c,c,c),new V3(c,-c,c),new V3(0,-1,h),new V3(-c,-c,c),new V3(h,0,-1),new V3(-h,0,-1),new V3(-c,-c,-c),new V3(0,-1,-h),new V3(c,-c,-c),new V3(c,c,-c),new V3(0,1,-h),new V3(-c,c,-c),new V3(1,h,0),new V3(-1,h,0),new V3(-1,-h,0),new V3(1,-h,0)].map(t=>t.unit()),t.DODECAHEDRON_FACE_VERTICES=[[4,3,2,1,0],[7,6,5,0,1],[12,11,10,9,8],[15,14,13,8,9],[14,3,4,16,13],[3,14,15,17,2],[11,6,7,18,10],[6,11,12,19,5],[4,0,5,19,16],[12,8,13,16,19],[15,9,10,18,17],[7,1,2,17,18]],t.OCTAHEDRON_VERTICES=[new V3(1,0,0),new V3(-1,0,0),new V3(0,1,0),new V3(0,-1,0),new V3(0,0,1),new V3(0,0,-1)],t.OCTAHEDRON_FACE_VERTICES=[[0,2,4],[2,1,4],[1,3,4],[3,0,4],[2,0,5],[1,2,5],[3,1,5],[0,3,5]];const{x:u,y:l}=new V3(1,GOLDEN_RATIO,0).unit();function f(){return p(t.ICOSAHEDRON_VERTICES,t.ICOSAHEDRON_FACE_VERTICES,"B2T.icosahedron()")}function p(t,e,s){const r=new Map,n=e.map(e=>{const s=PlaneSurface$$1.throughPoints(t[e[0]],t[e[1]],t[e[2]]),n=arrayFromFunction(e.length,s=>{const n=(s+1)%e.length,i=e[s],o=e[n],a=min(i,o),c=max(i,o),h=a*t.length+c;let u=r.get(h);return!u&&r.set(h,u=StraightEdge$$1.throughPoints(t[a],t[c])),i<o?u:u.flipped()});return new PlaneFace$$1(s,n)});return new BRep$$1(n,!1,s)}t.ICOSAHEDRON_VERTICES=[new V3(-u,l,0),new V3(u,l,0),new V3(-u,-l,0),new V3(u,-l,0),new V3(0,-u,l),new V3(0,u,l),new V3(0,-u,-l),new V3(0,u,-l),new V3(l,0,-u),new V3(l,0,u),new V3(-l,0,-u),new V3(-l,0,u)],t.ICOSAHEDRON_FACE_VERTICES=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],t.dodecahedron=function(){return p(t.DODECAHEDRON_VERTICES,t.DODECAHEDRON_FACE_VERTICES,"B2T.dodecahedron()")},t.octahedron=function(){return p(t.OCTAHEDRON_VERTICES,t.OCTAHEDRON_FACE_VERTICES,"B2T.octahedron()")},t.icosahedron=f,t.pyramidEdges=function(t,e,s="pyramid"+getGlobalId$$1()){assertInst(Edge$$1,...t),assertVectors(e);const r=t.map(t=>StraightEdge$$1.throughPoints(e,t.a)),n=t.map((n,i)=>{const o=s+"Wall"+i,a=(i+1)%t.length,c=[r[i],n,r[a].flipped()],h=projectPointCurve$$1(n.curve,n.minT,n.maxT,e,n.deltaT()<0);return Face$$1.create(h,c,void 0,o)}),i=new PlaneSurface$$1(P3$$1.XY).flipped(),o=Face$$1.create(i,Edge$$1.reversePath(t));n.push(o);const a=callsce("B2T.pyramidEdges",t,e,s);return new BRep$$1(n,!1,a)},t.fromBPT=function(t){const e=/.+/g,s=()=>e.exec(t)[0],r=()=>s().trim().split(/\s+/).map(t=>parseFloat(t)),n=parseInt(s()),i=arrayFromFunction(n,()=>{const[t,e]=r(),s=Array.from({length:(t+1)*(e+1)},()=>VV(...r(),1)),n=new NURBSSurface$$1(s,NURBS$$1.bezierKnots(t),NURBS$$1.bezierKnots(e),t,e,0,1,0,1);return n});return i}}(B2T||(B2T={}));class CustomPlane$$1 extends P3$$1{constructor(t,e,s,r="CustomPlane"+getGlobalId$$1(),n=chroma.random().gl(),i=-500,o=500,a=-500,c=500){const{normal1:h,w:u}=P3$$1.forAnchorAndPlaneVectors(t,e,s);super(h,u),this.up=s,this.right=e,this.uMin=i,this.uMax=o,this.vMin=a,this.vMax=c,this.name=r,this.color=n}get plane(){return this}toPlaneSurface(){return new PlaneSurface$$1(this,this.right,this.up)}toSource(){return callsce("new CustomPlane",this.anchor,this.right,this.up,this.name,this.color,this.sMin,this.sMax,this.tMin,this.tMax)}static forPlane(t,e=GL_COLOR_BLACK,s){const r=t.normal1.getPerpendicular().unit(),n=r.cross(t.normal1);return new CustomPlane$$1(t.anchor,n,r,s,e)}static fromPlaneSurface(t){return new CustomPlane$$1(t.plane.anchor,t.right,t.up,"genCustomPlane"+getGlobalId$$1())}distanceTo(t,e){return[new L3$$1(this.anchor.plus(this.right.times(this.uMin)),this.up),new L3$$1(this.anchor.plus(this.right.times(this.uMax)),this.up),new L3$$1(this.anchor.plus(this.up.times(this.vMin)),this.right),new L3$$1(this.anchor.plus(this.up.times(this.vMax)),this.right)].map((s,r)=>{const n=s.infoClosestToLine(t);return(isNaN(n.t)||r<2&&this.vMin<=n.t&&n.t<=this.vMax||r>=2&&this.uMin<=n.t&&n.t<=this.uMax)&&n.distance<=e?n.s:1/0}).min()}distanceTo2(t,e){return[new L3$$1(this.anchor.plus(this.right.times(this.uMin)),this.up),new L3$$1(this.anchor.plus(this.right.times(this.uMax)),this.up),new L3$$1(this.anchor.plus(this.up.times(this.vMin)),this.right),new L3$$1(this.anchor.plus(this.up.times(this.vMax)),this.right)].map((s,r)=>{const n=s.infoClosestToLine(t);return(isNaN(n.t)||r<2&&this.vMin<=n.t&&n.t<=this.vMax||r>=2&&this.uMin<=n.t&&n.t<=this.uMax)&&n.distance<=e?n.distance:1/0}).min()}}class Edge$$1 extends Transformable{constructor(t,e,s,r,n,i,o){super(),this.curve=t,this.a=e,this.b=s,this.aT=r,this.bT=n,this.flippedOf=i,this.name=o,assertNumbers(r,n),assert(!eq(r,n)),assertVectors(e,s),assertf(()=>t instanceof Curve$$1,t),assertf(()=>!t.isValidT||t.isValidT(r)&&t.isValidT(n),r,n,t),assertf(()=>t.at(r).like(e),()=>""+t.at(r)+e+" aT should have been "+t.pointT(e)),assertf(()=>t.at(n).like(s),()=>""+t.at(n)+s+" bT should have been "+t.pointT(s)),assertf(()=>fuzzyBetween(r,t.tMin,t.tMax),r,t.tMin,t.tMax),assertf(()=>fuzzyBetween(n,t.tMin,t.tMax),n,t.tMin,t.tMax),this.aT=clamp(r,t.tMin,t.tMax),this.bT=clamp(n,t.tMin,t.tMax),this.reversed=this.aT>this.bT}get minT(){return Math.min(this.aT,this.bT)}get maxT(){return Math.max(this.aT,this.bT)}static forCurveAndTs(t,e=t.tMin,s=t.tMax){return Edge$$1.create(t,t.at(e),t.at(s),e,s,void 0,e<s?t.tangentAt(e):t.tangentAt(e).negated(),e<s?t.tangentAt(s):t.tangentAt(s).negated())}static create(t,e,s,r,n,i,o,a,c){return t instanceof L3$$1?new StraightEdge$$1(t,e,s,r,n,i,c):new PCurveEdge$$1(t,e,s,r,n,i,o,a,c)}static isLoop(t){return t.every((e,s)=>e.b.like(t[(s+1)%t.length].a))}static edgesIntersect(t,e){assertNumbers(t.curve.hlol,e.curve.hlol),assertInst(Edge$$1,t,e),t.curve.hlol<e.curve.hlol&&([e,t]=[t,e]);const s=t.curve.isInfosWithCurve(e.curve);return s.some(t=>isNaN(t.tThis)||isNaN(t.tOther))&&(console.log(t.sce),console.log(e.sce),assert(!1)),s.some(({tThis:s,tOther:r})=>t.tValueInside(s)&&e.tValueInside(r))}static assertLoop(t){t.forEach((e,s)=>{const r=(s+1)%t.length;assert(e.b.like(t[r].a),`edges[${s}].b != edges[${r}].a (${t[s].b.sce} != ${t[r].a.sce})`)})}static ngon(t=3,e=1){return StraightEdge$$1.chain(arrayFromFunction(t,s=>V3.polar(e,TAU*s/t)))}static star(t=5,e=1,s=.5){const r=arrayFromFunction(2*t,r=>V3.polar(0==r%2?e:s,TAU*r/t/2));return StraightEdge$$1.chain(r)}static reversePath(t,e=!0){return e?arrayFromFunction(t.length,e=>t[t.length-1-e].flipped()):t}static rect(t=1,e=t){const s=[new V3(0,0,0),new V3(t,0,0),new V3(t,e,0),new V3(0,e,0)];return StraightEdge$$1.chain(s)}static reuleaux(t=3,e=1){assert(3<=t),assert(1==t%2);const s=arrayFromFunction(t,s=>V3.polar(e,TAU*s/t));return arrayFromFunction(t,e=>{const r=(e+floor(t/2))%t,n=(e+ceil(t/2))%t,i=s[r],o=s[n],a=s[e],c=a.to(i),h=new EllipseCurve$$1(a,c,V3.Z.cross(c));return Edge$$1.create(h,i,o,0,h.pointT(o),void 0,V3.Z.cross(c),V3.Z.cross(a.to(o)))})}static round(t,e){if(eq0(e))return t;const s=t.map((s,r)=>{const n=(r+1)%t.length,i=t[n];if(!s.b.like(i.a))return;const o=s.bDir.angleTo(i.aDir),a=s.curve,c=i.curve;if(a instanceof L3$$1&&c instanceof L3$$1){const t=a.dir1.cross(c.dir1);if(eq0(o))return;const s=t.cross(a.dir1),r=t.cross(c.dir1),n=a.transform(M4.translate(s.toLength(e))),i=c.transform(M4.translate(r.toLength(e))),h=n.isInfoWithLine(i);if(!h)throw new Error("tangential curves");const u=h.plus(s.toLength(-e)),l=h.plus(r.toLength(-e)),f=s.toLength(-e),p=new EllipseCurve$$1(h,f,t.cross(f).toLength(e));return Edge$$1.create(p,u,l,0,p.pointT(l),void 0,a.dir1,c.dir1)}return Edge$$1.arbitraryCorner(s,i,e)});return t.flatMap((e,r)=>{const n=(r+t.length-1)%t.length,i=s[n],o=s[r];if(!i&&!o)return e;const[a,c,h]=i?[e.curve.pointT(i.b),i.b,i.bDir]:[e.aT,e.a,e.aDir],[u,l,f]=o?[e.curve.pointT(o.a),o.a,o.aDir]:[e.bT,e.b,e.bDir],p=Edge$$1.create(e.curve,c,l,a,u,void 0,h,f);return o?[p,o]:p})}static arbitraryCorner(t,e,s){const r=t.curve,n=e.curve;const i=t.bT-s*sign(t.deltaT())/t.bDir.length(),o=e.aT+s*sign(e.deltaT())/e.aDir.length(),[a,c]=newtonIterate(function([t,e]){const i=r.at(t),o=n.at(e),a=r.tangentAt(t),c=n.tangentAt(e),h=a.cross(c),u=h.cross(a).unit(),l=h.cross(c).unit(),f=u.cross(l);h.likeO()&&assert(!1);const p=i.to(o);eq0(p.dot(h))||assert(!1);const d=p.cross(l).dot(f)/f.squared(),m=p.cross(u).dot(f)/f.squared(),$=i.plus(u.times(d)),g=o.plus(l.times(m));return assert($.like(g)),[abs(d)-s,abs(m)-s]},[i,o]),h=t.curve.at(a),u=e.curve.at(c),l=r.tangentAt(a),f=n.tangentAt(c),p=l.cross(f),d=p.cross(l).unit().toLength(-s),m=h.minus(d),$=new EllipseCurve$$1(m,d,p.cross(d).toLength(s));return Edge$$1.create($,h,u,0,$.pointT(u),void 0,r.tangentAt(a),n.tangentAt(c))}static pathFromSVG(t){let e=void 0;const s=new SVGPathData(t).toAbs().normalizeHVZ().sanitize(NLA_PRECISION).annotateArcs().commands,r=[];for(const t of s){assert("x"in t&&"y"in t);const s=new V3(t.x,t.y,0);switch(t.type){case SVGPathData.LINE_TO:r.push(StraightEdge$$1.throughPoints(e,s));break;case SVGPathData.CURVE_TO:{const n=new V3(t.x1,t.y1,0),i=new V3(t.x2,t.y2,0),o=new BezierCurve$$1(e,n,i,s,0,1),a=new PCurveEdge$$1(o,e,s,0,1,void 0,o.tangentAt(0),o.tangentAt(1));r.push(a);break}case SVGPathData.QUAD_TO:{const n=new V3(t.x1,t.y1,0),i=ParabolaCurve$$1.quadratic(e,n,s).rightAngled(),o=new PCurveEdge$$1(i,e,s,i.tMin,i.tMax,void 0,i.tangentAt(i.tMin),i.tangentAt(i.tMax));r.push(o);break}case SVGPathData.ARC:{const n=t.phi1*DEG,i=t.phi2*DEG,[o,a]=[n,i].sort(MINUS),c=arrayRange(-3,4,1).map(t=>t*PI).filter(t=>o<=t&&t<=a),h=V(t.cX,t.cY),u=V3.polar(t.rX,t.xRot*DEG),l=V3.polar(t.rY,t.xRot*DEG+Math.PI/2),f=getIntervals(c,o,a).map(([t,r])=>{const o=r-t,a=mod(t,TAU),c=a+o;assert(a>=0==c>=0);const f=a>PI||c>PI,p=f?a-PI:a,d=f?c-PI:c,m=new EllipseCurve$$1(h,f?u.negated():u,f?l.negated():l),$=n==t?e:i==t?s:m.at(p),g=n==r?e:i==r?s:m.at(d);return new PCurveEdge$$1(m,$,g,p,d,void 0,m.tangentAt(p),m.tangentAt(d))});r.push(...t.phiDelta>0?f:Edge$$1.reversePath(f));break}}e=s}return r}toString(){return callsce("new "+this.constructor.name,this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir)}split(t){const e=this.curve.at(t),s=this.tangentAt(t);return[Edge$$1.create(this.curve,this.a,e,this.aT,t,void 0,this.aDir,s,this.name+"left"),Edge$$1.create(this.curve,e,this.b,t,this.bT,void 0,s,this.bDir,this.name+"left")]}colinearToLine(t){return this.curve instanceof L3$$1&&this.curve.isColinearTo(t)}tValueInside(t){return this.aT<this.bT?lt(this.aT,t)&&lt(t,this.bT):lt(this.bT,t)&&lt(t,this.aT)}isValidT(t){return this.aT<this.bT?le(this.aT,t)&&le(t,this.bT):le(this.bT,t)&&le(t,this.aT)}clampedT(t){return this.aT<this.bT?clamp(t,this.aT,this.bT):clamp(t,this.bT,this.aT)}equals(t){return this===t||this.constructor==t.constructor&&this.a.equals(t.a)&&this.b.equals(t.b)&&this.curve.equals(t.curve)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.a.hashCode())+this.b.hashCode())+this.curve.hashCode())}like(t){return this===t||t instanceof Edge$$1&&this.curve.isColinearTo(t.curve)&&this.a.like(t.a)&&this.b.like(t.b)}isCanon(){return!this.reversed}getCanon(){return this.reversed?this.flipped():this}overlaps(t,e){assert(this.curve.isColinearTo(t.curve));const s=this.curve.containsPoint(t.a)&&this.curve.pointT(t.a),r=this.curve.containsPoint(t.b)&&this.curve.pointT(t.b);return!1===s&&!1===r?!e&&t.overlaps(this,!0):!(le(t.maxT,this.minT)||le(this.maxT,t.minT))}getAABB(){const t=[1/0,1/0,1/0],e=[-1/0,-1/0,-1/0];this.curve.roots().forEach((s,r)=>{s.forEach(s=>{lt(this.minT,s)&&lt(s,this.maxT)&&(t[r]=Math.min(t[r],this.curve.at(s).e(r)),e[r]=Math.max(e[r],this.curve.at(s).e(r)))})});const s=new AABB(V(t),V(e));return s.addPoint(this.a),s.addPoint(this.b),s}length(t=1){return this.curve.arcLength(this.minT,this.maxT,t)}deltaT(){return this.bT-this.aT}deltaTSign(){return sign(this.bT-this.aT)}atAvgT(){return this.curve.at((this.minT+this.maxT)/2)}static loopsEqual(t,e){return t.length==e.length&&arrayRange(0,t.length,1).some(s=>t.every((r,n)=>r.equals(e[(s+n)%t.length])))}}class PCurveEdge$$1 extends Edge$$1{constructor(t,e,s,r,n,i,o,a,c){super(t,e,s,r,n,i,c),this.flippedOf=i,this.aDir=o,this.bDir=a,assertVectors(o,a),assertf(()=>!o.likeO(),t),assertf(()=>!a.likeO(),t),t instanceof PICurve$$1||(assertf(()=>t.tangentAt(r).likeOrReversed(o),""+r+t.tangentAt(r).sce+" "+o.sce),assertf(()=>t.tangentAt(n).likeOrReversed(a),""+n+t.tangentAt(n).sce+" "+a.sce)),assert(this.reversed===this.aDir.dot(t.tangentAt(r))<0,r+" "+n+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(r)),assert(this.reversed===this.bDir.dot(t.tangentAt(n))<0,r+" "+n+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(r))}static forCurveAndTs(t,e,s,r){return new PCurveEdge$$1(t,t.at(e),t.at(s),e,s,void 0,e<s?t.tangentAt(e):t.tangentAt(e).negated(),e<s?t.tangentAt(s):t.tangentAt(s).negated(),r)}toSource(){return callsce("new PCurveEdge",this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir,this.name)}getVerticesNo0(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!1)}pointsCount(){return this.points().length}points(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!0)}edgeISTsWithSurface(t){return this.curve.isTsWithSurface(t).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}edgeISTsWithPlane(t){return this.curve.isTsWithPlane(t).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(t){return this.reversed?this.curve.tangentAt(t).negated():this.curve.tangentAt(t)}flipped(){return this.flippedOf||(this.flippedOf=new PCurveEdge$$1(this.curve,this.b,this.a,this.bT,this.aT,this,this.bDir.negated(),this.aDir.negated(),this.name))}transform(t,e){return new PCurveEdge$$1(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT,this.bT,void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+e)}transform4(t,e){const s=t.transformPoint(this.a),r=t.transformPoint(this.b),n=this.curve.transform4(t);return new PCurveEdge$$1(n,s,r,snap(n.pointT(s),this.aT),snap(n.pointT(r),this.bT),void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+e)}isCoEdge(t){return this===t||this===t.flippedOf||this.curve.isColinearTo(t.curve)&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}}class StraightEdge$$1 extends Edge$$1{constructor(t,e,s,r,n,i,o){super(t,e,s,r,n,i,o),this.flippedOf=i,assertInst(L3$$1,t),!i||assertInst(StraightEdge$$1,i),!o||assertf(()=>"string"==typeof o,o),assert(!e.like(s),"!a.like(b)"+e+s),this.tangent=this.aT<this.bT?this.curve.dir1:this.curve.dir1.negated()}get aDir(){return this.tangent}get bDir(){return this.tangent}static throughPoints(t,e,s){return new StraightEdge$$1(L3$$1.throughPoints(t,e,0,t.to(e).length()),t,e,0,t.to(e).length(),void 0,s)}static chain(t,e=!0){const s=t.length;return arrayFromFunction(e?s:s-1,e=>StraightEdge$$1.throughPoints(t[e],t[(e+1)%s]))}toSource(){return callsce("new StraightEdge",this.curve,this.a,this.b,this.aT,this.bT)}getVerticesNo0(){return[this.b]}pointsCount(){return 2}points(){return[this.a,this.b]}edgeISTsWithPlane(t){const e=snap2(this.curve.isTWithPlane(t),this.aT,this.bT);return this.minT<=e&&e<=this.maxT?[e]:[]}edgeISTsWithSurface(t){return t instanceof PlaneSurface$$1?this.edgeISTsWithPlane(t.plane):t.isTsForLine(this.curve).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(){return this.tangent}flipped(){return this.flippedOf||(this.flippedOf=new StraightEdge$$1(this.curve,this.b,this.a,this.bT,this.aT,this,this.name))}transform(t,e){const s=t.transformVector2(this.curve.dir1,this.curve.anchor).length(),r=this.curve.transform(t),n=t.transformPoint(this.a),i=t.transformPoint(this.b);return new StraightEdge$$1(r,n,i,t.isNoProj()?this.aT*s:r.pointT(n),t.isNoProj()?this.bT*s:r.pointT(i),void 0,""+this.name+e)}transform4(t,e){const s=t.transformVector2(this.curve.dir1,this.curve.anchor).length(),r=this.curve.transform4(t),n=t.transformPoint(this.a),i=t.transformPoint(this.b);return new StraightEdge$$1(r,n,i,t.isNoProj()?this.aT*s:r.pointT(n),t.isNoProj()?this.bT*s:r.pointT(i),void 0,""+this.name+e)}isCoEdge(t){return this===t||this===t.flippedOf||t.constructor===StraightEdge$$1&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}getEdgeT(t){assertVectors(t);let e=t.minus(this.curve.anchor).dot(this.curve.dir1);if(eq0(this.curve.at(e).distanceTo(t)))return e=snap2(e,this.aT,this.bT),this.minT<=e&&e<=this.maxT?e:void 0}}class FaceInfoFactory{static makeStatic(t){return new class extends FaceInfoFactory{constructor(){super()}info(e,s,r){return t}}}info(t,e,s){throw new Error("no default implementation")}extrudeBottom(t,e,s=[]){return this.info(t,e,s)}extrudeTop(t,e,s=[]){return this.info(t,e,s)}extrudeWall(t,e,s,r=[]){return this.info(e,s,r)}rotationWall(t,e,s,r=[]){return this.info(e,s,r)}rotationStart(t,e,s=[]){return this.info(t,e,s)}rotationEnd(t,e,s=[]){return this.info(t,e,s)}newSubFace(t,e,s,r=[]){return t.info}transform(t,e,s,r,n,i=[]){return t.info}}class Face$$1 extends Transformable{constructor(t,e,s=[],r,n){super(),this.surface=t,this.contour=e,this.holes=s,this.name=r,this.info=n,this.aabb=void 0,Edge$$1.assertLoop(e),assert(e.every(t=>t instanceof Edge$$1),()=>"contour.every(f => f instanceof Edge)"+e),s&&s.forEach(t=>Edge$$1.assertLoop(t)),s&&s.forEach(e=>assert(!t.edgeLoopCCW(e))),assert(!s||s.constructor==Array,s&&s.toString()),this.allEdges=Array.prototype.concat.apply(this.contour,this.holes)}static assembleFacesFromLoops(t,e,s){const r=[],n=[];return t.forEach(t=>(function t(s,r){if(0==r.length)r.push(s);else{const n=r.find(t=>BRep$$1.loop1ContainsLoop2(t.loop,t.ccw,s.loop,s.ccw,e));if(n)t(s,n.subloops);else{for(let t=r.length;--t>=0;){const n=r[t];BRep$$1.loop1ContainsLoop2(s.loop,s.ccw,n.loop,n.ccw,e)&&(s.subloops.push(n),r.splice(t,1))}r.push(s)}}})({loop:t,ccw:e.edgeLoopCCW(t),subloops:[]},n)),n.forEach(t=>(function t(n){r.push(new s(e,n.ccw?n.loop:Edge$$1.reversePath(n.loop),n.subloops.map(t=>t.ccw?Edge$$1.reversePath(t.loop):t.loop))),n.subloops.forEach(e=>e.subloops.forEach(e=>t(e)))})(t)),r}static create(t,e,s,r,n){return t instanceof PlaneSurface$$1?new PlaneFace$$1(t,e,s,r,n):new RotationFace$$1(t,e,s,r,n)}intersectFace(t,e,s,r,n,i,o){function a(t,e){return o.has(new Pair(t,e))}function c(t,e){return o.add(new Pair(t,e))}function h(o,h,u){if(!h&&!u){let e=l.surface.normalP(o.a).cross(t.surface.normalP(o.a));if(e.likeO()){const s=lerp(o.aT,o.bT,1/GOLDEN_RATIO),r=o.curve.at(s);e=l.surface.normalP(r).cross(t.surface.normalP(r))}if(e.likeO()){const e=o.a,s=P3$$1.normalOnAnchor(o.aDir,e),n=l.surface.normalP(e),i=n.dot(t.surface.normalP(e))>0,a=s.normal1.cross(n),c=l.surface.isCurvesWithPlane(s)[0],h=c.pointT(e),u=sign(a.dot(c.tangentAt(h))),f=t.surface.isCurvesWithPlane(s)[0],p=f.pointT(e),d=sign(a.dot(c.tangentAt(p))),m=c.diff(h,EPS$$1*u).dot(n),$=f.diff(p,EPS$$1*d).dot(n);$<m&&mapPush(r,t,i?o.flipped():o),n.dot(t.surface.normalP(e))<0==$<m&&mapPush(r,l,o.flipped());const g=c.diff(h,EPS$$1*u).dot(n),v=f.diff(p,EPS$$1*d).dot(n);v<g&&mapPush(r,t,i?o:o.flipped()),i!=v<g&&mapPush(r,l,o)}else e.dot(o.aDir)<0&&(o=o.flipped()),mapPush(r,l,o),mapPush(r,t,o.flipped());return!0}function f(t,e,s,n,i,c,h,u,l){if(t&&!e){if(a(t.getCanon(),n))return!1;const e=n.surface;i.edgeFaces.get(t.getCanon()).forEach(t=>{const e=fff$$1(t,n.surface),s=e==INSIDE$$1||!h&&e==COPLANAR_SAME$$1,i=t.edge.tangentAt(t.edge.curve.pointT(o.a)).like(o.aDir)?o:o.flipped();console.log(o.sce),assert(t.edge.tangentAt(t.edge.curve.pointT(i.a)).like(i.aDir)),s&&mapPush(r,t.face,i)});const s=e.normalP(o.a),c=s.cross(o.aDir),u=splitsVolumeEnclosingFacesP$$1(i,t.getCanon(),o.a,c,s);let l,f;(l=u==INSIDE$$1||h&&u==COPLANAR_SAME$$1)&&mapPush(r,n,o);const p=splitsVolumeEnclosingFacesP$$1(i,t.getCanon(),o.a,c.negated(),s);if((f=p==INSIDE$$1||h&&p==COPLANAR_SAME$$1)&&mapPush(r,n,o.flipped()),l||f||u==COPLANAR_SAME$$1&&p==INSIDE$$1||p==COPLANAR_SAME$$1&&u==INSIDE$$1)return!0}return!1}const p=f(h,u,0,t,e,0,!1),d=f(u,h,0,l,s,0,!0);if(p||d)return!0;if(h&&u){if(a(h.getCanon(),u.getCanon()))return!1;function m(t,e,s,n,i,a,c,h){for(const c of s.edgeFaces.get(t.getCanon())){const s=splitsVolumeEnclosingFaces$$1(n,e.getCanon(),c.inside,c.normalAtCanonA),h=s==INSIDE$$1||i&&s==COPLANAR_SAME$$1,u=c.edge.aDir.like(o.aDir)?o:o.flipped();if(h){mapPush(r,c.face,u);const e=t.getCanon().curve.pointT(o.a);eq(e,t.aT)||eq(e,t.bT)||splitsVolumeEnclosingCone2$$1(n,o.a,o.curve,o.aT,-Math.sign(o.deltaT()))==INSIDE$$1&&mapPush(a,t.getCanon(),{p:o.a,edgeT:e});const s=t.getCanon().curve.pointT(o.b);eq(s,t.aT)||eq(s,t.bT)||splitsVolumeEnclosingCone2$$1(n,o.b,o.curve,o.bT,Math.sign(o.deltaT()))==INSIDE$$1&&mapPush(a,t.getCanon(),{p:o.b,edgeT:s})}}}return c(h.getCanon(),u.getCanon()),m(h,u,e,s,!0,n),m(u,h,s,e,!1,i),!1}return!1}function u(t,r,o){if(t&&!r&&(t.colinear||t.edgeT==t.edge.aT||t.edgeT==t.edge.bT||(mapPush(n,t.edge.getCanon(),t),assert(t.edge.isValidT(t.edgeT)))),r&&!t&&(r.colinear||r.edgeT==r.edge.aT||r.edgeT==r.edge.bT||(mapPush(i,r.edge.getCanon(),r),assert(r.edge.isValidT(r.edgeT)))),t&&r){function a(t,e,s,r,n,i,o,a,h,u){if(!t.colinear&&t.edgeT!=t.edge.aT&&t.edgeT!=t.edge.bT)if(c(t.edge.getCanon(),e.edge.getCanon()),t.p.like(e.edge.a)||t.p.like(e.edge.b)){const s=t.p.like(e.edge.a)?e.edge.a:e.edge.b,r=splitsVolumeEnclosingCone2$$1(a,s,t.edge.curve,t.edgeT,1),n=splitsVolumeEnclosingCone2$$1(a,s,t.edge.curve,t.edgeT,-1);INSIDE$$1!=r&&INSIDE$$1!=n||(mapPush(u,t.edge.getCanon(),t),assert(t.edge.isValidT(t.edgeT)))}else{const s=splitsVolumeEnclosingFacesP2$$1(a,e.edge.getCanon(),t.p,t.edge.curve,t.edgeT,1,n.normalP(t.p)),r=splitsVolumeEnclosingFacesP2$$1(a,e.edge.getCanon(),t.p,t.edge.curve,t.edgeT,-1,n.normalP(t.p));(INSIDE$$1==s||h&&COPLANAR_SAME$$1==s||INSIDE$$1==r||h&&COPLANAR_SAME$$1==r)&&(mapPush(u,t.edge.getCanon(),t),assert(t.edge.isValidT(t.edgeT)))}}assert(t.colinear||r.colinear||eq(t.t,r.t)),a(t,r,0,0,f,0,0,s,!0,n),a(r,t,0,0,p,0,0,e,!1,i)}}assertInst(Face$$1,t);const l=this,f=l.surface,p=t.surface;if(!this.getAABB().touchesAABBfuzzy(t.getAABB()))return;if(f.isCoplanarTo(p))return;const d=f.isCurvesWithSurface(p);if(0!=d.length){for(const t of d)assert(f.containsCurve(t)),assert(p.containsCurve(t));for(let e=0;e<d.length;e++){const s=d[e],r=l.edgeISPsWithSurface(s,t.surface),n=t.edgeISPsWithSurface(s,l.surface);function m(t,e){return 0==t.length?isFinite(s.tMin)&&e.containsPoint2(s.at(s.tMin))==PointVsFace.INSIDE:t[0].insideDir.dot(s.tangentAt(t[0].t))<0}assertf(()=>0==r.length||!eq0(r[0].insideDir.dot(s.tangentAt(r[0].t))),()=>r[0].insideDir.dot(s.tangentAt(r[0].t))),assertf(()=>0==n.length||!eq0(n[0].insideDir.dot(s.tangentAt(n[0].t))),()=>n[0].insideDir.dot(s.tangentAt(n[0].t)));let i,o,a=m(r,l),c=m(n,t);if(0==r.length&&!a||0==n.length&&!c)continue;let f,p,$,g,v=0,P=0,C=a&&c?s.at(s.tMin):void 0,x=s.tMin;for(;v<r.length||P<n.length;){assert(v<=r.length),assert(P<=n.length);const t=r[v],e=n[P];if(assert(t||e),P==n.length||v<r.length&&lt(t.t,e.t)?(f=t,a=!a,t.used=!0,i=t.colinear?t:void 0,v++):v==r.length||gt(t.t,e.t)?(f=e,e.used=!0,c=!c,o=e.colinear?e:void 0,P++):(f=t,t.used=!0,e.used=!0,a=!a,c=!c,i=t.colinear?t:void 0,o=e.colinear?e:void 0,v++,P++),!C||a&&c)a&&c&&(C=f.p,p=f.insideDir,x=f.t,$=t&&t.used?t:void 0,g=e&&e.used?e:void 0);else{if(p=s.tangentAt(x),eq(x,f.t)){C=void 0;continue}assert(lt(x,f.t)),x>f.t&&(p=p.negated());let r=s.tangentAt(f.t);x>f.t&&(r=r.negated());const n=Edge$$1.create(s,C,f.p,x,f.t,void 0,p,r,"genseg"+getGlobalId$$1());C=void 0,h(n,i&&i.edge,o&&o.edge)&&(u($||i,g||o),u(t&&t.used&&t||i,e&&e.used&&e||o))}}if(a&&c&&x!==s.tMax){const t=s.tMax;p=s.tangentAt(x),x>t&&(p=p.negated());let e=s.tangentAt(t);x>t&&(e=e.negated());const r=Edge$$1.create(s,C,s.at(t),x,t,void 0,p,e,"genseg"+getGlobalId$$1());h(r,i&&i.edge,o&&o.edge)&&u($||i,g||o)}}l.getAllEdges().forEach(e=>{o.add(new Pair(e.getCanon(),t))}),t.getAllEdges().forEach(t=>{o.add(new Pair(t.getCanon(),l))})}}edgeISPsWithSurface(t,e){const s=this.surface,r=this.holes.concat([this.contour]),n=[];for(const i of r){const r=i.map(e=>e.curve.isColinearTo(t));for(let o=0;o<i.length;o++){const a=i[o],c=(o+1)%i.length,h=i[c];if(r[o]){if(t.containsPoint(a.a)){const e=(o-1+i.length)%i.length,c=i[e],h=t.pointT(a.a),u=a.aDir.cross(s.normalP(a.a));!r[e]&&dotCurve2$$1(c.curve,c.bT,u,-sign(c.deltaT()))>0&&n.push({p:c.b,insideDir:a.aDir.negated(),t:h,edge:c,edgeT:c.bT,colinear:!1}),n.push({p:a.a,insideDir:a.aDir,t:h,edge:a,edgeT:a.aT,colinear:!0})}if(t.containsPoint(a.b)){const e=t.pointT(a.b),i=a.bDir.cross(s.normalP(a.b));!r[c]&&dotCurve2$$1(h.curve,h.aT,i,sign(h.deltaT()))>0&&n.push({p:a.b,insideDir:a.bDir,t:e,edge:h,edgeT:h.aT,colinear:!1}),n.push({p:a.b,insideDir:a.bDir.negated(),t:e,edge:a,edgeT:a.bT,colinear:!0})}}else{const i=a.edgeISTsWithSurface(e);for(const e of i){const i=a.curve.at(e);if(!t.containsPoint(i))continue;const o=t.pointT(i);assert(!isNaN(o));const h=a.tangentAt(e).cross(s.normalP(i)).negated(),u=t.tangentAt(o);if(e==a.bT){if(!r[c]){if(!eq(o,t.tMax)){const e=this.pointsToInside3(a.b,t,o,1);assert(e!=PointVsFace.ON_EDGE),PointVsFace.INSIDE==e&&n.push({p:a.b,insideDir:u,t:o,edge:a,edgeT:a.bT,colinear:!1})}if(!eq(o,t.tMin)){const e=this.pointsToInside3(a.b,t,o,-1);assert(e!=PointVsFace.ON_EDGE),PointVsFace.INSIDE==e&&n.push({p:a.b,insideDir:u.negated(),t:o,edge:a,edgeT:a.bT,colinear:!1})}}}else if(e!=a.aT)if(eq0(h.dot(u))){const s=sign(u.dot(a.curve.tangentAt(e))),r=1e-4;for(const c of[-1,1]){if(-1==c*s&&e==a.minT||1==c*s&&e==a.maxT||-1==c&&o==t.tMin||1==c&&o==t.tMax)continue;t.at(o).to(t.at(o+c*r)).dot(h)-a.curve.at(e).to(a.curve.at(e+c*s*r)).dot(h)>0&&n.push({p:i,insideDir:u.times(c),t:o,edge:a,edgeT:e,colinear:!1})}}else n.push({p:i,insideDir:h,t:o,edge:a,edgeT:e,colinear:!1})}}}}return n.sort((e,s)=>e.t-s.t||e.insideDir.dot(t.tangentAt(e.t))),n}transform(t){const e=t.isMirroring(),s=Edge$$1.reversePath(this.contour.map(e=>e.transform(t)),e),r=this.holes.map(s=>Edge$$1.reversePath(s.map(e=>e.transform(t)),e));return new this.constructor(this.surface.transform(t),s,r,this.name,this.info)}transform4(t){const e=t.isMirroring(),s=Edge$$1.reversePath(this.contour.map(e=>e.transform4(t)),e),r=this.holes.map(s=>Edge$$1.reversePath(s.map(e=>e.transform4(t)),e));return new this.constructor(this.surface.transform4(t),s,r,this.name,this.info)}flipped(){const t=this.contour.map(t=>t.flipped()).reverse(),e=this.holes.map(t=>t.map(t=>t.flipped()).reverse());return new this.constructor(this.surface.flipped(),t,e,this.name,this.info)}toString(){return"new "+this.constructor.name+"("+this.surface+", ["+this.contour.map(t=>"\n\t"+t).join()+"]"+this.holes.map(t=>"\n\t\thole: "+t.join())+")"}toSource(){return"new "+this.constructor.name+"("+this.surface.toSource()+", ["+this.contour.map(t=>"\n\t"+t.toSource()+",").join("")+"], ["+this.holes.map(t=>"["+t.map(t=>"\n\t"+t.toSource()+",").join("")+"]").join(",")+"])"}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.holes.length==t.holes.length&&Edge$$1.loopsEqual(this.contour,t.contour)&&this.holes.every(e=>t.holes.some(t=>Edge$$1.loopsEqual(e,t)))}hashCode(){function t(t){let e=0;for(const s of t)e=31*e+s|0;return e}function e(e){return t(e.map(t=>t.hashCode()).sort(MINUS))}let s=0;return s=31*(s=31*(s=31*s+t(this.holes.map(t=>e(t)).sort(MINUS))|0)+e(this.contour)|0)+this.surface.hashCode()|0}likeFace(t){function e(t,e){return t.length==e.length&&arrayRange(0,t.length,1).some(s=>t.every((r,n)=>r.like(e[(s+n)%t.length])))}return assertInst(Face$$1,t),this.surface.like(t.surface)&&this.holes.length==t.holes.length&&e(this.contour,t.contour)&&this.holes.every(s=>t.holes.some(t=>e(s,t)))}getAllEdges(){return this.allEdges}addEdgeLines(t){assert(!1,"buggy, fix");const e=this.contour.flatMap(t=>t.getVerticesNo0()),s=t.vertices.length;for(let r=0;r<e.length;r++)t.vertices.push(e[r]),t.LINES.push(s+r,s+(r+1)%e.length)}containsPoint(t){return assertVectors(t),this.surface.loopContainsPoint(this.contour,t)!=PointVsFace.OUTSIDE&&!this.holes.some(e=>this.surface.loopContainsPoint(e,t)!=PointVsFace.OUTSIDE)}containsPoint2(t){assertVectors(t);const e=this.surface.loopContainsPoint(this.contour,t);if(e!=PointVsFace.INSIDE)return e;for(const e of this.holes){const s=this.surface.loopContainsPoint(e,t);if(s!=PointVsFace.OUTSIDE)return s==PointVsFace.ON_EDGE?PointVsFace.ON_EDGE:PointVsFace.OUTSIDE}return PointVsFace.INSIDE}intersectsLine(t){if(assertInst(L3$$1,t),!this.getAABB().intersectsLine(t))return NaN;const e=this.surface.isTsForLine(t).filter(e=>this.containsPoint(t.at(e))).withMax(t=>-t);return void 0!=e?e:NaN}toMesh(){const t=(new Mesh).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES").addVertexBuffer("normals","ts_Normal");return this.addToMesh(t),t}zDirVolume(){return this.surface.zDirVolume(this.getAllEdges())}calcArea(){return this.surface.calculateArea(this.getAllEdges())}getLoops(){return[this.contour,...this.holes]}getAABB(){return this.aabb||(this.aabb=AABB.forAABBs(this.contour.map(t=>t.getAABB())))}pointsToInside3(t,e,s,r){const n=this.surface.normalP(t),i=e.tangentAt(s).times(r),o=n.cross(i),a=e.at(s).to(e.at(s+1e-6*r)).dot(o);let c,h=1/0,u=!1;for(const s of this.getAllEdges()){const r=s.a.like(t),l=s.b.like(t);if(assert(r==s.a.like(t)),assert(l==s.b.like(t)),!r&&!l)continue;const f=r?s.aDir:s.bDir.negated(),p=i.angleRelativeNormal(f,n);if(eq0(p)){if(e.isColinearTo(s.curve))return PointVsFace.ON_EDGE;const t=r?s.aT:s.bT,n=(r?1:-1)*sign(s.deltaT()),i=s.curve.diff(t,1e-6*n).dot(o)-a;i>0&&(!u||i<h)&&(u=!0,h=i,c=r?PointVsFace.OUTSIDE:PointVsFace.INSIDE)}else if(!u){const t=(p+TAU)%TAU;t<h&&(h=t,c=r?PointVsFace.OUTSIDE:PointVsFace.INSIDE)}}if(void 0==c)throw new Error;return c}pointsToInside2(t,e){return this.pointsToInside3(t,L3$$1.anchorDirection(t,e),0,1)}}class PlaneFace$$1 extends Face$$1{constructor(t,e,s,r,n){assert(t instanceof P3$$1||t instanceof PlaneSurface$$1),super(t instanceof P3$$1?new PlaneSurface$$1(t):t,e,s,r,n)}static forVertices(t,e,...s){const r=t instanceof P3$$1?new PlaneSurface$$1(t):t;assert(isCCW(e,r.plane.normal1),"isCCW(vs, planeSurface.plane.normal1)");const n=StraightEdge$$1.chain(e);s.forEach(t=>assert(doubleSignedArea(t,r.plane.normal1)>=0,"doubleSignedArea(vs, planeSurface.plane.normal1) >= 0"));const i=s.map(t=>StraightEdge$$1.chain(t));return new PlaneFace$$1(t,n,i)}addToMesh(t){const e=t.vertices.length,s=this.surface.plane.normal1,r=this.contour.flatMap(t=>t.getVerticesNo0());for(let s=0;s<r.length;s++)t.LINES.push(e+s,e+(s+1)%r.length);const n=[];this.holes.forEach(t=>{n.push(r.length),r.push(...t.flatMap(t=>t.getVerticesNo0()))});const i=triangulateVertices$$1(s,r,n).map(t=>t+e);Array.prototype.push.apply(t.vertices,r),Array.prototype.push.apply(t.TRIANGLES,i),Array.prototype.push.apply(t.normals,arrayFromFunction(r.length,()=>s))}intersectsLine(t){assertInst(L3$$1,t);const e=t.isTWithPlane(this.surface.plane);return Number.isFinite(e)&&this.containsPoint(t.at(e))?e:NaN}withHole(t){return new PlaneFace$$1(this.surface,this.contour,[t])}pointsToInside(t,e){return this.containsPoint2(t.plus(e.times(8*NLA_PRECISION)))}edgeISPsWithPlane(t,e){assert(this.surface.plane.containsLine(t)),assert(e.containsLine(t));const s=this.surface.plane,r=[];return[this.contour].concat(this.holes).forEach(n=>{const i=n.map(e=>e.colinearToLine(t)&&-sign(e.aDir.dot(t.dir1))),o=t.dir1.cross(s.normal1);n.forEach((s,n,a)=>{const c=(n+1)%a.length,h=a[c],u=i[n];if(u){const e=t.pointT(s.a),n=t.pointT(s.b);r.push({p:s.a,insideDir:s.aDir,t:e,edge:s,edgeT:s.aT,colinear:!0},{p:s.b,insideDir:s.bDir.negated(),t:n,edge:s,edgeT:s.bT,colinear:!0}),u*(i[c]||dotCurve2$$1(h.curve,h.aT,o,h.deltaTSign()))<0&&r.push({p:h.a,insideDir:s.bDir,t:n,edge:h,edgeT:h.aT,colinear:!1})}else{const n=s.edgeISTsWithPlane(e);assert(n.every(t=>e.containsPoint(s.curve.at(t))),n);for(const a of n)if(a==s.bT){dotCurve2$$1(s.curve,s.bT,o,-s.deltaTSign())*(i[c]||dotCurve2$$1(h.curve,h.aT,o,h.deltaTSign()))<0&&r.push({p:s.b,insideDir:e.normal1.negated(),t:t.pointT(s.b),edge:s,edgeT:s.bT,colinear:!1})}else if(a!=s.aT){const n=s.curve.at(a);assert(e.containsPoint(n),s.toString(),n,a,e.distanceToPoint(n)),assert(t.containsPoint(n),s.toString(),n,a,t.distanceToPoint(n));const i=e.normal1.negated();r.push({p:n,insideDir:i,t:t.pointT(n),edge:s,edgeT:a,colinear:!1})}}})}),r.sort((e,s)=>e.t-s.t||e.insideDir.dot(t.dir1)),r}}class RotationFace$$1 extends Face$$1{constructor(t,e,s,r,n){super(t,e,s,r,n)}static loopDoesNotCrossPlane(t,e){let s=0;function r(t){return 0!=s?!s||s*t<0:(s=t,!1)}for(const s of t){const t=s.edgeISTsWithPlane(e);if(0==t.length){if(!(s.curve instanceof L3$$1)&&r(e.distanceToPointSigned(s.a)))return!1}else for(const n of t){if(s.aT!=n&&r(dotCurve2$$1(s.curve,n,e.normal1,-s.deltaTSign())))return!1;if(s.bT!=n&&r(dotCurve2$$1(s.curve,n,e.normal1,s.deltaTSign())))return!1}}return!0}getAABB(){return this.aabb?this.aabb:(this.aabb=AABB.forAABBs(this.contour.map(t=>t.getAABB())),this.aabb.addPoints(this.surface.getExtremePoints().filter(t=>this.containsPoint(t))),this.aabb)}unrollLoop(t){const e=[],s=this.surface.uvPFunc(),r=t.map(t=>t.getVerticesNo0()),n=r.findIndex(t=>!eq(s(t[0]).x,Math.PI));assert(-1!=n);for(let i=0;i<t.length;i++){const o=(i+n)%t.length;for(let t=0;t<r[o].length;t++){const n=r[o][t],i=s(n);e.push(i)}}return t.forEach(t=>{t.getVerticesNo0().forEach(t=>{e.push(s(t))})}),console.log("vs\n",e.join("\n"),e.length),e}unrollEllipsoidLoops(t){const e=[],s=[],r=[],n=this.surface,i=n.uvPFunc(),o=n instanceof EllipsoidSurface$$1?t=>t.like(n.center.plus(n.f3))||t.like(n.center.minus(n.f3)):t=>t.like(this.surface.center);for(const a of t){r.push(e.length);for(let t=0;t<a.length;t++){const r=(t+1)%a.length,c=a[t].getVerticesNo0();if(s.push(...c),e.push(...c.map(t=>i(t))),o(a[r].a)){const i=n.matrixInverse.transformVector(a[t].bDir),o=n.matrixInverse.transformVector(a[r].aDir),c=Math.atan2(-i.y,-i.x),h=Math.atan2(o.y,o.x),u=e.pop();e.push(new V3(c,u.y,0),new V3(h,u.y,0)),s.push(s.last)}e.forEach(({u:t,v:e})=>{assert(isFinite(t)),assert(isFinite(e))})}}let a;if(this.surface instanceof EllipsoidSurface$$1)a=s.map(t=>n.normalP(t));else{const t=n.normalUVFunc();a=e.map(({u:e,v:s})=>t(e,s))}return assert(s.length==s.length),{verticesUV:e,vertices:s,normals:a,loopStarts:r}}unrollCylinderLoops(t){const e=t.map(t=>t.flatMap(t=>t.getVerticesNo0())),s=this.surface,r=e.concatenated(),n=e.reduce((t,e)=>(t.push(t.last+e.length),t),[0]),i=s.uvPFunc(),o=r.map(t=>i(t)),a=s.normalUVFunc();return{verticesUV:o,vertices:r,normals:o.map(({u:t,v:e})=>a(t,e)),loopStarts:n}}addToMesh(t,e=this.surface.uStep,s=this.surface.vStep){assertf(()=>e>0&&s>0,e,s,"Surface: "+this.surface);const r=[],n=(t,r)=>this.surface.pUVFunc()(t*e,r*s),i=(t,r)=>this.surface.normalUVFunc()(t*e,r*s),o=this.getLoops(),{vertices:a,verticesUV:c,normals:h,loopStarts:u}=this.surface instanceof EllipsoidSurface$$1||this.surface instanceof ConicSurface$$1?this.unrollEllipsoidLoops(o):this.unrollCylinderLoops(o);u.push(a.length);const l=c.map(({u:t,v:r})=>new V3(t/e,r/s,0));for(let e=0;e<o.length;e++){const s=u[e],r=u[e+1]-s,n=t.vertices.length+u[e];for(let e=0;e<r;e++)t.LINES.push(n+e,n+(e+1)%r)}disableConsole();let f=1/0,p=-1/0,d=1/0,m=-1/0;l.forEach(([t,e])=>{assert(isFinite(t)),assert(isFinite(e)),f=min(f,t),p=max(p,t),d=min(d,e),m=max(m,e)}),ParametricSurface$$1.is(this.surface);const $=floor(f+NLA_PRECISION),g=floor(d+NLA_PRECISION),v=ceil(p-NLA_PRECISION)-$,P=ceil(m-NLA_PRECISION)-g;if(console.log(e,s,v,P),1==v&&1==P){const t=triangulateVertices$$1(V3.Z,l,u.slice(1,1+this.holes.length));r.push(...t)}else{const t=new Array(v*P);function C(e,s,r){assert(s<v&&r<P,`${s}, ${r}, ${v}, ${P}`),console.log("complete part",e,s,r),assert(e.length);const n=s+$,i=r+g;for(const t of e)assert(le(n,l[t].x)&&le(l[t].x,n+1),`${t} ${l[t].str} ${n} ${n}`),assert(le(i,l[t].y)&&le(l[t].y,i+1));const o=r*v+s;(t[o]||(t[o]=[])).push(e)}for(let t=0;t<o.length;t++){let e,s=void 0,r=-1,n=-1,i=-1,o=-1,a=0;const c=u[t],h=u[t+1]-c;for(let t=0;t<h;t++){const u=c+t,f=l[u],p=c+(t+1)%h,d=l[p],m=f.to(d);assert(f);const M=m.x,V=m.y;let w=u,S=f,T=0,I=400;for(;--I;){const t=floor(S.u+(eq0(M)?-sign(V):sign(M))*NLA_PRECISION)-$,c=floor(S.v+(eq0(V)?sign(M):sign(V))*NLA_PRECISION)-g;assert(t<v&&c<P,`${t}, ${c}, ${v}, ${P}`);const h=ceil(sign(M)*S.u+NLA_PRECISION)-sign(M)*S.u,u=ceil(sign(V)*S.v+NLA_PRECISION)-sign(V)*S.v,l=T+h/abs(M),m=T+u/abs(V);if(i==t&&o==c||(s&&(e?(a++,C(s,i,o)):(e=s,r=i,n=o)),s=[w]),i=t,o=c,T=min(l,m),ge(T,1)){s.push(p);break}{const t=f.lerp(d,T),e=x(t.x,t.y);s.push(e),S=t,w=e}}assert(I,"whileLimit")}0==a&&assert(!1,"found a hole, try increasing resolution"),r==i&&n==o?(s.pop(),C(s.concat(e),i,o)):(C(e,r,n),C(s,i,o)),console.log("firstPart",e)}console.log("calculated parts",t);const e=new Array((v+1)*(P+1));function x(t,e){return l.push(new V3(t,e,0)),h.push(i(t,e)),a.push(n(t,e))-1}function M(t,s){const r=s*(v+1)+t;return e[r]||(e[r]=x(t+$,s+g))}for(let e=0;e<v;e++){let s=!1;for(let n=0;n<P;n++){const i=$+e,o=g+n,a=t[n*v+e];if(a){function V(t){const e=l[t],s=e.x-i,r=e.y-o;return assert(-NLA_PRECISION<s&&s<1+NLA_PRECISION&&-NLA_PRECISION<r&&r<1+NLA_PRECISION,"oob u1 v1 "+s+" "+r+" "+t+" "+e.str+"IF THIS FAILS check canonSeamU is correct"),r<s?s+r:4-s-r}for(;a.length;){const t=[],i=a[0];assert(i.length>0);let o=i;do{t.push(...o);const r=V(o.last),i=a.indexWithMax(t=>-mod(V(t[0])-r,4)),c=a.removeIndex(i);let h=r;const u=V(c[0])>h?V(c[0]):V(c[0])+4;let l=ceil(h+NLA_PRECISION),f=eq0((h+NLA_PRECISION)%1-NLA_PRECISION);for(;lt(l,u);){switch(l%4){case 0:t.push(M(e,n));break;case 1:s=s!=f,t.push(M(e+1,n));break;case 2:t.push(M(e+1,n+1));break;case 3:s=s!=f,t.push(M(e,n+1))}f=!0,l++}s=s!=(f&&l%2==1&&eq(l,u)),h=l,o=c}while(o!=i);if(3==t.length)r.push(...t);else{const e=triangulateVertices$$1(V3.Z,t.map(t=>l[t]),[]).map(e=>t[e]);r.push(...e)}}}else s&&pushQuad(r,!1,M(e,n),M(e+1,n),M(e,n+1),M(e+1,n+1))}}}Array.prototype.push.apply(t.TRIANGLES,r.map(e=>e+t.vertices.length)),Array.prototype.push.apply(t.vertices,a),Array.prototype.push.apply(t.normals,h),enableConsole()}addToMesh2(t){const e=[];let s=1/0,r=-1/0;const n=this.surface.pUVFunc(),i=this.surface.normalUVFunc(),o=this.holes.concat([this.contour]).map(t=>this.unrollLoop(t));o.forEach(t=>{t.forEach(({x:t,y:n})=>{const i=e.binaryIndexOf(t,(t,e)=>snap(t.value-e,0));i<0&&e.splice(-i-1,0,{value:t,left:[],right:[]}),s=min(s,n),r=max(r,n)})}),console.log("zzzs",s,r,o[0].toSource().replace(/\), /g,",\n"));o.forEach(t=>{t.forEach((t,s,r)=>{let n=r[(s+1)%r.length],i=n.x-t.x;if(eq0(i))return;i<0&&([t,n]=[n,t],i=-i);const o=e.binaryIndexOf(t.x,(t,e)=>snap(t.value-e,0)),a=e.binaryIndexOf(n.x,(t,e)=>snap(t.value-e,0));e[o].right.binaryInsert(t.y);for(let s=(o+1)%e.length;s!=a;s=(s+1)%e.length){const r=(e[s].value-t.x)/i,o=n.y*r+t.y*(1-r);e[s].left.binaryInsert(o),e[s].right.binaryInsert(o)}e[a].left.binaryInsert(n.y)})});const a=[],c=[],h=[];for(let t=0;t<e.length;t++){const s=e[t],r=e[(t+1)%e.length];assert(s.right.length==r.left.length);for(let t=0;t<s.right.length;t++)a.push(n(s.value,s.right[t]),n(r.value,r.left[t])),h.push(i(s.value,s.right[t]),i(r.value,r.left[t]))}const u=a.length,l=(r-s)/8,f=arrayFromFunction(7,t=>s+(1+t)*l);console.log("detailsZs",f);for(let t=0;t<e.length;t++){const s=e[t].value;for(let t=0;t<f.length;t++)a.push(n(s,f[t])),h.push(i(s,f[t]))}let p=0;const d=e.length-1;for(let t=0;t<d;t++){const s=(t+1)%e.length;let r=!1,n=0;const i=e[t],o=e[(t+1)%e.length];for(let e=0;e<f.length+1;e++){const a=f[e]||1e5;r?i.right[n]<a||o.left[n]<a?(pushQuad(c,!0,u+t*f.length+e-1,u+s*f.length+e-1,p+2*n,p+2*n+1),r=!1,n++,(i.right[n]<a||o.left[n]<a)&&e--):pushQuad(c,!0,u+t*f.length+e,u+t*f.length+e-1,u+s*f.length+e,u+s*f.length+e-1):i.right[n]<a&&o.left[n]<a&&(i.right[n+1]<a||o.left[n+1]<a?(pushQuad(c,!0,p+2*n,p+2*(n+1),p+2*n+1,p+2*(n+1)+1),n+=2,(i.right[n]<a||o.left[n]<a)&&e--):(pushQuad(c,!0,p+2*n,p+2*n+1,u+t*f.length+e,u+s*f.length+e),r=!0,n++))}p+=2*i.right.length}const m=c.map(e=>e+t.vertices.length);Array.prototype.push.apply(t.vertices,a),Array.prototype.push.apply(t.TRIANGLES,m),Array.prototype.push.apply(t.normals,h)}}const EPS$$1=1e-5;let globalId=0;function getGlobalId$$1(){return globalId++}function addLikeSurfaceFaces$$1(t,e,s){for(let r=0;r<t.length;r++){const n=t[r];let i=!1,o=!1;for(let t=0;t<n.length;t++){const r=n[t];r==e&&(i=!0),r==s&&(o=!0)}if(i!=o)return void n.push(i?s:e);if(i)return}t.push([e,s])}function assembleFaceFromLooseEdges$$1(t,e,s){const r=new Set;const n=[];let i,o=void 0;for(;i=t.find(t=>!r.has(t));){o=i;const s=[];let a=0;do{r.add(o),s.push(o);const n=t.filter(t=>o.b.like(t.a)),i=e.normalP(o.b),a=n.indexWithMax(t=>o.bDir.angleRelativeNormal(t.aDir,i));o=n[a]}while(i!=o&&a++<200);assert(201!=a),n.push(s)}const a=BRep$$1.assembleFacesFromLoops(n,e,s);return assertf(()=>1==a.length),a[0]}function calcNextEdgeIndex$$1(t,e,s){let r=-20,n=!1,i=Number.MAX_SAFE_INTEGER;const o=t.bDir.cross(s),a=sign(t.deltaT()),c=t.curve.diff(t.bT,1e-4*-a).dot(o);for(let a=e.length;a--;){const h=e[a],u=(t.bDir.negated().angleRelativeNormal(h.aDir,s)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION;if(eq0(u)){if(t.curve.isColinearTo(h.curve))continue;const e=sign(h.deltaT()),s=h.curve.diff(h.aT,1e-4*e).dot(o)-c;s<0&&(!n||s>r)&&(n=!0,r=s,i=a)}else n||gt(u,r)&&(r=u,i=a)}return i==Number.MAX_SAFE_INTEGER?0:i}class BRep$$1 extends Transformable{constructor(t,e,s,r){super(),this.faces=t,assertInst(Face$$1,...t),this.infiniteVolume=e,assert(!this.infiniteVolume||!0===this.infiniteVolume),this.generator=s,this.vertexNames=r,this.edgeFaces=void 0}static loop1ContainsLoop2(t,e,s,r,n){for(const e of s){const s=n.loopContainsPoint(t,e.a);if(PointVsFace.ON_EDGE!=s)return PointVsFace.INSIDE==s}for(const e of s){const s=e.curve.at(.2*e.aT+.8*e.bT),r=n.loopContainsPoint(t,s);if(PointVsFace.ON_EDGE!=r)return PointVsFace.INSIDE==r}if(e!=r)return r;throw new Error(t.sce+s.sce)}static assembleFacesFromLoops(t,e,s,r){const n=[],i=[];return t.forEach(t=>(function t(s,r){if(0==r.length)r.push(s);else{const n=r.find(t=>BRep$$1.loop1ContainsLoop2(t.loop,t.ccw,s.loop,s.ccw,e));if(n)t(s,n.subloops);else{for(let t=r.length;--t>=0;){const n=r[t];BRep$$1.loop1ContainsLoop2(s.loop,s.ccw,n.loop,n.ccw,e)&&(s.subloops.push(n),r.splice(t,1))}r.push(s)}}})({loop:t,ccw:e.edgeLoopCCW(t),subloops:[]},i)),i.forEach(t=>(function t(i){if(i.ccw)if(i.subloops.every(t=>!t.ccw)){const o=i.subloops.map(t=>t.loop),a=r&&r.newSubFace(s,e,i.loop,o),c=new s.constructor(e,i.loop,o,"genface"+getGlobalId$$1(),a);n.push(c),i.subloops.forEach(e=>e.subloops.forEach(e=>e.ccw&&t(e)))}else i.subloops.forEach(e=>e.ccw&&t(e))})(t)),n}static join(t,e){return new BRep$$1(t.flatMap(t=>t.faces),!1,e)}containsPoint(t,e=!1){const s=[V(-.3920414696448526,-.12936136783391444,-.9108068525164064),V(.6520650903544943,-.07151288645511984,-.7547827667692488),V(.9433494201061395,-.2402757256238473,-.22882186797013926),V(.13678704228501923,-.04480387361087783,.9895867410047372),V(.0662057922721913,-.5865836917435423,.8071780259955845),V(-.7322576567870621,-.12953393611526787,.6685953061989045),V(.6579719127258273,-.012300218400456116,.7529420075219719),V(-.5576497966736425,.8006695748324647,.2189861552871446)];t:for(const r of s){const s=new L3$$1(t,r);let n=this.infiniteVolume;for(const t of this.faces){assert(!t.surface.containsCurve(s));const r=t.surface.isTsForLine(s);for(const i of r){const r=s.at(i),o=t.containsPoint2(r);if(!e&&assert(!eq0(i)),i>0){if(o==PointVsFace.ON_EDGE)continue t;o==PointVsFace.INSIDE&&(n=!n)}}}return n}return!1}withMergedFaces(){const t=[];for(let e=0;e<this.faces.length;e++){let s=!1;for(let r=0;r<e;r++)if(this.faces[e].surface.isCoplanarTo(this.faces[r].surface)){const n=t.find(t=>t.includes(this.faces[r]));n&&(n.push(this.faces[e]),s=!0)}!s&&t.push([this.faces[e]])}if(console.log("likeSurfaceFaces",t),t.every(t=>1==t.length))return this;const e=[];let s=0;for(const r of t)if(console.log(r),1==r.length)e.push(r[0]);else{const t=r.flatMap(t=>t.getAllEdges());for(let e=t.length;e-- >0;)for(let r=0;r<e;r++)if(console.log("blugh",s),assert(e>=0&&r>=0&&s++<500,e+" "+r+" "+s),t[e].isCoEdge(t[r])){t.splice(e,1),t.splice(r,1),e--;break}const n=assembleFaceFromLooseEdges$$1(t,r[0].surface,r[0]);e.push(n)}return new BRep$$1(e,this.infiniteVolume,this.generator&&this.generator+".withMergedFaces()",this.vertexNames)}calculateVolume(){return this.faces.map(t=>t.zDirVolume().volume).sum()}toMesh(){const t=(new Mesh).addVertexBuffer("normals","ts_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");t.faceIndexes=new Map;for(const e of this.faces){const s=t.TRIANGLES.length;e.addToMesh(t),t.faceIndexes.set(e,{start:s,count:t.TRIANGLES.length-s})}return t}minus(t,e){const s=this.generator&&t.generator&&this.generator+".minus("+t.generator+")";return this.intersection(t.flipped(),!0,!0,s,e)}plus(t,e){const s=this.generator&&t.generator&&this.generator+".plus("+t.generator+")";return this.flipped().intersection(t.flipped(),!0,!0,s,e).flipped()}and(t,e){const s=this.generator&&t.generator&&this.generator+".and("+t.generator+")";return this.intersection(t,!0,!0,s,e)}xor(t,e){const s=this.generator&&t.generator&&this.generator+".xor("+t.generator+")";return new BRep$$1(this.minus(t,e).faces.concat(t.minus(this,e).faces),this.infiniteVolume!=t.infiniteVolume,s)}equals(t){return this.faces.length==t.faces.length&&this.faces.every(e=>t.faces.some(t=>e.equals(t)))}like(t){return this.faces.length==t.faces.length&&this.faces.every(e=>t.faces.some(t=>e.likeFace(t)))}toString(){return`new BRep([\n${this.faces.join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}getConstructorParameters(){return[this.faces,this.infiniteVolume]}toSource(t=!0){return t&&this.generator||`new BRep([\n${this.faces.map(SCE).join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}reconstituteFaces(t,e,s,r,n){const i=new Map,o=[];for(const c of t){const t=c.getAllEdges().filter(t=>!e.get(t)),h=c.getAllEdges().mapFilter(t=>e.get(t)).concatenated(),u=s.get(c)||[];if(u.length||h.length){i.set(c,"partial");const e=[];function a(){return u.find(t=>!s.has(t))||h.find(t=>!s.has(t))||t.find(t=>!s.has(t))}const s=new Set;let l;for(;l=a();){const r=l,n=[];let i=0;do{s.add(l),n.push(l);const e=t.filter(t=>l.b.like(t.a)),i=h.filter(t=>l.b.like(t.a)),o=u.filter(t=>l.b.like(t.a)),a=e.concat(i,o);if(0==a.length)break;assert(0<a.length,()=>c.sce);const f=c.surface.normalP(l.b),p=calcNextEdgeIndex$$1(l,a,f);if(l=a[p],s.has(l))break;assert(l),assert(l!=r)}while(++i<400);400==i&&assert(!1,"too many"),n.length>1&&l==r&&e.push(n)}const f=BRep$$1.assembleFacesFromLoops(e,c.surface,c,n);r.push(...f);const p=f.flatMap(t=>t.getAllEdges());o.push(...t.filter(t=>p.includes(t)))}}for(;0!=o.length;){const t=o.pop();this.edgeFaces.get(t.getCanon()).forEach(t=>{i.has(t.face)||(i.set(t.face,"inside"),o.push.apply(o,t.face.getAllEdges()))})}r.push(...t.filter(t=>"inside"==i.get(t)))}static getLooseEdgeSegments(t,e){const s=new JavaMap;for(const[n,i]of t){if(0==i.length)continue;const t=e.get(n);i.sort((t,e)=>snap0(t.edgeT-e.edgeT)||0);let o,a=n.a,c=n.aDir,h=n.aT;function r(e,r,i){for(let e=0;e<t.length;e++){const r=t[e];mapPush(s,r.reversed?n.flipped():n,r.reversed?i.flipped():i)}}for(let t=0;t<i.length;t++){const e=i[t],s=n.tangentAt(e.edgeT);if(!eq(e.edgeT,h)){r(0,0,Edge$$1.create(n.curve,a,e.p,h,e.edgeT,void 0,c,s,"looseSegment"+getGlobalId$$1()))}a=e.p,h=e.edgeT,o=e,c=s}if(o&&!eq(h,n.bT)){r(0,0,Edge$$1.create(n.curve,a,n.b,h,n.bT,void 0,c,n.bDir,"looseSegment"+getGlobalId$$1()))}}return s}getIntersectionEdges(t){const e=new Map,s=new JavaMap,r=new JavaMap,n=new JavaSet;return this.faces.forEach(i=>{t.faces.forEach(o=>{i.intersectFace(o,this,t,e,s,r,n)})}),Array.from(e.values()).concatenated()}shellCount(){const t=new Set;let e,s=0;for(;e=this.faces.find(e=>!t.has(e));){s++;const r=[e];for(;e=r.pop();)for(const s of e.getAllEdges())for(const{face:n}of this.edgeFaces.get(s.getCanon()))e===n||t.has(n)||(t.add(n),r.push(n))}return s}getAABB(){return AABB.forAABBs(this.faces.map(t=>t.getAABB()))}assertSanity(){if(NLA_DEBUG){this.buildAdjacencies();for(const[t,e]of this.edgeFaces)assert(e.length%2==0,()=>t+e.sce)}}buildAdjacencies(){if(this.edgeFaces)return this;this.edgeFaces=new JavaMap;for(const t of this.faces)for(const e of t.getAllEdges()){const s=e.getCanon(),r=t.surface.normalP(s.a),n=r.cross(s==e?e.aDir:e.bDir);mapPush(this.edgeFaces,s,{face:t,edge:e,normalAtCanonA:r,reversed:s!=e,inside:n,angle:0})}for(const[t,e]of this.edgeFaces){const s=e.find(t=>t.reversed);s?(e.forEach(e=>{e!=s&&(e.angle=s.inside.angleRelativeNormal(e.inside,t.aDir.unit()),e.angle<0&&(e.angle+=2*Math.PI))}),e.sort((t,e)=>snap(t.angle-e.angle,0))):console.warn("invalid brep")}return this}intersection(t,e,s,r,n){this.assertSanity(),t.assertSanity(),this.buildAdjacencies(),t.buildAdjacencies();const i=new Map,o=new JavaMap,a=new JavaMap,c=new JavaSet;for(const e of this.faces)for(const s of t.faces)e.intersectFace(s,this,t,i,o,a,c);for(const t of o.keys())assert(this.edgeFaces.get(t));for(const e of a.keys())assert(t.edgeFaces.get(e));const h=[];if(0==i.size&&0==o.size&&0==a.size){const e=t.containsPoint(this.faces[0].contour[0].a,!0)!==t.infiniteVolume,s=!e&&this.containsPoint(t.faces[0].contour[0].a)!==this.infiniteVolume;if(e||s){const[s,r]=e?[this,t]:[t,this];return s.infiniteVolume?r.infiniteVolume?r:BRep$$1.join([s,r]):r.infiniteVolume?BRep$$1.EMPTY:s}return this.infiniteVolume?t.infiniteVolume?BRep$$1.join([this,t]):BRep$$1.EMPTY:t.infiniteVolume?this:BRep$$1.EMPTY}if(e){const t=BRep$$1.getLooseEdgeSegments(o,this.edgeFaces);this.faces.map(e=>[e,Array.from(t.entries()).flatMap(([t,s])=>e.getAllEdges().some(e=>e.equals(t))?s:[])]);this.reconstituteFaces(this.faces,t,i,h,n)}if(s){const e=BRep$$1.getLooseEdgeSegments(a,t.edgeFaces);t.faces.map(t=>[t,Array.from(e.entries()).flatMap(([e,s])=>t.getAllEdges().some(t=>t.equals(e))?s:[])]);t.reconstituteFaces(t.faces,e,i,h,n)}return new BRep$$1(h,this.infiniteVolume&&t.infiniteVolume,r)}transform(t,e){let s;return this.vertexNames&&(s=new Map,this.vertexNames.forEach((r,n)=>s.set(t.transformPoint(n),r+e))),new BRep$$1(this.faces.map(e=>e.transform(t)),this.infiniteVolume,this.generator&&e&&this.generator+e,s)}transform4(t,e){let s;return this.vertexNames&&(s=new Map,this.vertexNames.forEach((r,n)=>s.set(t.transformPoint(n),r+e))),new BRep$$1(this.faces.map(e=>e.transform4(t)),this.infiniteVolume,this.generator&&e&&this.generator+e,s)}flipped(){return new BRep$$1(this.faces.map(t=>t.flipped()),!this.infiniteVolume,this.generator&&this.generator+".flipped()",this.vertexNames)}}function dotCurve$$1(t,e,s){let r=t.dot(e);return eq0(r)&&(r=t.dot(s)),assert(!eq0(r)),r}function dotCurve2$$1(t,e,s,r){assert(1==r||-1==r,r);const n=t.tangentAt(e).dot(s);if(!eq0(n))return r*n;if(t.ddt){const r=t.ddt(e).dot(s);if(!eq0(r))return r}const i=t.at(e).to(t.at(e+4*r*NLA_PRECISION)).dot(s);return assert(!(t instanceof L3$$1)),i}BRep$$1.EMPTY=new BRep$$1([],!1,"BRep.EMPTY",new Map).buildAdjacencies(),BRep$$1.R3=new BRep$$1([],!0,"BRep.R3",new Map).buildAdjacencies();const INSIDE$$1=0,OUTSIDE$$1=1,COPLANAR_SAME$$1=2,COPLANAR_OPPOSITE$$1=3,ALONG_EDGE_OR_PLANE$$1=4;function splitsVolumeEnclosingFaces$$1(t,e,s,r){assert(4==arguments.length),assert(e==e.getCanon());const n=t.edgeFaces.get(e);assertf(()=>n.length%2==0),assertf(()=>t.edgeFaces);const i=n[0],o=e.aDir.unit(),a=(i.inside.angleRelativeNormal(s,o)+2*Math.PI+NLA_PRECISION)%(2*Math.PI)-NLA_PRECISION,c=n.findIndex(t=>lt(a,t.angle)),h=n[-1==c?n.length-1:c-1];if(eq(h.angle,a)){return h.normalAtCanonA.dot(r)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}return h.reversed?INSIDE$$1:OUTSIDE$$1}function splitsVolumeEnclosingFacesP$$1(t,e,s,r,n){assert(5==arguments.length),assert(e==e.getCanon()),assertf(()=>t.edgeFaces);const i=t.edgeFaces.get(e);assertf(()=>i.length%2==0);const o=e.tangentAt(e.curve.pointT(s)).unit(),a=t=>{const e=t.edge.getCanon()==t.edge?o:o.negated(),n=t.face.surface.normalP(s).cross(e);return-((r.angleRelativeNormal(n,o)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION)},c=i.withMax(a);if(eq0(a(c))){return c.face.surface.normalP(s).dot(n)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}return c.reversed?OUTSIDE$$1:INSIDE$$1}function splitsVolumeEnclosingFacesP2$$1(t,e,s,r,n,i,o){assert(e==e.getCanon()),assertf(()=>t.edgeFaces);const a=t.edgeFaces.get(e);assertf(()=>a.length%2==0);const c=e.tangentAt(e.curve.pointT(s)).unit();let h=r.tangentAt(n).times(i);h.isParallelTo(c)&&(h=(h=r.diff(n,1e-4*i/r.tangentAt(n).length()).rejectedFrom(c)).div(h.length()));let u=20,l=!1,f=OUTSIDE$$1;for(const t of a){const e=t.edge.getCanon()==t.edge?c:c.negated(),a=t.face.surface.normalP(s).cross(e),p=(h.angleRelativeNormal(a,c)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION;if(eq0(p)){const e=t.face.surface.normalP(s);if(t.face.surface.containsCurve(r)){return e.dot(o)>0?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1}const a=P3$$1.normalOnAnchor(c,s),p=t.face.surface.isCurvesWithPlane(a)[0],d=p.pointT(s),m=sign(p.tangentAt(d).dot(h)),$=1e-4,g=(p.at(d).to(p.at(d+i*m*$)).dot(e)-r.at(n).to(r.at(n+i*$)).dot(e))*(t.reversed?-1:1);g>0&&(!l||g<u)&&(l=!0,u=g,f=t.reversed?OUTSIDE$$1:INSIDE$$1)}else l||p<u&&(u=p,f=t.reversed?OUTSIDE$$1:INSIDE$$1)}return f}function splitsVolumeEnclosingCone$$1(t,e,s){const r=P3$$1.forAnchorAndPlaneVectors(e,s,s.getPerpendicular()),n=[];for(let i=0;i<t.faces.length;i++){const o=t.faces[i];if(assertf(()=>o instanceof PlaneFace$$1),o.getAllEdges().some(t=>t.a.like(e)))if(r.isParallelToPlane(o.surface.plane)){if(o.pointsToInside(e,s)!=PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE$$1}else{const t=L3$$1.fromPlanes(r,o.surface.plane),i=o.edgeISPsWithPlane(t,r);let a=0;for(;a<i.length;){const o=i[a++],c=i[a++],h=o.p.like(e);if(h||c.p.like(e)){const e=h?t.dir1:t.dir1.negated(),i=(s.angleRelativeNormal(e,r.normal1)+2*Math.PI+NLA_PRECISION/2)%(2*Math.PI);n.push({angle:i,out:h})}}}}return n.sort((t,e)=>t.angle-e.angle),eq0(n[0].angle)?ALONG_EDGE_OR_PLANE$$1:n[0].out?OUTSIDE$$1:INSIDE$$1}function splitsVolumeEnclosingCone2$$1(t,e,s,r,n){assert(s.containsPoint(e));const i=t.faces.filter(t=>t.getAllEdges().some(t=>t.a.like(e)));for(let t=0;t<i.length;t++){const o=i[t];if(o.surface.containsCurve(s)&&o.pointsToInside3(e,s,r,n)!=PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE$$1}return t.containsPoint(s.at(r+1e-6*n),!0)?INSIDE$$1:OUTSIDE$$1}function fff$$1(t,e){const s=t.edge.reversed?t.edge.b:t.edge.a,r=e.normalP(s),n=snap0(t.inside.dot(r));if(0!==n)return 0<n?OUTSIDE$$1:INSIDE$$1;if(e.isCoplanarTo(t.face.surface))return 0<t.normalAtCanonA.dot(r)?COPLANAR_SAME$$1:COPLANAR_OPPOSITE$$1;throw new Error}function triangulateVertices$$1(t,e,s){const r=t.maxAbsDim(),n=sign(t.e(r)),i=new Float64Array(2*e.length);let o=e.length;for(;o--;)switch(r){case 0:i[2*o]=e[o].y*n,i[2*o+1]=e[o].z;break;case 1:i[2*o]=e[o].z*n,i[2*o+1]=e[o].x;break;case 2:i[2*o]=e[o].x*n,i[2*o+1]=e[o].y}return earcut(i,s)}function intersectionUnitCircleLine$$1(t,e,s){assertNumbers(t,e,s);const r=sqrt(t*t+e*e-s*s);return{x1:(t*s+e*r)/(t*t+e*e),x2:(t*s-e*r)/(t*t+e*e),y1:(e*s-t*r)/(t*t+e*e),y2:(e*s+t*r)/(t*t+e*e)}}function intersectionUnitCircleLine2$$1(t,e,s){assertNumbers(t,e,s);const r=snap0(t*t+e*e-s*s);if(r<0)return[];if(0==r)return[[t*s/(t*t+e*e),e*s/(t*t+e*e)]];{const n=sqrt(r);return[[(t*s+e*n)/(t*t+e*e),(e*s-t*n)/(t*t+e*e)],[(t*s-e*n)/(t*t+e*e),(e*s+t*n)/(t*t+e*e)]]}}function intersectionCircleLine$$1(t,e,s,r){assertNumbers(t,e,s,r);const n=sqrt(r*r*(t*t+e*e)-s*s);return{x1:(t*s+e*n)/(t*t+e*e),x2:(t*s-e*n)/(t*t+e*e),y1:(e*s-t*n)/(t*t+e*e),y2:(e*s+t*n)/(t*t+e*e)}}function intersectionUnitHyperbolaLine$$1(t,e,s){assertNumbers(t,e,s);const r=t*t,n=e*e,i=s*s,o=2*sqrt(n*i+n*n-r*n),a=sqrt(4*i*n-4*(n-r)*(i-r));return{x1:(-2*t*s+o)/2/(n-r),x2:(-2*t*s-o)/2/(n-r),y1:(2*e*s-a)/2/(n-r),y2:(2*e*s+a)/2/(n-r)}}function curvePointPP$$1(t,e,s,r){const n=NLA_PRECISION/4;let i,o,a,c,h,u=s,l=t.pointFoot(u),f=e.pointFoot(u),p=16;do{if(i=t.pUV(l.x,l.y),o=e.pUV(f.x,f.y),eq0(i.distanceTo(o),n))break;a=t.normalUV(l.x,l.y),c=e.normalUV(f.x,f.y),h=a.cross(c),u=V3.add(c.cross(h).times(i.dot(a)),h.cross(a).times(o.dot(c)),h.times(h.dot(u))).div(h.squared()),l=t.pointFoot(u,l.x,l.y),f=e.pointFoot(u,f.x,f.y)}while(--p);if(eq0(i.distanceTo(o),n))return{p:u,st1:l,st2:f}}function followAlgorithmPP$$1(t,e,s,r,n=uvInAABB2$$1.bind(void 0,t),i=uvInAABB2$$1.bind(void 0,e)){const o=[],a=[],c=[],h=[];let u=s,l=t.uvP(u),f=e.uvP(u);assert(t.pUV(l.x,l.y).like(u)),assert(l.like(t.pointFoot(u,l.x,l.y))),assert(f.like(e.pointFoot(u,f.x,f.y))),assert(e.pUV(f.x,f.y).like(u));for(let s=0;s<1e3;s++){({p:u,st1:l,st2:f}=curvePointPP$$1(t,e,u)),assert(t.containsPoint(u),u,t),assert(e.containsPoint(u));const p=t.normalUV(l.x,l.y),d=e.normalUV(f.x,f.y),m=p.cross(d).toLength(r);if(a.push(m),o.push(u),c.push(l),h.push(f),s>4&&(!n(l.x,l.y)||!i(f.x,f.y)))break;u=u.plus(m)}return{points:o,tangents:a,st1s:c,st2s:h}}function followAlgorithm2d$$1(t,e,s=.5,r,n,i,o){assertNumbers(s,t(0,0)),assertVectors(e),o||(o=new V3(-t.y(e.x,e.y),t.x(e.x,e.y),0).toLength(s)),assertVectors(o);const a=[],c=[];assert(eq0(t(e.x,e.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))",t(e.x,e.y));let h=0,u=e,l=o,f=!1;do{a.push(u),c.push(l);const o=u.plus(l);assert(o);const p=curvePointMF$$1(t,o),d=t.x(p.x,p.y),m=t.y(p.x,p.y),$=new V3(-m,d,0).toLength(s);if(assert(!u.equals(p)),l.dot($)<0){const e=newtonIterate2d(t.x,t.y,u.x,u.y);if(eq0(t(e.x,e.y))&&e.distanceTo(u)<abs(s)){a.push(e),c.push(u.to(e));break}throw new Error}if(i&&u.equals(i))break;if(f){if(u.distanceTo(e)>abs(s)){a.pop(),c.pop(),assert(a.last.distanceTo(e)<=abs(s));break}}else h>4&&u.distanceTo(e)<=abs(s)&&(f=!0);if(h>1&&!uvInAABB2$$1(r,u.x,u.y)){const e=figureOutBorderPoint(r,u,t);a.pop(),c.pop(),a.last.distanceTo(e)<abs(s)/2&&(a.pop(),c.pop());const n=new V3(-t.y(e.x,e.y),t.x(e.x,e.y),0).toLength(s);a.push(e),c.push(n);break}if(h>4&&!n(u.x,u.y))break;assert(eq0(t(p.x,p.y),2*NLA_PRECISION),u,p,o,t(p.x,p.y)),l=$,u=p}while(++h<1e3);return assert(h<1e3),{points:a,tangents:c}}function figureOutBorderPoint(t,e,s){if(e.x<t.uMin||t.uMax<e.x){const r=t.uMax<e.x?t.uMax:t.uMin,n=newtonIterateWithDerivative(t=>s(r,t),e.y,4,t=>s.y(r,t));if(uvInAABB2$$1(t,r,n))return new V3(r,n,0)}if(e.y<t.vMin||t.vMax<e.y){const r=t.vMax<e.y?t.vMax:t.vMin,n=newtonIterateWithDerivative(t=>s(t,r),e.x,4,t=>s.x(t,r));return assert(uvInAABB2$$1(t,n,r)),new V3(n,r,0)}throw new Error(e+" "+t)}function followAlgorithm2dAdjustable$$1(t,e,s=.5,r,n=e){assertNumbers(s,t(0,0)),assertVectors(e);const i=[],o=[];assert(eq0(t(e.x,e.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let a=e,c=a,h=0;do{const e=t.x(a.x,a.y),s=t.y(a.x,a.y),r=t.xx(a.x,a.y),n=t.yy(a.x,a.y),h=t.xy(a.x,a.y),u=abs((Math.pow(s,2)*r-2*e*s*h+Math.pow(e,2)*n)/Math.pow(Math.pow(e,2)+Math.pow(s,2),2)),l=new V3(e,s,0).times(u),f=1/16/l.length(),p=new V3(-s,e,0).unit(),d=a.plus(p.times(f).plus(l.times(Math.pow(f,2)/2)));i.push(a),o.push(p),c=a;const m=curvePointMF$$1(t,d);m.equals(a)&&assertNever(),console.log(a.to(m).length()),assert(eq0(t((a=m).x,a.y)))}while(h++<1e3&&(h<4||c.distanceTo(n)>s)&&r(a.x,a.y));assert(1e3!=h);const u=h<4||c.distanceTo(n)>s?a:n,l=new V3(-t.y(u.x,u.y),t.x(u.x,u.y),0).toLength(s);return i.push(u),o.push(l),{points:i,tangents:o}}function intersectionICurveICurve$$1(t,e,s,r,n,i){assertNumbers(n,t(0,0),i(0,0)),assertVectors(e,s),assert(!r||r instanceof V3);const o=[];assert(eq0(t(e.x,e.y))),n=n||.5;let a=e,c=a,h=0;for(;h++<1e3&&(h<4||a.distanceTo(s)>1.1*n);){const e=t(a.x,a.y),s=(t(a.x+1e-5,a.y)-e)/1e-5,r=(t(a.x,a.y+1e-5)-e)/1e-5;let i=new V3(-r,s,0).toLength(n);a.minus(c).dot(i)<0&&(i=i.negated()),c=a,a=curvePointMF$$1(t,a.plus(i)),o.push(a)}return o}function intersectionICurveICurve2$$1(t,e,s){let r,n=e[0],i=s(n.x,n.y);const o=[];for(let a=0;a<e.length;a++)r=i,(i=s((n=e[a]).x,n.y))*r<=0&&o.push(newtonIterate2d(t,s,n.x,n.y));return o}function cassini$$1(t,e){return(s,r)=>(s*s+r*r)*(s*s+r*r)-2*e*e*(s*s-r*r)-(Math.pow(t,4)-Math.pow(e,4))}var MathFunctionR2R;!function(t){t.forNerdamer=function(t,e=["x","y"]){const s=nerdamer(t),r=nerdamer.diff(s,e[0]),n=nerdamer.diff(s,e[1]),i=s.buildFunction(e);return i.x=r.buildFunction(e),i.y=n.buildFunction(e),i.xx=nerdamer.diff(r,e[0]).buildFunction(e),i.xy=nerdamer.diff(r,e[1]).buildFunction(e),i.yy=nerdamer.diff(n,e[1]).buildFunction(e),i},t.nerdamerToR2_R=function(t,e=["x","y"]){return t.buildFunction(e)},t.forFFxFy=function(t,e,s){return t.x=e,t.y=s,t}}(MathFunctionR2R||(MathFunctionR2R={}));const cas2$$1=cassini$$1(.9,1.02);function arrayLerp$$1(t,e,s){return 0==s%1?e[s]:t(e[Math.floor(s)],e[Math.ceil(s)],s%1)}function doNotSerialize$$1(t,e){(t.__SERIALIZATION_BLACKLIST||(t.__SERIALIZATION_BLACKLIST={}))[e]="no"}class ClassSerializer$$1{constructor(){this.CLASS_NAMES=new Map,this.NAME_CLASSES=new Map,this.addClass("Object",Object)}addClass(t,e){if(this.NAME_CLASSES.has(t))throw new Error(t);return this.NAME_CLASSES.set(t,e),this.CLASS_NAMES.set(e,t),this}addNamespace(t,e){return Object.keys(t).forEach(s=>{const r=t[s];"function"==typeof r&&r.name&&this.addClass((e?e+".":"")+s,r)}),this}setUpdater(t){return this.updater=t,this}serialize(t){return JSON.stringify(this.serializeObj(t))}serializeObj(t){const e=t=>{if(void 0!==t&&t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor));else if(Array.isArray(t))if(r.has(t))n.has(t)||(n.set(t,i.length),i.push(t));else{r.add(t);for(let s=0;s<t.length;s++)e(t[s])}else if(void 0!==t&&"object"==typeof t)if(r.has(t))n.has(t)||(n.set(t,i.length),i.push(t));else{if(assert(!t.__noxTarget||!r.has(t.__noxTarget)),assert(!t.__noxProxy||!r.has(t.__noxProxy)),r.add(t),!t.getConstructorParameters)for(const s of Object.keys(t).sort())"__noxProxy"!=s&&"__noxTarget"!=s&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[s]||e(t[s]));e(Object.getPrototypeOf(t))}},s=(t,e,r)=>{if("string"==typeof t||"number"==typeof t||"boolean"==typeof t||null===t)return t;if(void 0===t)return{"#REF":-1};if(t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor))return{"#REF":this.CLASS_NAMES.get(t.constructor)};let i;if(e&&!r&&void 0!==(i=n.get(t)))return{"#REF":i};if(Array.isArray(t))return t.map(t=>s(t,e));if("object"==typeof t){if(t.getConstructorParameters)return{"#CONSTRUCTOR":this.CLASS_NAMES.get(t.constructor),"#ARGS":s(t.getConstructorParameters(),!1)};const r={};Object.prototype!==Object.getPrototypeOf(t)&&(r["#PROTO"]=s(Object.getPrototypeOf(t),e));for(const n of Object.keys(t))"__noxProxy"!=n&&"__noxTarget"!=n&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[n]||(r[n]=s(t[n],e)));return r}throw new Error("?"+typeof t+t.toString())},r=new Set,n=new Map;let i=[];return n.set(t,0),i.push(t),e(t),i=i.map(t=>s(t,!0,!0))}unserialize(t){let e=0;const s=(t,i)=>{if(++e>100)throw new Error;if(t&&t.constructor===Array){i(t);for(let e=0;e<t.length;e++)s(t[e],s=>t[e]=s)}else if("object"==typeof t&&void 0!=t)if("#CONSTRUCTOR"in t){const e=t["#CONSTRUCTOR"],r=this.NAME_CLASSES.get(e);assert(r,e+" Missing ");let n=void 0;s(t["#ARGS"],t=>n=t),i(new r(...n))}else if("#REF"in t){const e=t["#REF"];"string"==typeof e?i(this.NAME_CLASSES.get(e).prototype):"number"==typeof e&&(-1==e?i(void 0):n[e]?i(n[e]):s(r[e],t=>i(n[e]=t)))}else{let e;"#PROTO"in t?s(t["#PROTO"],t=>{e=Object.create(t),i(e)}):i(e=t);const r=Object.keys(t);for(let n=0;n<r.length;n++)"#PROTO"!=r[n]&&s(t[r[n]],t=>e[r[n]]=t);Object.defineProperty(e,"loadID",{value:getGlobalId$$1(),enumerable:!1,writable:!1}),this.updater&&this.updater(e)}else i(t);e--},r=JSON.parse(t),n=new Array(r.length);return s({"#REF":0},()=>{}),n[0]}}const fragmentShaderLighting="\n\tprecision highp float;\n\tuniform vec4 color;\n\tuniform vec3 camPos;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tvec3 normal1 = normalize(normal);\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\n\t\tvec3 lightDir = normalize(vPosition.xyz - lightPos);\n        vec3 reflectionDirection = reflect(lightDir, normal1);\n        vec3 eyeDirection = normalize(camPos.xyz-vPosition.xyz);\n        float uMaterialShininess = 256.0;\n\t\tfloat specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n\t\tfloat lightIntensity = 0.6 + 0.2 * max(0.0, -dot(lightDir, normal1)) + 0.2*specularLightWeighting;\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\n\t}\n",vertexShaderLighting="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tuniform mat4 ts_ModelViewMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n        vPosition = ts_ModelViewMatrix * ts_Vertex;\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\n\t}\n",vertexShaderWaves="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tuniform mat4 ts_ModelViewMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tnormal = normalize(ts_NormalMatrix * ts_Normal);\n\t\tfloat offset = mod  (((ts_Vertex.x + ts_Vertex.y + ts_Vertex.z) * 31.0), 20.0) - 10.0;\n\t\tvec4 modPos = ts_Vertex + vec4(normal * offset, 0);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * modPos;\n        vPosition = ts_ModelViewMatrix * modPos;\n\t}\n",vertexShaderBasic="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t}\n",vertexShaderColor="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tattribute vec4 ts_Color;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t\tfragColor = ts_Color;\n\t}\n",vertexShaderArc="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float step, offset;\n\tuniform float radius, width;\n\tvoid main() {\n\t\tfloat r = radius;\n\t\tfloat t = offset + ts_Vertex.x * step;\n\t\tfloat pRadius = r - ts_Vertex.y * width;\n\t\tvec4 p = vec4(pRadius * cos(t), pRadius * sin(t), 0, 1);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\n}\n",vertexShaderConic3d="\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec3 center, f1, f2;\n\tuniform int mode;\n\tfloat sinh(float x) { return (exp(x) - exp(-x)) / 2.0; }\n\tfloat cosh(float x) { return (exp(x) + exp(-x)) / 2.0; }\n\tvoid main() {\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\n\n\t\tvec3 normal = normalize(cross(f1, f2));\n\n\t\tvec3 p, tangent;\n\t\tif (0 == mode) { // ellipse\n\t\t\tp = center + f1 * cos(t) + f2 * sin(t);\n\t\t\ttangent = f1 * -sin(t) + f2 * cos(t);\n\t\t}\n\t\tif (1 == mode) { // parabola\n\t\t\tp = center + f1 * t + f2 * t * t;\n\t\t\ttangent = f1 + 2.0 * f2 * t;\n\t\t}\n\t\tif (2 == mode) { // hyperbola\n\t\t\tp = center + f1 * cosh(t) + f2 * sinh(t);\n\t\t\ttangent = f1 * sinh(t) + f2 * cosh(t);\n\t\t}\n\t\tvec3 outDir = normalize(cross(normal, tangent));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + normal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderNURBS="#version 300 es\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tin vec4 ts_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec4 points[32];\n\tuniform int pointCount, degree;\n\tuniform float knots[40];\n\tuniform vec3 normal;\n\tconst int MIN_DEGREE = 1;\n\tconst int MAX_DEGREE = 6;\n\t\n\tint tInterval(float t) {\n\t\tfor (int s = degree; s < 40 - 1 - degree; s++) {\n\t\t\tif (t >= knots[s] && t <= knots[s + 1]) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec4 stepp(int k, int i, vec4 dkMinus1iMinus1, vec4 dkMinus1i) {\n\t    return dkMinus1i - dkMinus1iMinus1 * float(k) / (knots[i + degree - k] - knots[i - 1]);\n\t}\n\t\n\tvoid main() {\n\t\t// ts_Vertex.x is in [0, 1]\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT);\n\t\t\n\t\tint s = tInterval(t);\n\t\t\n\t\tvec4 v[MAX_DEGREE + 1];\n\t\tfor (int i = 0; i < degree + 1; i++) {\n\t\t    v[i] = points[s - degree + i];\n\t\t}\n\t\t\n\t\tvec4 pTangent4, ddt4 = vec4(0, 0, 1, 0);\n\t\tfor (int level = 0; level < degree; level++) {\n\t\t\tif (level == degree - 2) {\n\t\t\t\t// see https://www.globalspec.com/reference/61012/203279/10-8-derivatives\n\t\t\t\tvec4 a = v[degree];\n\t\t\t\tvec4 b = v[degree - 1];\n\t\t\t\tvec4 c = v[degree - 2];\n\t\t\t\tddt4 = stepp(degree, s + 1, stepp(degree - 1, s + 1, a, b), stepp(degree - 1, s, b, c));\n\t\t\t}\n\t\t\tif (level == degree - 1) {\n\t\t\t\tvec4 a = v[degree];\n\t\t\t\tvec4 b = v[degree - 1];\n\t\t\t\tpTangent4 = (b - a) * (float(degree) / (knots[s] - knots[s + 1]));\n\t\t\t}\n\t\t\tfor (int i = degree; i > level; i--) {\n\t\t\t\tfloat alpha = (t - knots[i + s - degree]) / (knots[i + s - level] - knots[i + s - degree]);\n\n\t\t\t\t// interpolate each component\n                v[i] = (1.0 - alpha) * v[i - 1] + alpha * v[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec4 p4 = v[degree];\n\t\t\n\t\tvec3 p = p4.xyz / p4.w;\n\t\tvec3 pTangent = ((pTangent4.xyz * p4.w) - (p4.xyz * pTangent4.w)) / (p4.w * p4.w);\n\t\tvec3 ddt = (\n\t\t    p4.xyz * (-p4.w * ddt4.w + 2.0 * pow(pTangent4.w, 2.0))\n\t\t    + pTangent4.xyz * (-2.0 * p4.w * pTangent4.w) \n\t\t    + ddt4.xyz * pow(p4.w, 2.0)\n        ) / pow(p4.w, 3.0);\n\t\t\n\t\tvec3 outDir = normalize(cross(ddt, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n    }\n",vertexShaderBezier="\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform float width, startT, endT;\n\tuniform vec3 p0, p1, p2, p3;\n\tvoid main() {\n\t\t// ts_Vertex.x is in [0, 1]\n\t\tfloat t = startT + ts_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 pPos = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 pNormal = normalize(vec3(pTangent.y, -pTangent.x, 0));\n\t\tvec4 p = vec4(pPos - ts_Vertex.y * width * pNormal, 1);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * p;\n\t}\n",vertexShaderBezier3d="\n    precision highp float;\n    // calculates a bezier curve using ts_Vertex.x as the (t) parameter of the curve\n\tuniform float scale, startT, endT;\n\tuniform vec3 ps[4];\n\tuniform vec3 p0, p1, p2, p3, normal;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\t// ts_Vertex.y is in [0, 1]\n\t\tvec3 p5 = ps[0];\n\t\tfloat t = startT * (1.0 - ts_Vertex.x) + endT * ts_Vertex.x, s = 1.0 - t;\n\t\tfloat c0 = s * s * s, \n\t\t      c1 = 3.0 * s * s * t, \n\t\t      c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 p = (p0 * c0 + p1 * c1) + (p2 * c2 + p3 * c3);\n\t\tfloat c01 = 3.0 * s * s, \n\t\t      c12 = 6.0 * s * t, \n\t\t      c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 outDir = normalize(cross(normal, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * ts_Vertex.y + correctNormal * ts_Vertex.z);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderGeneric="\n\tuniform float scale;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tuniform mat3 ts_NormalMatrix;\n\tattribute vec3 ts_Normal;\n\tvoid main() {\n\t\tvec3 normal = normalize(ts_NormalMatrix * ts_Normal);\n\t\tvec4 vertexPos = ts_Vertex + vec4(normal * scale, 0);\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vertexPos;\n\t}\n",vertexShaderRing="\n\t#define M_PI 3.1415926535897932384626433832795\n\tuniform float step;\n\tuniform float innerRadius, outerRadius;\n\tattribute float index;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tattribute vec4 ts_Vertex;\n\tvoid main() {\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(index, index, index, 1);\n\t\tfloat id = atan(ts_Vertex.x, ts_Vertex.y) / M_PI  * 32.0;\n\t\tfloat radius = mod(id, 2.0) < 1.0 ? outerRadius : innerRadius;\n\t\tgl_Position = ts_ModelViewProjectionMatrix * vec4(radius * cos(index * step), radius * sin(index * step), 0, 1);\n\t}\n",fragmentShaderColor="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = color;\n\t}\n",fragmentShaderColor3="#version 300 es\n\tprecision highp float;\n\tuniform vec4 color;\n\tout vec4 fragColor;\n\tvoid main() {\n\t\tfragColor = color;\n\t}\n",fragmentShaderVaryingColor="\n\tprecision highp float;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_FragColor = fragColor;\n\t}\n",fragmentShaderColorHighlight="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tfloat diagonal = (gl_FragCoord.x + 2.0 * gl_FragCoord.y);\n\t\tif (mod(diagonal, 50.0) > 40.0) { // mod(diagonal, 2.0) > 1.0\n\t\t\tdiscard;\n\t\t\t//gl_FragColor = color + vec4(0.2,0.2,0.2,0);\n\t\t} else {\n\t\t\tgl_FragColor = color - vec4(0.2,0.2,0.2,0);\n\t\t}\n\t}\n",vertexShaderTexture="\n\tvarying vec2 texturePos;\n\tattribute vec4 ts_Vertex;\n\tuniform mat4 ts_ModelViewProjectionMatrix;\n\tvoid main() {\n\t\ttexturePos = ts_Vertex.xy;\n\t\tgl_Position = ts_ModelViewProjectionMatrix * ts_Vertex;\n\t}\n",fragmentShaderTextureColor="\n\tprecision highp float;\n\tvarying vec2 texturePos;\n\tuniform vec4 color;\n\tuniform sampler2D texture;\n\tvoid main() {\n\t\tgl_FragColor = texture2D(texture, texturePos) * color;\n\t}\n";function parseGetParams$$1(t){const e={};return t.split("&").forEach(function(t){const s=t.indexOf("=");-1==s?e[t]=t:e[t.substr(0,s)]=decodeURI(t.substr(s+1))}),e}const COLORS$$1={RD_FILL:chroma("#9EDBF9"),RD_STROKE:chroma("#77B0E0"),TS_FILL:chroma("#D19FE3"),TS_STROKE:chroma("#A76BC2"),PP_FILL:chroma("#F3B6CF"),PP_STROKE:chroma("#EB81B4")};class BREPGLContext$$1{constructor(t){this.cachedMeshes=new WeakMap,this.shaders=initShaders$$1(t),initMeshes$$1(this.meshes={},t)}static create(t){return addOwnProperties(t,BREPGLContext$$1.prototype),addOwnProperties(t,new BREPGLContext$$1(t)),t}drawPoint(t,e=GL_COLOR_BLACK,s=5){this.pushMatrix(),this.translate(t),this.scale(s/2,s/2,s/2),this.shaders.singleColor.uniforms({color:e}).draw(this.meshes.sphere1),this.popMatrix()}drawEdge(t,e=GL_COLOR_BLACK,s=2){CURVE_PAINTERS$$1[t.curve.constructor.name](this,t.curve,e,t.minT,t.maxT,s)}drawCurve(t,e=GL_COLOR_BLACK,s=2,r,n){CURVE_PAINTERS$$1[t.constructor.name](this,t,e,r,n,s)}drawVector(t,e,s=GL_COLOR_BLACK,r=1){if(t.likeO())return;this.pushMatrix();const n=4*r;if(n>t.length())return;const i=t.getPerpendicular().unit();this.multMatrix(M4.forSys(t.unit(),i,t.cross(i).unit(),e)),this.scale(t.length()-n,r/2,r/2),this.shaders.singleColor.uniforms({color:s}).draw(this.meshes.vectorShaft),this.scale(1/(t.length()-n),1,1),this.translate(t.length()-n,0,0),this.scale(n/2,1,1),this.shaders.singleColor.draw(this.meshes.vectorHead),this.popMatrix()}drawVectors(t,e){this.drawVector(V3.X,V3.O,chroma("red").gl(),e),this.drawVector(V3.Y,V3.O,chroma("green").gl(),e),this.drawVector(V3.Z,V3.O,chroma("blue").gl(),e),t.forEach(t=>this.drawVector(t.v,t.anchor,t.color,e))}drawPlane(t,e,s=!1){this.pushMatrix(),this.multMatrix(M4.forSys(t.right,t.up,t.normal1)),this.translate(t.uMin,t.vMin,t.w),this.scale(t.uMax-t.uMin,t.vMax-t.vMin,1);const r=s?this.meshes.xyDottedLinePlane:this.meshes.xyLinePlane;this.shaders.singleColor.uniforms({color:e}).draw(r,this.LINES),this.popMatrix()}drawBox(t,e){this.pushMatrix(),this.multMatrix(t),e?this.shaders.singleColor.uniforms({color:e}).draw(this.meshes.cube,this.LINES):this.shaders.multiColor.draw(this.meshes.cube,this.LINES),this.popMatrix()}}function conicPainter(t,e,s,r,n,i,o=2){e.shaders.ellipse3d.uniforms({f1:s.f1,f2:s.f2,center:s.center,color:r,startT:n,endT:i,scale:o,mode:t}).draw(e.meshes.pipe)}const CURVE_PAINTERS$$1={[EllipseCurve$$1.name]:conicPainter.bind(void 0,0),[ParabolaCurve$$1.name]:conicPainter.bind(void 0,1),[HyperbolaCurve$$1.name]:conicPainter.bind(void 0,2),[ImplicitCurve$$1.name](t,e,s,r,n,i=2){let o=t.cachedMeshes.get(e);o||(o=(new Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","ts_Normal"),e.addToMesh(o,4),o.compile(),t.cachedMeshes.set(e,o));const a=ceil(r),c=floor(n);if(a<=c){const h=24;if(t.shaders.generic3d.uniforms({color:s,scale:i}).draw(o,t.TRIANGLES,a*h,(floor(n)-a)*h),r%1!=0){const n=e.at(r);t.pushMatrix();const c=M4.forSys(n.to(e.points[a]),o.normals[4*a].toLength(i),o.normals[4*a+1].toLength(i),n);t.multMatrix(c),t.shaders.singleColor.uniforms({color:s}).draw(t.meshes.pipeSegmentForICurve),console.log(t.meshes.pipeSegmentForICurve),t.popMatrix()}if(n%1!=0){const r=e.at(n);t.pushMatrix();const a=M4.forSys(e.points[c].to(r),o.normals[4*c].toLength(i),o.normals[4*c+1].toLength(i),e.points[c]);t.multMatrix(a),t.shaders.singleColor.uniforms({color:s}).draw(t.meshes.pipeSegmentForICurve),t.popMatrix()}}else{const o=e.at(r),a=e.at(n);t.pushMatrix();const c=o.to(a),h=c.getPerpendicular().toLength(i),u=c.cross(h).toLength(i),l=M4.forSys(c,h,u,o);t.multMatrix(l),t.shaders.singleColor.uniforms({color:s}).draw(t.meshes.pipeSegmentForICurve),t.popMatrix()}},[BezierCurve$$1.name](t,e,s,r,n,i=2,o=V3.Z){t.shaders.bezier3d.uniforms({p0:e.p0,p1:e.p1,p2:e.p2,p3:e.p3,color:s,startT:r,endT:n,scale:i,normal:o}).draw(t.meshes.pipe)},[NURBS$$1.name](t,e,s,r,n,i=2,o=V3.Z){t.shaders.nurbs.uniforms({"points[0]":Vector.pack(e.points),degree:e.degree,"knots[0]":e.knots,color:s,startT:r,endT:n,scale:i,normal:o}).draw(t.meshes.pipe)},[L3$$1.name](t,e,s,r,n,i=2,o=V3.Z){t.pushMatrix();const a=e.at(r),c=e.at(n).minus(a),h=c.getPerpendicular().unit(),u=M4.forSys(c,h,c.cross(h).unit(),a);t.multMatrix(u),t.scale(1,i,i),t.shaders.singleColor.uniforms({color:s}).draw(t.meshes.pipe),t.popMatrix()}};function initMeshes$$1(t,e){e.makeCurrent(),t.cube=(()=>{const t=B2T.box().toMesh().addVertexBuffer("colors","ts_Color");return t.colors=t.vertices.map(t=>[t.x,t.y,t.z,1].map(t=>.9*t)),t.compile(),t})(),t.sphere1=Mesh.sphere(2),t.segment=Mesh.plane({startY:-.5,height:1,detailX:128}),t.text=Mesh.plane(),t.vector=Mesh.rotation([V3.O,V(0,.05,0),V(.8,.05),V(.8,.1),V(1,0)],L3$$1.X,TAU,16,!0),t.vectorShaft=Mesh.rotation([V3.O,V3.Y,V3.XY],L3$$1.X,TAU,8,!0),t.vectorHead=Mesh.rotation([V3.Y,V(0,2,0),V(2,0,0)],L3$$1.X,TAU,8,!0),t.pipe=Mesh.rotation(arrayFromFunction(512,(t,e)=>new V3(t/(e-1),-.5,0)),L3$$1.X,TAU,8,!0),t.xyLinePlane=Mesh.plane(),t.xyDottedLinePlane=makeDottedLinePlane(),t.pipeSegmentForICurve=Mesh.offsetVertices(M4.rotateY(90*DEG).transformedPoints(arrayFromFunction(4,t=>V3.polar(1,TAU*t/4))),V3.X,!0)}function initShaders$$1(t){return t.makeCurrent(),{singleColor:Shader.create(vertexShaderBasic,fragmentShaderColor),multiColor:Shader.create(vertexShaderColor,fragmentShaderVaryingColor),singleColorHighlight:Shader.create(vertexShaderBasic,fragmentShaderColorHighlight),textureColor:Shader.create(vertexShaderTexture,fragmentShaderTextureColor),arc:Shader.create(vertexShaderRing,fragmentShaderColor),arc2:Shader.create(vertexShaderArc,fragmentShaderColor),ellipse3d:Shader.create(vertexShaderConic3d,fragmentShaderColor),generic3d:Shader.create(vertexShaderGeneric,fragmentShaderColor),bezier3d:Shader.create(vertexShaderBezier3d,fragmentShaderColor),nurbs:Shader.create(vertexShaderNURBS,fragmentShaderColor3),bezier:Shader.create(vertexShaderBezier,fragmentShaderColor),lighting:Shader.create(vertexShaderLighting,fragmentShaderLighting),waves:Shader.create(vertexShaderWaves,fragmentShaderLighting)}}function makeDottedLinePlane(t=128){const e=(new Mesh).addIndexBuffer("LINES"),s=arrayFromFunction(t,e=>new V3(e/t,0,0));return e.vertices.push(...s),e.vertices.push(...M4.forSys(V3.Y,V3.O,V3.O,V3.X).transformedPoints(s)),e.vertices.push(...M4.forSys(V3.X.negated(),V3.O,V3.O,new V3(1,1,0)).transformedPoints(s)),e.vertices.push(...M4.forSys(V3.Y.negated(),V3.O,V3.O,V3.Y).transformedPoints(s)),e.LINES=arrayFromFunction(4*t,e=>e-(e>=2*t?1:0)),e.compile(),e}function initNavigationEvents$$1(t,e,s){const r=t.canvas;let n=V3.O;r.addEventListener("mousemove",r=>{const i=V(r.pageX,r.pageY),o=n.to(i);if(4&r.buttons){const r=V(2*-o.x/t.canvas.width,2*o.y/t.canvas.height),n=t.projectionMatrix.inversed().transformVector(r);e.pos=e.pos.plus(n),e.focus=e.focus.plus(n),setupCamera$$1(e,t),s()}if(2&r.buttons){const r=-o.x/6*DEG,n=-o.y/6*DEG;let i=M4.rotateLine(e.focus,e.up,r);const a=e.up.cross(e.pos.minus(e.focus));i=i.times(M4.rotateLine(e.focus,a,n)),e.pos=i.transformPoint(e.pos),e.up=i.transformVector(e.up),setupCamera$$1(e,t),s()}n=i}),r.addEventListener("wheel",r=>{const n=2*-sign(r.deltaY);e.zoomFactor*=pow(.9,-n);const i=getPosOnTarget$$1(r),o=V(2*i.x/t.canvas.offsetWidth-1,2*-i.y/t.canvas.offsetHeight+1,0),a=o.times(1-1/pow(.9,-n)),c=t.projectionMatrix.inversed(),h=c.transformVector(a);e.pos=e.pos.plus(h),e.focus=e.focus.plus(h);const u=c.transformPoint(o),l=M4.rotateLine(u,e.pos.to(e.focus),10*-sign(r.deltaX)*DEG);e.up=l.transformVector(e.up),e.pos=l.transformPoint(e.pos),e.focus=l.transformPoint(e.focus),setupCamera$$1(e,t),s(),r.preventDefault()})}function getMouseLine$$1(t,e){const s=V(2*t.x/e.canvas.width-1,2*-t.y/e.canvas.height+1,0),r=V(2*t.x/e.canvas.width-1,2*-t.y/e.canvas.height+1,1),n=e.projectionMatrix.inversed(),i=n.transformPoint(s),o=n.transformPoint(r).minus(i);return L3$$1.anchorDirection(i,o)}function getPosOnTarget$$1(t){const e=t.target.getBoundingClientRect();return{x:t.clientX-e.left,y:t.clientY-e.top}}function setupCamera$$1(t,e,s=!1){const{pos:r,focus:n,up:i,zoomFactor:o}=t;e.matrixMode(e.PROJECTION),e.loadIdentity();const a=e.canvas.width/2/o,c=e.canvas.height/2/o;e.ortho(-a,a,-c,c,-1e4,1e4),e.lookAt(r,n,i),e.matrixMode(e.MODELVIEW),!s&&cameraChangeListeners$$1.forEach(e=>e(t))}CURVE_PAINTERS$$1[PICurve$$1.name]=CURVE_PAINTERS$$1[ImplicitCurve$$1.name],CURVE_PAINTERS$$1[PPCurve$$1.name]=CURVE_PAINTERS$$1[ImplicitCurve$$1.name];const cameraChangeListeners$$1=[],SHADERS_TYPE_VAR$$1=!1;export{Curve$$1 as Curve,breakDownPPCurves$$1 as breakDownPPCurves,AABB2$$1 as AABB2,uvInAABB2$$1 as uvInAABB2,curvePoint$$1 as curvePoint,curvePointMF$$1 as curvePointMF,XiEtaCurve$$1 as XiEtaCurve,parabola4Projection$$1 as parabola4Projection,ImplicitCurve$$1 as ImplicitCurve,surfaceIsICurveIsInfosWithLine$$1 as surfaceIsICurveIsInfosWithLine,BezierCurve$$1 as BezierCurve,HyperbolaCurve$$1 as HyperbolaCurve,L3$$1 as L3,PICurve$$1 as PICurve,PPCurve$$1 as PPCurve,ParabolaCurve$$1 as ParabolaCurve,EllipseCurve$$1 as EllipseCurve,NURBS$$1 as NURBS,P3$$1 as P3,Surface$$1 as Surface,PointVsFace,ImplicitSurface$$1 as ImplicitSurface,ParametricSurface$$1 as ParametricSurface,ConicSurface$$1 as ConicSurface,ProjectedCurveSurface$$1 as ProjectedCurveSurface,RotatedCurveSurface$$1 as RotatedCurveSurface,getExtremePointsHelper$$1 as getExtremePointsHelper,CylinderSurface$$1 as CylinderSurface,EllipsoidSurface$$1 as EllipsoidSurface,PlaneSurface$$1 as PlaneSurface,PointProjectedSurface$$1 as PointProjectedSurface,NURBSSurface$$1 as NURBSSurface,ZDirVolumeVisitor$$1 as ZDirVolumeVisitor,glqV3$$1 as glqV3,glqArray$$1 as glqArray,CalculateAreaVisitor$$1 as CalculateAreaVisitor,projectCurve$$1 as projectCurve,projectPointCurve$$1 as projectPointCurve,rotateCurve$$1 as rotateCurve,B2T,CustomPlane$$1 as CustomPlane,Edge$$1 as Edge,PCurveEdge$$1 as PCurveEdge,StraightEdge$$1 as StraightEdge,FaceInfoFactory,Face$$1 as Face,PlaneFace$$1 as PlaneFace,RotationFace$$1 as RotationFace,EPS$$1 as EPS,getGlobalId$$1 as getGlobalId,addLikeSurfaceFaces$$1 as addLikeSurfaceFaces,assembleFaceFromLooseEdges$$1 as assembleFaceFromLooseEdges,calcNextEdgeIndex$$1 as calcNextEdgeIndex,BRep$$1 as BRep,dotCurve$$1 as dotCurve,dotCurve2$$1 as dotCurve2,INSIDE$$1 as INSIDE,OUTSIDE$$1 as OUTSIDE,COPLANAR_SAME$$1 as COPLANAR_SAME,COPLANAR_OPPOSITE$$1 as COPLANAR_OPPOSITE,ALONG_EDGE_OR_PLANE$$1 as ALONG_EDGE_OR_PLANE,splitsVolumeEnclosingFaces$$1 as splitsVolumeEnclosingFaces,splitsVolumeEnclosingFacesP$$1 as splitsVolumeEnclosingFacesP,splitsVolumeEnclosingFacesP2$$1 as splitsVolumeEnclosingFacesP2,splitsVolumeEnclosingCone$$1 as splitsVolumeEnclosingCone,splitsVolumeEnclosingCone2$$1 as splitsVolumeEnclosingCone2,fff$$1 as fff,triangulateVertices$$1 as triangulateVertices,intersectionUnitCircleLine$$1 as intersectionUnitCircleLine,intersectionUnitCircleLine2$$1 as intersectionUnitCircleLine2,intersectionCircleLine$$1 as intersectionCircleLine,intersectionUnitHyperbolaLine$$1 as intersectionUnitHyperbolaLine,curvePointPP$$1 as curvePointPP,followAlgorithmPP$$1 as followAlgorithmPP,followAlgorithm2d$$1 as followAlgorithm2d,followAlgorithm2dAdjustable$$1 as followAlgorithm2dAdjustable,intersectionICurveICurve$$1 as intersectionICurveICurve,intersectionICurveICurve2$$1 as intersectionICurveICurve2,cassini$$1 as cassini,MathFunctionR2R,cas2$$1 as cas2,arrayLerp$$1 as arrayLerp,doNotSerialize$$1 as doNotSerialize,ClassSerializer$$1 as ClassSerializer,parseGetParams$$1 as parseGetParams,COLORS$$1 as COLORS,BREPGLContext$$1 as BREPGLContext,CURVE_PAINTERS$$1 as CURVE_PAINTERS,initMeshes$$1 as initMeshes,initShaders$$1 as initShaders,initNavigationEvents$$1 as initNavigationEvents,getMouseLine$$1 as getMouseLine,getPosOnTarget$$1 as getPosOnTarget,setupCamera$$1 as setupCamera,cameraChangeListeners$$1 as cameraChangeListeners,SHADERS_TYPE_VAR$$1 as SHADERS_TYPE_VAR};