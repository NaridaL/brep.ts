import{AABB,arrayFromFunction,assert as assert$1,assertNumbers,callsce,clamp,eq,eq0,fuzzyUniquesF,getIntervals,glqInSteps,le,newtonIterate2dWithDerivatives,newtonIterateWithDerivative,NLA_PRECISION,Transformable,V,V3,assertf,assertInst,assertVectors,hasConstructor,M4,TAU,arrayRange,assertNever,between,combinations,fuzzyUniques,gaussLegendre24Weights,gaussLegendre24Xs,gaussLegendreQuadrature24,lerp,Matrix,MINUS,newtonIterate1d,solveCubicReal2,Vector,checkDerivate,lt,newtonIterateSmart,pqFormula,snap0,floatHashCode,isCCW,ge,getRoots,snap,GOLDEN_RATIO,randomColor,DEG,fuzzyBetween,mod,newtonIterate,snap2,disableConsole,doubleSignedArea,enableConsole,gt,mapPush,newtonIterate2d,NLA_DEBUG,SCE,addOwnProperties}from"ts3dutils";import{pushQuad,Mesh,DRAW_MODES,GL_COLOR_BLACK,Shader}from"tsgl";import{load,Path}from"opentype.js";import{SVGPathData}from"svg-pathdata";import{Pair,JavaMap,JavaSet}from"javasetmap.ts";import earcut from"earcut";import nerdamer from"nerdamer";import chroma from"chroma-js";const{ceil:ceil,floor:floor,abs:abs$1}=Math;class Curve extends Transformable{constructor(t,e){super(),this.tMin=t,this.tMax=e,assertNumbers(t,e),assert$1("number"==typeof t&&!isNaN(t)),assert$1("number"==typeof e&&!isNaN(e)),assert$1(t<e)}static integrate(t,e,s,r){const n=(s-e)/r;let i=0,a=t.at(e),o=0,c=e+n;for(;o<r;o++,c+=n){const e=t.at(c);i+=a.distanceTo(e),a=e}return i}static ispsRecursive(t,e,s,r,n,i){const a=[];return function e(s,n,i,o,c,h,l=0){const u=NLA_PRECISION;if(c.fuzzyTouchesAABB(h)){const c=(s+n)/2,h=(i+o)/2;if(Math.abs(n-s)<u||Math.abs(o-i)<u)return function(e,s){if(!a.some(t=>eq(t.tThis,e)&&eq(t.tOther,s))){const n=(t,e,s,r)=>t.ddt(s).dot(t.at(s).minus(e.at(r)))+t.tangentAt(s).squared(),i=(t,e,s,r)=>-t.tangentAt(s).dot(e.tangentAt(r)),o=newtonIterate2dWithDerivatives((e,s)=>t.tangentAt(e).dot(t.at(e).minus(r.at(s))),(e,s)=>r.tangentAt(s).dot(t.at(e).minus(r.at(s))),e,s,16,n.bind(void 0,t,r),i.bind(void 0,t,r),(e,s)=>-i(r,t,s,e),(e,s)=>-n(r,t,s,e));assert$1(isFinite(o.x)),assert$1(isFinite(o.y)),void 0==o&&console.log(e,s,t.sce,r.sce),a.push({tThis:o.x,tOther:o.y,p:t.at(o.x)})}}(c,h),!0;{const a=t.getAABB(s,c),u=r.getAABB(i,h);let f,d;e(s,c,i,h,a,u,l+1)||e(s,c,h,o,a,d=r.getAABB(h,o),l+1)||e(c,n,i,h,f=t.getAABB(c,n),u,l+1)||e(c,n,h,o,f,d,l+1)}}return!1}(e,s,n,i,t.getAABB(e,s),r.getAABB(n,i)),fuzzyUniquesF(a,t=>t.tThis)}static breakDownIC(t,{sMin:e,sMax:s,tMin:r,tMax:n},i,a,o,c,h){const l=(t,i)=>e<=t&&t<=s&&r<=i&&i<=n,u=n-r,f=ceil((s-e)/i),d=ceil(u/a),p=new Array(f*d).fill(0);arrayFromFunction(d,t=>p.slice(f*t,f*(t+1)).map(t=>t?"X":"_").join("")).join("\n");const m=(t,e)=>p[e*f+t],g=(t,e)=>0<=t&&t<f&&0<=e&&e<d&&(p[e*f+t]=1),P=[],v=[];for(let s=0;s<f;s++)t:for(let n=0;n<d;n++){if(m(s,n))continue;g(s,n);let c=e+(s+.5)*i,h=r+(n+.5)*a;const u=c,f=h;for(let e=0;e<8;e++){const e=t(c,h),s=t.x(c,h),r=t.y(c,h);if(0==s*s+r*r)continue t;const n=e/(s*s+r*r);c-=n*s,h-=n*r}const d=floor((c-e)/i),p=floor((h-r)/a);if(v.push({i:s,j:n,li:d,lj:p,startS:u,startT:f,s:c,t:h,"bounds(s, t)":l(c,h),"ic(s,t)":t(c,h)}),(s==d&&n==p||!m(d,p))&&(g(d,p),l(c,h)&&eq0(t(c,h)))){console.log(V(c,h).sce);const s=mkcurves(t,c,h,o,t.x,t.y,l);for(const t of s){assert$1(t.points.length>2);for(const{x:s,y:n}of t.points){const t=(s-e)/i,o=(n-r)/a;g(t-.5|0,o-.5|0),g(t-.5|0,o+.5|0),g(t+.5|0,o-.5|0),g(t+.5|0,o+.5|0)}}P.push(...s)}}for(const{points:t}of P)for(let e=0;e<t.length-1;e++)assert$1(!t[e].equals(t[e+1]));return P}toString(){return this.toSource()}toSource(t=(t=>t)){return callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}withBounds(t=this.tMin,e=this.tMax){return assert$1(this.tMin<=t&&t<=this.tMax),assert$1(this.tMin<=e&&e<=this.tMax),assert$1(this.tMin<=e&&e<=this.tMax),new this.constructor(...this.getConstructorParameters().slice(0,-2),t,e)}closestPointToPoint(t){return this.at(this.closestTToPoint(t))}isValidT(t){return le(this.tMin,t)&&le(t,this.tMax)}diff(t,e){return this.at(t).to(this.at(t+e))}closestTToPoint(t,e){const s=void 0!==e?e:arrayFromFunction(32,t=>this.tMin+(this.tMax-this.tMin)*t/32).withMax(e=>-this.at(e).distanceTo(t));return newtonIterateWithDerivative(e=>this.at(e).minus(t).dot(this.tangentAt(e)),s,16,e=>this.tangentAt(e).squared()+this.at(e).minus(t).dot(this.ddt(e)))}calcSegmentPoints(t,e,s,r,n,i){assert$1(this.tIncrement,"tIncrement not defined on "+this);const a=this.tIncrement,o=[];if(i&&o.push(s),assert$1(n!=t<e),t<e){const s=Math.ceil((t+NLA_PRECISION)/a),r=Math.floor((e-NLA_PRECISION)/a);for(let t=s;t<=r;t++)o.push(this.at(t*a))}else{const s=Math.floor((t-NLA_PRECISION)/a),r=Math.ceil((e+NLA_PRECISION)/a);for(let t=s;t>=r;t--)o.push(this.at(t*a))}return o.push(r),o}distanceToPoint(t,e,s){const r=this.closestTToPoint(t,e,s);return this.at(r).distanceTo(t)}asSegmentDistanceToPoint(t,e,s){let r=this.closestTToPoint(t,e,s);return r=clamp(r,e,s),this.at(r).distanceTo(t)}isInfosWithCurve(t){return Curve.ispsRecursive(this,this.tMin,this.tMax,t,t.tMin,t.tMax)}arcLength(t,e,s=1){return assert$1(t<e,"startT < endT"),glqInSteps(t=>this.tangentAt(t).length(),t,e,s)}getAABB(t=this.tMin,e=this.tMax){t=isFinite(t)?t:this.tMin,e=isFinite(e)?e:this.tMax;const s=this.at(t),r=this.at(e),n=this.roots(),i=new Array(3),a=new Array(3);for(let o=0;o<3;o++){const c=n[o];i[o]=Math.min(s.e(o),r.e(o)),a[o]=Math.max(s.e(o),r.e(o));for(const s of c)t<s&&s<e&&(i[o]=Math.min(i[o],this.at(s).e(o)),a[o]=Math.max(a[o],this.at(s).e(o)))}return new AABB(V3.fromArray(i),V3.fromArray(a))}reversed(){throw new Error}clipPlane(t){const e=this.isTsWithPlane(t).filter(t=>this.tMin<=t&&t<=this.tMax);return getIntervals(e,this.tMin,this.tMax).mapFilter(([e,s])=>{const r=(e+s)/2;return!eq(e,s)&&t.distanceToPointSigned(this.at(r))<0&&this.withBounds(e,s)})}}function mkcurves(t,e,s,r,n,i,a){const o=V(e,s),{points:c,tangents:h}=followAlgorithm2d(t,o,r,a);if(c[0].distanceTo(c.last)<r&&c.length>2){for(let t=0;t<c.length-1;t++)assert$1(!c[t].equals(c[t+1]));const t=floor(c.length/2),e=c.slice(0,t),s=c.slice(t-1,c.length),r=h.slice(0,t),n=h.slice(t-1,h.length);n[n.length-1]=r[0],s[n.length-1]=e[0];for(let t=0;t<e.length-1;t++)assert$1(!e[t].equals(e[t+1]));for(let t=0;t<s.length-1;t++)assert$1(!s[t].equals(s[t+1]));return[{points:e,tangents:r},{points:s,tangents:n}]}{const{points:e,tangents:s}=followAlgorithm2d(t,o,-r,a),n=followAlgorithm2d(t,e.last,r,a,void 0,s.last.negated());return assert$1(n.points.length>2),[n]}}function curvePoint(t,e,s,r){let n=e;for(let e=0;e<8;e++){const e=t(n.x,n.y),i=s(n.x,n.y),a=r(n.x,n.y),o=e/(i*i+a*a);n=n.minus(new V3(o*i,o*a,0))}return n}function curvePointMF(t,e,s=8,r=1/(1<<30)){let n=e;for(let e=0;e<s;e++){const e=t(n.x,n.y),s=t.x(n.x,n.y),i=t.y(n.x,n.y),a=e/(s*s+i*i);if(n=n.minus(new V3(a*s,a*i,0)),abs$1(e)<=r)break}return n}Curve.hlol=0;const{PI:PI}=Math;class XiEtaCurve extends Curve{constructor(t,e,s,r=-PI,n=PI){if(super(r,n),this.center=t,this.f1=e,this.f2=s,this.tMin=r,this.tMax=n,assertVectors(t,e,s),this.normal=e.cross(s),this.normal.likeO()){this.matrix=M4.forSys(e,s,e.unit(),t);const r=e.getPerpendicular();this.inverseMatrix=new M4(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1).times(M4.forSys(e,r,e.cross(r),t).inversed())}else this.normal=this.normal.unit(),this.matrix=M4.forSys(e,s,this.normal,t),this.inverseMatrix=this.matrix.inversed()}static magic(t,e,s){throw new Error("abstract")}static forAB(t,e,s=V3.O){return new this(s,V(t,0,0),V(0,e,0))}static XYLCValid(t){throw new Error("abstract")}static XYLCPointT(t){throw new Error("abstract")}static unitIsInfosWithLine(t,e,s,r){throw new Error("abstract")}addToMesh(t,e=4,s=0,r=1){const n=arrayFromFunction(e,t=>V3.polar(1,TAU*t/e)),i=arrayFromFunction(e,t=>V3.polar(s,TAU*t/e)),a=this.tIncrement,o=Math.ceil((this.tMin+NLA_PRECISION)/a),c=Math.floor((this.tMax-NLA_PRECISION)/a);for(let s=o;s<=c;s+=r){const r=s*a,o=t.vertices.length;if(0!==s)for(let s=0;s<e;s++)pushQuad(t.TRIANGLES,!0,o-e+s,o+s,o-e+(s+1)%e,o+(s+1)%e);const c=this.at(r),h=this.tangentAt(r),l=M4.forSys(this.normal,h.cross(this.normal),h,c);t.normals.push(...l.transformedVectors(n)),t.vertices.push(...l.transformedPoints(i))}}getConstructorParameters(){return[this.center,this.f1,this.f2,this.tMin,this.tMax]}isInfosWithCurve(t){return t instanceof L3$1?this.isInfosWithLine(t.anchor,t.dir1,this.tMin,this.tMax,t.tMin,t.tMax):t instanceof BezierCurve?this.isInfosWithBezier(t):t instanceof XiEtaCurve&&!this.normal.isParallelTo(t.normal)?this.isTsWithPlane(t.getPlane()).mapFilter(e=>{const s=this.at(e);if(t.containsPoint(s))return{tThis:e,tOther:t.pointT(s),p:s}}):super.isInfosWithCurve(t)}transform(t){return new this.constructor(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),this.tMin,this.tMax)}equals(t){return this==t||t.constructor==this.constructor&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.center.hashCode())+this.f1.hashCode())+this.f2.hashCode())}likeCurve(t){return hasConstructor(t,this.constructor)&&this.center.like(t.center)&&this.f1.like(t.f1)&&this.f2.like(t.f2)}normalP(t){return this.tangentAt(t).cross(this.normal)}getPlane(){return P3.normalOnAnchor(this.normal,this.center)}isTsWithPlane(t){if(assertInst(P3,t),t.normal1.isParallelTo(this.normal))return[];const e=t.normal1,s=t.w,r=this.center,n=this.f1,i=this.f2,a=e.dot(n),o=e.dot(i),c=s-e.dot(r);return this.constructor.magic(a,o,c)}pointT(t){assertVectors(t);const e=this.inverseMatrix.transformPoint(t);return this.constructor.XYLCPointT(e)}containsPoint(t){const e=this.inverseMatrix.transformPoint(t);return eq0(e.z)&&this.constructor.XYLCValid(e)}isInfosWithLine(t,e,s,r,n=-1e5,i=1e5){const a=this.inverseMatrix.transformPoint(t),o=this.inverseMatrix.transformVector(e);if(eq0(o.z)){if(eq0(a.z))return this.constructor.unitIsInfosWithLine(a,o,t,e)}else{const s=a.z/o.z,r=o.times(s).plus(a);if(this.constructor.XYLCValid(r))return[{tThis:this.constructor.XYLCPointT(r),tOther:s,p:t.plus(e.times(s))}]}return[]}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof SemiEllipsoidSurface){const e=t.asEllipsoidSurface().isCurvesWithSurface(new PlaneSurface$1(this.getPlane()));return e.length<1?[]:this.isInfosWithCurve(e[0]).filter(e=>t.containsPoint(e.p)).map(t=>t.tThis)}if(t instanceof ProjectedCurveSurface||t instanceof EllipsoidSurface||t instanceof ConicSurface)return t.isCurvesWithPlane(this.getPlane()).flatMap(t=>this.isInfosWithCurve(t)).map(t=>t.tThis);throw new Error}isInfosWithBezier(t){const e=t.transform(this.inverseMatrix);if(new PlaneSurface$1(P3.XY).containsCurve(e))return this.isInfosWithBezier2D(t);return e.isTsWithPlane(P3.XY).mapFilter(s=>{const r=e.at(s);if(this.constructor.XYLCValid(r))return{tOther:s,p:t.at(s),tThis:this.constructor.XYLCPointT(r)}})}isInfosWithBezier2D(t,e,s){return e=isFinite(e)?e:t.tMin,s=isFinite(s)?s:t.tMax,assertf(()=>0<Math.PI),assertf(()=>e<s),Curve.ispsRecursive(this,this.tMin,this.tMax,t,e,s)}isOrthogonal(){return this.f1.isPerpendicularTo(this.f2)}at2(t,e){return assertNumbers(t,e),this.center.plus(this.f1.times(t)).plus(this.f2.times(e))}debugToMesh(t,e){t[e]||t.addVertexBuffer(e,e);for(let s=0;s<Math.PI;s+=.1){const r=this.at(s);t[e].push(r,r.plus(this.tangentAt(s).toLength(1))),t[e].push(r,r.plus(this.normalP(s).toLength(1)))}t[e].push(this.center,this.center.plus(this.f1.times(1.2))),t[e].push(this.center,this.center.plus(this.f2)),t[e].push(this.center,this.center.plus(this.normal))}}const{ceil:ceil$1,floor:floor$1}=Math;class ImplicitCurve extends Curve{constructor(t,e,s=1,r,n=(1==s?0:-(t.length-1)),i=(1==s?t.length-1:0)){super(n,i),this.points=t,this.tangents=e,this.dir=s,this.generator=r,assert$1(t.length>2),assert$1(0<=n&&n<=t.length-1),assert$1(0<=i&&i<=t.length-1)}likeCurve(t){throw new Error("Method not implemented.")}toSource(t=(t=>t)){return this.generator||super.toSource(t)}containsPoint(t){return assertVectors(t),!isNaN(this.pointT(t))}equals(t){return this==t||Object.getPrototypeOf(t)==PICurve.prototype&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])}hashCode(){return[this.points[0],this.tangents[0]].hashCode()}tangentP(t){assertVectors(t),assert$1(this.containsPoint(t),"this.containsPoint(pWC)"+this.containsPoint(t));const e=this.pointT(t);return this.tangentAt(e)}tangentAt(t){return t=clamp(t,this.tMin,this.tMax),V3.lerp(this.tangents[floor$1(t)],this.tangents[ceil$1(t)],t%1)}at(t){return assert$1(!isNaN(t)),V3.lerp(this.points[floor$1(t)],this.points[ceil$1(t)],t%1)}getConstructorParameters(){return[]}transform(t){return new ImplicitCurve(t.transformedPoints(this.points),t.transformedVectors(this.tangents))}roots(){const t=arrayRange(0,this.points.length);return[t,t,t]}addToMesh(t,e=4,s=0,r=1){const n=arrayFromFunction(e,t=>V3.polar(1,TAU*t/e)),i=arrayFromFunction(e,t=>V3.polar(s,TAU*t/e));let a=V3.Z,o=M4.IDENTITY;for(let s=ceil$1(this.tMin);s<floor$1(this.tMax);s+=r){const r=t.vertices.length;if(ceil$1(this.tMin)!==s)for(let s=0;s<e;s++)pushQuad(t.TRIANGLES,!0,r-e+s,r+s,r-e+(s+1)%e,r+(s+1)%e);const c=this.points[s],h=this.tangents[s],l=M4.rotateAB(a,h).times(o);t.normals.push(...l.transformedVectors(n));const u=M4.translate(c).times(l);t.vertices.push(...u.transformedPoints(i)),a=h,o=l}}}ImplicitCurve.prototype.tIncrement=1;const{PI:PI$1,abs:abs$2,sin:sin,cos:cos}=Math;class BezierCurve extends Curve{constructor(t,e,s,r,n=-.1,i=1.1){super(n,i),assertVectors(t,e,s,r),assert$1(isFinite(n)&&isFinite(i)),this.p0=t,this.p1=e,this.p2=s,this.p3=r}get points(){return[this.p0,this.p1,this.p2,this.p3]}static graphXY(t,e,s,r,n,i){const a=s/3+r,o=e/3-r+2*a,c=t+r-3*a+3*o;return new BezierCurve(V(0,r),V(1/3,a),V(2/3,o),V(1,c),n,i)}static quadratic(t,e,s,r=0,n=1){const i=L3$1.throughPoints(t,s);return i.containsPoint(e)?i:new BezierCurve(t,e.times(2).plus(t).div(3),e.times(2).plus(s).div(3),s,r,n)}static approximateUnitArc(t){const e=4/3*Math.tan(t/4);return new BezierCurve(V3.X,new V3(1,e,0),new V3(cos(t)+e*sin(t),sin(t)-e*cos(t),0),V3.sphere(t,0),0,1)}static testEdges(){const t=BezierCurve.graphXY(2,-3,-3,2,.6,2),e=t.magic().map(t=>Edge.forCurveAndTs(t).translate(3));return console.log(e.length),[Edge.forCurveAndTs(t)].concat(e)}getConstructorParameters(){return[this.p0,this.p1,this.p2,this.p3,this.tMin,this.tMax]}at(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=1-t,a=i*i*i,o=3*i*i*t,c=3*i*t*t,h=t*t*t;return new V3(e.x*a+s.x*o+r.x*c+n.x*h,e.y*a+s.y*o+r.y*c+n.y*h,e.z*a+s.z*o+r.z*c+n.z*h)}tangentAt(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=1-t,a=3*i*i,o=6*i*t,c=3*t*t;return new V3((s.x-e.x)*a+(r.x-s.x)*o+(n.x-r.x)*c,(s.y-e.y)*a+(r.y-s.y)*o+(n.y-r.y)*c,(s.z-e.z)*a+(r.z-s.z)*o+(n.z-r.z)*c)}ddt(t){assertNumbers(t);const e=this.p0,s=this.p1,r=this.p2,n=this.p3,i=6*(1-t),a=6*t;return new V3((r.x-2*s.x+e.x)*i+(n.x-2*r.x+s.x)*a,(r.y-2*s.y+e.y)*i+(n.y-2*r.y+s.y)*a,(r.z-2*s.z+e.z)*i+(n.z-2*r.z+s.z)*a)}normalP(t){const e=this.tangentAt(t);return e.cross(this.ddt(t)).cross(e)}isTsWithPlane(t){assertInst(P3,t);const{p0:e,p1:s,p2:r,p3:n}=this,i=t.normal1,a=s.minus(r).times(3).minus(e).plus(n),o=e.plus(r).times(3).minus(s.times(6)),c=s.minus(e).times(3),h=e;return solveCubicReal2(a.dot(i),o.dot(i),c.dot(i),h.dot(i)-t.w).filter(t=>between(t,this.tMin,this.tMax))}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof SemiCylinderSurface){const e=new P3(t.dir.unit(),0),s=this.project(e);return t.baseCurve.project(e).isInfosWithBezier2D(s).map(t=>t.tOther)}if(t instanceof ProjectedCurveSurface){const e=new P3(t.dir.unit(),0),s=this.project(e);return t.baseCurve.project(e).isInfosWithCurve(s).map(t=>t.tOther)}if(t instanceof EllipsoidSurface){const e=this.transform(t.inverseMatrix),s=t=>e.at(t).length()-1,r=t=>e.at(t).unit().dot(e.tangentAt(t)),n=1/2048,i=(this.tMax,this.tMin,[]);for(let t=this.tMin;t<=this.tMax;t+=n){const a=n*e.tangentAt(t).length();if(abs$2(s(t))<=a){let e=newtonIterateWithDerivative(s,t,16,r);eq0(s(e))&&!eq0(r(e))||(e=newtonIterate1d(r,t,16)),eq0(s(e))&&!i.some(t=>eq(t,e))&&i.push(e)}}return i}if(t instanceof SemiEllipsoidSurface)return this.isTsWithSurface(t.asEllipsoidSurface()).filter(e=>t.containsPoint(this.at(e)));throw new Error}likeCurve(t){return this==t||hasConstructor(t,BezierCurve)&&this.p0.like(t.p0)&&this.p1.like(t.p1)&&this.p2.like(t.p2)&&this.p3.like(t.p3)}equals(t){return this==t||hasConstructor(t,BezierCurve)&&this.p0.equals(t.p0)&&this.p1.equals(t.p1)&&this.p2.equals(t.p2)&&this.p3.equals(t.p3)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.p0.hashCode())+this.p1.hashCode())+this.p2.hashCode())+this.p3.hashCode())}isColinearTo(t){if(this===t||this.likeCurve(t))return!0;if(!(t instanceof BezierCurve))return!1;let e,s,r;if(isNaN(e=this.pointT(t.p0))||isNaN(s=this.pointT(t.p3)))return!1;if(eq(1,e))r=this.split(s)[1].reversed();else{const t=(s-e)/(1-e);r=this.split(e)[1].split(t)[0]}return t.likeCurve(r)}reversed(){return new BezierCurve(this.p3,this.p2,this.p1,this.p0,1-this.tMax,1-this.tMin)}getCoefficients(){const{p0:t,p1:e,p2:s,p3:r}=this;return[e.minus(s).times(3).minus(t).plus(r),t.plus(s).times(3).minus(e.times(6)),e.minus(t).times(3),t]}tangentCoefficients(){const{p0:t,p1:e,p2:s,p3:r}=this,n=e.minus(t),i=s.minus(e),a=r.minus(s),o=n.plus(a).times(3).minus(i.times(6)),c=i.minus(n).times(6),h=n.times(3);return[V3.O,o,c,h]}pointT(t){return this.closestTToPoint(t)}pointT3(t){const{p0:e,p1:s,p2:r,p3:n}=this,i=s.minus(r).times(3).minus(e).plus(n),a=e.plus(r).times(3).minus(s.times(6)),o=s.minus(e).times(3),c=e.minus(t),h=NLA_PRECISION<i.maxAbsElement()?i.maxAbsDim():NLA_PRECISION<a.maxAbsElement()?a.maxAbsDim():NLA_PRECISION<o.maxAbsElement()?o.maxAbsDim():assertNever(),l=solveCubicReal2(i.e(h),a.e(h),o.e(h),c.e(h)).filter(e=>this.at(e).like(t));return 0==l.length?NaN:1==l.length?l[0]:void assert$1(!1,"multiple intersection "+this.toString()+t.sce)}pointT2(t){const{p0:e,p1:s,p2:r,p3:n}=this,i=s.minus(r).times(3).minus(e).plus(n).els(),a=e.plus(r).times(3).minus(s.times(6)).els(),o=s.minus(e).times(3).els(),c=e.minus(t).els();let h=void 0;for(let t=0;t<3;t++)if(eq0(i[t])&&eq0(a[t])&&eq0(o[t])){if(!eq0(c[t]))return NaN}else{const e=solveCubicReal2(i[t],a[t],o[t],c[t]);if(0==e.length)return NaN;if(1==e.length)return e[0];if(h){if(0==(h=h.filter(t=>e.some(e=>eq(t,e)))).length)return NaN;if(1==h.length)return h[0]}else h=e}assert$1(!1,"multiple intersection "+h+this.toString()+t.sce)}transform(t){return new BezierCurve(t.transformPoint(this.p0),t.transformPoint(this.p1),t.transformPoint(this.p2),t.transformPoint(this.p3),this.tMin,this.tMax)}isClosed(){return this.p0.like(this.p3)}isQuadratic(){return this.p1.like(this.p2)}debugToMesh(t,e){const s=t.addVertexBuffer(e,e);for(let t=-2;t<=2;t+=.01){const r=this.at(t);s[e].push(r,r.plus(this.tangentAt(t).toLength(1))),s[e].push(r,r.plus(this.normalP(t).toLength(1)))}s[e].push(this.p0,this.p1),s[e].push(this.p1,this.p2),s[e].push(this.p2,this.p3)}split(t){const e=1-t,{p0:s,p1:r,p2:n,p3:i}=this,a=s.times(e).plus(r.times(t)),o=r.times(e).plus(n.times(t)),c=n.times(e).plus(i.times(t)),h=a.times(e).plus(o.times(t)),l=o.times(e).plus(c.times(t)),u=h.times(e).plus(l.times(t));return[new BezierCurve(s,a,h,u),new BezierCurve(u,l,c,i)]}containsPoint(t){return isFinite(this.pointT(t))}roots(){const{p0:t,p1:e,p2:s,p3:r}=this,n=e.minus(t),i=s.minus(e),a=r.minus(s),o=n.plus(a).times(3).minus(i.times(6)),c=i.minus(n).times(6),h=n.times(3);return arrayFromFunction(3,t=>solveCubicReal2(0,o.e(t),c.e(t),h.e(t)))}isInfosWithLine(t,e,s,r,n=-1e5,i=1e5){const a=e.length();let o=Curve.ispsRecursive(this,this.tMin,this.tMax,new L3$1(t,e.unit()),n,i);return(o=fuzzyUniquesF(o,t=>t.tOther)).forEach(t=>t.tOther/=a),o}closestPointToLine(t,e,s){e=isFinite(e)?e:this.tMin,s=isFinite(s)?s:this.tMax;const r=t.anchor.dot(t.dir1),n=e=>{const s=this.at(e);return s.minus(t.at(s.dot(t.dir1)-r)).dot(this.tangentAt(e))},i=arrayFromFunction(32,t=>e+(s-e)*t/32).withMax(t=>-n(t));return newtonIterate1d(n,i,8)}isInfosWithBezie3(t,e,s,r,n){const i=(e,s)=>{if(!h.some(t=>eq(t.tThis,e)&&eq(t.tOther,s))){const r=(t,e,s,r)=>t.ddt(s).dot(t.at(s).minus(e.at(r)))+t.tangentAt(s).squared(),n=(t,e,s,r)=>-t.tangentAt(s).dot(e.tangentAt(r)),i=newtonIterate2dWithDerivatives((e,s)=>this.tangentAt(e).dot(this.at(e).minus(t.at(s))),(e,s)=>t.tangentAt(s).dot(this.at(e).minus(t.at(s))),e,s,16,r.bind(void 0,this,t),n.bind(void 0,this,t),(e,s)=>-n(t,this,s,e),(e,s)=>-r(t,this,s,e));h.push({tThis:i.x,tOther:i.y,p:this.at(i.x)})}},a=[e="number"==typeof e&&isFinite(e)?e:this.tMin,s="number"==typeof s&&isFinite(s)?s:this.tMax,r="number"==typeof r&&isFinite(r)?r:t.tMin,n="number"==typeof n&&isFinite(n)?n:t.tMax],o=(e+s)/2,c=(r+n)/2,h=(this.getAABB(e,o),this.getAABB(o,s),t.getAABB(r,r),t.getAABB(c,n),[]);for(;a.length;){const e=a.length-4,s=a[e],r=a[e+1],n=a[e+2],o=a[e+3];a.length-=4;const c=this.getAABB(s,r),h=t.getAABB(n,o);if(c&&h&&c.intersectsAABB2d(h)){const t=(s+r)/2,e=(n+o)/2,l=1e-5;r-s<l||o-n<l?(console.log(s,r,n,o),console.log(c.sce),console.log(h.sce),console.log(t,e),i(t,e)):Array.prototype.push.call(a,s,t,n,e,s,t,e,o,t,r,n,e,t,r,e,o)}}return h}isInfosWithBezier(t,e,s,r,n){e="number"==typeof e&&isFinite(e)?e:this.tMin,s="number"==typeof s&&isFinite(s)?s:this.tMax,r="number"==typeof r&&isFinite(r)?r:t.tMin,n="number"==typeof n&&isFinite(n)?n:t.tMax,assertf(()=>e<s),assertf(()=>r<n);const i=[],a=this.likeCurve(t),o=this.isColinearTo(t);if(!a&&!o)return Curve.ispsRecursive(this,e,s,t,r,n);{a||(r=this.pointT(t.at(r)),n=this.pointT(t.at(n))),e=Math.min(e,r),s=Math.max(s,n);const o=fuzzyUniques(this.roots().concatenated().filter(isFinite).concat([e,s])).sort(MINUS);Array.from(combinations(o.length-1)).forEach(({i:e,j:s})=>{Math.abs(e-s)>2&&i.push(...Curve.ispsRecursive(this,o[e],o[e+1],t,o[s],o[s+1]))})}return i}selfIntersectionsInfo(){return this.isInfosWithBezier(this)}isInfosWithCurve(t){return t instanceof L3$1?this.isInfosWithLine(t.anchor,t.dir1,t.tMin,t.tMax):t instanceof BezierCurve?this.isInfosWithBezier(t):t.isInfosWithCurve(this).map(({tThis:t,tOther:e,p:s})=>({tThis:e,tOther:t,p:s}))}getAreaInDirSurface(t,e,s,r){assertf(()=>t.hasLength(1));const n=s=>{const r=this.tangentAt(s),n=this.at(s),i=r.cross(e.normalP(n)),a=Math.sign(i.dot(t));return n.dot(t)*r.rejected1Length(t)*a},i=e=>{const s=this.at(e).dot(t);return this.at(e).minus(t.times(s/2))},a=gaussLegendreQuadrature24(n,s,r);return{area:a,centroid:V3.add.apply(void 0,arrayFromFunction(24,t=>{const e=s+(gaussLegendre24Xs[t]+1)/2*(r-s);return i(e).times(gaussLegendre24Weights[t]*n(e))})).div(2*(r-s)*a)}}magic(t=this.tMin,e=this.tMax,s=[]){const r=arrayFromFunction(20,s=>lerp(t,e,s/19)),n=r.map(t=>this.at(t)),i=r.map(t=>this.normalP(t).unit()),a=t=>{const e=r.map((e,s)=>new L3$1(n[s],t[s].unit())),s=arrayFromFunction(19,t=>{const s=t+1,r=e[t],n=e[s];return r.infoClosestToLine(n)}),i=s.map(t=>t.s-t.t),a=s.map(t=>V3.lerp(t.closest,t.closest2,.5)),o=arrayFromFunction(19,t=>{const e=lerp(r[t],r[t+1],.5),s=this.at(e);return Math.pow(s.distanceTo(a[t]),.5)});return i.concat(o)},o=V3.packXY(i),c=t=>a(V3.unpackXY(t)),h=new Vector(new Float64Array(o));for(let t=0;t<2;t++){const t=new Vector(new Float64Array(c(h.v)));console.log(t.v);const e=Matrix.jacobi(c,h.v);console.log("jacobi\n",e.toString(t=>""+t));e.getDependentRowIndexes();const s=e.transposed();console.log(e.times(s).str),console.log(e.times(s).inversed().str);const r=s.times(e.times(s).inversed()).timesVector(t);h=h.minus(r)}const l=V3.unpackXY(h.v),u=arrayFromFunction(20,t=>new L3$1(n[t],l[t].unit()));return arrayFromFunction(19,t=>{const e=t+1,s=u[t],r=u[e],i=s.infoClosestToLine(r);return EllipseCurve.circleForCenter2P(i.closest,n[t],n[e],i.s)})}magic2(t=this.tMin,e=this.tMax,s=[]){const r=this.at(t),n=this.at(e),i=this.normalP(t).unit(),a=this.normalP(e).unit(),o=new L3$1(r,i),c=new L3$1(n,a),h=o.infoClosestToLine(c);if(h.s<0||h.t<0||h.distance>.01||!eq(h.s,h.t,.01));else{const i=V3.lerp(h.closest,h.closest2,.5),a=lerp(t,e,.5),o=this.at(a),c=lerp(t,e,2/3),l=(this.at(c),(h.s+h.t)/2);if(eq(i.distanceTo(o),l,.01)){const t=EllipseCurve.circleForCenter2P(i,r,n,l);return s.push(t),s}}const l=(t+e)/2;return this.magic(t,l,s),this.magic(l,e,s),s}}BezierCurve.EX2D=BezierCurve.graphXY(2,-3,-3,2),BezierCurve.EX3D=new BezierCurve(V3.O,V(-.1,-1,1),V(1.1,1,1),V3.X),BezierCurve.QUARTER_CIRCLE=BezierCurve.approximateUnitArc(PI$1/2),BezierCurve.prototype.hlol=Curve.hlol++,BezierCurve.prototype.tIncrement=1/80;const{PI:PI$2,cos:cos$1,sin:sin$1,min:min,max:max,tan:tan,sign:sign,ceil:ceil$2,floor:floor$2,abs:abs$3,sqrt:sqrt,pow:pow,atan2:atan2,round:round}=Math;class EllipseCurve extends XiEtaCurve{constructor(t,e,s,r=-PI$2,n=PI$2){super(t,e,s,r,n),assert$1(EllipseCurve.isValidT(r)),assert$1(EllipseCurve.isValidT(n))}static isValidT(t){return-Math.PI<=t&&t<=Math.PI}static XYLCValid(t){return eq(1,t.lengthXY())}static XYLCPointT(t,e){const s=t.angleXY();return s<-Math.PI+NLA_PRECISION||s>Math.PI-NLA_PRECISION?(assert$1(isFinite(e)),Math.sign(e)*Math.PI):s}static magic(t,e,s){return intersectionUnitCircleLine2(t,e,s).map(([t,e])=>Math.atan2(e,t))}static unitIsInfosWithLine(t,e,s,r){const n=e.dot(e);return pqFormula(2*e.dot(t)/n,(t.dot(t)-1)/n).map(n=>({tThis:Math.atan2(t.y+n*e.y,t.x+n*e.x),tOther:n,p:L3$1.at(s,r,n)}))}static circle(t,e=V3.O){return new EllipseCurve(e,new V3(t,0,0),new V3(0,t,0))}static circleForCenter2P(t,e,s,r){const n=t.to(e),i=n.cross(t.to(s)).cross(n).toLength(n.length()),a=n.angleTo(t.to(s));return new EllipseCurve(t,n,i,0,a)}getVolZAnd(t,e,s){return{volume:glqInSteps(e=>(function(e){const s=t.times(t.dot(e));return s.lengthXY()*(e.z-s.z/2)})(this.at(e))*this.tangentAt(e).cross(this.normal).unit().z,e,s,4),centroid:void 0}}getAreaInDir(t,e,s,r){assertf(()=>t.isPerpendicularTo(this.normal)),assertf(()=>e.isPerpendicularTo(this.normal));const n=this.inverseMatrix.transformVector(e),i=n.cross(V3.Z),a=s-i.angleXY(),o=r-i.angleXY(),c=this.inverseMatrix.getTranslation().dot(n.unit());Math.PI;function h(t){return(t-Math.sin(t)*Math.cos(t))/2}function l(t){return Math.pow(Math.sin(t),3)/3}function u(t){return(Math.cos(3*t)-9*Math.cos(t))/24}const f=-c*(-Math.cos(o)+Math.cos(a)),d=h(o)-h(a)+f,p=(l(o)-l(a)+-c*(-Math.cos(o)-Math.cos(a))/2*f)/d,m=(u(o)-u(a)- -c/2*f)/d,g=this.matrix.xyAreaFactor();return assert$1(!eq0(g)),{area:d*g,centroid:this.matrix.transformPoint(M4.rotateZ(i.angleXY()).transformPoint(new V3(p,m,0)))}}at(t){return this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return assertNumbers(t),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}tangentAt2(t,e){return this.f2.times(t).minus(this.f1.times(e))}isCircular(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}reversed(){return new this.constructor(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}isColinearTo(t){if(!hasConstructor(t,EllipseCurve))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:e,f2:s}=this.rightAngled(),{f1:r,f2:n}=t.rightAngled();return e.length()>s.length()&&([e,s]=[s,e]),r.length()>n.length()&&([r,n]=[n,r]),eq(e.squared(),Math.abs(e.dot(r)))&&eq(s.squared(),Math.abs(s.dot(n)))}}eccentricity(){const t=this.rightAngled(),e=t.f1.length(),s=t.f1.length(),[r,n]=e>s?[e,s]:[s,e];return Math.sqrt(1-n*n/r/r)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t,e,s){return assert$1(t<e,"startT < endT"),this.isCircular()?this.f1.length()*(e-t):super.arcLength(t,e,s)}circumferenceApproximate(){const{f1:t,f2:e}=this.rightAngled(),s=t.length(),r=e.length(),n=Math.pow(s-r,2)/Math.pow(s+r,2);return Math.PI*(s+r)*(1+3*n/(10+Math.sqrt(4-3*n)))}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e),r=e.squared()-t.squared();if(eq0(s))return this;const n=2*s,i=r+Math.sqrt(r*r+4*s*s),{x1:a,y1:o}=intersectionUnitCircleLine(n,i,0);return new EllipseCurve(this.center,t.times(a).plus(e.times(o)),t.times(-o).plus(e.times(a)))}isInfosWithEllipse(t){if(this.normal.isParallelTo(t.normal)&&eq0(this.center.minus(t.center).dot(t.normal))){const e=t.transform(this.inverseMatrix).rightAngled(),s=e.f1.lengthXY(),r=e.f2.lengthXY(),n=e.center.lengthXY(),i=min(s,r),a=max(s,r);if(lt(n+a,1)||lt(1,n-a)||lt(1,i-n)||eq(1,s)&&eq(1,r)&&eq0(n))return[];const o=t=>e.at(t).lengthXY()-1,c=t=>e.at(t).xy().dot(e.tangentAt(t))/e.at(t).lengthXY();checkDerivate(o,c,-PI$2,PI$2,1);const h=[];arrayRange(-.8*PI$2,PI$2,PI$2/4).map(t=>[t,c(t),newtonIterateSmart(o,t,16,c,1e-4),o(newtonIterateSmart(o,t,16,c,1e-4))]);for(let t=-.8*PI$2;t<PI$2;t+=PI$2/4){let s=newtonIterateSmart(o,t,16,c,1e-4);le(s,-PI$2)&&(s+=TAU),assert$1(!isNaN(s)),e.isValidT(s)&&eq0(o(s))&&!h.some(t=>eq(s,t))&&h.push(s)}return h.map(s=>{const r=this.matrix.transformPoint(e.at(s));return{tThis:this.pointT(r),tOther:t.pointT(r,PI$2),p:r}})}return this.isTsWithPlane(t.getPlane()).mapFilter(e=>{const s=this.at(e);if(t.containsPoint(s))return{tThis:e,tOther:t.pointT(s),p:s}})}isInfosWithCurve(t){return t instanceof EllipseCurve?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}roots(){return arrayFromFunction(3,t=>{const e=this.f2.e(t),s=-this.f1.e(t),{x1:r,y1:n,x2:i,y2:a}=intersectionUnitCircleLine(e,s,0);return[Math.atan2(n,r),Math.atan2(a,i)]})}closestTToPoint(t,e){const s=this.inverseMatrix.transformPoint(t).angleXY(),r=t.minus(this.center);return newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(r)),s)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const e=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.inverseMatrix.transformVector(e).angleXY()}}EllipseCurve.XY=new EllipseCurve(V3.O,V3.X,V3.Y),EllipseCurve.prototype.hlol=Curve.hlol++,EllipseCurve.prototype.tIncrement=2*Math.PI/3200;const{PI:PI$3,cos:cos$2,sin:sin$2,min:min$1,max:max$1,tan:tan$1,sign:sign$1,ceil:ceil$3,floor:floor$3,abs:abs$4,sqrt:sqrt$1,pow:pow$1,atan2:atan2$1,round:round$1}=Math;class HyperbolaCurve extends XiEtaCurve{constructor(t,e,s,r=-7,n=7){super(t,e,s,r,n)}static XYLCValid(t){return t.x>0&&eq(1,t.x*t.x-t.y*t.y)}static XYLCPointT(t){return Math.asinh(t.y)}static magic(t,e,s){if(eq0(e)){const e=snap0(Math.pow(s,2)/Math.pow(t,2)-1);if(e<0||s*t<0)return[];if(0==e)return[0];const r=Math.sqrt(e);return[-Math.asinh(r),Math.asinh(r)]}if(eq(abs$4(t),abs$4(e))){if(le(s*t,0))return[];const r=sign$1(t*e)*(Math.pow(s,2)-Math.pow(t,2))/2/t/s;return[Math.asinh(r)]}{const r=snap0(Math.pow(e,2)*(-Math.pow(t,2)+Math.pow(e,2)+Math.pow(s,2)));if(r<0)return[];const n=(t*s-Math.sqrt(r))/(Math.pow(t,2)-Math.pow(e,2)),i=(t*s+Math.sqrt(r))/(Math.pow(t,2)-Math.pow(e,2)),a=(Math.pow(e,2)*s-t*Math.sqrt(r))/(e*(Math.pow(e,2)-Math.pow(t,2))),o=(Math.pow(e,2)*s+t*Math.sqrt(r))/(e*(Math.pow(e,2)-Math.pow(t,2)));return[n>0&&Math.asinh(a),i>0&&Math.asinh(o)].filter(t=>!1!==t)}}at(t){return assertNumbers(t),this.center.plus(this.f1.times(Math.cosh(t))).plus(this.f2.times(Math.sinh(t)))}tangentAt(t){return assertNumbers(t),this.f1.times(Math.sinh(t)).plus(this.f2.times(Math.cosh(t)))}tangentAt2(t,e){return assertNumbers(t,e),this.f1.times(e).plus(this.f2.times(t))}ddt(t){return assertNumbers(t),this.f1.times(Math.cosh(t)).plus(this.f2.times(Math.sinh(t)))}isColinearTo(t){if(!hasConstructor(t,HyperbolaCurve))return!1;if(!t.center||!this.center.like(t.center))return!1;if(this===t)return!0;const{f1:e,f2:s}=this.rightAngled(),{f1:r,f2:n}=t.rightAngled();return eq(e.squared(),Math.abs(e.dot(r)))&&eq(s.squared(),Math.abs(s.dot(n)))}reversed(){return new HyperbolaCurve(this.center,this.f1,this.f2.negated(),-this.tMax,-this.tMin)}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e),r=e.squared()+t.squared();if(eq0(s))return this;const n=2*s,i=r+Math.sqrt(r*r-4*s*s),{x1:a,y1:o}=intersectionUnitHyperbolaLine(n,i,0);return new HyperbolaCurve(this.center,t.times(a).plus(e.times(o)),t.times(o).plus(e.times(a)))}eccentricity(){const t=this.rightAngled(),e=t.f1.length(),s=t.f1.length(),[r,n]=e>s?[e,s]:[s,e];return Math.sqrt(1+n*n/r/r)}roots(){return arrayFromFunction(3,t=>{const e=this.f2.e(t),s=this.f1.e(t);return HyperbolaCurve.magic(e,s,0)})}}HyperbolaCurve.XY=new HyperbolaCurve(V3.O,V3.X,V3.Y),HyperbolaCurve.prototype.tIncrement=PI$3/16;class L3$1 extends Curve{constructor(t,e,s=-4096,r=4096){super(s,r),this.anchor=t,this.dir1=e,assertVectors(t,e),assert$1(e.hasLength(1),"dir must be unit"+e),assertf(()=>!Number.isNaN(t.x))}static throughPoints(t,e,s,r){return new L3$1(t,e.minus(t).unit(),s,r)}static pointT(t,e,s){return assertVectors(t,e,s),s.minus(t).dot(e)/e.squared()}static at(t,e,s){return t.plus(e.times(s))}static fromPlanes(t,e){if(assertInst(P3,t,e),t.normal1.cross(e.normal1).length()<1e-10)throw new Error("Parallel planes");return t.intersectionWithPlane(e)}static containsPoint(t,e,s){const r=L3$1.pointT(t,e,s),n=L3$1.at(t,e,r).distanceTo(s);return eq0(n)}addToMesh(t,e=4,s=0,r=1,n=this.tMin,i=this.tMax){const a=arrayFromFunction(e,t=>V3.polar(1,TAU*t/e)),o=arrayFromFunction(e,t=>V3.polar(s,TAU*t/e)),c=this.tIncrement;Math.ceil((this.tMin+NLA_PRECISION)/c),Math.floor((this.tMax-NLA_PRECISION)/c);for(let s=0;s<=1;s+=1){const r=t.vertices.length;if(0!==s)for(let s=0;s<e;s++)pushQuad(t.TRIANGLES,!0,r-e+s,r+s,r-e+(s+1)%e,r+(s+1)%e);const c=0==s?n:i,h=this.at(c),l=(this.dir1,this.dir1.getPerpendicular()),u=M4.forSys(l,this.dir1.cross(l),this.dir1,h);t.normals.push(...u.transformedVectors(a)),t.vertices.push(...u.transformedPoints(o))}}roots(){return[[],[],[]]}containsPoint(t){assertVectors(t);const e=this.distanceToPoint(t);return assertNumbers(e),eq0(e)}likeCurve(t){return this==t||hasConstructor(t,L3$1)&&this.anchor.like(t.anchor)&&this.dir1.like(t.dir1)}equals(t){return this==t||Object.getPrototypeOf(t)==L3$1.prototype&&this.anchor.equals(t.anchor)&&this.dir1.equals(t.dir1)}isColinearTo(t){return t instanceof L3$1&&this.containsPoint(t.anchor)&&eq(1,Math.abs(this.dir1.dot(t.dir1)))}distanceToLine(t){if(assertInst(L3$1,t),this.isParallelToLine(t))return this.distanceToPoint(t.anchor);const e=this.dir1.cross(t.dir1).unit(),s=this.anchor.minus(t.anchor);return Math.abs(s.dot(e))}distanceToPoint(t){assertVectors(t);const e=t.minus(this.anchor).dot(this.dir1);return this.at(e).distanceTo(t)}asSegmentDistanceToPoint(t,e,s){let r=t.minus(this.anchor).dot(this.dir1);return r=clamp(r,e,s),this.at(r).minus(t).length()}asSegmentDistanceToLine(t,e,s){assertInst(L3$1,t);const r=this.dir1.cross(t.dir1),n=r.squared();if(eq0(n))return;const i=t.anchor.minus(this.anchor);if(!eq0(i.dot(r.unit())))return;let a=this.infoClosestToLine(t).t;return a=clamp(a,e,s),this.at(clamp(a,e,s))}at(t){return assertNumbers(t),this.anchor.plus(this.dir1.times(t))}pointT(t){return assertVectors(t),t.minus(this.anchor).dot(this.dir1)}isParallelToLine(t){return assertInst(L3$1,t),eq(1,Math.abs(this.dir1.dot(t.dir1)))}angleToLine(t){return assertInst(L3$1,t),this.dir1.angleTo(t.dir1)}intersectsLine(t){return eq0(this.distanceToLine(t))}isInfosWithCurve(t){if(t instanceof L3$1){const e=this.dir1.cross(t.dir1),s=e.squared();if(eq0(s))return[];const r=t.anchor.minus(this.anchor);if(eq0(r.dot(e))){const n=r.cross(t.dir1).dot(e)/s;return[{tThis:n,tOther:r.cross(this.dir1).dot(e)/s,p:this.at(n)}]}return[]}throw new Error}isInfoWithLine(t){assertInst(L3$1,t);const e=this.dir1.cross(t.dir1),s=e.squared();if(eq0(s))return;const r=t.anchor.minus(this.anchor);if(!eq0(r.dot(e.unit())))return;const n=r.cross(t.dir1).dot(e)/s;return this.at(n)}intersectionLineST(t){assertInst(L3$1,t);const e=this.dir1.cross(t.dir1),s=e.squared(),r=t.anchor.minus(this.anchor);return{s:r.cross(this.dir1).dot(e)/s,t:r.cross(t.dir1).dot(e)/s}}ddt(t){return V3.O}getConstructorParameters(){return[this.anchor,this.dir1]}closestTToPoint(t){return t.minus(this.anchor).dot(this.dir1)}infoClosestToLine(t){if(this.isParallelToLine(t))return{t:NaN,s:NaN,distance:this.distanceToLine(t)};const e=t.anchor,s=t.dir1,r=this.anchor,n=this.dir1,i=s.dot(n),a=s.squared(),o=n.squared(),c=e.minus(r),h=i*i-o*a,l=(c.dot(s)*i-c.dot(n)*a)/h,u=(c.dot(s)*o-c.dot(n)*i)/h;return{t:l,s:u,closest:this.at(l),closest2:t.at(u),distance:this.at(l).distanceTo(t.at(u))}}intersectionWithPlane(t){const e=(t.w-t.normal1.dot(this.anchor))/t.normal1.dot(this.dir1);return this.anchor.plus(this.dir1.times(e))}tangentAt(t){return this.dir1}isTWithPlane(t){const e=t.normal1.dot(this.dir1);return eq0(e)?NaN:(t.w-t.normal1.dot(this.anchor))/e}reversed(){return new L3$1(this.anchor,this.dir1.negated(),-this.tMax,-this.tMin)}isTsWithPlane(t){return[this.isTWithPlane(t)]}flipped(){return new L3$1(this.anchor,this.dir1.negated())}transform(t){const e=t.transformPoint(this.anchor),s=t.transformVector(this.dir1);return new L3$1(e,s.unit(),this.tMin*s.length(),this.tMax*s.length())}hashCode(){return 31*this.anchor.hashCode()+this.dir1.hashCode()}}L3$1.anchorDirection=((t,e)=>new L3$1(t,e.unit())),L3$1.X=new L3$1(V3.O,V3.X),L3$1.Y=new L3$1(V3.O,V3.Y),L3$1.Z=new L3$1(V3.O,V3.Z),L3$1.prototype.hlol=Curve.hlol++;const{floor:floor$4,abs:abs$5,ceil:ceil$4,min:min$2,max:max$2}=Math;class PICurve$1 extends ImplicitCurve{constructor(t,e,s,r,n,i,a,o=1,c,h,l){super(t,e,o,c,h,l),this.parametricSurface=s,this.implicitSurface=r,this.pmPoints=n,this.pmTangents=i,this.stepSize=a,assert$1(Array.isArray(n)),assert$1(1==o),assert$1(a<=1);const u=s.pSTFunc(),f=s.dpds(),d=s.dpdt(),p=r.didp.bind(r);this.dids=((t,e)=>p(u(t,e)).dot(f(t,e))),this.didt=((t,e)=>p(u(t,e)).dot(d(t,e)));for(let e=0;e<t.length-1;e++)assert$1(!t[e].equals(t[e+1]))}static forParametricStartEnd(t,e,s,r,n=.02,i,a,o){const c=t.pSTFunc(),h=e.implicitFunction(),l=t.dpds(),u=t.dpdt(),f=e.didp.bind(e),d=MathFunctionR2R.forFFxFy((t,e)=>h(c(t,e)),(t,e)=>f(c(t,e)).dot(l(t,e)),(t,e)=>f(c(t,e)).dot(u(t,e))),{points:p,tangents:m}=followAlgorithm2d(d,s,n,t.bounds.bind(t),r,i);return PICurve$1.forParametricPointsTangents(t,e,p,m,n,1,a,o)}static forStartEnd(t,e,s,r,n=.02,i,a,o){const c=t.stP(s),h=t.dpds()(c.x,c.y),l=t.dpdt()(c.x,c.y),u=i&&M4.forSys(h,l).inversed().transformVector(i),f=PICurve$1.forParametricStartEnd(t,e,c,t.stP(r),n,u);return f.withBounds(a&&f.pointT(a),o&&f.pointT(o))}static forParametricPointsTangents(t,e,s,r,n,i=1,a,o){const c=t.pSTFunc(),h=(e.implicitFunction(),t.dpds()),l=t.dpdt(),u=s.map(({x:t,y:e})=>c(t,e)),f=s.map(({x:t,y:e},s)=>{const n=h(t,e),i=l(t,e);return n.times(r[s].x).plus(i.times(r[s].y))});return new PICurve$1(u,f,t,e,s,r,n,i,void 0,a,o)}getConstructorParameters(){return[this.points,this.tangents,this.parametricSurface,this.implicitSurface,this.pmPoints,this.pmTangents,this.stepSize,this.dir,this.generator,this.tMin,this.tMax]}reversed(){return assertNever(),new PICurve$1(this.parametricSurface,this.implicitSurface,this.endPoint,this.startPoint,-this.dir)}implicitCurve(){const t=this.parametricSurface.pSTFunc(),e=this.implicitSurface.implicitFunction();return function(s,r){return e(t(s,r))}}isColinearTo(t){return t instanceof PICurve$1&&(!!this.equals(t)||(this.parametricSurface.isCoplanarTo(t.parametricSurface)&&this.implicitSurface.isCoplanarTo(t.implicitSurface),!1))}containsPoint(t){assertVectors(t);const e=this.pointT(t);return!isNaN(e)&&this.isValidT(e)}equals(t){return Object.getPrototypeOf(t)==PICurve$1.prototype&&this.parametricSurface.equals(t.parametricSurface)&&this.implicitSurface.equals(t.implicitSurface)&&this.points[0].equals(t.points[0])&&this.tangents[0].equals(t.tangents[0])&&this.dir===t.dir}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*(t=31*t+this.parametricSurface.hashCode())+this.implicitSurface.hashCode())+this.points[0].hashCode())+this.tangents[0].hashCode())}tangentP(t){assertVectors(t),assert$1(this.containsPoint(t),"this.containsPoint(point)"+this.containsPoint(t));const e=this.pointT(t);return this.tangentAt(e)}tangentAt(t){return V3.lerp(this.tangents[floor$4(t)],this.tangents[ceil$4(t)],t%1)}at(t){if(assert$1(!isNaN(t)),t%1==0)return this.points[t];const e=V3.lerp(this.pmPoints[floor$4(t)],this.pmPoints[ceil$4(t)],t%1);return this.closestPointToParams(e)}stT(t){if(assert$1(!isNaN(t)),t%1==0)return this.points[t];const e=V3.lerp(this.pmPoints[floor$4(t)],this.pmPoints[ceil$4(t)],t%1);return curvePoint(this.implicitCurve(),e,this.dids,this.didt)}closestTToPoint(t,e){return 0}closestPointToParams(t){const e=curvePoint(this.implicitCurve(),t,this.dids,this.didt);return this.parametricSurface.pSTFunc()(e.x,e.y)}isTsWithSurface(t){if(t instanceof PlaneSurface$1)return this.isTsWithPlane(t.plane);if(t instanceof EllipsoidSurface||t instanceof SemiEllipsoidSurface){const e=this.parametricSurface,s=this.implicitSurface;if(e instanceof ProjectedCurveSurface&&s instanceof SemiEllipsoidSurface){const r=s.isCurvesWithSurface(t).flatMap(t=>t.isTsWithSurface(e).map(e=>t.at(e)));return fuzzyUniques(r.map(t=>this.pointT(t))).filter(t=>!isNaN(t)&&this.isValidT(t))}}throw new Error}isTsWithPlane(t){assertInst(P3,t);const e=this.parametricSurface,s=this.implicitSurface,r=e.isCurvesWithPlane(t),n=s.isCurvesWithPlane(t).flatMap(t=>r.flatMap(e=>t.isInfosWithCurve(e)));return fuzzyUniques(n.map(t=>this.pointT(t.p))).filter(t=>!isNaN(t)&&this.isValidT(t))}pointT(t){if(assertVectors(t),!this.parametricSurface.containsPoint(t)||!this.implicitSurface.containsPoint(t))return NaN;const e=this.parametricSurface.stPFunc()(t),s=this.points,r=this.pmPoints;let n=0,i=e.distanceTo(r[0]);for(;i>abs$5(this.stepSize)&&n<s.length-1;)n=min$2(r.length-1,n+max$2(1,Math.round(i/abs$5(this.stepSize)/2/2))),i=e.distanceTo(r[n]);if(i>1.1*abs$5(this.stepSize))return NaN;if(n==s.length-1&&n--,s[n].like(t))return n;if(s[n+1].like(t))return n+1;const a=n+V3.inverseLerp(s[n],s[n+1],t);return a?newtonIterate1d(e=>this.at(e).distanceTo(t),a,2):void 0}transform(t){const e=t.isMirroring()?-1:1;return PICurve$1.forStartEnd(this.parametricSurface.transform(t),this.implicitSurface.transform(t),t.transformPoint(this.points[0]),t.transformPoint(this.points.last),this.stepSize*e,t.transformVector(this.tangents[0]),t.transformPoint(this.at(this.tMin)),t.transformPoint(this.at(this.tMax)))}roots(){const t=arrayRange(0,this.points.length);return[t,t,t]}toSource(t=(t=>t)){return callsce("PICurve.forParametricStartEnd",this.parametricSurface,this.implicitSurface,this.pmPoints[0],this.pmPoints.last,this.stepSize,this.pmTangents[0],this.tMin,this.tMax)}}PICurve$1.prototype.tIncrement=1;class ParabolaCurve extends XiEtaCurve{constructor(t,e,s,r=-10,n=10){super(t,e,s,r,n)}static eccentricity(){return 1}static unitIsInfosWithLine(t,e,s,r){const n=Math.pow(e.x,2);return pqFormula((t.x*e.x+e.y)/n,(Math.pow(t.x,2)+t.y)/n).filter(s=>le(0,t.y+s*e.y)).map(n=>({tThis:e.x*n+t.x,tOther:n,p:L3$1.at(s,r,n)}))}static magic(t,e,s){return pqFormula(t/e,-s/e)}static XYLCValid(t){return eq(Math.pow(t.x,2),t.y)}static XYLCPointT(t){return t.x}static quadratic(t,e,s){const r=t.plus(s).minus(e.times(2)),n=e.minus(t).times(2);return new ParabolaCurve(t,n,r,0,1)}at(t){return this.center.plus(this.f1.times(t)).plus(this.f2.times(t*t))}tangentAt(t){return assertNumbers(t),this.f1.plus(this.f2.times(2*t))}ddt(t){return assertNumbers(t),this.f2.times(2)}tangentAt2(t,e){return assertNumbers(t,e),this.f1.plus(this.f2.times(2*e))}reversed(){return new this.constructor(this.center,this.f1.negated(),this.f2,-this.tMax,-this.tMin)}roots(){return arrayFromFunction(3,t=>eq0(this.f2.e(t))?[]:[-this.f1.e(t)/2/this.f2.e(t)])}isColinearTo(t){if(!hasConstructor(t,ParabolaCurve))return!1;const e=this.rightAngled(),s=t.rightAngled();return e.center.like(s.center)&&e.f2.like(s.f2)&&e.f1.likeOrReversed(s.f1)}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e);if(eq0(s)&&t.hasLength(1))return this;const r=-s/e.squared()/2,n=this.at(r),i=this.tangentAt(r),a=i.length(),o=i.unit(),c=t=>this.at(t).minus(n).dot(o);return new ParabolaCurve(n,o,e.div(Math.pow(a,2)),c(this.tMin),c(this.tMax))}arcLength(t,e){let s=this.f1;const r=this.f2,n=s.dot(r);let i=0;eq0(n)||(i=-n/r.squared()/2,s=s.plus(r.times(2*i)));const a=s.length(),o=r.length()/a;function c(t){return Math.asinh(2*o*t)/4/o+t*Math.sqrt(1+o*o*4*t*t)/2}return a*(c(e-i)-c(t-i))}asBezier(){return BezierCurve.quadratic(this.at(-1),new L3$1(this.at(-1),this.tangentAt(-1).unit()).isInfoWithLine(new L3$1(this.at(1),this.tangentAt(1).unit())),this.at(1))}}ParabolaCurve.XY=new ParabolaCurve(V3.O,V3.X,V3.Y),ParabolaCurve.YZ=new ParabolaCurve(V3.O,V3.Y,V3.Z),ParabolaCurve.ZX=new ParabolaCurve(V3.O,V3.Z,V3.X),ParabolaCurve.prototype.tIncrement=1/32;const{PI:PI$4,min:min$3,max:max$3}=Math;class SemiEllipseCurve extends XiEtaCurve{constructor(t,e,s,r=0,n=PI$4){super(t,e,s,r,n),assert$1(0<=this.tMin&&this.tMin<PI$4),assert$1(0<this.tMax&&this.tMax<=PI$4)}static XYLCValid(t){const{x:e,y:s}=t;return le(0,s)&&eq0(Math.pow(e,2)+Math.pow(s,2)-1)}static XYLCPointT(t){const e=Math.atan2(t.y,t.x);return e<-PI$4/2?e+TAU:e}static magic(t,e,s){const r=intersectionUnitCircleLine2(t,e,s),n=[];for(const[t,e]of r)le(0,e)&&n.push(SemiEllipseCurve.XYLCPointT(new V3(t,e,0)));return n}static unitIsInfosWithLine(t,e,s,r){const n=e.squared();return pqFormula(2*e.dot(t)/n,(t.squared()-1)/n).filter(s=>le(0,t.y+s*e.y)).map(n=>({tThis:SemiEllipseCurve.XYLCPointT(e.times(n).plus(t)),tOther:n,p:L3$1.at(s,r,n)}))}static semicircle(t,e=V3.O){return new SemiEllipseCurve(e,new V3(t,0,0),new V3(0,t,0))}static fromEllipse(t,e,s){return[e<0&&new SemiEllipseCurve(t.center,t.f1.negated(),t.f2.negated(),e+PI$4,min$3(0,s)+PI$4),s>0&&new SemiEllipseCurve(t.center,t.f1,t.f2,max$3(0,e),s)].filter(t=>t)}getAreaInDir(t,e,s,r){return EllipseCurve.prototype.getAreaInDir.call(this,t,e,s,r)}at(t){return assertNumbers(t),this.center.plus(this.f1.times(Math.cos(t))).plus(this.f2.times(Math.sin(t)))}tangentAt(t){return assertNumbers(t),this.f2.times(Math.cos(t)).minus(this.f1.times(Math.sin(t)))}ddt(t){return assertNumbers(t),assert$1(this.isValidT(t)),this.f2.times(-Math.sin(t)).minus(this.f1.times(Math.cos(t)))}isCircular(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)}isColinearTo(t){if(!(t=>t.constructor==this.constructor)(t))return!1;if(!hasConstructor(t,SemiEllipseCurve))return!1;if(!this.center.like(t.center))return!1;if(this==t)return!0;if(this.isCircular())return t.isCircular()&&eq(this.f1.length(),t.f1.length())&&this.normal.isParallelTo(t.normal);{let{f1:e,f2:s}=this.rightAngled(),{f1:r,f2:n}=t.rightAngled();return e.length()>s.length()&&([e,s]=[s,e]),r.length()>n.length()&&([r,n]=[n,r]),eq(e.squared(),Math.abs(e.dot(r)))&&eq(s.squared(),Math.abs(s.dot(n)))}}isValidT(t){return le(0,t)&&le(t,PI$4)}pointT(t){assertVectors(t),assert$1(this.containsPoint(t));const e=this.inverseMatrix.transformPoint(t),s=SemiEllipseCurve.XYLCPointT(e);return assert$1(this.isValidT(s)),s}reversed(){return new SemiEllipseCurve(this.center,this.f1.negated(),this.f2,PI$4-this.tMax,PI$4-this.tMin)}eccentricity(){const t=this.rightAngled(),e=t.f1.length(),s=t.f1.length(),[r,n]=e>s?[e,s]:[s,e];return Math.sqrt(1-n*n/r/r)}circumference(){return this.arcLength(-Math.PI,Math.PI)}arcLength(t,e,s=2){assert$1(t<e,"startT < endT");const r=this.f1.length();return eq(r,this.f2.length())?r*(e-t):super.arcLength(t,e,s)}circumferenceApproximate(){const{f1:t,f2:e}=this.rightAngled(),s=t.length(),r=e.length(),n=(s-r)*(s-r)/(s+r)/(s+r);return Math.PI*(s+r)*(1+3*n/(10+Math.sqrt(4-3*n)))}rightAngled(){const t=this.f1,e=this.f2,s=t.dot(e),r=e.squared()-t.squared();if(eq0(s))return this;const n=2*s,i=r+Math.sqrt(r*r+4*s*s),{x1:a,y1:o}=intersectionUnitCircleLine(n,i,0),c=t.times(a).plus(e.times(o)),h=t.times(-o).plus(e.times(a));return new SemiEllipseCurve(this.center,c,h)}asEllipse(){return new EllipseCurve(this.center,this.f1,this.f2,this.tMin,this.tMax)}isInfosWithEllipse(t){return this.normal.isParallelTo(t.normal)&&eq0(this.center.minus(t.center).dot(t.normal))?(t instanceof SemiEllipseCurve&&(t=t.asEllipse()),this.asEllipse().isInfosWithCurve(t).filter(e=>this.isValidT(e.tThis)&&t.isValidT(e.tOther))):this.isTsWithPlane(P3.normalOnAnchor(t.normal.unit(),t.center)).mapFilter(e=>{const s=this.at(e);if(t.containsPoint(s))return{tThis:e,tOther:t.pointT(s),p:s}})}isInfosWithCurve(t){return t instanceof SemiEllipseCurve||t instanceof EllipseCurve?this.isInfosWithEllipse(t):super.isInfosWithCurve(t)}roots(){return arrayFromFunction(3,t=>{const e=this.f2.e(t),s=-this.f1.e(t),{x1:r,y1:n,x2:i,y2:a}=intersectionUnitCircleLine(e,s,0);return[Math.atan2(n,r),Math.atan2(a,i)]})}closestTToPoint(t){const e=this.inverseMatrix.transformPoint(t).angleXY(),s=t.minus(this.center);return newtonIterate1d(t=>this.tangentAt(t).dot(this.f1.times(Math.cos(t)).plus(this.f2.times(Math.sin(t))).minus(s)),e)}area(){return Math.PI*this.f1.cross(this.f2).length()}angleToT(t){const e=this.f1.unit().times(Math.cos(t)).plus(this.f2.rejectedFrom(this.f1).unit().times(Math.sin(t)));return this.inverseMatrix.transformVector(e).angleXY()}}SemiEllipseCurve.UNIT=new SemiEllipseCurve(V3.O,V3.X,V3.Y),SemiEllipseCurve.prototype.hlol=Curve.hlol++,SemiEllipseCurve.prototype.tIncrement=2*Math.PI/128;class P3 extends Transformable{constructor(t,e=0){super(),this.normal1=t,this.w=e,assertVectors(t),assertNumbers(e),assert$1(t.hasLength(1),"normal1.hasLength(1)"+t)}get anchor(){return this.normal1.times(this.w)}static throughPoints(t,e,s){assertVectors(t,e,s);const r=e.minus(t).cross(s.minus(t)).unit();return new P3(r,r.dot(t))}static normalOnAnchor(t,e){assertVectors(t,e);const s=t.unit();return new P3(s,s.dot(e))}static forAxisIntercepts(t,e,s){assertNumbers(t,e,s);const r=new V3(1/t,1/e,1/s);return new P3(r.unit(),r.length())}static forAnchorAndPlaneVectors(t,e,s){return assertVectors(t,e,s),P3.normalOnAnchor(e.cross(s),t)}axisIntercepts(){const t=this.w,e=this.normal1;return new V3(t/e.x,t/e.y,t/e.z)}isCoplanarToPlane(t){return assertInst(P3,t),this.like(t)||this.likeFlipped(t)}like(t){return assertInst(P3,t),eq(this.w,t.w)&&this.normal1.like(t.normal1)}likeFlipped(t){return assertInst(P3,t),eq(this.w,-t.w)&&this.normal1.like(t.normal1.negated())}isParallelToPlane(t){return assertInst(P3,t),eq(1,Math.abs(this.normal1.dot(t.normal1)))}isParallelToLine(t){return assertInst(L3$1,t),eq0(this.normal1.dot(t.dir1))}isPerpendicularToLine(t){return assertInst(L3$1,t),eq(1,Math.abs(this.normal1.dot(t.dir1)))}isPerpendicularToPlane(t){return assertInst(P3,t),eq0(this.normal1.dot(t.normal1))}toSource(t){return callsce("new P3",this.normal1,this.w)}translated(t){return new P3(this.normal1,this.w+t.dot(this.normal1))}transform(t){const e=t.isMirroring(),s=this.normal1.getPerpendicular(),r=s.cross(this.normal1),n=t.transformPoint(this.anchor),i=t.transformPoint(this.anchor.plus(r)),a=t.transformPoint(this.anchor.plus(s));return P3.throughPoints(n,e?a:i,e?i:a)}distanceToLine(t){return assertInst(L3$1,t),this.isParallelToLine(t)?0:this.distanceToPoint(t.anchor)}containsPoint(t){return assertVectors(t),eq(this.w,this.normal1.dot(t))}containsLine(t){return assertInst(L3$1,t),this.containsPoint(t.anchor)&&this.isParallelToLine(t)}distanceToPointSigned(t){return assertInst(V3,t),this.normal1.dot(t)-this.w}distanceToPoint(t){return assertInst(V3,t),Math.abs(this.normal1.dot(t)-this.w)}intersectionWithLine(t){return t.intersectionWithPlane(this)}intersectionWithPlane(t){assertInst(P3,t),assert$1(!this.isParallelToPlane(t),"!this.isParallelToPlane(plane)");const e=this.normal1,s=t.normal1,r=e.cross(s).unit(),n=M4.forRows(e,s,r).inversed().transformVector(new V3(this.w,t.w,0));return new L3$1(n,r)}projectedPoint(t){return t.minus(this.normal1.times(t.minus(this.anchor).dot(this.normal1)))}projectedVector(t){return t.minus(this.normal1.times(t.dot(this.normal1)))}flipped(){return new P3(this.normal1.negated(),-this.w)}containsCurve(t){if(t instanceof L3$1)return this.containsLine(t);if(t instanceof SemiEllipseCurve||t instanceof EllipseCurve||t instanceof HyperbolaCurve||t instanceof ParabolaCurve)return this.containsPoint(t.center)&&this.normal1.isParallelTo(t.normal);if(t instanceof BezierCurve)return t.points.every(t=>this.containsPoint(t));throw new Error(""+t)}hashCode(){return 31*this.normal1.hashCode()|0+floatHashCode(this.w)}}P3.YZ=new P3(V3.X,0),P3.ZX=new P3(V3.Y,0),P3.XY=new P3(V3.Z,0);const{ceil:ceil$5,floor:floor$5}=Math;class Surface extends Transformable{static loopContainsPointGeneral(t,e,s,r){const n=P3.normalOnAnchor(r,e),i=t.map(t=>t.colinearToLine(s));let a=!1;function o(t){const e=s.pointT(t);if(eq0(e))return!0;e>0&&(a=!a)}for(let a=0;a<t.length;a++){const c=t[a],h=(a+1)%t.length,l=t[h];if(i[a]){const t=s.pointT(c.a),e=s.pointT(c.b);if(Math.min(t,e)<=NLA_PRECISION&&-NLA_PRECISION<=Math.max(t,e))return PointVsFace.ON_EDGE;if(!(i[h]||dotCurve(r,l.aDir,l.aDDT)<0)&&o(c.b))return PointVsFace.ON_EDGE}else for(const t of c.edgeISTsWithPlane(n))if(t==c.bT){if(!s.containsPoint(c.b))continue;if(c.b.like(e))return PointVsFace.ON_EDGE;if(dotCurve(r,c.bDir,c.bDDT)>0!=(i[h]||dotCurve(r,l.aDir,l.aDDT)<0)&&o(c.b))return PointVsFace.ON_EDGE}else if(t!=c.aT){const e=c.curve.at(t);if(!s.containsPoint(e))continue;if(o(e))return PointVsFace.ON_EDGE}}return a?PointVsFace.INSIDE:PointVsFace.OUTSIDE}toString(){return this.toSource()}toSource(t=(t=>t)){return callsce.call(void 0,"new "+this.constructor.name,...this.getConstructorParameters())}isCurvesWithSurface(t){return t.isCurvesWithSurface(this).map(t=>t.reversed())}containsCurve(t){if(t instanceof ImplicitCurve){for(let e=ceil$5(t.tMin);e<=floor$5(t.tMax);e++)if(!this.containsPoint(t.points[e]))return!1;return!0}return!1}flipped2(t){return t?this.flipped():this}clipCurves(t){return t}hashCode(){return this.getConstructorParameters().hashCode()}zDirVolume(t){return this.visit(ZDirVolumeVisitor,t)}calculateArea(t){return this.visit(CalculateAreaVisitor,t)}}var PointVsFace;!function(t){t[t.INSIDE=0]="INSIDE",t[t.OUTSIDE=1]="OUTSIDE",t[t.ON_EDGE=2]="ON_EDGE"}(PointVsFace||(PointVsFace={}));const{ceil:ceil$6,min:min$4}=Math;class ParametricSurface extends Surface{static isCurvesParametricImplicitSurface(t,e,s,r=s,n){const i=t.pSTFunc(),a=e.implicitFunction(),o=t.dpds(),c=t.dpdt(),h=e.didp.bind(e),l=(t,e)=>h(i(t,e)).dot(o(t,e)),u=(t,e)=>h(i(t,e)).dot(c(t,e)),f=MathFunctionR2R.forFFxFy((t,e)=>a(i(t,e)),l,u);return Curve.breakDownIC(f,t,s,r,n,l,u).map(({points:s,tangents:r},i)=>PICurve$1.forParametricPointsTangents(t,e,s,r,n))}static is(t){return t.pSTFunc}pST(t,e){return this.pSTFunc()(t,e)}pSTFunc(){return this.pST.bind(this)}stP(t){return this.stPFunc()(t)}stPFunc(){return this.stP.bind(this)}bounds(t,e){return this.sMin<=t&&t<=this.sMax&&this.tMin<=e&&e<=this.tMax}boundsSigned(t,e){return min$4(t-this.sMin,this.sMax-t,e-this.tMin,this.tMax-e)}normalP(t){const e=this.stPFunc()(t);return this.normalST(e.x,e.y)}normalSTFunc(){return this.normalST.bind(this)}normalST(t,e){return this.normalSTFunc()(t,e)}parametersValid(t,e){return between(t,this.sMin,this.sMax)&&between(e,this.tMin,this.tMax)}pointFoot(t,e,s){throw new Error}toMesh(){return assert$1(isFinite(this.tMin)&&isFinite(this.tMax)&&isFinite(this.sMin)&&isFinite(this.sMax)),Mesh.parametric(this.pSTFunc(),this.normalSTFunc(),this.sMin,this.sMax,this.tMin,this.tMax,ceil$6((this.sMax-this.sMin)/this.uStep),ceil$6((this.tMax-this.tMin)/this.vStep))}isCurvesWithImplicitSurface(t,e,s,r){return ParametricSurface.isCurvesParametricImplicitSurface(this,t,e,s,r)}}class ImplicitSurface extends Surface{static is(t){return t.implicitFunction}}const{PI:PI$5,cos:cos$3,sin:sin$3,min:min$5,max:max$4,tan:tan$2,ceil:ceil$7,floor:floor$6,abs:abs$6,sqrt:sqrt$2,pow:pow$2,atan2:atan2$2,round:round$2,sign:sign$2}=Math;class ConicSurface extends ParametricSurface{constructor(t,e,s,r){super(),this.center=t,this.f1=e,this.f2=s,this.dir=r,assertVectors(t,e,s,r),this.matrix=M4.forSys(e,s,r,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$2(this.f1.cross(this.f2).dot(this.dir)),this.normalMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}get apex(){return this.center}static atApexThroughEllipse(t,e){return assertVectors(t),assertInst(SemiEllipseCurve,e),new ConicSurface(t,e.f1,e.f2,t.to(e.center))}static unitISLineTs(t,e){const{x:s,y:r,z:n}=t,{x:i,y:a,z:o}=e,c=i*i+a*a-o*o;return pqFormula(2*(s*i+r*a-n*o)/c,(s*s+r*r-n*n)/c).filter(t=>0<n+t*o)}static unitISPlane(t,e,s){if(eq0(e)){if(assert$1(!eq0(t)),eq0(s))return[new L3$1(V3.O,new V3(0,-sqrt$2(2)/2,-sqrt$2(2)/2),void 0,0),new L3$1(V3.O,new V3(0,-sqrt$2(2)/2,sqrt$2(2)/2),0)];{const e=new V3(s/t,0,0),r=new V3(0,0,abs$6(s/t)),n=new V3(0,s/t,0);return[new HyperbolaCurve(e,r,n)]}}{const r=t*t,n=e*e;if(eq0(s)){if(eq(r,n))return[new L3$1(V3.O,new V3(e,0,-t).unit())];if(r<n)assert$1(!1,"intersection is single point V3.O");else if(r>n)return[new L3$1(V3.O,new V3(e,sqrt$2(r-n),-t).unit()),new L3$1(V3.O,new V3(e,-sqrt$2(r-n),-t).unit())]}else{if(eq(r,n)){const r=new V3(s/2/t,0,s/2/e),n=new V3(s/2/t,s/e,s/2/e),i=new V3(0,0,s/e).minus(r);return[new ParabolaCurve(r,n.minus(r),i.z<0?i.negated():i)]}if(r<n){const i=new V3(-t*s/(n-r),0,s*e/(n-r));if(i.z<0)return[];const a=new V3(s/(t-e),0,-s/(t-e)),o=new V3(-t*s/(n-r),s/sqrt$2(n-r),s*e/(n-r));return[new EllipseCurve(i,i.to(a),i.to(o))]}if(r>n){const i=new V3(-t*s/(n-r),0,s*e/(n-r)),a=new V3(s/(t-e),0,-s/(t-e)),o=new V3(-t*s/(n-r),s/sqrt$2(r-n),s*e/(n-r)),c=i.to(a);return[new HyperbolaCurve(i,c.z>0?c:c.negated(),i.to(o))]}}}}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.center.equals(t.center)&&this.f1.equals(t.f1)&&this.f2.equals(t.f2)&&this.dir.equals(t.dir)}like(t){return!!this.isCoplanarTo(t)&&this.normalDir==t.normalDir}getVectors(){return[{anchor:this.center,dir1:this.dir},{anchor:this.center.plus(this.dir),dir1:this.f1},{anchor:this.center.plus(this.dir),dir1:this.f2}]}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.center,this.f1,this.dir)}loopContainsPoint(t,e){assertVectors(e);const s=this.center.like(e)?new L3$1(e,this.matrix.transformVector(new V3(0,1,1)).unit()):L3$1.throughPoints(e,this.apex),r=s.dir1.cross(this.dir);return Surface.loopContainsPointGeneral(t,e,s,r)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.dir]}isTsForLine(t){const e=this.inverseMatrix.transformPoint(t.anchor),s=this.inverseMatrix.transformVector(t.dir1);return ConicSurface.unitISLineTs(e,s)}isCoplanarTo(t){return this===t||!!(t instanceof ConicSurface&&this.apex.like(t.apex))&&this.containsEllipse(new SemiEllipseCurve(t.center.plus(t.dir),t.f1,t.f2))}containsEllipse(t){const e=t.transform(this.inverseMatrix);if(e.center.z<0)return!1;const{f1:s,f2:r}=e.rightAngled(),n=e.center.plus(s),i=e.center.plus(r);return eq(Math.pow(n.x,2)+Math.pow(n.y,2),Math.pow(n.z,2))&&eq(Math.pow(i.x,2)+Math.pow(i.y,2),Math.pow(i.z,2))&&(eq0(s.z)||eq0(r.z))}containsLine(t){const e=t.transform(this.inverseMatrix),s=e.dir1;return e.containsPoint(V3.O)&&eq(s.x*s.x+s.y*s.y,s.z*s.z)}containsParabola(t){assertInst(ParabolaCurve,t);const e=t.transform(this.inverseMatrix);if(e.center.z<0||e.f2.z<0)return!1;const{center:s,f1:r,f2:n}=e.rightAngled();return eq(s.x*s.x+s.y*s.y,s.z*s.z)&&eq0(r.z)&&eq(n.x*n.x+n.y*n.y,n.z*n.z)}containsHyperbola(t){return assertInst(HyperbolaCurve,t),!0}containsCurve(t){return t instanceof SemiEllipseCurve?this.containsEllipse(t):t instanceof L3$1?this.containsLine(t):t instanceof HyperbolaCurve?this.containsHyperbola(t):t instanceof ParabolaCurve?this.containsParabola(t):super.containsCurve(t)}transform(t){return new ConicSurface(t.transformPoint(this.center),t.transformVector(this.f1).times(t.isMirroring()?-1:1),t.transformVector(this.f2),t.transformVector(this.dir))}rightAngled(){}flipped(){return new ConicSurface(this.center,this.f1.negated(),this.f2,this.dir)}normalSTFunc(){const{f1:t,f2:e}=this,s=this.dir;return(r,n)=>e.cross(t).plus(e.cross(s.times(Math.cos(r)))).plus(s.cross(t.times(Math.sin(r)))).unit()}normalP(t){const e=this.inverseMatrix.transformPoint(t);return this.normalSTFunc()(e.angleXY(),e.z)}pSTFunc(){return(t,e)=>this.matrix.transformPoint(new V3(e*cos$3(t),e*sin$3(t),e))}dpds(){return(t,e)=>{const s=new V3(e*-sin$3(t),e*cos$3(t),0);return this.matrix.transformVector(s)}}dpdt(){return(t,e)=>{const s=new V3(cos$3(t),sin$3(t),1);return this.matrix.transformVector(s)}}implicitFunction(){return t=>{const e=this.inverseMatrix.transformPoint(t),s=e.lengthXY();return this.normalDir*(s-e.z)}}containsPoint(t){return eq0(this.implicitFunction()(t))}boundsFunction(){assert$1(!1)}stP(t){const e=this.inverseMatrix.transformPoint(t),s=e.angleXY();return new V3(s<-PI$5/2?s+TAU:s,e.z,0)}isCurvesWithSurface(t){return t instanceof PlaneSurface$1?this.isCurvesWithPlane(t.plane):ImplicitSurface.is(t)?ParametricSurface.isCurvesParametricImplicitSurface(this,t,.1,.1/this.dir.length(),.02):super.isCurvesWithSurface(t)}getCenterLine(){return new L3$1(this.center,this.dir)}isCurvesWithPlane(t){assertInst(P3,t);const e=t.transform(this.inverseMatrix),s=e.normal1,r=s.z,n=s.lengthXY(),i=e.w,a=M4.rotateZ(s.angleXY()),o=eq0(s.lengthXY())?this.matrix:this.matrix.times(a);return ConicSurface.unitISPlane(n,r,i).flatMap(e=>{const s=e.transform(o);if(e instanceof EllipseCurve){const t=e.transform(a),r=t.isTsWithPlane(P3.ZX);return getIntervals(r,-PI$5,PI$5).filter(([e,s])=>t.at((e+s)/2).y>0).flatMap(([t,e])=>SemiEllipseCurve.fromEllipse(s,t,e))}const r=s.at(.2);return this.normalP(r).cross(t.normal1).dot(s.tangentAt(.2))>0?s:s.reversed()})}edgeLoopCCW(t){const e=this.stPFunc();return isCCW(t.flatMap(t=>t.getVerticesNo0()).map(t=>e(t)),V3.Z)}}ConicSurface.UNIT=new ConicSurface(V3.O,V3.X,V3.Y,V3.Z),ConicSurface.prototype.uStep=PI$5/16,ConicSurface.prototype.vStep=256,ConicSurface.prototype.sMin=0,ConicSurface.prototype.sMax=PI$5,ConicSurface.prototype.tMin=0,ConicSurface.prototype.tMax=16;const{PI:PI$6,cos:cos$4,sin:sin$4,abs:abs$7,sign:sign$3}=Math;class EllipsoidSurface extends ParametricSurface{constructor(t,e,s,r){super(),this.center=t,this.f1=e,this.f2=s,this.f3=r,assertVectors(t,e,s,r),this.matrix=M4.forSys(e,s,r,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$3(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.inverseMatrix)}static unitISTsWithLine(t,e){const s=e.dot(e),r=2*t.dot(e),n=t.dot(t)-1;return pqFormula(r/s,n/s)}static unitISCurvesWithPlane(t){assertInst(P3,t);let e=Math.abs(t.w);if(lt(e,1)){const s=Math.sqrt(1-e*e),r=(t.anchor,t.normal1.getPerpendicular().toLength(s)),n=t.normal1.cross(r);return[new EllipseCurve(t.anchor,r,n)]}return[]}static sphere(t,e){return assertNumbers(t),e&&assertVectors(e),new EllipsoidSurface(e||V3.O,new V3(t,0,0),new V3(0,t,0),new V3(0,0,t))}static forABC(t,e,s,r){return new EllipsoidSurface(r||V3.O,new V3(t,0,0),new V3(0,e,0),new V3(0,0,s))}static calculateAreaSpheroid(t,e,s,r){assertf(()=>t.isPerpendicularTo(e)),assertf(()=>e.isPerpendicularTo(s)),assertf(()=>s.isPerpendicularTo(t));const n=M4.forSys(t,e,s).inversed(),i=t.length(),a=s.unit();return r.map(t=>{if(t.curve instanceof EllipseCurve){const e=glqInSteps(e=>{const s=t.curve.at(e),r=t.tangentAt(e),o=n.transformPoint(s);return o.angleXY()*i*Math.sqrt(1+Math.pow(o.z,2))*Math.sqrt(1+Math.pow(a.dot(r),2))},t.aT,t.bT,1);return console.log("edge",t,e),e}assertNever()}).sum()}like(t){return this.isCoplanarTo(t)&&this.isInsideOut()==t.isInsideOut()}edgeLoopCCW(t){throw new Error}rootPoints(){}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3]}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}isCurvesWithPlane(t){const e=t.transform(this.inverseMatrix);return EllipsoidSurface.unitISCurvesWithPlane(e).map(t=>t.transform(this.matrix))}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface){if(t.dir.isParallelTo(this.dir1)){const e=t.baseCurve.transform(M4.project(this.baseEllipse.getPlane(),this.dir1));return this.baseEllipse.isInfosWithEllipse(e).map(t=>new L3$1(t.p,this.dir1))}eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),assert$1(!1)}else if(t instanceof ProjectedCurveSurface){const e=t.transform(this.inverseMatrix),s=e.baseCurve.project(new P3(e.dir,0)),r=s.isTsWithSurface(EllipsoidSurface.UNIT);return iii(r,EllipsoidSurface.UNIT,s).flatMap(r=>{const n=new L3$1(s.at(r[0]),e.dir),i=EllipsoidSurface.UNIT.isTsForLine(n).map(t=>n.at(t)),a=new L3$1(s.at(r[1]),e.dir),o=EllipsoidSurface.UNIT.isTsForLine(a).map(t=>a.at(t));return[0,1].map(e=>{let s=i[e]||i[0],r=o[e]||o[0];return 0!==e&&([s,r]=[r,s]),assert$1(EllipsoidSurface.UNIT.containsPoint(s)),assert$1(EllipsoidSurface.UNIT.containsPoint(r)),PICurve.forStartEnd(t,this.asEllipsoidSurface(),s,r)})})}}isTsForLine(t){assertInst(L3$1,t);const e=this.inverseMatrix.transformPoint(t.anchor),s=this.inverseMatrix.transformVector(t.dir1);return EllipsoidSurface.unitISTsWithLine(e,s)}isCoplanarTo(t){if(this===t)return!0;if(t.constructor!==EllipsoidSurface)return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&eq(this.f1.length(),this.f2.length());const e=this.inverseMatrix.times(t.matrix);return e.is3x3()&&e.isOrthogonal()}containsEllipse(t){const e=t.transform(this.inverseMatrix),s=e.center.length(),r=Math.sqrt(1-s*s);return lt(s,1)&&e.isCircular()&&e.f1.hasLength(r)}containsCurve(t){return t instanceof EllipseCurve?this.containsEllipse(t):super.containsCurve(t)}transform(t){return new EllipsoidSurface(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new EllipsoidSurface(this.center,this.f1,this.f2,this.f3.negated())}toMesh(t=3){return Mesh.sphere(t).transform(this.matrix)}normalSTFunc(){return(t,e)=>{let{f1:s,f2:r,f3:n}=this;return r.cross(n).times(Math.cos(e)*Math.cos(t)).plus(n.cross(s).times(Math.cos(e)*Math.sin(t))).plus(s.cross(r).times(Math.sin(e))).unit()}}normalP(t){return this.normalMatrix.transformVector(this.inverseMatrix.transformPoint(t)).unit()}normalST(t,e){return this.normalMatrix.transformVector(V3.sphere(t,e))}pST(t,e){return this.matrix.transformPoint(V3.sphere(t,e))}dpds(){return(t,e)=>this.matrix.transformVector(new V3(sin$4(t)*-cos$4(e),cos$4(t)*cos$4(e),0))}dpdt(){return(t,e)=>this.matrix.transformVector(new V3(sin$4(e)*-cos$4(t),-sin$4(t)*sin$4(e),cos$4(e)))}stPFunc(){return(t,e)=>{const s=this.inverseMatrix.transformPoint(t);let r=s.angleXY();abs$7(r)>Math.PI-NLA_PRECISION&&(assert$1(e==-PI$6||e==PI$6),r=e);let n=Math.asin(s.z);return new V3(r,n,0)}}isSphere(){return eq(this.f1.length(),this.f2.length())&&eq(this.f2.length(),this.f3.length())&&eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}implicitFunction(){return t=>{return this.inverseMatrix.transformPoint(t).length()-1}}didp(t){const e=this.inverseMatrix.transformPoint(t);return this.inverseMatrix.transformVector(e.unit())}mainAxes(){const{f1:t,f2:e,f3:s}=this;if(eq0(t.dot(e))&&eq0(e.dot(s))&&eq0(s.dot(t)))return this;const{U:r,SIGMA:n}=this.matrix.svd3();assert$1(n.isDiagonal()),assert$1(r.isOrthogonal());const i=r.times(n),[a,o,c]=arrayFromFunction(3,t=>new V3(i.m[t],i.m[t+4],i.m[t+8]));return new EllipsoidSurface(this.center,a,o,c)}containsPoint(t){return eq0(this.implicitFunction()(t))}boundsFunction(){return(t,e)=>between(e,-PI$6,PI$6)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,e){assertVectors(e);const s=new EllipseCurve(this.center,this.matrix.transformVector(this.inverseMatrix.transformPoint(e).withElement("z",0).unit()),this.f3),r=s.pointT(e),n=s.normal,i=P3.normalOnAnchor(s.normal,e),a=t.map(t=>t.curve.isColinearTo(s));let o=!1;function c(t){const e=s.pointT(t);if(eq(r,e))return!0;r<e&&le(e,PI$6)&&(o=!o)}for(let e=0;e<t.length;e++){const o=t[e],h=(e+1)%t.length,l=t[h];if(a[e]){const t=s.pointT(o.a),e=s.pointT(o.b);if(le(Math.min(t,e),r)&&ge(r,Math.max(t,e)))return PointVsFace.ON_EDGE;if((a[h]||dotCurve(n,l.aDir,l.aDDT)<0)&&c(o.b))return PointVsFace.ON_EDGE}else for(const t of o.edgeISTsWithPlane(i))if(t==o.bT){if(!s.containsPoint(o.b))continue;if(dotCurve(n,o.bDir,o.bDDT)<0!=(a[h]||dotCurve(n,l.aDir,l.aDDT)<0)&&c(o.b))return PointVsFace.ON_EDGE}else if(t!=o.aT){const e=o.curve.at(t);if(!s.containsPoint(e))continue;if(c(e))return PointVsFace.ON_EDGE}}return o?PointVsFace.INSIDE:PointVsFace.OUTSIDE}surfaceAreaApprox(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),n=1.6075;return 4*PI$6*Math.pow((Math.pow(e*s,n)+Math.pow(s*r,n)+Math.pow(r*e,n))/3,1/n)}surfaceArea(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),[n,i,a]=[e,s,r].sort(MINUS);function o(t,e){if(e<t){const s=1-Math.pow(e,2)/Math.pow(t,2),r=Math.sqrt(s);return 2*PI$6*Math.pow(t,2)*(1+(1-s)/Math.sqrt(r)*Math.atanh(r))}{const s=Math.sqrt(1-Math.pow(t,2)/Math.pow(e,2));return 2*PI$6*Math.pow(t,2)*(1+e/t/s*Math.asin(s))}}if(eq(a,i))return o(a,n);if(eq(i,n))return o(i,a);if(eq(n,a))return o(n,i);const c=Math.acos(n/a),h=Math.pow(a,2)*(Math.pow(i,2)-Math.pow(n,2))/(Math.pow(i,2)*(Math.pow(a,2)-Math.pow(n,2))),l=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),-.5),0,c),u=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),.5),0,c);return 2*PI$6*Math.pow(n,2)+2*PI$6*a*i/Math.sin(c)*(u*Math.pow(Math.sin(c),2)+l*Math.pow(Math.cos(c),2))}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.center,this.f1,this.f3)}}EllipsoidSurface.UNIT=new EllipsoidSurface(V3.O,V3.X,V3.Y,V3.Z),EllipsoidSurface.prototype.uStep=PI$6/32,EllipsoidSurface.prototype.vStep=PI$6/32;const{sign:sign$4}=Math;class ProjectedCurveSurface extends ParametricSurface{constructor(t,e,s=t.tMin,r=t.tMax,n=-100,i=100){super(),this.baseCurve=t,this.dir=e,this.sMin=s,this.sMax=r,this.tMin=n,this.tMax=i,assertInst(Curve,t),assertInst(V3,e),assertNumbers(s,r,n,i),assert$1(s<r),assert$1(n<i)}getConstructorParameters(){return[this.baseCurve,this.dir,this.sMin,this.sMax,this.tMin,this.tMax]}equals(t){return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.dir.equals(t.dir)&&this.baseCurve.equals(t.baseCurve)}hashCode(){return[this.dir,this.baseCurve].hashCode()}containsLine(t){return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor)}dpds(){return(t,e)=>this.baseCurve.tangentAt(t)}dpdt(){return(t,e)=>this.dir}normalST(t,e){return this.baseCurve.tangentAt(t).cross(this.dir).unit()}pST(t,e){return this.baseCurve.at(t).plus(this.dir.times(e))}pointFoot(t,e,s){const r=new P3(this.dir,0),n=this.baseCurve.project(r),i=r.projectedPoint(t),a=n.closestTToPoint(i,e),o=t.minus(this.baseCurve.at(a)).dot(this.dir);return new V3(a,o,0)}stPFunc(){const t=new P3(this.dir.unit(),0),e=this.baseCurve.project(t);return s=>{const r=t.projectedPoint(s),n=e.pointT(r),i=L3$1.pointT(this.baseCurve.at(n),this.dir,s);return new V3(n,i,0)}}isCurvesWithPlane(t){if(assertInst(P3,t),this.dir.isPerpendicularTo(t.normal1)){return this.baseCurve.isTsWithPlane(t).map(e=>{const s=0<this.baseCurve.tangentAt(e).dot(t.normal1)?this.dir:this.dir.negated();return new L3$1(this.baseCurve.at(e),s.unit())})}{let e=this.baseCurve.transform(M4.project(t,this.dir));return this.dir.dot(t.normal1)>0&&(e=e.reversed()),[e]}}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof ProjectedCurveSurface){const e=t.dir;if(this.dir.isParallelTo(e)){const s=t.baseCurve;return this.baseCurve.isInfosWithCurve(s).map(s=>{const r=this.normalP(s.p).cross(t.normalP(s.p));return new L3$1(s.p,e.times(sign$4(r.dot(e))))})}if(t instanceof ProjectedCurveSurface){const e=new L3$1(this.baseCurve.at(.5),this.dir),s=e.at(t.isTsForLine(e)[0]);return console.log(s),[new PPCurve(this,t,s)]}}if(t instanceof SemiEllipsoidSurface)return t.isCurvesWithSurface(this);assertNever()}containsPoint(t){const e=this.stPFunc()(t);return this.pSTFunc()(e.x,e.y).like(t)}containsCurve(t){if(t instanceof L3$1)return this.dir.isParallelTo(t.dir1)&&this.containsPoint(t.anchor);if(t instanceof PICurve$1)return super.containsCurve(t);const e=new P3(this.dir.unit(),0),s=this.baseCurve.project(e),r=t.project(e);return s.isColinearTo(r)}isCoplanarTo(t){return this==t||hasConstructor(t,ProjectedCurveSurface)&&this.dir.isParallelTo(t.dir)&&this.containsCurve(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;const e=this.pSTFunc()(0,0),s=this.normalSTFunc()(0,0),r=t.normalP(e);return 0<s.dot(r)}loopContainsPoint(t,e){assertVectors(e),assert$1(isFinite(e.x),e.y,e.z);const s=new L3$1(e,this.dir.unit()),r=this.stPFunc()(e);isNaN(r.x)&&(console.log(this.sce,e.sce),assert$1(!1));const n=this.baseCurve.tangentAt(r.x).rejectedFrom(this.dir);return Surface.loopContainsPointGeneral(t,e,s,n)}edgeLoopCCW(t){if(t.length<56){let e=0;for(let s=0;s<t.length;s++){const r=(s+1)%t.length,n=t[s],i=t[r];e+=n.bDir.angleRelativeNormal(i.aDir,this.normalP(n.b))}return e>0}{const e=this.stPFunc();return isCCW(t.map(t=>e(t.a)),V3.Z)}}transform(t){const e=t.isMirroring()?-1:1;return new this.constructor(this.baseCurve.transform(t),t.transformVector(this.dir).times(e),this.sMin,this.sMax,1==e?this.tMin:-this.tMax,1==e?this.tMax:-this.tMin)}isTsForLine(t){assertInst(L3$1,t);const e=new P3(this.dir.unit(),0),s=e.projectedVector(t.dir1);if(s.likeO())return[];const r=e.projectedPoint(t.anchor);return this.baseCurve.project(e).isInfosWithLine(r,s,this.sMin,this.sMax,t.tMin,t.tMax).map(t=>t.tOther)}flipped(){return new this.constructor(this.baseCurve,this.dir.negated(),this.sMin,this.sMax,-this.tMax,-this.tMin)}}ProjectedCurveSurface.prototype.uStep=.025,ProjectedCurveSurface.prototype.vStep=256;const{PI:PI$7}=Math;class CylinderSurface extends ProjectedCurveSurface{constructor(t,e,s=-1/0,r=1/0){super(t,e,void 0,void 0,s,r),assert$1(2==arguments.length),assertVectors(e),assertInst(EllipseCurve,t),assert$1(e.hasLength(1)),this.matrix=M4.forSys(t.f1,t.f2,e,t.center),this.inverseMatrix=this.matrix.inversed()}static cylinder(t){return new CylinderSurface(new EllipseCurve(V3.O,new V3(t,0,0),new V3(0,t,0)),V3.Z)}static unitISLineTs(t,e){const{x:s,y:r}=t,{x:n,y:i}=e,a=Math.pow(n,2)+Math.pow(i,2),o=2*(s*n+r*i),c=Math.pow(s,2)+Math.pow(r,2)-1;return pqFormula(o/a,c/a)}getConstructorParameters(){return[this.baseCurve,this.dir]}loopContainsPoint(t,e){assertVectors(e);const s=new L3$1(e,this.dir),r=(this.baseCurve.at(PI$7),this.dir.cross(this.normalP(e)));return Surface.loopContainsPointGeneral(t,e,s,r)}isTsForLine(t){assertInst(L3$1,t);const e=this.inverseMatrix.transformVector(t.dir1);if(e.isParallelTo(V3.Z))return[];const s=this.inverseMatrix.transformPoint(t.anchor);return assert$1(!CylinderSurface.unitISLineTs(s,e).length||!isNaN(CylinderSurface.unitISLineTs(s,e)[0]),"sad "+e),CylinderSurface.unitISLineTs(s,e)}isCoplanarTo(t){return this==t||t instanceof CylinderSurface&&this.dir.isParallelTo(t.dir)&&this.containsEllipse(t.baseCurve)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsEllipse(t){const e=t.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(e)}containsCurve(t){return t instanceof EllipseCurve?this.containsEllipse(t):t instanceof L3$1?this.containsLine(t):t instanceof SemiEllipseCurve?this.containsEllipse(t):void assert$1(!1)}normalP(t){const e=this.inverseMatrix.transformPoint(t);return this.normalSTFunc()(e.angleXY(),e.z)}implicitFunction(){return t=>{const e=this.inverseMatrix.transformPoint(t).lengthXY();return Math.sign(this.baseCurve.normal.dot(this.dir))*(1-e)}}containsPoint(t){return eq0(this.implicitFunction()(t))}pointToParameterFunction(){return(t,e)=>{const s=this.inverseMatrix.transformPoint(t);let r=s.angleXY();return abs(r)>Math.PI-NLA_PRECISION&&(assert$1(e==-PI$7||e==PI$7),r=e),new V3(r,s.z,0)}}isCurvesWithSurface(t){if(t instanceof PlaneSurface)return this.isCurvesWithPlane(t.plane);if(t instanceof CylinderSurface){if(t.dir.isParallelTo(this.dir)){const e=t.baseCurve.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithEllipse(e).map(t=>new L3$1(t.p,this.dir))}eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),assert$1(!1)}}getCenterLine(){return new L3$1(this.baseCurve.center,this.dir)}edgeLoopCCW(t){if(t.length<56){let e=0;for(let s=0;s<t.length;s++){const r=(s+1)%t.length,n=t[s],i=t[r];e+=n.bDir.angleRelativeNormal(i.aDir,this.normalP(n.b))}return e>0}{const e=this.stPFunc();return isCCW(t.map(t=>e(t.a)),V3.Z)}}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){return P3.forAnchorAndPlaneVectors(this.baseCurve.center,this.baseCurve.f1,this.dir)}}CylinderSurface.UNIT=new CylinderSurface(EllipseCurve.XY,V3.Z),CylinderSurface.prototype.uStep=TAU/128,CylinderSurface.prototype.vStep=256;const{PI:PI$8,cos:cos$5,sin:sin$5,min:min$6,max:max$5,sign:sign$5,tan:tan$3,ceil:ceil$8,floor:floor$7,abs:abs$8,sqrt:sqrt$3,pow:pow$3,atan2:atan2$3,round:round$3}=Math;class RotationREqFOfZ extends ParametricSurface{constructor(t,e,s,r,n,i=(t=>(e(t+EPS)-e(t))/EPS)){super(),this.matrix=t,this.rt=e,this.tMin=s,this.tMax=r,this.normalDir=n,this.drdz=i,assertInst(M4,t),assert$1(t.isNoProj()),assert$1(1==n||-1==n),this.matrixInverse=t.inversed()}getConstructorParameters(){return[this.matrix,this.rt,this.tMin,this.tMax,this.normalDir,this.drdz]}flipped(){return new RotationREqFOfZ(this.matrix,this.rt,this.tMin,this.tMax,-this.normalDir,this.drdz)}transform(t){return new RotationREqFOfZ(t.times(this.matrix),this.rt,this.tMin,this.tMax,this.normalDir,this.drdz)}containsPoint(t){return eq0(this.implicitFunction()(t))}pSTFunc(){return(t,e)=>{const s=this.rt(e);return this.matrix.transformPoint(V3.polar(s,t,e))}}dpds(){return(t,e)=>{const s=this.rt(e);return this.matrix.transformVector(new V3(s*-sin$5(t),s*cos$5(t),0))}}dpdt(){return(t,e)=>{const s=this.drdz(e);return this.matrix.transformVector(new V3(s*cos$5(t),s*sin$5(t),1))}}normalSTFunc(){const t=this.matrix.inversed().transposed();return(e,s)=>{const r=this.drdz(s);return t.transformVector(V3.polar(1,e,-r)).toLength(this.normalDir)}}implicitFunction(){return t=>{const e=this.matrixInverse.transformPoint(t),s=e.lengthXY();return this.rt(e.z)-s}}stPFunc(){return t=>{const e=this.matrixInverse.transformPoint(t);return new V3(atan2$3(e.y,e.x),e.z,0)}}}Object.assign(RotationREqFOfZ.prototype,ImplicitSurface.prototype),RotationREqFOfZ.prototype.sMin=0,RotationREqFOfZ.prototype.sMax=PI$8;const{PI:PI$9,cos:cos$6,sin:sin$6,min:min$7,max:max$6,tan:tan$4,sign:sign$6,ceil:ceil$9,floor:floor$8,abs:abs$9,sqrt:sqrt$4,pow:pow$4,atan2:atan2$4,round:round$4}=Math;class SemiCylinderSurface extends ProjectedCurveSurface{constructor(t,e,s,r,n=-1/0,i=1/0){super(t,e,s,r,n,i),assertInst(SemiEllipseCurve,t),this.matrix=M4.forSys(t.f1,t.f2,e,t.center),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$6(this.baseCurve.normal.dot(this.dir)),this.normalMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir)}static semicylinder(t){return new SemiCylinderSurface(new SemiEllipseCurve(V3.O,new V3(t,0,0),new V3(0,t,0)),V3.Z,void 0,void 0)}static unitISLineTs(t,e){const{x:s,y:r}=t,{x:n,y:i}=e,a=Math.pow(n,2)+Math.pow(i,2),o=2*(s*n+r*i),c=Math.pow(s,2)+Math.pow(r,2)-1;return pqFormula(o/a,c/a).filter(t=>SemiEllipseCurve.XYLCValid(new V3(s+n*t,r+i*t,0)))}getConstructorParameters(){return[this.baseCurve,this.dir,this.sMin,this.sMax,this.tMin,this.tMax]}normalP(t){return this.normalMatrix.transformVector(this.inverseMatrix.transformPoint(t).xy()).unit()}loopContainsPoint(t,e){if(assertVectors(e),!this.containsPoint(e))return OUTSIDE;const s=new L3$1(e,this.dir.unit()),r=(this.baseCurve.at(PI$9),this.dir.cross(this.normalP(e)));return Surface.loopContainsPointGeneral(t,e,s,r)}isTsForLine(t){assertInst(L3$1,t);const e=this.inverseMatrix.transformVector(t.dir1);if(e.isParallelTo(V3.Z))return[];const s=this.inverseMatrix.transformPoint(t.anchor);return assert$1(!SemiCylinderSurface.unitISLineTs(s,e).length||!isNaN(SemiCylinderSurface.unitISLineTs(s,e)[0]),"sad "+e),SemiCylinderSurface.unitISLineTs(s,e)}isCoplanarTo(t){return this==t||hasConstructor(t,SemiCylinderSurface)&&this.dir.isParallelTo(t.dir)&&this.containsSemiEllipse(t.baseCurve,!1)}like(t){if(!this.isCoplanarTo(t))return!1;return 0<this.baseCurve.normal.dot(this.dir)==0<t.baseCurve.normal.dot(t.dir)}containsSemiEllipse(t,e=!0){const s=t.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve==t||this.baseCurve.isColinearTo(s)&&(!e||le(0,t.transform(this.inverseMatrix).getAABB().min.y))}containsCurve(t){return t instanceof L3$1?this.containsLine(t):t instanceof SemiEllipseCurve?this.containsSemiEllipse(t):!(t instanceof BezierCurve)&&super.containsCurve(t)}implicitFunction(){return t=>{const e=this.inverseMatrix.transformPoint(t).lengthXY();return Math.sign(this.baseCurve.normal.dot(this.dir))*(1-e)}}containsPoint(t){const e=this.inverseMatrix.transformPoint(t);return SemiEllipseCurve.XYLCValid(e)}stP(t){assert$1(1==arguments.length);const e=this.inverseMatrix.transformPoint(t),s=SemiEllipseCurve.XYLCPointT(e);return new V3(s,e.z,0)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof SemiCylinderSurface){if(t.dir.isParallelTo(this.dir)){const e=t.baseCurve.transform(M4.project(this.baseCurve.getPlane(),this.dir));return this.baseCurve.isInfosWithEllipse(e).map(e=>{const s=sign$6(this.normalP(e.p).cross(t.normalP(e.p)).dot(this.dir))||1;return new L3$1(e.p,this.dir.times(s))})}eq0(this.getCenterLine().distanceToLine(t.getCenterLine())),assert$1(!1)}}getCenterLine(){return new L3$1(this.baseCurve.center,this.dir)}facesOutwards(){return this.baseCurve.normal.dot(this.dir)>0}getSeamPlane(){let t=this.baseCurve.f1.cross(this.dir);return t=t.times(-sign$6(t.dot(this.baseCurve.f2))),P3.normalOnAnchor(t,this.baseCurve.center)}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}}SemiCylinderSurface.UNIT=new SemiCylinderSurface(SemiEllipseCurve.UNIT,V3.Z,void 0,void 0,0,1),SemiCylinderSurface.prototype.uStep=TAU/32,SemiCylinderSurface.prototype.vStep=256;const{PI:PI$10,min:min$8,max:max$7,sign:sign$7,abs:abs$10,sqrt:sqrt$5}=Math;class SemiEllipsoidSurface extends EllipsoidSurface{constructor(t,e,s,r){super(t,e,s,r),this.center=t,this.f1=e,this.f2=s,this.f3=r,assertVectors(t,e,s,r),this.matrix=M4.forSys(e,s,r,t),this.inverseMatrix=this.matrix.inversed(),this.normalDir=sign$7(this.f1.cross(this.f2).dot(this.f3)),this.pLCNormalWCMatrix=this.matrix.as3x3().inversed().transposed().scale(this.normalDir),this.pWCNormalWCMatrix=this.pLCNormalWCMatrix.times(this.inverseMatrix)}static unitArea(t){return t.map(t=>{if(t.curve instanceof PICurve$1){const e=t.curve.calcSegmentPoints(t.aT,t.bT,t.a,t.b,t.aT>t.bT,!0);let s=0;for(let t=0;t<e.length-1;t++){const r=e[t],n=e[t+1];s+=(abs$10(r.angleXY())+abs$10(n.angleXY()))/2*(n.z-r.z)}return s}if(t.curve instanceof SemiEllipseCurve){return glqInSteps(e=>{const s=t.curve.at(e),r=t.curve.tangentAt(e);return abs$10(s.angleXY())*r.z},t.aT,t.bT,1)}assertNever()}).sum()}static unitISTsWithLine(t,e){const s=e.dot(e),r=2*t.dot(e),n=t.dot(t)-1;return pqFormula(r/s,n/s).filter(s=>le(0,t.y+s*e.y))}static unitISCurvesWithPlane(t){const e=Math.abs(t.w);if(lt(e,1)){const s=Math.sqrt(1-Math.pow(e,2)),r=t.normal1.y*t.w,n=abs$10(e*s);if(le(r,-n)&&!eq0(e))return[];if(le(r,0)&&!t.normal1.isParallelTo(V3.Y)){let e=t.normal1.isParallelTo(V3.Y)?V3.Z:t.normal1.cross(V3.Y).toLength(s);const n=e.cross(t.normal1),i=-r/n.y,a=max$7(0,Math.asin(i));return[new SemiEllipseCurve(t.anchor,e,n,a,PI$10-a)]}{const e=(t.normal1.isParallelTo(V3.Y)?V3.X:t.normal1.cross(V3.Y)).toLength(s),n=e.cross(t.normal1),i=eq0(n.y)?-1:-r/n.y,a=Math.acos(max$7(-1,i-NLA_PRECISION));return[new SemiEllipseCurve(t.anchor,n.negated(),e,PI$10-a,PI$10),new SemiEllipseCurve(t.anchor,n,e.negated(),0,a)]}}return[]}static unitISCurvesWithEllipsoidSurface(t){if(t.isSphere()){const e=t.f1.length(),s=t.center.length();if(le(1,s-e)||le(s+e,1)||le(s-e,-1))return[];{const r=2*function(t,e,s){const r=(t+e+s)/2;return sqrt$5(r*(r-t)*(r-e)*(r-s))}(1,e,s)/s,n=sign$7(1+Math.pow(s,2)-Math.pow(e,2))*sqrt$5(1-Math.pow(r,2)),i=new P3(t.center.unit(),n);return SemiEllipsoidSurface.unitISCurvesWithPlane(i.flipped())}}assertNever()}static unitISCurvesWithSemiCylinderSurface(t){if(new L3$1(t.baseCurve.center,t.dir).containsPoint(V3.O)){const e=t.baseCurve.transform(M4.project(new P3(t.dir,0))),s=e.f1.length(),r=e.f2.length();if(lt(1,min$8(s,r)))return[];if(e.isCircular()){const r=Math.sqrt(1-Math.pow(min$8(1,s),2)),n=(t.dir.y<0?t.dir.negated():t.dir).times(r);return[new SemiEllipseCurve(n,e.f1,e.f2)]}}assert$1(!1)}static sphere(t,e=V3.O){return assertNumbers(t),new SemiEllipsoidSurface(e,new V3(t,0,0),new V3(0,t,0),new V3(0,0,t))}static forABC(t,e,s,r=V3.O){return new SemiEllipsoidSurface(r,new V3(t,0,0),new V3(0,e,0),new V3(0,0,s))}static calculateAreaSpheroid(t,e,s,r){assertf(()=>t.isPerpendicularTo(e)),assertf(()=>e.isPerpendicularTo(s)),assertf(()=>s.isPerpendicularTo(t));const n=M4.forSys(t,e,s).inversed(),i=t.length(),a=s.unit();return r.map(t=>{if(t.curve instanceof SemiEllipseCurve){return glqInSteps(e=>{const s=t.curve.at(e),r=t.tangentAt(e),o=n.transformPoint(s);return o.angleXY()*i*Math.sqrt(1+Math.pow(o.z,2))*Math.sqrt(1+Math.pow(a.dot(r),2))},t.aT,t.bT,1)}assertNever()}).sum()}equals(t){return this==t||Object.getPrototypeOf(t)==this.constructor.prototype&&this.matrix.equals(t.matrix)}edgeLoopCCW(t){return SemiEllipsoidSurface.unitArea(t.map(t=>t.transform(this.inverseMatrix)))>0}like(t){return!!this.isCoplanarTo(t)&&this.matrix.determinant3()*t.matrix.determinant3()>0}rootPoints(){}toMesh(){return ParametricSurface.prototype.toMesh.call(this)}getConstructorParameters(){return[this.center,this.f1,this.f2,this.f3]}clipCurves(t){return t.flatMap(t=>t.clipPlane(this.getSeamPlane()))}isCurvesWithPCS(t){let e=ParametricSurface.isCurvesParametricImplicitSurface(t,this,.1,.1/t.dir.length(),.05);return e=this.clipCurves(e),e=t.clipCurves(e)}isCurvesWithSurface(t){if(t instanceof PlaneSurface$1)return this.isCurvesWithPlane(t.plane);if(t instanceof SemiCylinderSurface)return this.isCurvesWithSemiCylinderSurface(t);if(t instanceof SemiEllipsoidSurface){const e=t.transform(this.inverseMatrix),s=SemiEllipsoidSurface.unitISCurvesWithEllipsoidSurface(e).map(t=>t.transform(this.matrix));return t.clipCurves(s)}if(t instanceof ProjectedCurveSurface)return this.isCurvesWithPCS(t);if(t instanceof ParametricSurface){let e=ParametricSurface.isCurvesParametricImplicitSurface(t,this,.1,.1,.05);return e=this.clipCurves(e),e=t.clipCurves(e)}assert$1(!1)}isCurvesWithPlane(t){const e=t.transform(this.inverseMatrix);return SemiEllipsoidSurface.unitISCurvesWithPlane(e).map(t=>t.transform(this.matrix))}isCurvesWithSemiCylinderSurface(t){if(L3$1.containsPoint(t.baseCurve.center,t.dir,this.center)){assert$1(this.isSphere());const e=t.baseCurve.transform(M4.project(t.baseCurve.getPlane(),t.dir));if(e.isCircular()){const t=this.f1.length(),s=e.f1.length();eq(t,s),assert$1(!1)}}return this.isCurvesWithPCS(t)}isTsForLine(t){assertInst(L3$1,t);const e=this.inverseMatrix.transformPoint(t.anchor),s=this.inverseMatrix.transformVector(t.dir1);return SemiEllipsoidSurface.unitISTsWithLine(e,s)}isCoplanarTo(t){if(this===t)return!0;if(!hasConstructor(t,SemiEllipsoidSurface))return!1;if(!this.center.like(t.center))return!1;if(this.isSphere())return t.isSphere()&&eq(this.f1.length(),this.f2.length());const e=this.inverseMatrix.times(t.matrix);return e.is3x3()&&e.isOrthogonal()}containsEllipse(t){const e=t.transform(this.inverseMatrix),s=e.center.length(),r=Math.sqrt(1-Math.pow(s,2));return lt(s,1)&&e.isCircular()&&e.f1.hasLength(r)}containsCurve(t){return t instanceof SemiEllipseCurve?this.containsEllipse(t):super.containsCurve(t)}transform(t){return new SemiEllipsoidSurface(t.transformPoint(this.center),t.transformVector(this.f1),t.transformVector(this.f2),t.transformVector(this.f3).times(t.isMirroring()?-1:1))}isInsideOut(){return this.f1.cross(this.f2).dot(this.f3)<0}flipped(){return new SemiEllipsoidSurface(this.center,this.f1,this.f2,this.f3.negated())}normalSTFunc(){return(t,e)=>{const{f1:s,f2:r,f3:n}=this;return r.cross(n).times(Math.cos(e)*Math.cos(t)).plus(n.cross(s).times(Math.cos(e)*Math.sin(t))).plus(s.cross(r).times(Math.sin(e))).unit()}}normalP(t){return this.pLCNormalWCMatrix.transformVector(this.inverseMatrix.transformPoint(t)).unit()}normalST(t,e){return this.pLCNormalWCMatrix.transformVector(V3.sphere(t,e)).unit()}stPFunc(){return t=>{const e=this.inverseMatrix.transformPoint(t),s=abs$10(e.angleXY()),r=Math.asin(clamp(e.z,-1,1));return assert$1(isFinite(s)),assert$1(isFinite(r)),new V3(s,r,0)}}pSTFunc(){return(t,e)=>this.matrix.transformPoint(V3.sphere(t,e))}isSphere(){return eq(this.f1.length(),this.f2.length())&&eq(this.f2.length(),this.f3.length())&&eq(this.f3.length(),this.f1.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}isVerticalSpheroid(){return eq(this.f1.length(),this.f2.length())&&this.f1.isPerpendicularTo(this.f2)&&this.f2.isPerpendicularTo(this.f3)&&this.f3.isPerpendicularTo(this.f1)}mainAxes(){const{f1:t,f2:e,f3:s}=this;if(eq0(t.dot(e))&&eq0(e.dot(s))&&eq0(s.dot(t)))return this;const{U:r,SIGMA:n}=this.matrix.svd3();assert$1(n.isDiagonal()),assert$1(r.isOrthogonal());const i=r.times(n),[a,o,c]=arrayFromFunction(3,t=>new V3(i.m[t],i.m[t+4],i.m[t+8]));return new SemiEllipsoidSurface(this.center,a,o,c)}containsPoint(t){return eq0(this.implicitFunction()(t))}boundsFunction(){return(t,e)=>between(t,0,PI$10)&&between(e,-PI$10,PI$10)}volume(){return 4/3*Math.PI*this.f1.dot(this.f2.cross(this.f3))}loopContainsPoint(t,e){if(!this.containsPoint(e))return PointVsFace.OUTSIDE;assertVectors(e);const s=this.inverseMatrix.transformPoint(e).withElement("z",0),r=new SemiEllipseCurve(this.center,this.f3,s.likeO()?this.f2:this.matrix.transformVector(s.unit())),n=r.pointT(e);if(P3.normalOnAnchor(this.f2.unit(),this.center).containsPoint(e)){let s;return t.some(t=>t.curve.containsPoint(e)&&le(t.minT,s=t.curve.pointT(e))&&le(s,t.maxT))?PointVsFace.ON_EDGE:PointVsFace.OUTSIDE}const i=r.normal,a=P3.normalOnAnchor(r.normal,e),o=t.map(t=>r.isColinearTo(t.curve));let c=!1;function h(t){const e=r.pointT(t);if(eq(n,e))return!0;n<e&&le(e,PI$10)&&(c=!c)}for(let s=0;s<t.length;s++){const n=t[s],c=(s+1)%t.length,l=t[c];if(o[s]){let t;if(n.curve.containsPoint(e)&&le(n.minT,t=n.curve.pointT(e))&&le(t,n.maxT))return PointVsFace.ON_EDGE;if(!(o[c]||dotCurve(i,l.aDir,l.aDDT)<0)&&r.containsPoint(n.b)&&h(n.b))return PointVsFace.ON_EDGE}else for(const t of n.edgeISTsWithPlane(a))if(t==n.bT){if(!r.containsPoint(n.b))continue;if(dotCurve2(n.curve,n.bT,i,-sign$7(n.deltaT()))<0!=(o[c]||dotCurve(i,l.aDir,l.aDDT)<0)&&h(n.b))return PointVsFace.ON_EDGE}else if(t!=n.aT){const e=n.curve.at(t);if(!r.containsPoint(e))continue;if(h(e))return PointVsFace.ON_EDGE}}return c?PointVsFace.INSIDE:PointVsFace.OUTSIDE}zDirVolumeForLoop2(t){const e=this.inverseMatrix.getZ().toAngles(),s=M4.rotateY(-e.theta).times(M4.rotateZ(-e.phi)).times(this.inverseMatrix),r=M4.rotateX(PI$10/2);let n=0;return assert$1(V3.X.isParallelTo(s.transformVector(V3.Z))),t.map(t=>t.transform(s)).forEach((t,e,s)=>{const i=s[(e+1)%s.length];if(t.b.like(V3.X)){const e=(t.bDir.angleRelativeNormal(i.aDir,V3.X)+2*PI$10)%(2*PI$10);n+=2/3*e}if(t.b.like(V3.X.negated())){const e=(t.bDir.angleRelativeNormal(i.aDir,V3.X)+2*PI$10)%(2*PI$10);n+=2/3*e}const a=gaussLegendreQuadrature24(function(e){const s=t.curve.at(e).withElement("x",0);return 1/3*(1-(Math.pow(s.y,2)+Math.pow(s.z,2)))*t.tangentAt(e).dot(r.transformVector(s.unit()))},t.aT,t.bT);n+=a}),n*this.f1.dot(this.f2.cross(this.f3))}surfaceAreaApprox(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),n=1.6075;return 4*PI$10*Math.pow((Math.pow(e*s,n)+Math.pow(s*r,n)+Math.pow(r*e,n))/3,1/n)}surfaceArea(){const t=this.mainAxes(),e=t.f1.length(),s=t.f2.length(),r=t.f3.length(),[n,i,a]=[e,s,r].sort(MINUS);function o(t,e){if(e<t){const s=1-Math.pow(e,2)/Math.pow(t,2),r=Math.sqrt(s);return 2*PI$10*Math.pow(t,2)*(1+(1-s)/Math.sqrt(r)*Math.atanh(r))}{const s=Math.sqrt(1-Math.pow(t,2)/Math.pow(e,2));return 2*PI$10*Math.pow(t,2)*(1+e/t/s*Math.asin(s))}}if(eq(a,i))return o(a,n);if(eq(i,n))return o(i,a);if(eq(n,a))return o(n,i);const c=Math.acos(n/a),h=Math.pow(a,2)*(Math.pow(i,2)-Math.pow(n,2))/(Math.pow(i,2)*(Math.pow(a,2)-Math.pow(n,2))),l=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),-.5),0,c),u=gaussLegendreQuadrature24(t=>Math.pow(1-h*Math.pow(Math.sin(t),2),.5),0,c);return 2*PI$10*Math.pow(n,2)+2*PI$10*a*i/Math.sin(c)*(u*Math.pow(Math.sin(c),2)+l*Math.pow(Math.cos(c),2))}getSeamPlane(){const t=P3.forAnchorAndPlaneVectors(this.center,this.f1,this.f3);return t.normal1.dot(this.f2)<0?t:t.flipped()}asEllipsoidSurface(){return new EllipsoidSurface(this.center,this.f1,this.f2,this.f3)}getExtremePoints(){assert$1(this.isSphere());const t=this.f1.length();return[V3.X,V3.X.negated(),V3.Y,V3.Y.negated(),V3.Z,V3.Z.negated()].filter(t=>lt(0,t.dot(this.f2))).map(e=>e.times(t).plus(this.center))}}SemiEllipsoidSurface.UNIT=new SemiEllipsoidSurface(V3.O,V3.X,V3.Y,V3.Z),SemiEllipsoidSurface.prototype.uStep=PI$10/16,SemiEllipsoidSurface.prototype.vStep=PI$10/16,SemiEllipsoidSurface.prototype.sMin=0,SemiEllipsoidSurface.prototype.sMax=PI$10,SemiEllipsoidSurface.prototype.tMin=-PI$10/2,SemiEllipsoidSurface.prototype.tMax=PI$10/2;class PlaneSurface$1 extends ParametricSurface{constructor(t,e=t.normal1.getPerpendicular().unit(),s=t.normal1.cross(e).unit(),r=-100,n=100,i=-100,a=100){super(),this.plane=t,this.right=e,this.up=s,this.sMin=r,this.sMax=n,this.tMin=i,this.tMax=a,assertInst(P3,t),assert$1(this.right.cross(this.up).like(this.plane.normal1)),this.matrix=M4.forSys(e,s,t.normal1,t.anchor)}toSource(t=(t=>t)){return callsce.call(void 0,"new PlaneSurface",...this.getConstructorParameters())}static throughPoints(t,e,s){return new PlaneSurface$1(P3.throughPoints(t,e,s))}isCoplanarTo(t){return t instanceof PlaneSurface$1&&this.plane.isCoplanarToPlane(t.plane)}isTsForLine(t){return t.isTsWithPlane(this.plane)}like(t){return t instanceof PlaneSurface$1&&this.plane.like(t.plane)}pST(t,e){return this.matrix.transformPoint(new V3(t,e,0))}implicitFunction(){return t=>this.plane.distanceToPointSigned(t)}isCurvesWithSurface(t){return t instanceof PlaneSurface$1?this.isCurvesWithPlane(t.plane):super.isCurvesWithSurface(t)}isCurvesWithPlane(t){return this.plane.isParallelToPlane(t)?[]:[this.plane.intersectionWithPlane(t)]}edgeLoopCCW(t){return isCCW(t.flatMap(t=>t.points()),this.plane.normal1)}loopContainsPoint(t,e){const s=this.right.plus(this.up.times(.123)).unit(),r=new L3$1(e,s),n=s.cross(this.plane.normal1);return Surface.loopContainsPointGeneral(t,e,r,n)}stPFunc(){const t=this.matrix.inversed();return function(e){return t.transformPoint(e)}}pointFoot(t){return this.stP(t)}normalP(t){return this.plane.normal1}containsPoint(t){return this.plane.containsPoint(t)}containsCurve(t){return this.plane.containsCurve(t)}transform(t){return new PlaneSurface$1(this.plane.transform(t))}flipped(){return new PlaneSurface$1(this.plane.flipped(),this.right,this.up.negated())}getConstructorParameters(){return[this.plane,this.right,this.up]}toMesh(t=-10,e=10,s=-10,r=10){const n=(new Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal"),i=M4.forSys(this.right,this.up,this.plane.normal1,this.plane.anchor);return n.vertices=[V(t,s),V(e,s),V(t,r),V(e,r)].map(t=>i.transformPoint(t)),n.normals=arrayFromFunction(4,t=>this.plane.normal1),pushQuad(n.TRIANGLES,!1,0,1,2,3),n.compile(),n}dpds(){return()=>this.right}dpdt(){return()=>this.up}equals(t){}didp(t){return this.plane.normal1}}const{PI:PI$11}=Math,ZDirVolumeVisitor={[ConicSurface.name](t){return{volume:t.map(t=>{if(t.curve instanceof SemiEllipseCurve||t.curve instanceof HyperbolaCurve||t.curve instanceof ParabolaCurve){const e=e=>{const s=t.curve.at(e),r=t.tangentAt(e);return(s.z+s.rejectedFrom(this.dir).z)/2*s.projectedOn(this.dir).lengthXY()*r.dot(V3.Z.cross(this.dir).unit())},s=t.curve instanceof SemiEllipseCurve?-Math.sign(t.curve.normal.dot(this.dir)):-Math.sign(this.center.to(t.curve.center).cross(t.curve.f1).dot(this.dir));return glqInSteps(e,t.aT,t.bT,1)*s}if(t.curve instanceof L3)return 0;assertNever()}).sum()*Math.sign(this.normal.dot(this.dir))}},[PlaneSurface$1.name](){const{centroid:t,area:e}=this.calculateArea();return{volume:this.surface.plane.normal1.z*t.z*e,centroid:new V3(t.x,t.y,t.z/2)}},[SemiCylinderSurface.name](t){if(V3.Z.cross(this.dir).likeO())return{volume:0};const e=this.dir.cross(V3.Z).unit(),s=this.dir.rejectedFrom(V3.Z).unit();return{volume:edges.map(t=>{if(t.curve instanceof SemiEllipseCurve){const r=r=>{const n=t.curve.at(r),i=t.curve.tangentAt(r);return(n.z+n.rejectedFrom(this.dir).z)/2*n.projectedOn(this.dir).dot(s)*i.dot(e)},n=-Math.sign(t.curve.normal.dot(this.dir));return glqInSteps(r,t.aT,t.bT,1)*n}if(t.curve instanceof L3)return 0;assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},[CylinderSurface.name](t){if(V3.Z.cross(this.dir).likeO())return{volume:0};const e=this.dir.cross(V3.Z).unit(),s=this.dir.rejectedFrom(V3.Z).unit();return console.log("scalingVector",e.sce),{volume:t.map(t=>{if(t.curve instanceof EllipseCurve){const r=r=>{const n=t.curve.at(r),i=t.curve.tangentAt(r);return(n.z+n.rejectedFrom(this.dir).z)/2*n.projectedOn(this.dir).dot(s)*i.dot(e)},n=-Math.sign(t.curve.normal.dot(this.dir)),i=glqInSteps(r,t.aT,t.bT,1);return console.log("edge",t,i,n),i*n}if(t.curve instanceof L3)return 0;assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},[EllipsoidSurface.name](t){const e=this.inverseMatrix.transformVector(V3.Z).toAngles(),s=M4.rotateAB(this.inverseMatrix.transformVector(V3.Z),V3.Z).times(M4.rotateZ(-e.phi)).times(this.inverseMatrix);function r(t){let e=0;return assert(V3.Z.isParallelTo(s.transformVector(V3.Z))),t.map(t=>t.transform(s)).forEach((t,s,r)=>{r[(s+1)%r.length];const n=gaussLegendreQuadrature24(function(e){const s=t.curve.at(e),r=t.curve.tangentAt(e),n=s.lengthXY(),i=s.withElement("z",0);return((s.angleXY()+TAU-NLA_PRECISION)%TAU+NLA_PRECISION)*Math.sqrt(1-n*n)*n*Math.abs(r.dot(i.unit()))*Math.sign(r.z)},t.aT,t.bT);console.log("edge",t,"volume",n),e+=n}),e}const[n,i]=EllipsoidSurface.splitOnPlaneLoop(t.map(t=>t.transform(s)),ccw);return{area:(r(n)+r(i))*this.f1.dot(this.f2.cross(this.f3)),centroid:void 0}},zDirVolumeForLoop2(t){const e=this.inverseMatrix.getZ().toAngles(),s=M4.rotateY(-e.theta).times(M4.rotateZ(-e.phi)).times(this.inverseMatrix),r=M4.rotateX(PI$11/2);let n=0;return assert(V3.X.isParallelTo(s.transformVector(V3.Z))),t.map(t=>t.transform(s)).forEach((t,e,s)=>{const i=s[(e+1)%s.length];if(t.b.like(V3.X)){const e=(t.bDir.angleRelativeNormal(i.aDir,V3.X)+2*PI$11)%(2*PI$11);n+=2/3*e,console.log("xaa")}if(t.b.like(V3.X.negated())){const e=(t.bDir.angleRelativeNormal(i.aDir,V3.X)+2*PI$11)%(2*PI$11);n+=2/3*e,console.log("xbb")}const a=gaussLegendreQuadrature24(function(e){const s=t.curve.at(e).withElement("x",0),n=1/3*(1-(Math.pow(s.y,2)+Math.pow(s.z,2)))*t.tangentAt(e).dot(r.transformVector(s.unit()));return console.log("at2d",s.sce,"result",n),n},t.aT,t.bT);console.log("edge",t,"volume",a),n+=a}),n*this.f1.dot(this.f2.cross(this.f3))},[SemiEllipsoidSurface.name](t){const e=this.inverseMatrix.transformVector(V3.Z).toAngles(),s=M4.rotateAB(this.inverseMatrix.transformVector(V3.Z),V3.Z).times(M4.rotateZ(-e.phi)).times(this.inverseMatrix);function r(t){let e=0;return assert(V3.Z.isParallelTo(s.transformVector(V3.Z))),t.map(t=>t.transform(s)).forEach((t,s,r)=>{r[(s+1)%r.length];const n=gaussLegendreQuadrature24(function(e){const s=t.curve.at(e),r=t.curve.tangentAt(e),n=s.lengthXY(),i=s.withElement("z",0);return((s.angleXY()+TAU-NLA_PRECISION)%TAU+NLA_PRECISION)*Math.sqrt(1-n*n)*n*Math.abs(r.dot(i.unit()))*Math.sign(r.z)},t.aT,t.bT);e+=n}),e}const[n,i]=SemiEllipsoidSurface.splitOnPlaneLoop(t.map(t=>t.transform(s)),ccw);return{volume:(r(n)+r(i))*this.f1.dot(this.f2.cross(this.f3)),centroid:void 0}}},{PI:PI$12}=Math,CalculateAreaVisitor={[ConicSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve||t.curve instanceof HyperbolaCurve||t.curve instanceof ParabolaCurve){const e=e=>{const s=t.curve.at(e),r=t.tangentAt(e);return s.minus(this.center).cross(r.rejectedFrom(this.dir)).length()/2},s=t.curve instanceof SemiEllipseCurve?-Math.sign(t.curve.normal.dot(this.dir)):-Math.sign(this.center.to(t.curve.center).cross(t.curve.f1).dot(this.dir));return glqInSteps(e,t.aT,t.bT,4)*s}if(t.curve instanceof L3$1)return 0;assertNever()}).sum()*Math.sign(this.normal.dot(this.dir))},[PlaneSurface$1.name](t){let e=V3.O,s=0,r=0,n=0,i=this.surface.right,a=this.surface.up;for(const o of t){let t,c,h,l;if(o instanceof StraightEdge){const s=o.a.lerp(o.b,.5);t=new V3(s.x,e.y,e.z/2),h=s.dot(i)/2,l=s.dot(a),c=o.a.distanceTo(o.b)*o.curve.dir1.dot(i),c=(o.a.dot(a)+o.b.dot(a))/2*o.b.to(o.a).dot(i)}else{let t=o.curve;if(t instanceof SemiEllipseCurve){let e=t.getAreaInDir(i,a,o.aT,o.bT);c=e.area;let s=this.surface.stPFunc()(e.centroid);h=s.x,l=s.y}else t instanceof BezierCurve?c=t.getAreaInDirSurface(a,this.surface,o.aT,o.bT).area:assertNever()}s+=c*h,r+=c*l,n+=c}return e=i.times(s).plus(a.times(r)),assert$1(isFinite(n)),{area:n,centroid:e}},[CylinderSurface.name](t){return t.map(t=>{if(t.curve instanceof EllipseCurve){const e=e=>{const s=t.curve.at(e),r=t.tangentAt(e);return s.dot(this.dir)*r.rejected1Length(this.dir)},s=-Math.sign(t.curve.normal.dot(this.dir)),r=glqInSteps(e,t.aT,t.bT,4);return console.log("edge",t,r),r*s}if(t.curve instanceof L3$1)return 0;assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))},[EllipsoidSurface.name](t,e=!0){assert$1(this.isVerticalSpheroid());const{f1:s,f2:r,f3:n}=this,i=s.length(),a=n.unit();return t.map(t=>{if(t.curve instanceof EllipseCurve){const e=glqInSteps(e=>{const s=t.curve.at(e),r=t.curve.tangentAt(e),n=this.inverseMatrix.transformPoint(s);let o=n.angleXY();eq(Math.abs(o),PI$12)&&(o=t.curve.normal.isParallelTo(this.f2)?PI$12*-Math.sign((t.bT-t.aT)*t.curve.normal.dot(this.f2)):PI$12*dotCurve(this.f2,r,t.curve.ddt(e)),console.log(o));const c=o*i*Math.sqrt(1-Math.pow(n.z,2)),h=this.matrix.transformVector(new V3(-n.z*n.x/n.lengthXY(),-n.z*n.y/n.lengthXY(),n.lengthXY())).unit();r.dot(a);return c*h.dot(r)},t.aT,t.bT,1);return console.log("edge",t,e),e}assertNever()}).sum()*Math.sign(this.f1.cross(this.f2).dot(this.f3))},[SemiCylinderSurface.name](t,e=!0){assert$1(this.isVerticalSpheroid());const{f1:s,f2:r,f3:n}=this,i=s.length(),a=n.unit();return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){return glqInSteps(e=>{const s=t.curve.at(e),r=t.curve.tangentAt(e),n=this.inverseMatrix.transformPoint(s);let o=n.angleXY();eq(Math.abs(o),PI$12)&&(o=t.curve.normal.isParallelTo(this.f2)?PI$12*-Math.sign((t.bT-t.aT)*t.curve.normal.dot(this.f2)):PI$12*dotCurve(this.f2,r,t.curve.ddt(e)));const c=o*i*Math.sqrt(1-Math.pow(n.z,2)),h=this.matrix.transformVector(new V3(-n.z*n.x/n.lengthXY(),-n.z*n.y/n.lengthXY(),n.lengthXY())).unit();r.dot(a);return c*h.dot(r)},t.aT,t.bT,1)}assertNever()}).sum()*Math.sign(this.f1.cross(this.f2).dot(this.f3))},[ProjectedCurveSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){const e=e=>{const s=t.curve.at(e),r=t.tangentAt(e);return s.dot(this.dir)*r.rejected1Length(this.dir)},s=-Math.sign(t.curve.normal.dot(this.dir));return glqInSteps(e,t.aT,t.bT,4)*s}if(t.curve instanceof L3$1)return 0;assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))},[SemiCylinderSurface.name](t){return t.map(t=>{if(t.curve instanceof SemiEllipseCurve){const e=e=>{const s=t.curve.at(e),r=t.tangentAt(e);return s.dot(this.dir)*r.rejected1Length(this.dir)},s=-Math.sign(t.curve.normal.dot(this.dir));return glqInSteps(e,t.aT,t.bT,4)*s}if(t.curve instanceof L3$1)return 0;assertNever()}).sum()*Math.sign(this.baseCurve.normal.dot(this.dir))}},{PI:PI$13,min:min$9,max:max$8,ceil:ceil$10}=Math;function projectCurve(t,e,s){if(t instanceof L3$1){const r=e.cross(t.dir1).toLength(s?-1:1);return new PlaneSurface$1(P3.normalOnAnchor(r,t.anchor))}if(t instanceof SemiEllipseCurve){const r=s?e:e.negated();return new SemiCylinderSurface(t,r.unit(),void 0,void 0)}if(t instanceof BezierCurve||t instanceof XiEtaCurve){const r=e.times(s?1:-1);return new ProjectedCurveSurface(t,r,0,1,s?0:-1,s?1:0)}throw new Error}var B2T;!function(t){function e(e,s=P3.XY,r=V3.Z,n="extrude"+getGlobalId(),i,a){e=h(e),assertf(()=>Edge.isLoop(e));const o=new Map,c=new PlaneSurface$1(s),l=M4.translate(r),u=e.map(t=>t.transform(l,"top")),f=e.length,d=a&&a.extrudeBottom(c,e),p=new PlaneFace(c,e,[],n+"Bottom",d),m=u.map(t=>t.flipped()).reverse(),g=new PlaneSurface$1(s.flipped().translated(r)),P=a&&a.extrudeBottom(g,m),v=new PlaneFace(g,m,[],n+"Top",P);e.forEach(e=>t.registerVertexName(o,e.name+"A",e.a)),m.forEach(e=>t.registerVertexName(o,e.name+"A",e.a));const C=arrayFromFunction(f,t=>StraightEdge.throughPoints(e[t].a,u[t].a,n+"Rib"+t)),S=e.map((t,s)=>{const i=n+"Wall"+s,o=(s+1)%f,c=[e[s].flipped(),C[s],u[s],C[o].flipped()],h=projectCurve(t.curve,r,t.reversed),l=a&&a.extrudeWall(s,h,c);return Face.create(h,c,void 0,i,l)});return S.push(p,v),i=i||callsce("B2T.extrudeEdges",e,s,r,n),new B2(S,s.normal1.dot(r)>0,i,o)}function s(t=1,e="sphere"+getGlobalId(),s=TAU){const r=PCurveEdge.create(new SemiEllipseCurve(V3.O,new V3(0,0,-t),new V3(t,0,0)),new V3(0,0,-t),new V3(0,0,t),0,PI$13,void 0,new V3(t,0,0),new V3(-t,0,0)),i=callsce("B2T.sphere",t,e,s);return n([StraightEdge.throughPoints(r.b,r.a),r],s,e,i)}function n(t,e,s,r,n){assert$1(!eq(PI$13,e)||PI$13==e),assertf(()=>lt(0,e)&&le(e,TAU)),e=snap(e,TAU);const i=new PlaneSurface$1(P3.ZX.flipped()).edgeLoopCCW(t)?new PlaneSurface$1(P3.ZX.flipped()):new PlaneSurface$1(P3.ZX);assertf(()=>Edge.isLoop(t));ceil$10((e-NLA_PRECISION)/PI$13);const a=!eq(e,2*PI$13),o=t.map(t=>{const e=t.a,s=e.lengthXY();if(!eq0(s))return new SemiEllipseCurve(V(0,0,e.z),V(s,0,0),V(0,s,0))}),c=t.map((e,s)=>{const r=(s+1)%t.length;if(e instanceof StraightEdge){const t=e.curve;if(t.dir1.isParallelTo(V3.Z)){if(eq0(e.a.x))return;const t=e.a.z>e.b.z,[r,n]=[0,e.b.z-e.a.z].sort(MINUS);return new SemiCylinderSurface(o[s],t?V3.Z.negated():V3.Z,void 0,void 0,r,n)}if(t.dir1.isPerpendicularTo(V3.Z)){const t=e.a.x>e.b.x;let s=new PlaneSurface$1(new P3(V3.Z,e.a.z));return t||(s=s.flipped()),s}{const t=e.a,n=e.b,i=t.z-t.x*(n.z-t.z)/(n.x-t.x),a=new V3(0,0,i),c=e.a.z>e.b.z,h=o[t.x>n.x?s:r],l=ConicSurface.atApexThroughEllipse(a,h);return c!=(-1==l.normalDir)?l.flipped():l}}if(e.curve instanceof SemiEllipseCurve){const t=e.a.z>e.b.z,s=e.curve.rightAngled();assert$1(s.normal.isPerpendicularTo(V3.Z)),assert$1(L3$1.Z.containsPoint(s.center));let r=s.f1.length(),n=s.f2.length();return s.isCircular()||(assert$1(s.f1.isParallelTo(V3.Z)&&s.f2.isParallelTo(V3.X)||s.f2.isParallelTo(V3.Z)&&s.f1.isParallelTo(V3.X)),s.f1.isParallelTo(V3.Z)&&([r,n]=[n,r])),SemiEllipsoidSurface.forABC(r,(t?-1:1)*r,n,s.center)}assert$1(!1,e)});let h,l=t;const u=[];for(let r=0;r<e;r+=PI$13){const i=0,a=min$9(e-r,PI$13),f=M4.rotateZ(r+a);M4.rotateZ(r);h=r+a==TAU?t:t.map(t=>t.transform(f));const d=arrayFromFunction(t.length,t=>{const e=l[t].a,n=e.lengthXY(),c=h[t].a;if(!eq0(n)){const n=0==r?o[t]:o[t].rotateZ(r);return new PCurveEdge(n,e,c,i,a,void 0,n.tangentAt(i),n.tangentAt(a),s+"rib"+t)}});for(let e=0;e<t.length;e++)if(c[e]){const i=l[e],a=(e+1)%t.length,o=[l[e].flipped(),!eq0(i.a.x)&&d[e],h[e],!eq0(i.b.x)&&d[a].flipped()].filter(t=>t),f=0==r?c[e]:c[e].rotateZ(r),p=n&&n.extrudeWall(e,f,o,void 0);u.push(Face.create(f,o,void 0,s+"Wall"+e,p))}l=h}if(a){const r=Edge.reversePath(h),a=n&&n.rotationStart(i,t,void 0),o=n&&n.rotationEnd(i.flipped().rotateZ(e),r,void 0);u.push(new PlaneFace(i,t,void 0,s+"start",a),new PlaneFace(i.flipped().rotateZ(e),r,void 0,s+"end",o))}const f=new PlaneSurface$1(P3.ZX).edgeLoopCCW(t);return new B2(u,f,r)}t.box=function(e=1,s=1,r=1,n){assertNumbers(e,s,r),assertInst("string"==typeof n);const i=[new V3(0,0,0),new V3(0,s,0),new V3(e,s,0),new V3(e,0,0)],a=callsce("B2T.box",e,s,r,n);return t.extrudeVertices(i,P3.XY.flipped(),new V3(0,0,r),n,a)},t.puckman=function(e,s,r,n){assertf(()=>lt(0,e)),assertf(()=>lt(0,s)&&le(s,TAU)),assertf(()=>lt(0,r));const i=StraightEdge.chain([V3.O,new V3(e,0,0),new V3(e,0,r),new V3(0,0,r)],!0);return t.rotateEdges(i,s,n||"puckman"+getGlobalId())},t.registerVertexName=function(t,e,s){Array.from(t.keys()).some(t=>t.like(s))||t.set(s,e)},t.extrudeEdges=e,t.cylinder=function(t=1,e=1,s=TAU,r="cylinder"+getGlobalId()){const i=[new V3(0,0,0),new V3(t,0,0),new V3(t,0,e),new V3(0,0,e)];return n(StraightEdge.chain(i,!0),s,r)},t.cone=function(t=1,e=1,s=TAU,r="cone"+getGlobalId()){const i=[new V3(0,0,0),new V3(t,0,e),new V3(0,0,e)];return n(StraightEdge.chain(i,!0),s,r)},t.sphere=s,t.menger=function(e=2,s="menger"+getGlobalId()){let r=t.box(1,1,1);if(0==e)return r;const n=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped();function i(t,e){if(r=r.and(n.transform(e)),a=r,t>1){const s=e.times(M4.scale(1/3,1/3,1));for(let e=0;e<9;e++)4!=e&&i(t-1,s.times(M4.translate(e%3,e/3|0,0)))}}return i(e,M4.IDENTITY),i(e,M4.YZX),i(e,M4.ZXY),r},t.menger2=function(e=2,s="menger"+getGlobalId()){if(0==e)return t.box(1,1,1);const r=t.box(1/3,1/3,2).translate(1/3,1/3,-.5).flipped(),n=[];!function t(e,s){if(n.push(...r.transform(s).faces),e>1){const r=s.times(M4.scale(1/3,1/3,1));for(let s=0;s<9;s++)4!=s&&t(e-1,r.times(M4.translate(s%3,s/3|0,0)))}}(e,M4.IDENTITY);const i=new B2(n,!0);return t.box().and(i).and(i.transform(M4.YZX)).and(i.transform(M4.ZXY))},t.torus=function(e,s,r,n){assertNumbers(e,s,r),assertf(()=>s>e);const i=SemiEllipseCurve.semicircle(e,new V3(s,0,0)),a=[PCurveEdge.forCurveAndTs(i,-Math.PI,0),PCurveEdge.forCurveAndTs(i,0,Math.PI)];return t.rotateEdges(a,r,n||"torus"+getGlobalId())},t.torusUnsplit=function(e,s,r,n){assertNumbers(e,s,r),assertf(()=>s>e);const i=PCurveEdge.forCurveAndTs(SemiEllipseCurve.semicircle(e,new V3(s,0,0)),-Math.PI,Math.PI);return t.rotateEdges([i],r,n||"torus"+getGlobalId())},t.rotateEdges=n,t.quaffle=function(){const e=t.sphere(1).translate(0,1.7).flipped(),s=new B2(t.TETRAHEDRON_VERTICES.flatMap(t=>e.rotateAB(V3.Y,t).faces),!1);return t.sphere().and(s)},t.extrudeFace=function(t,s){return new B2(e(t.contour,t.surface.plane,s).faces.slice(0,-2).concat(t,t.translate(s.x,s.y,s.z).flipped(),t.holes.flatMap(r=>e(r,t.surface.plane.flipped(),s).faces.slice(0,-2))),!1)},t.loadFonts=function(){return o("fonts/FiraSansMedium.woff").then(e=>t.defaultFont=e)};const i=new Map;function o(t){return new Promise(function(e,s){const r=i.get(t);r?e(r):load(t,function(r,n){r?s(r):(i.set(t,n),e(n))})})}function c(e,s,r=1,n=t.defaultFont){const i=[];n.getPath(e,0,0,s).commands.forEach(t=>{"M"==t.type&&i.push([]),i.last.push(t)});const a=i.map(t=>{const e=new Path;e.commands=t;const s=Edge.reversePath(Edge.pathFromSVG(e.toPathData(13))).map(t=>t.mirrorY());return assert$1(Edge.isLoop(s)),s}),o=Face.assembleFacesFromLoops(a,new PlaneSurface$1(P3.XY),PlaneFace),c=`B2T.text(${e.sce}, ${s}, ${r})`;return B2.join(o.map(e=>t.extrudeFace(e,V(0,0,-r))),c)}function h(t){return t.flatMap(t=>{const e=t.curve;if(e instanceof EllipseCurve){return(t.minT<0&&t.maxT>0?t.split(0):[t]).map(t=>t.minT>=0?Edge.create(new SemiEllipseCurve(e.center,e.f1,e.f2,max$8(0,e.tMin),e.tMax),t.a,t.b,t.aT,t.bT,void 0,t.aDir,t.bDir,t.name):Edge.create(new SemiEllipseCurve(e.center,e.f1.negated(),e.f2.negated(),e.tMin+PI$13,min$9(PI$13,e.tMax+PI$13)),t.a,t.b,t.aT+PI$13,t.bT+PI$13,void 0,t.aDir,t.bDir,t.name))}return e instanceof BezierCurve&&t.a.like(t.b)?t.split(lerp(t.aT,t.bT,.5)):t})}t.loadFont=o,t.loadFontsAsync=function(e){t.defaultFont?e():load("fonts/FiraSansMedium.woff",function(s,r){if(s)throw new Error("Could not load font: "+s);t.defaultFont=r,e()})},t.text=c,t.minorityReport=function(){const e=t.sphere(),s=t.text("LEO CROW",64,128).scale(.1/32).translate(-.5,-.05,1.2).flipped(),r=t.sphere(.98);return e.and(s).plus(r)},t.whatever=function(){const t=p(),e=B2.join(t.faces.map((t,e)=>{const s=c(""+(e+1),.4,-2),r=t.contour.map(t=>t.a).reduce((t,e)=>t.plus(e),V3.O).div(3),n=M4.forSys(t.contour[0].aDir,r.cross(t.contour[0].aDir),r.unit(),r);return s.transform(n.times(M4.translate(-s.getAABB().size().x/2,-.1,-.04)))})),r=s(.9);return t.and(r).and(e)},t.d20=function(){const t=p(),e=B2.join(t.faces.map((t,e)=>{const s=c(""+(e+1),.4,-2),r=t.contour.map(t=>t.a).reduce((t,e)=>t.plus(e),V3.O).div(3),n=M4.forSys(t.contour[0].aDir,r.cross(t.contour[0].aDir),r.unit(),r);return s.transform(n.times(M4.translate(-s.getAABB().size().x/2,-.1,-.04)))})),r=s(.9);return t.and(r).and(e)},t.rotStep=function(t,e,s){const n=e/s,i=!eq(e,2*PI$13),a=i?s+1:s,o=arrayFromFunction(a,e=>{if(0==e)return t;const s=M4.rotateZ(n*e);return t.map(t=>t.transform(s))}),c=arrayFromFunction(s,e=>{const s=(e+1)%a;return arrayFromFunction(t.length,r=>{if(!eq0(t[r].a.lengthXY()))return StraightEdge.throughPoints(o[e][r].a,o[s][r].a)})}),h=[];let l;if(t.forEach((e,n)=>{const u=(n+1)%t.length,f=V3.O,d=projectCurve(o[r][n],f,o[r][n].deltaT()<0);if(e instanceof StraightEdge&&e.curve.dir1.isPerpendicularTo(V3.Z)){const t=e.a.x>e.b.x;if(d=new PlaneSurface$1(t?new P3(V3.Z,e.a.z):new P3(V3.Z.negated(),-e.a.z)),i){const t=[];eq0(e.a.x)||t.push(...arrayFromFunction(s,t=>c[t][n])),t.push(o[s][n]),eq0(e.b.x)||t.push(...arrayFromFunction(s,t=>c[s-t-1][u].flipped())),t.push(e.flipped()),l=new PlaneFace(d,t)}else{const r=arrayFromFunction(s,t?t=>c[t][n]:t=>c[s-t-1][u].flipped());let i;t&&!eq0(e.b.x)?i=arrayFromFunction(s,t=>c[s-t-1][u].flipped()):t||eq0(e.a.x)||(i=arrayFromFunction(s,t=>c[t][n])),l=new PlaneFace(d,r,i?[i]:[])}h.push(l)}else if(!(e instanceof StraightEdge&&eq0(e.a.lengthXY())&&eq0(e.b.lengthXY())))for(let t=0;t<s;t++){const s=(t+1)%a,r=[o[t][n].flipped(),c[t][n],o[s][n],c[t][u]&&c[t][u].flipped()].filter(t=>t);if(e instanceof StraightEdge){const t=new PlaneSurface$1(P3.throughPoints(r[0].a,r[1].a,r[2].a));h.push(new PlaneFace(t,r))}else assert$1(!1,e.toString())}}),i){const r=o[s].map(t=>t.flipped()).reverse(),n=new PlaneFace(new PlaneSurface$1(P3.ZX.rotateZ(e)),r);h.push(new PlaneFace(new PlaneSurface$1(P3.ZX.flipped()),t),n)}return new B2(h)},t.fixEdges=h,t.extrudeVertices=function(e,s,r,n,i){assert$1(e.every(t=>t instanceof V3),"baseVertices.every(v => v instanceof V3)"),assertInst(P3,s),assertVectors(r),s.normal1.dot(r)>0&&(s=s.flipped());const a=StraightEdge.chain(e,!0);return i=i||callsce("B2T.extrudeVertices",e,s,r,n),t.extrudeEdges(a,s,r,n,i)},t.tetrahedron=function(t,e,s,r,n="tetra"+getGlobalId()){assertVectors(t,e,s,r);const i=P3.throughPoints(t,e,s).distanceToPointSigned(r);if(eq0(i))throw new Error("four points are coplanar");i>0&&([s,r]=[r,s]);const a=StraightEdge.throughPoints(t,e),o=StraightEdge.throughPoints(t,s),c=StraightEdge.throughPoints(t,r),h=StraightEdge.throughPoints(e,s),l=StraightEdge.throughPoints(e,r),u=StraightEdge.throughPoints(s,r),f=[new PlaneFace(PlaneSurface$1.throughPoints(t,e,s),[a,h,o.flipped()],[],n+"abc"),new PlaneFace(PlaneSurface$1.throughPoints(t,r,e),[c,l.flipped(),a.flipped()],[],n+"adb"),new PlaneFace(PlaneSurface$1.throughPoints(e,r,s),[l,u.flipped(),h.flipped()],[],n+"bdc"),new PlaneFace(PlaneSurface$1.throughPoints(s,r,t),[u,c.flipped(),o],[],n+"cda")],d=`B2T.tetrahedron(${t.sce}, ${e.sce}, ${s.sce}, ${r.sce})`;return new B2(f,!1,d)};const l=1/GOLDEN_RATIO,u=2-GOLDEN_RATIO;t.TETRAHEDRON_VERTICES=[new V3(1,0,-1/Math.sqrt(2)),new V3(-1,0,-1/Math.sqrt(2)),new V3(0,-1,1/Math.sqrt(2)),new V3(0,1,1/Math.sqrt(2))].map(t=>t.unit()),t.DODECAHEDRON_VERTICES=[new V3(u,0,1),new V3(-u,0,1),new V3(-l,l,l),new V3(0,1,u),new V3(l,l,l),new V3(l,-l,l),new V3(0,-1,u),new V3(-l,-l,l),new V3(u,0,-1),new V3(-u,0,-1),new V3(-l,-l,-l),new V3(0,-1,-u),new V3(l,-l,-l),new V3(l,l,-l),new V3(0,1,-u),new V3(-l,l,-l),new V3(1,u,0),new V3(-1,u,0),new V3(-1,-u,0),new V3(1,-u,0)].map(t=>t.unit()),t.DODECAHEDRON_FACE_VERTICES=[[4,3,2,1,0],[7,6,5,0,1],[12,11,10,9,8],[15,14,13,8,9],[14,3,4,16,13],[3,14,15,17,2],[11,6,7,18,10],[6,11,12,19,5],[4,0,5,19,16],[12,8,13,16,19],[15,9,10,18,17],[7,1,2,17,18]],t.OCTAHEDRON_VERTICES=[new V3(1,0,0),new V3(-1,0,0),new V3(0,1,0),new V3(0,-1,0),new V3(0,0,1),new V3(0,0,-1)],t.OCTAHEDRON_FACE_VERTICES=[[0,2,4],[2,1,4],[1,3,4],[3,0,4],[2,0,5],[1,2,5],[3,1,5],[0,3,5]];const{x:f,y:d}=new V3(1,GOLDEN_RATIO,0).unit();function p(){return m(t.ISOCAHEDRON_VERTICES,t.ISOCAHEDRON_FACE_VERTICES,"B2T.octahedron()")}function m(t,e,s){const r=new Map,n=e.map(e=>{const s=PlaneSurface$1.throughPoints(t[e[0]],t[e[1]],t[e[2]]),n=arrayFromFunction(e.length,s=>{const n=(s+1)%e.length,i=e[s],a=e[n],o=min$9(i,a),c=max$8(i,a),h=o*t.length+c;let l=r.get(h);return!l&&r.set(h,l=StraightEdge.throughPoints(t[o],t[c])),i<a?l:l.flipped()});return new PlaneFace(s,n)});return new B2(n,!1,s)}t.ISOCAHEDRON_VERTICES=[new V3(-f,d,0),new V3(f,d,0),new V3(-f,-d,0),new V3(f,-d,0),new V3(0,-f,d),new V3(0,f,d),new V3(0,-f,-d),new V3(0,f,-d),new V3(d,0,-f),new V3(d,0,f),new V3(-d,0,-f),new V3(-d,0,f)],t.ISOCAHEDRON_FACE_VERTICES=[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],t.dodecahedron=function(){return m(t.DODECAHEDRON_VERTICES,t.DODECAHEDRON_FACE_VERTICES,"B2T.dodecahedron()")},t.octahedron=function(){return m(t.OCTAHEDRON_VERTICES,t.OCTAHEDRON_FACE_VERTICES,"B2T.octahedron()")},t.isocahedron=p,t.pyramidEdges=function(t,e,s="pyramid"+getGlobalId()){assertInst(Edge,...t),assertVectors(e);const r=t.map(t=>StraightEdge.throughPoints(e,t.a)),n=t.map((e,n)=>{const i=s+"Wall"+n,a=(n+1)%t.length,o=[r[n],e,r[a].flipped()];return Face.create(void 0,o,void 0,i)}),i=Face.create(baseSurface,t);n.push(i);const a=callsce("B2T.pyramidEdges",t,e,s);return new B2(n,!1,a,s)}}(B2T||(B2T={}));class CustomPlane extends P3{constructor(t,e,s,r,n=randomColor(),i=-500,a=500,o=-500,c=500){const{normal1:h,w:l}=P3.forAnchorAndPlaneVectors(t,e,s);super(h,l),this.up=s,this.right=e,this.sMin=i,this.sMax=a,this.tMin=o,this.tMax=c,this.color=n,this.name=r}get plane(){return this}toPlaneSurface(){return new PlaneSurface$1(this,this.right,this.up)}static forPlane(t,e,s){const r=t.normal1.getPerpendicular().unit(),n=r.cross(t.normal1);return new CustomPlane(t.anchor,n,r,s,e)}static fromPlaneSurface(t){return new CustomPlane(t.plane.anchor,t.right,t.up,"genCustomPlane"+getGlobalId())}distanceTo(t,e){return[new L3$1(this.anchor.plus(this.right.times(this.sMin)),this.up),new L3$1(this.anchor.plus(this.right.times(this.sMax)),this.up),new L3$1(this.anchor.plus(this.up.times(this.tMin)),this.right),new L3$1(this.anchor.plus(this.up.times(this.tMax)),this.right)].map((s,r)=>{const n=s.infoClosestToLine(t);return(isNaN(n.t)||r<2&&this.tMin<=n.t&&n.t<=this.tMax||r>=2&&this.sMin<=n.t&&n.t<=this.sMax)&&n.distance<=e?n.s:1/0}).min()}distanceTo2(t,e){return[new L3$1(this.anchor.plus(this.right.times(this.sMin)),this.up),new L3$1(this.anchor.plus(this.right.times(this.sMax)),this.up),new L3$1(this.anchor.plus(this.up.times(this.tMin)),this.right),new L3$1(this.anchor.plus(this.up.times(this.tMax)),this.right)].map((s,r)=>{const n=s.infoClosestToLine(t);return(isNaN(n.t)||r<2&&this.tMin<=n.t&&n.t<=this.tMax||r>=2&&this.sMin<=n.t&&n.t<=this.sMax)&&n.distance<=e?n.distance:1/0}).min()}}const{PI:PI$14,sign:sign$8,ceil:ceil$11,floor:floor$9,abs:abs$11}=Math;class Edge extends Transformable{constructor(t,e,s,r,n,i,a){super(),this.curve=t,this.a=e,this.b=s,this.aT=r,this.bT=n,this.flippedOf=i,this.name=a,assertNumbers(r,n),assert$1(!eq(r,n)),assertVectors(e,s),assertf(()=>t instanceof Curve,t),assertf(()=>!t.isValidT||t.isValidT(r)&&t.isValidT(n),r+" "+n),assertf(()=>t.at(r).like(e),+e),assertf(()=>t.at(n).like(s),""+t.at(n)+s),assertf(()=>fuzzyBetween(r,t.tMin,t.tMax)),assertf(()=>fuzzyBetween(n,t.tMin,t.tMax)),this.aT=clamp(r,t.tMin,t.tMax),this.bT=clamp(n,t.tMin,t.tMax),this.reversed=this.aT>this.bT}get minT(){return Math.min(this.aT,this.bT)}get maxT(){return Math.max(this.aT,this.bT)}static forCurveAndTs(t,e=t.tMin,s=t.tMax){return Edge.create(t,t.at(e),t.at(s),e,s,void 0,e<s?t.tangentAt(e):t.tangentAt(e).negated(),e<s?t.tangentAt(s):t.tangentAt(s).negated())}static create(t,e,s,r,n,i,a,o,c){return t instanceof L3$1?new StraightEdge(t,e,s,r,n,i,c):new PCurveEdge(t,e,s,r,n,i,a,o,c)}static isLoop(t){return t.every((e,s)=>e.b.like(t[(s+1)%t.length].a))}static edgesIntersect(t,e){assertNumbers(t.curve.hlol,e.curve.hlol),assertInst(Edge,t,e),t.curve.hlol<e.curve.hlol&&([e,t]=[t,e]);const s=t.curve.isInfosWithCurve(e.curve);return s.some(t=>isNaN(t.tThis)||isNaN(t.tOther))&&(console.log(t.sce),console.log(e.sce),assert$1(!1)),s.some(({tThis:s,tOther:r})=>t.tValueInside(s)&&e.tValueInside(r))}static assertLoop(t){t.forEach((e,s)=>{const r=(s+1)%t.length;assert$1(e.b.like(t[r].a),`edges[${s}].b != edges[${r}].a (${t[s].b.sce} != ${t[r].a.sce})`)})}static ngon(t=3,e=1){return StraightEdge.chain(arrayFromFunction(t,s=>V3.polar(e,TAU*s/t)))}static star(t=5,e=1,s=.5){const r=arrayFromFunction(2*t,r=>V3.polar(0==r%2?e:s,TAU*r/t/2));return StraightEdge.chain(r)}static reversePath(t,e=!0){return e?arrayFromFunction(t.length,e=>t[t.length-1-e].flipped()):t}static rect(t=1,e=t){const s=[new V3(0,0,0),new V3(t,0,0),new V3(t,e,0),new V3(0,e,0)];return StraightEdge.chain(s)}static reuleaux(t=3,e=1){assert$1(3<=t),assert$1(1==t%2);const s=arrayFromFunction(t,s=>V3.polar(e,TAU*s/t));return arrayFromFunction(t,e=>{const r=(e+floor$9(t/2))%t,n=(e+ceil$11(t/2))%t,i=s[r],a=s[n],o=s[e],c=o.to(i),h=new SemiEllipseCurve(o,c,V3.Z.cross(c));return Edge.create(h,i,a,0,h.pointT(a),void 0,V3.Z.cross(c),V3.Z.cross(o.to(a)))})}static round(t,e){if(eq0(e))return t;const s=t.map((s,r)=>{const n=(r+1)%t.length,i=t[n];if(!s.b.like(i.a))return;const a=s.bDir.angleTo(i.aDir),o=s.curve,c=i.curve;if(o instanceof L3$1&&c instanceof L3$1){const t=o.dir1.cross(c.dir1);if(eq0(a))return;const s=t.cross(o.dir1),r=t.cross(c.dir1),n=o.transform(M4.translate(s.toLength(e))),i=c.transform(M4.translate(r.toLength(e))),h=n.isInfoWithLine(i);if(!h)throw new Error("tangential curves");const l=h.plus(s.toLength(-e)),u=h.plus(r.toLength(-e)),f=s.toLength(-e),d=new SemiEllipseCurve(h,f,t.cross(f).toLength(e));return Edge.create(d,l,u,0,d.pointT(u),void 0,o.dir1,c.dir1)}return Edge.arbitraryCorner(s,i,e)});return t.flatMap((e,r)=>{const n=(r+t.length-1)%t.length,i=(t.length,s[n]),a=s[r];if(!i&&!a)return e;const[o,c,h]=i?[e.curve.pointT(i.b),i.b,i.bDir]:[e.aT,e.a,e.aDir],[l,u,f]=a?[e.curve.pointT(a.a),a.a,a.aDir]:[e.bT,e.b,e.bDir],d=Edge.create(e.curve,c,u,o,l,void 0,h,f);return a?[d,a]:d})}static arbitraryCorner(t,e,s){const r=t.curve,n=e.curve;const i=t.bT-s*sign$8(t.deltaT())/t.bDir.length(),a=e.aT+s*sign$8(e.deltaT())/e.aDir.length(),[o,c]=newtonIterate(function([t,e]){const i=r.at(t),a=n.at(e),o=r.tangentAt(t),c=n.tangentAt(e),h=o.cross(c),l=h.cross(o).unit(),u=h.cross(c).unit(),f=l.cross(u);h.likeO()&&assert$1(!1);const d=i.to(a);eq0(d.dot(h))||assert$1(!1);const p=new L3$1(i,l),m=new L3$1(a,u),g=(p.infoClosestToLine(m),p.isInfoWithLine(m),d.cross(u).dot(f)/f.squared()),P=d.cross(l).dot(f)/f.squared(),v=i.plus(l.times(g)),C=a.plus(u.times(P));return assert$1(v.like(C)),[abs$11(g)-s,abs$11(P)-s]},[i,a]),h=t.curve.at(o),l=e.curve.at(c),u=(r.at(o),n.at(c),r.tangentAt(o)),f=n.tangentAt(c),d=u.cross(f),p=d.cross(u).unit(),m=(d.cross(f).unit(),p.toLength(-s)),g=h.minus(m),P=new SemiEllipseCurve(g,m,d.cross(m).toLength(s));return Edge.create(P,h,l,0,P.pointT(l),void 0,r.tangentAt(o),n.tangentAt(c))}static pathFromSVG(t){let e=void 0;const s=new SVGPathData(t).toAbs().normalizeHVZ().sanitize(NLA_PRECISION).annotateArcs().commands,r=[];for(const t of s){assert$1("x"in t&&"y"in t);const s=new V3(t.x,t.y,0);switch(t.type){case SVGPathData.LINE_TO:r.push(StraightEdge.throughPoints(e,s));break;case SVGPathData.CURVE_TO:{const n=new V3(t.x1,t.y1,0),i=new V3(t.x2,t.y2,0),a=new BezierCurve(e,n,i,s,0,1),o=new PCurveEdge(a,e,s,0,1,void 0,a.tangentAt(0),a.tangentAt(1));r.push(o);break}case SVGPathData.QUAD_TO:{const n=new V3(t.x1,t.y1,0),i=ParabolaCurve.quadratic(e,n,s).rightAngled(),a=new PCurveEdge(i,e,s,i.tMin,i.tMax,void 0,i.tangentAt(i.tMin),i.tangentAt(i.tMax));r.push(a);break}case SVGPathData.ARC:{const n=t.phi1*DEG,i=t.phi2*DEG,[a,o]=[n,i].sort(MINUS),c=arrayRange(-3,4,1).map(t=>t*PI$14).filter(t=>a<=t&&t<=o),h=V(t.cX,t.cY),l=V3.polar(t.rX,t.xRot*DEG),u=V3.polar(t.rY,t.xRot*DEG+Math.PI/2),f=getIntervals(c,a,o).map(([t,r])=>{const a=r-t,o=mod(t,TAU),c=o+a;assert$1(o>=0==c>=0);const f=o>PI$14||c>PI$14,d=f?o-PI$14:o,p=f?c-PI$14:c,m=new SemiEllipseCurve(h,f?l.negated():l,f?u.negated():u),g=n==t?e:i==t?s:m.at(d),P=n==r?e:i==r?s:m.at(p);return new PCurveEdge(m,g,P,d,p,void 0,m.tangentAt(d),m.tangentAt(p))});r.push(...t.phiDelta>0?f:Edge.reversePath(f));break}}e=s}return r}toString(){return callsce("new "+this.constructor.name,this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir)}split(t){const e=this.curve.at(t),s=this.tangentAt(t);return[Edge.create(this.curve,this.a,e,this.aT,t,void 0,this.aDir,s,this.name+"left"),Edge.create(this.curve,e,this.b,t,this.bT,void 0,s,this.bDir,this.name+"left")]}colinearToLine(t){return this.curve instanceof L3$1&&this.curve.isColinearTo(t)}tValueInside(t){return this.aT<this.bT?lt(this.aT,t)&&lt(t,this.bT):lt(this.bT,t)&&lt(t,this.aT)}isValidT(t){return this.aT<this.bT?le(this.aT,t)&&le(t,this.bT):le(this.bT,t)&&le(t,this.aT)}clampedT(t){return this.aT<this.bT?clamp(t,this.aT,this.bT):clamp(t,this.bT,this.aT)}equals(t){return this===t||this.constructor==t.constructor&&this.a.equals(t.a)&&this.b.equals(t.b)&&this.curve.equals(t.curve)}hashCode(){let t=0;return 0|(t=31*(t=31*(t=31*t+this.a.hashCode())+this.b.hashCode())+this.curve.hashCode())}like(t){return this===t||t instanceof Edge&&this.curve.isColinearTo(t.curve)&&this.a.like(t.a)&&this.b.like(t.b)}isCanon(){return!this.reversed}getCanon(){return this.reversed?this.flipped():this}overlaps(t,e){assert$1(this.curve.isColinearTo(t.curve));const s=this.curve.containsPoint(t.a)&&this.curve.pointT(t.a),r=this.curve.containsPoint(t.b)&&this.curve.pointT(t.b);if(!1===s&&!1===r)return!e&&t.overlaps(this,!0);!1!==s?this.tangentAt(s).dot(t.aDir):this.tangentAt(r).dot(t.bDir);return!(le(edgeMaxT,this.minT)||le(this.maxT,edgeMinT))}getAABB(){const t=[1/0,1/0,1/0],e=[-1/0,-1/0,-1/0];this.curve.roots().forEach((s,r)=>{s.forEach(s=>{lt(this.minT,s)&&lt(s,this.maxT)&&(t[r]=Math.min(t[r],this.curve.at(s).e(r)),e[r]=Math.max(e[r],this.curve.at(s).e(r)))})});const s=new AABB(V(t),V(e));return s.addPoint(this.a),s.addPoint(this.b),s}length(t=1){return this.curve.arcLength(this.minT,this.maxT,t)}deltaT(){return this.bT-this.aT}atAvgT(){return this.curve.at((this.minT+this.maxT)/2)}}class PCurveEdge extends Edge{constructor(t,e,s,r,n,i,a,o,c){super(t,e,s,r,n,i,c),this.flippedOf=i,this.aDir=a,this.bDir=o,assertVectors(a,o),assertf(()=>!a.likeO(),t),assertf(()=>!o.likeO(),t),t instanceof PICurve$1||(assertf(()=>t.tangentAt(r).likeOrReversed(a),""+r+t.tangentAt(r).sce+" "+a.sce),assertf(()=>t.tangentAt(n).likeOrReversed(o))),assert$1(this.reversed===this.aDir.dot(t.tangentAt(r))<0,r+" "+n+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(r)),assert$1(this.reversed===this.bDir.dot(t.tangentAt(n))<0,r+" "+n+" "+t.constructor.name+" "+this.aDir.sce+" "+this.bDir.sce+" "+t.tangentAt(r))}static forCurveAndTs(t,e,s,r){return new PCurveEdge(t,t.at(e),t.at(s),e,s,void 0,e<s?t.tangentAt(e):t.tangentAt(e).negated(),e<s?t.tangentAt(s):t.tangentAt(s).negated(),r)}toSource(){return callsce("new PCurveEdge",this.curve,this.a,this.b,this.aT,this.bT,void 0,this.aDir,this.bDir,this.name)}getVerticesNo0(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!1)}pointsCount(){return this.points().length}points(){return this.curve.calcSegmentPoints(this.aT,this.bT,this.a,this.b,this.reversed,!0)}rotViaPlane(t,e){let s=this.aDir.angleRelativeNormal(this.bDir,t);return t.dot(this.curve.normal)>0==!this.reversed?s<0&&(s+=2*Math.PI):s>0&&(s-=2*Math.PI),s}edgeISTsWithSurface(t){return this.curve.isTsWithSurface(t).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}edgeISTsWithPlane(t){return this.curve.isTsWithPlane(t).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(t){return this.reversed?this.curve.tangentAt(t).negated():this.curve.tangentAt(t)}flipped(){return this.flippedOf||(this.flippedOf=new PCurveEdge(this.curve,this.b,this.a,this.bT,this.aT,this,this.bDir.negated(),this.aDir.negated(),this.name))}transform(t,e){return new PCurveEdge(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT,this.bT,void 0,t.transformVector(this.aDir),t.transformVector(this.bDir),""+this.name+e)}isCoEdge(t){return this===t||this===t.flippedOf||this.curve.isColinearTo(t.curve)&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}}class StraightEdge extends Edge{constructor(t,e,s,r,n,i,a){super(t,e,s,r,n,i,a),this.flippedOf=i,assertInst(L3$1,t),!i||assertInst(StraightEdge,i),!a||assertf(()=>"string"==typeof a,a),assert$1(!e.like(s),"!a.like(b)"+e+s),this.tangent=this.aT<this.bT?this.curve.dir1:this.curve.dir1.negated()}get aDir(){return this.tangent}get bDir(){return this.tangent}static throughPoints(t,e,s){return new StraightEdge(L3$1.throughPoints(t,e,0,t.to(e).length()),t,e,0,t.to(e).length(),void 0,s)}static chain(t,e=!0){const s=t.length;return arrayFromFunction(e?s:s-1,e=>StraightEdge.throughPoints(t[e],t[(e+1)%s]))}toSource(){return callsce("new StraightEdge",this.curve,this.a,this.b,this.aT,this.bT)}getVerticesNo0(){return[this.b]}pointsCount(){return 2}points(){return[this.a,this.b]}edgeISTsWithPlane(t){const e=snap2(this.curve.isTWithPlane(t),this.aT,this.bT);return this.minT<=e&&e<=this.maxT?[e]:[]}edgeISTsWithSurface(t){return t instanceof PlaneSurface$1?this.edgeISTsWithPlane(t.plane):t.isTsForLine(this.curve).map(t=>snap2(t,this.aT,this.bT)).filter(t=>this.minT<=t&&t<=this.maxT)}tangentAt(){return this.tangent}flipped(){return this.flippedOf||(this.flippedOf=new StraightEdge(this.curve,this.b,this.a,this.bT,this.aT,this,this.name))}transform(t,e){const s=t.transformVector(this.curve.dir1).length();return new StraightEdge(this.curve.transform(t),t.transformPoint(this.a),t.transformPoint(this.b),this.aT*s,this.bT*s,void 0,""+this.name+e)}isCoEdge(t){return this===t||this===t.flippedOf||t.constructor===StraightEdge&&(this.a.like(t.a)&&this.b.like(t.b)||this.a.like(t.b)&&this.b.like(t.a))}getEdgeT(t){assertVectors(t);let e=t.minus(this.curve.anchor).dot(this.curve.dir1);if(eq0(this.curve.at(e).distanceTo(t)))return e=snap2(e,this.aT,this.bT),this.minT<=e&&e<=this.maxT?e:void 0}}class FaceInfoFactory{static makeStatic(t){return new class extends FaceInfoFactory{constructor(){super()}info(e,s,r){return t}}}info(t,e,s){throw new Error("no default implementation")}extrudeBottom(t,e,s=[]){return this.info(t,e,s)}extrudeTop(t,e,s=[]){return this.info(t,e,s)}extrudeWall(t,e,s,r=[]){return this.info(e,s,r)}rotationWall(t,e,s,r=[]){return this.info(e,s,r)}rotationStart(t,e,s=[]){return this.info(t,e,s)}rotationEnd(t,e,s=[]){return this.info(t,e,s)}newSubFace(t,e,s,r=[]){return t.info}transform(t,e,s,r,n,i=[]){return t.info}}const{PI:PI$15,min:min$10,max:max$9,sign:sign$9,ceil:ceil$12,floor:floor$10,abs:abs$12}=Math;class Face extends Transformable{constructor(t,e,s=[],r,n){super(),this.surface=t,this.contour=e,this.holes=s,this.name=r,this.info=n,Edge.assertLoop(e),assert$1(e.every(t=>t instanceof Edge),()=>"contour.every(f => f instanceof Edge)"+e),e.forEach(e=>{assert$1(t.containsCurve(e.curve),"edge not in surface "+e+t)}),assert$1(t.edgeLoopCCW(e),t.toString()+e.join("\n")),s&&s.forEach(t=>Edge.assertLoop(t)),s&&s.forEach(e=>assert$1(!t.edgeLoopCCW(e))),assert$1(!s||s.constructor==Array,s&&s.toString()),this.allEdges=Array.prototype.concat.apply(this.contour,this.holes)}static assembleFacesFromLoops(t,e,s){const r=[],n=[];return t.forEach(t=>(function t(s,r){if(0==r.length)r.push(s);else{const n=r.find(t=>B2.loop1ContainsLoop2(t.loop,t.ccw,s.loop,s.ccw,e));if(n)t(s,n.subloops);else{for(let t=r.length;--t>=0;){const n=r[t];B2.loop1ContainsLoop2(s.loop,s.ccw,n.loop,n.ccw,e)&&(s.subloops.push(n),r.splice(t,1))}r.push(s)}}})({loop:t,ccw:e.edgeLoopCCW(t),subloops:[]},n)),n.forEach(t=>(function t(n){r.push(new s(e,n.ccw?n.loop:Edge.reversePath(n.loop),n.subloops.map(t=>t.ccw?Edge.reversePath(t.loop):t.loop))),n.subloops.forEach(e=>e.subloops.forEach(e=>t(e)))})(t)),r}static create(t,e,s,r,n){return t instanceof PlaneSurface$1?new PlaneFace(t,e,s,r,n):new RotationFace(t,e,s,r,n)}intersectFace(t,e,s,r,n,i,a){function o(t,e){return a.has(new Pair(t,e))}function c(t,e){return a.add(new Pair(t,e))}function h(a,h,l){if(!h&&!l){let e=u.surface.normalP(a.a).cross(t.surface.normalP(a.a));if(e.likeO()){const s=lerp(a.aT,a.bT,1/GOLDEN_RATIO),r=a.curve.at(s);e=u.surface.normalP(r).cross(t.surface.normalP(r))}if(e.likeO()){const e=a.a,s=P3.normalOnAnchor(a.aDir,e),n=u.surface.normalP(e),i=n.dot(t.surface.normalP(e))>0,o=s.normal1.cross(n),c=u.surface.isCurvesWithPlane(s)[0],h=c.pointT(e),l=sign$9(o.dot(c.tangentAt(h))),f=t.surface.isCurvesWithPlane(s)[0],d=f.pointT(e),p=sign$9(o.dot(c.tangentAt(d))),m=c.diff(h,EPS*l).dot(n),g=f.diff(d,EPS*p).dot(n);g<m&&mapPush(r,t,i?a.flipped():a),n.dot(t.surface.normalP(e))<0==g<m&&mapPush(r,u,a.flipped());const P=c.diff(h,EPS*l).dot(n),v=f.diff(d,EPS*p).dot(n);v<P&&mapPush(r,t,i?a:a.flipped()),i!=v<P&&mapPush(r,u,a)}else e.dot(a.aDir)<0&&(a=a.flipped()),mapPush(r,u,a),mapPush(r,t,a.flipped());return!0}function f(t,e,s,n,i,c,h,l,u){if(t&&!e){if(o(t.getCanon(),n))return!1;const e=n.surface;i.edgeFaces.get(t.getCanon()).forEach(t=>{const e=fff(t,n.surface),s=e==INSIDE||!h&&e==COPLANAR_SAME,i=t.edge.tangentAt(t.edge.curve.pointT(a.a)).like(a.aDir)?a:a.flipped();assert$1(t.edge.tangentAt(t.edge.curve.pointT(i.a)).like(i.aDir)),s&&mapPush(r,t.face,i)});const s=e.normalP(a.a),c=s.cross(a.aDir),l=splitsVolumeEnclosingFacesP(i,t.getCanon(),a.a,c,s);let u,f;(u=l==INSIDE||h&&l==COPLANAR_SAME)&&mapPush(r,n,a);const d=splitsVolumeEnclosingFacesP(i,t.getCanon(),a.a,c.negated(),s);if((f=d==INSIDE||h&&d==COPLANAR_SAME)&&mapPush(r,n,a.flipped()),u||f||l==COPLANAR_SAME&&d==INSIDE||d==COPLANAR_SAME&&l==INSIDE)return!0}}const d=f(h,l,0,t,e,0,!1),p=f(l,h,0,u,s,0,!0);if(d||p)return!0;if(h&&l){if(o(h.getCanon(),l.getCanon()))return!1;function m(t,e,s,n,i,o,c,h){for(const c of s.edgeFaces.get(t.getCanon())){const s=splitsVolumeEnclosingFaces(n,e.getCanon(),c.inside,c.normalAtCanonA),h=s==INSIDE||i&&s==COPLANAR_SAME,l=c.edge.aDir.like(a.aDir)?a:a.flipped();if(h){mapPush(r,c.face,l);const e=t.getCanon().curve.pointT(a.a);eq(e,t.aT)||eq(e,t.bT)||splitsVolumeEnclosingCone2(n,a.a,a.curve,a.aT,-Math.sign(a.deltaT()))==INSIDE&&mapPush(o,t.getCanon(),{p:a.a,edgeT:e});const s=t.getCanon().curve.pointT(a.b);eq(s,t.aT)||eq(s,t.bT)||splitsVolumeEnclosingCone2(n,a.b,a.curve,a.bT,Math.sign(a.deltaT()))==INSIDE&&mapPush(o,t.getCanon(),{p:a.b,edgeT:s})}}}return c(h.getCanon(),l.getCanon()),m(h,l,e,s,!0,n),m(l,h,s,e,!1,i),!1}}function l(t,r,a){if(t&&!r&&(t.colinear||t.edgeT==t.edge.aT||t.edgeT==t.edge.bT||(mapPush(n,t.edge.getCanon(),t),assert$1(t.edge.isValidT(t.edgeT)))),r&&!t&&(r.colinear||r.edgeT==r.edge.aT||r.edgeT==r.edge.bT||(mapPush(i,r.edge.getCanon(),r),assert$1(r.edge.isValidT(r.edgeT)))),t&&r){function o(t,e,s,r,n,i,a,o,h,l){if(!t.colinear&&t.edgeT!=t.edge.aT&&t.edgeT!=t.edge.bT)if(c(t.edge.getCanon(),e.edge.getCanon()),t.p.like(e.edge.a)||t.p.like(e.edge.b)){const s=t.p.like(e.edge.a)?e.edge.a:e.edge.b,r=splitsVolumeEnclosingCone2(o,s,t.edge.curve,t.edgeT,1),n=splitsVolumeEnclosingCone2(o,s,t.edge.curve,t.edgeT,-1);INSIDE!=r&&INSIDE!=n||(mapPush(l,t.edge.getCanon(),t),assert$1(t.edge.isValidT(t.edgeT)))}else{const s=splitsVolumeEnclosingFacesP2(o,e.edge.getCanon(),t.p,t.edge.curve,t.edgeT,1,n.normalP(t.p)),r=splitsVolumeEnclosingFacesP2(o,e.edge.getCanon(),t.p,t.edge.curve,t.edgeT,-1,n.normalP(t.p));INSIDE!=s&&INSIDE!=r||(mapPush(l,t.edge.getCanon(),t),assert$1(t.edge.isValidT(t.edgeT)))}}assert$1(t.colinear||r.colinear||eq(t.t,r.t)),o(t,r,0,0,f,0,0,s,0,n),o(r,t,0,0,d,0,0,e,0,i)}}assertInst(Face,t);const u=this,f=u.surface,d=t.surface;if(!this.getAABB().fuzzyTouchesAABB(t.getAABB()))return;if(f.isCoplanarTo(d))return;const p=f.isCurvesWithSurface(d);if(0!=p.length){for(const t of p){const e=(t.tMin+t.tMax)/2,s=t.at(e),r=(t.tangentAt(e),f.normalP(s)),n=d.normalP(s),i=r.cross(n);assert$1(f.containsCurve(t)),assert$1(d.containsCurve(t)),i.likeO()}for(let e=0;e<p.length;e++){const s=p[e],r=u.edgeISPsWithSurface(s,t.surface),n=t.edgeISPsWithSurface(s,u.surface);function m(t,e){return 0==t.length?isFinite(s.tMin)&&e.containsPoint2(s.at(s.tMin))==PointVsFace.INSIDE:t[0].insideDir.dot(s.tangentAt(t[0].t))<0}assertf(()=>0==r.length||!eq0(r[0].insideDir.dot(s.tangentAt(r[0].t))),()=>r[0].insideDir.dot(s.tangentAt(r[0].t))),assertf(()=>0==n.length||!eq0(n[0].insideDir.dot(s.tangentAt(n[0].t))),()=>n[0].insideDir.dot(s.tangentAt(n[0].t)));let i,a,o=m(r,u),c=m(n,t);if(0==r.length&&!o||0==n.length&&!c)continue;let f,d,g,P,v=0,C=0,S=o&&c&&s.at(s.tMin),M=s.tMin;for(;v<r.length||C<n.length;){assert$1(v<=r.length),assert$1(C<=n.length);const t=r[v],e=n[C];if(assert$1(t||e),C==n.length||v<r.length&&lt(t.t,e.t)?(f=t,o=!o,t.used=!0,o&&(i=t.colinear&&t),v++):v==r.length||gt(t.t,e.t)?(f=e,e.used=!0,(c=!c)&&(a=e.colinear&&e),C++):(f=t,t.used=!0,e.used=!0,c=!c,(o=!o)&&(i=t.colinear&&t),c&&(a=e.colinear&&e),v++,C++),!S||o&&c)o&&c&&(S=f.p,d=f.insideDir,M=f.t,g=t&&t.used&&t,P=e&&e.used&&e);else{if(d=s.tangentAt(M),eq(M,f.t)){S=void 0;continue}assert$1(lt(M,f.t)),M>f.t&&(d=d.negated());let r=s.tangentAt(f.t);M>f.t&&(r=r.negated());const n=Edge.create(s,S,f.p,M,f.t,void 0,d,r,"genseg"+getGlobalId());S=void 0,h(n,i&&i.edge,a&&a.edge)&&(l(g||i,P||a),l(t&&t.used&&t||i,e&&e.used&&e||a))}}if(o&&c&&M!==s.tMax){const t=s.tMax;d=s.tangentAt(M),M>t&&(d=d.negated());let e=s.tangentAt(t);M>t&&(e=e.negated());const r=Edge.create(s,S,s.at(t),M,t,void 0,d,e,"genseg"+getGlobalId());h(r,i&&i.edge,a&&a.edge)&&l(g||i,P||a)}}u.getAllEdges().forEach(e=>{a.add(new Pair(e.getCanon(),t))}),t.getAllEdges().forEach(t=>{a.add(new Pair(t.getCanon(),u))})}}edgeISPsWithSurface(t,e){const s=this.surface,r=this.holes.concat([this.contour]),n=[];for(const i of r){const r=i.map(e=>e.curve.isColinearTo(t));for(let a=0;a<i.length;a++){const o=i[a],c=(a+1)%i.length,h=i[c];if(r[a]){if(t.containsPoint(o.a)){const e=(a-1+i.length)%i.length,c=i[e],h=t.pointT(o.a),l=o.aDir.cross(s.normalP(o.a));!r[e]&&dotCurve2(c.curve,c.bT,l,-sign$9(c.deltaT()))>0&&n.push({p:c.b,insideDir:o.aDir.negated(),t:h,edge:c,edgeT:c.bT,colinear:!1}),n.push({p:o.a,insideDir:o.aDir,t:h,edge:o,edgeT:o.aT,colinear:!0})}if(t.containsPoint(o.b)){const e=t.pointT(o.b),i=o.bDir.cross(s.normalP(o.b));!r[c]&&dotCurve2(h.curve,h.aT,i,sign$9(h.deltaT()))>0&&n.push({p:o.b,insideDir:o.bDir,t:e,edge:h,edgeT:h.aT,colinear:!1}),n.push({p:o.b,insideDir:o.bDir.negated(),t:e,edge:o,edgeT:o.bT,colinear:!0})}}else{const i=o.edgeISTsWithSurface(e);for(const a of i){const i=o.curve.at(a);if(!t.containsPoint(i))continue;const h=t.pointT(i);assert$1(!isNaN(h));const l=o.tangentAt(a).cross(s.normalP(i)).negated(),u=t.tangentAt(h);sign$9(u.dot(o.curve.tangentAt(a))),e.normalP(i);if(a==o.bT){if(!r[c]){if(!eq(h,t.tMax)){const e=this.pointsToInside3(o.b,t,h,1);assert$1(e!=PointVsFace.ON_EDGE),PointVsFace.INSIDE==e&&n.push({p:o.b,insideDir:u,t:h,edge:o,edgeT:o.bT,colinear:!1})}if(!eq(h,t.tMin)){const e=this.pointsToInside3(o.b,t,h,-1);assert$1(e!=PointVsFace.ON_EDGE),PointVsFace.INSIDE==e&&n.push({p:o.b,insideDir:u.negated(),t:h,edge:o,edgeT:o.bT,colinear:!1})}}}else if(a!=o.aT)if(eq0(l.dot(u))){const e=sign$9(u.dot(o.curve.tangentAt(a))),s=1e-4;for(const r of[-1,1]){if(-1==r*e&&a==o.minT||1==r*e&&a==o.maxT||-1==r&&h==t.tMin||1==r&&h==t.tMax)continue;t.at(h).to(t.at(h+r*s)).dot(l)-o.curve.at(a).to(o.curve.at(a+r*e*s)).dot(l)>0&&n.push({p:i,insideDir:u.times(r),t:h,edge:o,edgeT:a,colinear:!1})}}else n.push({p:i,insideDir:l,t:h,edge:o,edgeT:a,colinear:!1})}}}}return n.sort((e,s)=>e.t-s.t||e.insideDir.dot(t.tangentAt(e.t))),n}transform(t){const e=t.isMirroring(),s=Edge.reversePath(this.contour.map(e=>e.transform(t)),e),r=this.holes.map(s=>Edge.reversePath(s.map(e=>e.transform(t)),e));return new this.constructor(this.surface.transform(t),s,r,this.name,this.info)}flipped(){const t=this.contour.map(t=>t.flipped()).reverse(),e=this.holes.map(t=>t.map(t=>t.flipped()).reverse());return new this.constructor(this.surface.flipped(),t,e,this.name,this.info)}toString(){return"new "+this.constructor.name+"("+this.surface+", ["+this.contour.map(t=>"\n\t"+t).join()+"]"+this.holes.map(t=>"\n\t\thole: "+t.join())+")"}toSource(){return`new ${this.constructor.name}(${this.surface.toSource()}, [${this.contour.map(t=>"\n\t"+t.toSource()).join(",")}], [${this.holes.map(t=>"["+t.map(t=>"\n\t"+t.toSource()).join(",")+"]").join(",")}])`}equals(t){function e(t,e){return t.length==e.length&&arrayRange(0,t.length,1).some(s=>t.every((r,n)=>r.equals(e[(s+n)%t.length])))}return this==t||Object.getPrototypeOf(this)==Object.getPrototypeOf(t)&&this.holes.length==t.holes.length&&e(this.contour,t.contour)&&this.holes.every(s=>t.holes.some(t=>e(s,t)))}hashCode(){function t(t){let e=0;for(const s of t)e=31*e+s|0;return e}function e(e){return t(e.map(t=>t.hashCode()).sort(MINUS))}let s=0;return s=31*(s=31*(s=31*s+t(this.holes.map(t=>e(t)).sort(MINUS))|0)+e(this.contour)|0)+this.surface.hashCode()|0}likeFace(t){function e(t,e){return t.length==e.length&&arrayRange(0,t.length,1).some(s=>t.every((r,n)=>r.like(e[(s+n)%t.length])))}return assertInst(Face,t),this.surface.like(t.surface)&&this.holes.length==t.holes.length&&e(this.contour,t.contour)&&this.holes.every(s=>t.holes.some(t=>e(s,t)))}getAllEdges(){return this.allEdges}addEdgeLines(t){assert$1(!1,"buggy, fix");const e=this.contour.flatMap(t=>t.getVerticesNo0()),s=t.vertices.length;for(let r=0;r<e.length;r++)t.vertices.push(e[r]),t.LINES.push(s+r,s+(r+1)%e.length)}containsPoint(t){return assertVectors(t),this.surface.loopContainsPoint(this.contour,t)!=PointVsFace.OUTSIDE&&!this.holes.some(e=>this.surface.loopContainsPoint(e,t)!=PointVsFace.OUTSIDE)}containsPoint2(t){assertVectors(t);const e=this.surface.loopContainsPoint(this.contour,t);if(e!=PointVsFace.INSIDE)return e;for(const e of this.holes){const s=this.surface.loopContainsPoint(e,t);if(s!=PointVsFace.OUTSIDE)return s==PointVsFace.ON_EDGE?PointVsFace.ON_EDGE:PointVsFace.OUTSIDE}return PointVsFace.INSIDE}intersectsLine(t){if(assertInst(L3$1,t),!this.getAABB().intersectsLine(t))return NaN;const e=this.surface.isTsForLine(t).filter(e=>this.containsPoint(t.at(e))).withMax(t=>-t);return void 0!=e?e:NaN}toMesh(){const t=(new Mesh).addIndexBuffer("TRIANGLES").addIndexBuffer("LINES").addVertexBuffer("normals","LGL_Normal");return this.addToMesh(t),t}zDirVolume(){return this.surface.zDirVolume(this.getAllEdges())}calcArea(){return this.surface.calculateArea(this.getAllEdges())}getLoops(){return this.holes.concat(this.contour)}getAABB(){return this.aabb||(this.aabb=AABB.forAABBs(this.contour.map(t=>t.getAABB())))}pointsToInside3(t,e,s,r){const n=this.surface.normalP(t),i=e.tangentAt(s).times(r),a=n.cross(i),o=e.at(s).to(e.at(s+1e-6*r)).dot(a);let c,h=1/0,l=!1;for(const s of this.getAllEdges()){const r=s.a.like(t),u=s.b.like(t);if(assert$1(r==s.a.like(t)),assert$1(u==s.b.like(t)),!r&&!u)continue;const f=r?s.aDir:s.bDir.negated(),d=i.angleRelativeNormal(f,n);if(eq0(d)){if(e.isColinearTo(s.curve))return PointVsFace.ON_EDGE;const t=r?s.aT:s.bT,n=(r?1:-1)*sign$9(s.deltaT()),i=s.curve.diff(t,1e-6*n).dot(a)-o;i>0&&(!l||i<h)&&(l=!0,h=i,c=r?PointVsFace.OUTSIDE:PointVsFace.INSIDE)}else if(!l){const t=(d+TAU)%TAU;t<h&&(h=t,c=r?PointVsFace.OUTSIDE:PointVsFace.INSIDE)}}if(void 0==c)throw new Error;return c}pointsToInside2(t,e){return this.pointsToInside3(t,L3$1.anchorDirection(t,e),0,1)}}class PlaneFace extends Face{constructor(t,e,s,r,n){assert$1(t instanceof P3||t instanceof PlaneSurface$1),super(t instanceof P3?new PlaneSurface$1(t):t,e,s,r,n)}static forVertices(t,e,...s){const r=t instanceof P3?new PlaneSurface$1(t):t;assert$1(isCCW(e,r.plane.normal1),"isCCW(vs, planeSurface.plane.normal1)");const n=StraightEdge.chain(e);s.forEach(t=>assert$1(doubleSignedArea(t,r.plane.normal1)>=0,"doubleSignedArea(vs, planeSurface.plane.normal1) >= 0"));const i=s.map(t=>StraightEdge.chain(t));return new PlaneFace(t,n,i)}addToMesh(t){const e=t.vertices.length,s=this.surface.plane.normal1,r=this.contour.flatMap(t=>t.getVerticesNo0());for(let s=0;s<r.length;s++)t.LINES.push(e+s,e+(s+1)%r.length);const n=[];this.holes.forEach(t=>{n.push(r.length),r.push(...t.flatMap(t=>t.getVerticesNo0()))});const i=triangulateVertices(s,r,n).map(t=>t+e);Array.prototype.push.apply(t.vertices,r),Array.prototype.push.apply(t.TRIANGLES,i),Array.prototype.push.apply(t.normals,arrayFromFunction(r.length,()=>s))}intersectsLine(t){assertInst(L3$1,t);const e=t.isTWithPlane(this.surface.plane);return Number.isFinite(e)&&this.containsPoint(t.at(e))?e:NaN}withHole(t){return new PlaneFace(this.surface,this.contour,[t])}pointsToInside(t,e){return this.containsPoint2(t.plus(e.times(8*NLA_PRECISION)))}edgeISPsWithPlane(t,e){assert$1(this.surface.plane.containsLine(t)),assert$1(e.containsLine(t));const s=this.surface.plane,r=[];return[this.contour].concat(this.holes).forEach(n=>{const i=n.map(e=>e.colinearToLine(t)&&-sign$9(e.aDir.dot(t.dir1))),a=t.dir1.cross(s.normal1);n.forEach((s,n,o)=>{const c=(n+1)%o.length,h=o[c];if(i[n]){const e=t.pointT(s.a),o=t.pointT(s.b);r.push({p:s.a,insideDir:s.aDir,t:e,edge:s,edgeT:s.aT,colinear:!0},{p:s.b,insideDir:s.bDir.negated(),t:o,edge:s,edgeT:s.bT,colinear:!0});const l=i[c]||dotCurve(a,h.aDir,h.aDDT);i[n]*l<0&&r.push({p:h.a,insideDir:s.bDir,t:o,edge:h,edgeT:h.aT,colinear:!1})}else{const n=s.edgeISTsWithPlane(e);assert$1(n.every(t=>e.containsPoint(s.curve.at(t))),n);for(const o of n)if(o==s.bT){-dotCurve(a,s.bDir,s.bDDT)*(i[c]||dotCurve(a,h.aDir,h.aDDT))<0&&r.push({p:s.b,insideDir:e.normal1.negated(),t:t.pointT(s.b),edge:s,edgeT:s.bT,colinear:!1})}else if(o!=s.aT){const n=s.curve.at(o);assert$1(e.containsPoint(n),s.toString(),n,o,e.distanceToPoint(n)),assert$1(t.containsPoint(n),s.toString(),n,o,t.distanceToPoint(n));const i=e.normal1.negated();r.push({p:n,insideDir:i,t:t.pointT(n),edge:s,edgeT:o,colinear:!1})}}})}),r.sort((e,s)=>e.t-s.t||e.insideDir.dot(t.dir1)),r}}class RotationFace extends Face{constructor(t,e,s,r,n){super(t,e,s,r,n)}static loopDoesNotCrossPlane(t,e){let s=0;function r(t){if(0!=s)return!s||s*t<0;s=t}for(const s of t){const t=s.edgeISTsWithPlane(e);if(0==t.length){if(!(s.curve instanceof L3$1)&&r(e.distanceToPointSigned(s.a)))return!1}else for(const n of t){if(s.aT!=n&&r(dotCurve2(s.curve,n,e.normal1,-sign$9(s.bT-s.aT))))return!1;if(s.bT!=n&&r(dotCurve2(s.curve,n,e.normal1,sign$9(s.bT-s.aT))))return!1}}return!0}getAABB(){return this.aabb?this.aabb:this.surface instanceof SemiEllipsoidSurface||this.surface instanceof EllipsoidSurface?(this.aabb=AABB.forAABBs(this.contour.map(t=>t.getAABB())),this.aabb.addPoints(this.surface.getExtremePoints().filter(t=>this.containsPoint(t))),this.aabb):super.getAABB()}getCanonSeamU(){const t=this.surface.stPFunc();for(const e of this.contour){let s=t(e.a,PI$15).x;if(s!=PI$15&&!eq0(s))return sign$9(s)*PI$15;if((s=t(e.curve.at((e.aT+e.bT)/2),PI$15).x)!=PI$15&&!eq0(s))return sign$9(s)*PI$15}const e=this.contour[0].transform(this.surface.inverseMatrix);if(P3.ZX.containsCurve(e.curve)){const t=e.a.cross(e.aDir);return sign$9(t.dot(V3.Y))*PI$15}assert$1(!1,"Couldn't find canon seam u")}unrollLoop(t){const e=[],s=this.surface.stPFunc(),r=t.map(t=>t.getVerticesNo0()),n=r.findIndex(t=>!eq(s(t[0],Math.PI).x,Math.PI));assert$1(-1!=n);let i=Math.PI;for(let a=0;a<t.length;a++){const o=(a+n)%t.length;for(let t=0;t<r[o].length;t++){const n=r[o][t],a=s(n,i);Math.abs(a.x)<Math.PI-NLA_PRECISION&&(i=a.x),e.push(a)}}return t.forEach((t,r)=>{let n=t.bDir;t instanceof StraightEdge&&t.curve.dir1.isParallelTo(this.surface.dir||this.surface.dir1)&&(n=this.surface.normalP(t.b).cross(t.bDir)),t.getVerticesNo0().forEach(t=>{e.push(s(t,n))})}),console.log("vs\n",e.join("\n"),e.length),e}unrollEllipsoidLoops(t,e,s){const r=[],n=[],i=[],a=this.surface,o=a.stPFunc(),c=a instanceof SemiEllipsoidSurface?t=>t.like(a.center.plus(a.f3))||t.like(a.center.minus(a.f3)):t=>t.like(this.surface.center);for(const e of t){i.push(r.length);const t=this.getCanonSeamU();for(let s=0;s<e.length;s++){const i=(s+1)%e.length,h=e[s].getVerticesNo0();if(n.push(...h),r.push(...h.map(t=>o(t))),c(e[i].a)){const o=a.inverseMatrix.transformVector(e[s].bDir),c=a.inverseMatrix.transformVector(e[i].aDir);let h=Math.atan2(-o.y,-o.x);abs$12(h)>Math.PI-NLA_PRECISION&&(assert$1(t==-PI$15||t==PI$15),h=t);let l=Math.atan2(c.y,c.x);abs$12(l)>Math.PI-NLA_PRECISION&&(assert$1(t==-PI$15||t==PI$15),l=t);const u=r.pop();r.push(new V3(h,u.y,0),new V3(l,u.y,0)),n.push(n.last)}r.forEach(({x:t,y:e})=>{assert$1(isFinite(t)),assert$1(isFinite(e))})}}let h;if(this.surface instanceof EllipsoidSurface)h=n.map(t=>a.normalP(t));else{const t=a.normalSTFunc();h=r.map(({x:e,y:s})=>t(e,s))}return assert$1(n.length==n.length),{verticesUV:r.map(t=>new V3(t.x/e,t.y/s,0)),vertices:n,normals:h,loopStarts:i}}unrollCylinderLoops(t,e,s){const r=t.map(t=>t.flatMap(t=>t.getVerticesNo0())),n=this.surface,i=r.concatenated(),a=r.reduce((t,e)=>(t.push(t.last+e.length),t),[0]),o=n.stPFunc(),c=i.map(t=>o(t)),h=c.map(t=>new V3(t.x/e,t.y/s,0)),l=n.normalSTFunc();return{verticesUV:h,vertices:i,normals:c.map(({x:t,y:e})=>l(t,e)),loopStarts:a}}addToMesh(t,e=this.surface.uStep,s=this.surface.vStep){assertf(()=>e>0&&s>0,e,s,"Surface: "+this.surface);const r=[],n=(t,r)=>this.surface.pSTFunc()(t*e,r*s),i=(t,r)=>this.surface.normalSTFunc()(t*e,r*s),a=[this.contour].concat(this.holes),{vertices:o,verticesUV:c,normals:h,loopStarts:l}=this.surface instanceof SemiEllipsoidSurface||this.surface instanceof ConicSurface?this.unrollEllipsoidLoops(a,e,s):this.unrollCylinderLoops(a,e,s);l.push(o.length);for(let e=0;e<a.length;e++){const s=l[e],r=l[e+1]-s,n=t.vertices.length+l[e];for(let e=0;e<r;e++)t.LINES.push(n+e,n+(e+1)%r)}disableConsole();let u=1/0,f=-1/0,d=1/0,p=-1/0;c.forEach(({x:t,y:e})=>{assert$1(isFinite(t)),assert$1(isFinite(e)),u=min$10(u,t),f=max$9(f,t),d=min$10(d,e),p=max$9(p,e)}),ParametricSurface.is(this.surface)&&(assert$1(this.surface.boundsSigned(u*e,d*s)>-NLA_PRECISION),assert$1(this.surface.boundsSigned(f*e,p*s)>-NLA_PRECISION));const m=floor$10(u+NLA_PRECISION),g=floor$10(d+NLA_PRECISION),P=ceil$12(f-NLA_PRECISION)-m,v=ceil$12(p-NLA_PRECISION)-g;if(console.log(e,s,P,v),1==P&&1==v){const t=triangulateVertices(V3.Z,c,l.slice(1,1+this.holes.length));r.push(...t)}else{const t=new Array(P*v);function C(e,s,r){assert$1(s<P&&r<v,`${s}, ${r}, ${P}, ${v}`),console.log("complete part",e,s,r),assert$1(e.length);const n=s+m,i=r+g;for(const t of e)assert$1(le(n,c[t].x)&&le(c[t].x,n+1),`${t} ${c[t].str} ${n} ${n}`),assert$1(le(i,c[t].y)&&le(c[t].y,i+1));const a=r*P+s;(t[a]||(t[a]=[])).push(e)}for(let t=0;t<a.length;t++){let e,s=void 0,r=-1,n=-1,i=-1,a=-1,o=0;const h=l[t],u=l[t+1]-h;for(let t=0;t<u;t++){const l=h+t,f=c[l],d=h+(t+1)%u,p=c[d],M=f.to(p);assert$1(f);const T=M.x,x=M.y;let I=l,E=f,w=0,V=400;for(;--V;){const t=E.x,c=E.y,h=floor$10(t+(eq0(T)?-sign$9(x):sign$9(T))*NLA_PRECISION)-m,l=floor$10(c+(eq0(x)?sign$9(T):sign$9(x))*NLA_PRECISION)-g;assert$1(h<P&&l<v,`${h}, ${l}, ${P}, ${v}`);const u=ceil$12(sign$9(T)*t+NLA_PRECISION)-sign$9(T)*t,M=ceil$12(sign$9(x)*c+NLA_PRECISION)-sign$9(x)*c,V=w+u/abs$12(T),$=w+M/abs$12(x);if(a==h&&i==l||(s&&(e?(o++,C(s,a,i)):(e=s,r=a,n=i)),s=[I]),a=h,i=l,w=min$10(V,$),ge(w,1)){s.push(d);break}{const t=f.lerp(p,w),e=S(t.x,t.y);s.push(e),E=t,I=e}}assert$1(V,"whileLimit")}0==o&&assert$1(!1,"found a hole, try increasing resolution"),r==a&&n==i?(s.pop(),C(s.concat(e),a,i)):(C(e,r,n),C(s,a,i)),console.log("firstPart",e)}console.log("calculated parts",t);const e=new Array((P+1)*(v+1));function S(t,e){return c.push(new V3(t,e,0)),h.push(i(t,e)),o.push(n(t,e))-1}function M(t,s){const r=s*(P+1)+t;return e[r]||(e[r]=S(t+m,s+g))}for(let e=0;e<P;e++){let s=!1;for(let n=0;n<v;n++){const i=m+e,a=g+n,o=t[n*P+e];if(o){function T(t){const e=c[t],s=e.x-i,r=e.y-a;return assert$1(-NLA_PRECISION<s&&s<1+NLA_PRECISION&&-NLA_PRECISION<r&&r<1+NLA_PRECISION,"oob u1 v1 "+s+" "+r+" "+t+" "+e.str+"IF THIS FAILS check canonSeamU is correct"),r<s?s+r:4-s-r}for(;o.length;){const t=[],i=o[0];assert$1(i.length>0);let a=i;do{t.push(...a);const r=T(a.last),i=o.indexWithMax(t=>-mod(T(t[0])-r,4)),c=o.removeIndex(i);let h=r;const l=T(c[0])>h?T(c[0]):T(c[0])+4;let u=ceil$12(h+NLA_PRECISION),f=eq0((h+NLA_PRECISION)%1-NLA_PRECISION);for(;lt(u,l);){switch(u%4){case 0:t.push(M(e,n));break;case 1:s=s!=f,t.push(M(e+1,n));break;case 2:t.push(M(e+1,n+1));break;case 3:s=s!=f,t.push(M(e,n+1))}f=!0,u++}s=s!=(f&&u%2==1&&eq(u,l)),h=u,a=c}while(a!=i);if(3==t.length)r.push(...t);else{const e=triangulateVertices(V3.Z,t.map(t=>c[t]),[]).map(e=>t[e]);r.push(...e)}}}else s&&pushQuad(r,!1,M(e,n),M(e+1,n),M(e,n+1),M(e+1,n+1))}}}Array.prototype.push.apply(t.TRIANGLES,r.map(e=>e+t.vertices.length)),Array.prototype.push.apply(t.vertices,o),Array.prototype.push.apply(t.normals,h),enableConsole()}addToMesh2(t){const e=[];let s=1/0,r=-1/0;const n=this.surface.pSTFunc(),i=this.surface.normalSTFunc(),a=this.holes.concat([this.contour]).map(t=>this.unrollLoop(t));a.forEach(t=>{t.forEach(({x:t,y:n})=>{const i=e.binaryIndexOf(t,(t,e)=>snap(t.value-e,0));i<0&&e.splice(-i-1,0,{value:t,left:[],right:[]}),s=min$10(s,n),r=max$9(r,n)})}),console.log("zzzs",s,r,a[0].toSource().replace(/\), /g,",\n"));a.forEach(t=>{t.forEach((t,s,r)=>{let n=r[(s+1)%r.length],i=n.x-t.x;if(eq0(i))return;i<0&&([t,n]=[n,t],i=-i);const a=e.binaryIndexOf(t.x,(t,e)=>snap(t.value-e,0)),o=e.binaryIndexOf(n.x,(t,e)=>snap(t.value-e,0));e[a].right.binaryInsert(t.y);for(let s=(a+1)%e.length;s!=o;s=(s+1)%e.length){const r=(e[s].value-t.x)/i,a=n.y*r+t.y*(1-r);e[s].left.binaryInsert(a),e[s].right.binaryInsert(a)}e[o].left.binaryInsert(n.y)})});const o=[],c=[],h=[];for(let t=0;t<e.length;t++){const s=e[t],r=e[(t+1)%e.length];assert$1(s.right.length==r.left.length);for(let t=0;t<s.right.length;t++)o.push(n(s.value,s.right[t]),n(r.value,r.left[t])),h.push(i(s.value,s.right[t]),i(r.value,r.left[t]))}const l=o.length,u=(r-s)/8,f=arrayFromFunction(7,t=>s+(1+t)*u);console.log("detailsZs",f);for(let t=0;t<e.length;t++){const s=e[t].value;for(let t=0;t<f.length;t++)o.push(n(s,f[t])),h.push(i(s,f[t]))}let d=0;const p=e.length-1;for(let t=0;t<p;t++){const s=(t+1)%e.length;let r=!1,n=0;const i=e[t],a=e[(t+1)%e.length];for(let e=0;e<f.length+1;e++){const o=f[e]||1e5;r?i.right[n]<o||a.left[n]<o?(pushQuad(c,!0,l+t*f.length+e-1,l+s*f.length+e-1,d+2*n,d+2*n+1),r=!1,n++,(i.right[n]<o||a.left[n]<o)&&e--):pushQuad(c,!0,l+t*f.length+e,l+t*f.length+e-1,l+s*f.length+e,l+s*f.length+e-1):i.right[n]<o&&a.left[n]<o&&(i.right[n+1]<o||a.left[n+1]<o?(pushQuad(c,!0,d+2*n,d+2*(n+1),d+2*n+1,d+2*(n+1)+1),n+=2,(i.right[n]<o||a.left[n]<o)&&e--):(pushQuad(c,!0,d+2*n,d+2*n+1,l+t*f.length+e,l+s*f.length+e),r=!0,n++))}d+=2*i.right.length}const m=c.map(e=>e+t.vertices.length);Array.prototype.push.apply(t.vertices,o),Array.prototype.push.apply(t.TRIANGLES,m),Array.prototype.push.apply(t.normals,h)}}const{PI:PI$16,sign:sign$10,abs:abs$13,sqrt:sqrt$6}=Math,EPS=1e-5;let globalId=0;function getGlobalId(){return globalId++}function addLikeSurfaceFaces(t,e,s){for(let r=0;r<t.length;r++){const n=t[r];let i=!1,a=!1;for(let t=0;t<n.length;t++){const r=n[t];r==e&&(i=!0),r==s&&(a=!0)}if(i!=a)return void n.push(i?s:e);if(i)return}t.push([e,s])}function assembleFaceFromLooseEdges(t,e,s){const r=new Set;const n=[];let i,a;for(;i=t.find(t=>!r.has(t));){a=i;const s=[];let o=0;do{r.add(a),s.push(a);const n=t.filter(t=>a.b.like(t.a)),i=e.normalP(a.b),o=n.indexWithMax((t,e)=>a.bDir.angleRelativeNormal(t.aDir,i));a=n[o]}while(i!=a&&o++<200);assert$1(201!=o),n.push(s)}const o=B2.assembleFacesFromLoops(n,e,s);return assertf(()=>1==o.length),o[0]}function calcNextEdgeIndex(t,e,s){let r=-20,n=!1,i=Number.MAX_SAFE_INTEGER;const a=t.bDir.cross(s),o=sign$10(t.deltaT()),c=t.curve.diff(t.bT,1e-4*-o).dot(a);for(let o=e.length;o--;){const h=e[o],l=(t.bDir.negated().angleRelativeNormal(h.aDir,s)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION;if(eq0(l)){if(t.curve.isColinearTo(h.curve))continue;const e=sign$10(h.deltaT()),s=h.curve.diff(h.aT,1e-4*e).dot(a)-c;s<0&&(!n||s>r)&&(n=!0,r=s,i=o)}else n||gt(l,r)&&(r=l,i=o)}return i==Number.MAX_SAFE_INTEGER?0:i}class B2 extends Transformable{constructor(t,e,s,r){super(),this.faces=t,assertInst(Face,...t),this.infiniteVolume=e,assert$1(!1===this.infiniteVolume||!0===this.infiniteVolume),this.generator=s,this.vertexNames=r,this.edgeFaces=void 0}static loop1ContainsLoop2(t,e,s,r,n){for(const e of s){const s=n.loopContainsPoint(t,e.a);if(PointVsFace.ON_EDGE!=s)return PointVsFace.INSIDE==s}for(const e of s){const s=e.curve.at(.2*e.aT+.8*e.bT),r=n.loopContainsPoint(t,s);if(PointVsFace.ON_EDGE!=r)return PointVsFace.INSIDE==r}if(e!=r)return r;throw new Error(t.sce+s.sce)}static assembleFacesFromLoops(t,e,s,r){const n=[],i=[];return t.forEach(t=>(function t(s,r){if(0==r.length)r.push(s);else{const n=r.find(t=>B2.loop1ContainsLoop2(t.loop,t.ccw,s.loop,s.ccw,e));if(n)t(s,n.subloops);else{for(let t=r.length;--t>=0;){const n=r[t];B2.loop1ContainsLoop2(s.loop,s.ccw,n.loop,n.ccw,e)&&(s.subloops.push(n),r.splice(t,1))}r.push(s)}}})({loop:t,ccw:e.edgeLoopCCW(t),subloops:[]},i)),i.forEach(t=>(function t(i){if(i.ccw)if(i.subloops.every(t=>!t.ccw)){const a=i.subloops.map(t=>t.loop),o=r&&r.newSubFace(s,e,i.loop,a),c=new s.constructor(e,i.loop,a,"genface"+getGlobalId(),o);n.push(c),i.subloops.forEach(e=>e.subloops.forEach(e=>e.ccw&&t(e)))}else i.subloops.forEach(e=>e.ccw&&t(e))})(t)),n}static join(t,e){return new B2(t.flatMap(t=>t.faces),!1,e)}containsPoint(t,e=!1){const s=[V(-.3920414696448526,-.12936136783391444,-.9108068525164064),V(.6520650903544943,-.07151288645511984,-.7547827667692488),V(.9433494201061395,-.2402757256238473,-.22882186797013926),V(.13678704228501923,-.04480387361087783,.9895867410047372),V(.0662057922721913,-.5865836917435423,.8071780259955845),V(-.7322576567870621,-.12953393611526787,.6685953061989045),V(.6579719127258273,-.012300218400456116,.7529420075219719),V(-.5576497966736425,.8006695748324647,.2189861552871446)];t:for(const r of s){const s=new L3$1(t,r);let n=this.infiniteVolume;for(const t of this.faces){assert$1(!t.surface.containsCurve(s));const r=t.surface.isTsForLine(s);for(const i of r){const r=s.at(i),a=t.containsPoint2(r);if(!e&&assert$1(!eq0(i)),i>0){if(a==PointVsFace.ON_EDGE)continue t;a==PointVsFace.INSIDE&&(n=!n)}}}return n}return!1}withMergedFaces(){const t=[];for(let e=0;e<this.faces.length;e++){let s=!1;for(let r=0;r<e;r++)if(this.faces[e].surface.isCoplanarTo(this.faces[r].surface)){const n=t.find(t=>t.includes(this.faces[r]));n&&(n.push(this.faces[e]),s=!0)}!s&&t.push([this.faces[e]])}if(console.log("likeSurfaceFaces",t),t.every(t=>1==t.length))return this;const e=[];let s=0;for(const r of t)if(console.log(r),1==r.length)e.push(r[0]);else{const t=r.flatMap(t=>t.getAllEdges());for(let e=t.length;e-- >0;)for(let r=0;r<e;r++)if(console.log("blugh",s),assert$1(e>=0&&r>=0&&s++<500,e+" "+r+" "+s),t[e].isCoEdge(t[r])){t.splice(e,1),t.splice(r,1),e--;break}const n=assembleFaceFromLooseEdges(t,r[0].surface,r[0].constructor);e.push(n)}return new B2(e,this.infiniteVolume,this.generator&&this.generator+".withMergedFaces()",this.vertexNames)}calculateVolume(){return this.faces.map(t=>t.zDirVolume().volume).sum()}toMesh(){const t=(new Mesh).addVertexBuffer("normals","LGL_Normal").addIndexBuffer("TRIANGLES").addIndexBuffer("LINES");t.faceIndexes=new Map;for(const e of this.faces){const s=t.TRIANGLES.length;e.addToMesh(t),t.faceIndexes.set(e,{start:s,count:t.TRIANGLES.length-s})}return t}minus(t,e){const s=this.generator&&t.generator&&this.generator+".minus("+t.generator+")";return this.intersection(t.flipped(),!0,!0,s,e)}plus(t,e){const s=this.generator&&t.generator&&callsce(this.generator+".plus",t.generator);return this.flipped().intersection(t.flipped(),!0,!0,s,e).flipped()}and(t,e){const s=this.generator&&t.generator&&callsce(this.generator+".and",t.generator);return this.intersection(t,!0,!0,s,e)}xor(t,e){const s=this.generator&&t.generator&&callsce(this.generator+".xor",t.generator);return new B2(this.minus(t).faces.concat(t.minus(this).faces),this.infiniteVolume!=t.infiniteVolume,s)}equals(t){return this.faces.length==t.faces.length&&this.faces.every(e=>t.faces.some(t=>e.equals(t)))}like(t){return this.faces.length==t.faces.length&&this.faces.every(e=>t.faces.some(t=>e.likeFace(t)))}toString(){return`new B2([\n${this.faces.join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}getConstructorParameters(){return[this.faces,this.infiniteVolume]}toSource(t=!0){return t&&this.generator||`new B2([\n${this.faces.map(SCE).join(",\n").replace(/^/gm,"\t")}], ${this.infiniteVolume})`}reconstituteFaces(t,e,s,r,n){const i=new Map,a=[];for(const c of t){const t=c.getAllEdges().filter(t=>!e.get(t)),h=c.getAllEdges().mapFilter(t=>e.get(t)).concatenated(),l=s.get(c)||[];if(l.length||h.length){i.set(c,"partial");const e=[];function o(){return l.find(t=>!s.has(t))||h.find(t=>!s.has(t))||t.find(t=>!s.has(t))}const s=new Set;let u;for(;u=o();){const r=u,n=[];let i=0;do{s.add(u),n.push(u);const e=t.filter(t=>u.b.like(t.a)),i=h.filter(t=>u.b.like(t.a)),a=l.filter(t=>u.b.like(t.a)),o=e.concat(i,a);if(0==o.length)break;assert$1(0<o.length,()=>c.sce);const f=c.surface.normalP(u.b),d=(o.indexWithMax((t,e)=>(u.bDir.angleRelativeNormal(t.aDir,f)+NLA_PRECISION+PI$16)%TAU),calcNextEdgeIndex(u,o,f));if(u=o[d],s.has(u))break;assert$1(u),assert$1(u!=r)}while(++i<400);400==i&&assert$1(!1,"too many"),n.length>1&&u==r&&e.push(n)}const f=B2.assembleFacesFromLoops(e,c.surface,c,n);r.push(...f);const d=f.flatMap(t=>t.getAllEdges());a.push(...t.filter(t=>d.includes(t)))}}for(;0!=a.length;){const t=a.pop();this.edgeFaces.get(t.getCanon()).forEach(t=>{i.has(t.face)||(i.set(t.face,"inside"),a.push.apply(a,t.face.getAllEdges()))})}r.push(...t.filter(t=>"inside"==i.get(t)))}getLooseEdgeSegments(t,e){const s=new JavaMap;for(const[n,i]of t){if(0==i.length)continue;const t=e.get(n);i.sort((t,e)=>snap0(t.edgeT-e.edgeT)||+!!t.faces);let a,o=n.a,c=n.aDir,h=n.aT;function r(e,r,i){for(let a=0;a<t.length;a++){const o=t[a];!e||!e.faces||e.faces[a];(!r||!r.faces)&&mapPush(s,o.reversed?n.flipped():n,o.reversed?i.flipped():i)}}for(let t=0;t<i.length;t++){const e=i[t],s=n.tangentAt(e.edgeT);if(!eq(e.edgeT,h)){r(a,e,Edge.create(n.curve,o,e.p,h,e.edgeT,void 0,c,s,"looseSegment"+getGlobalId()))}o=e.p,h=e.edgeT,a=e,c=s}if(a&&!eq(h,n.bT)){r(a,void 0,Edge.create(n.curve,o,n.b,h,n.bT,void 0,c,n.bDir,"looseSegment"+getGlobalId()))}}return s}getIntersectionEdges(t){const e=new Map,s=new JavaMap,r=new JavaMap,n=[];return this.faces.forEach(i=>{t.faces.forEach(a=>{i.intersectFace(a,this,t,e,s,r,n)})}),Array.from(e.values()).concatenated()}shellCount(){const t=new Set;let e,s=0;for(;e=this.faces.find(e=>!t.has(e));){s++;const r=[e];for(;e=r.pop();)for(const s of e.getAllEdges())for(const{face:n}of this.edgeFaces.get(s.getCanon()))e===n||t.has(n)||(t.add(n),r.push(n))}return s}getAABB(){return AABB.forAABBs(this.faces.map(t=>t.getAABB()))}assertSanity(){if(!NLA_DEBUG)return;const t=this.faces.flatMap(t=>t.getAllEdges());for(const{i:e,j:s}of combinations(t.length)){t[e],t[s]}this.buildAdjacencies();for(const[t,e]of this.edgeFaces)assert$1(e.length%2==0,()=>t+e.sce)}buildAdjacencies(){if(this.edgeFaces)return this;this.edgeFaces=new JavaMap;for(const t of this.faces)for(const e of t.getAllEdges()){const s=e.getCanon(),r=t.surface.normalP(s.a),n=r.cross(s==e?e.aDir:e.bDir);mapPush(this.edgeFaces,s,{face:t,edge:e,normalAtCanonA:r,reversed:s!=e,inside:n,angle:0})}for(const[t,e]of this.edgeFaces){const s=e.find(t=>t.reversed);s?(e.forEach(e=>{e!=s&&(e.angle=s.inside.angleRelativeNormal(e.inside,t.aDir.unit()),e.angle<0&&(e.angle+=2*Math.PI))}),e.sort((t,e)=>snap(t.angle-e.angle,0))):console.warn("invalid brep")}return this}intersection(t,e,s,r,n){this.assertSanity(),t.assertSanity(),this.buildAdjacencies(),t.buildAdjacencies();const i=new Map,a=new JavaMap,o=new JavaMap,c=new JavaSet;for(const e of this.faces)for(const s of t.faces)e.intersectFace(s,this,t,i,a,o,c);for(const t of a.keys())assert$1(this.edgeFaces.get(t));for(const e of o.keys())assert$1(t.edgeFaces.get(e));const h=[];if(0==i.size&&0==a.size&&0==o.size){!t.containsPoint(this.faces[0].contour[0].a,!0)&&this.containsPoint(t.faces[0].contour[0].a);return this}if(e){const t=this.getLooseEdgeSegments(a,this.edgeFaces);this.faces.map(e=>[e,Array.from(t.entries()).filter(([t,s])=>e.getAllEdges().some(e=>e.equals(t))).concatenated()]);this.reconstituteFaces(this.faces,t,i,h,n)}if(s){const e=this.getLooseEdgeSegments(o,t.edgeFaces);t.faces.map(t=>[t,Array.from(e.entries()).filter(([e,s])=>t.getAllEdges().some(t=>t.equals(e))).flatMap(([t,e])=>e)]);t.reconstituteFaces(t.faces,e,i,h,n)}return new B2(h,this.infiniteVolume&&t.infiniteVolume,r)}transform(t,e){let s;return this.vertexNames&&(s=new Map,this.vertexNames.forEach((r,n)=>s.set(t.transformPoint(n),r+e))),new B2(this.faces.map(e=>e.transform(t)),this.infiniteVolume,this.generator&&e&&this.generator+e,s)}flipped(){return new B2(this.faces.map(t=>t.flipped()),!this.infiniteVolume,this.generator&&this.generator+".flipped()",this.vertexNames)}}function dotCurve(t,e,s){let r=t.dot(e);return eq0(r)&&(r=t.dot(s)),assert$1(!eq0(r)),r}function dotCurve2(t,e,s,r){assert$1(1==r||-1==r,r);const n=t.tangentAt(e).dot(s);if(!eq0(n))return r*n;const i=t.ddt(e).dot(s);if(!eq0(i))return i;const a=t.at(e).to(t.at(e+4*r*NLA_PRECISION)).dot(s);return assert$1(!(t instanceof L3$1)),a}B2.EMPTY=new B2([],!1,"B2.EMPTY",new Map).buildAdjacencies(),B2.R3=new B2([],!0,"B2.R3",new Map).buildAdjacencies();const INSIDE=0,OUTSIDE$1=1,COPLANAR_SAME=2,COPLANAR_OPPOSITE=3,ALONG_EDGE_OR_PLANE=4;function splitsVolumeEnclosingFaces(t,e,s,r){assert$1(4==arguments.length),assert$1(e==e.getCanon());const n=t.edgeFaces.get(e);assertf(()=>n.length%2==0),assertf(()=>t.edgeFaces);const i=n[0],a=e.aDir.unit(),o=(i.inside.angleRelativeNormal(s,a)+2*Math.PI+NLA_PRECISION)%(2*Math.PI)-NLA_PRECISION,c=n.findIndex(t=>lt(o,t.angle)),h=n[-1==c?n.length-1:c-1];if(eq(h.angle,o)){return h.normalAtCanonA.dot(r)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}return h.reversed?INSIDE:OUTSIDE$1}function splitsVolumeEnclosingFacesP(t,e,s,r,n){assert$1(5==arguments.length),assert$1(e==e.getCanon()),assertf(()=>t.edgeFaces);const i=t.edgeFaces.get(e);assertf(()=>i.length%2==0);const a=e.tangentAt(e.curve.pointT(s)).unit(),o=t=>{const e=t.edge.getCanon()==t.edge?a:a.negated(),n=t.face.surface.normalP(s).cross(e);return-((r.angleRelativeNormal(n,a)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION)},c=i.withMax(o);if(eq0(o(c))){return c.normalAtCanonA.dot(n)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}return c.reversed?OUTSIDE$1:INSIDE}function splitsVolumeEnclosingFacesP2(t,e,s,r,n,i,a){assert$1(e==e.getCanon()),assertf(()=>t.edgeFaces);const o=t.edgeFaces.get(e);assertf(()=>o.length%2==0);const c=e.tangentAt(e.curve.pointT(s)).unit();let h=r.tangentAt(n).times(i);h.isParallelTo(c)&&(h=(h=r.diff(n,1e-4*i/r.tangentAt(n).length()).rejectedFrom(c)).div(h.length()));let l=20,u=!1,f=OUTSIDE$1;for(const t of o){const e=t.edge.getCanon()==t.edge?c:c.negated(),o=t.face.surface.normalP(s).cross(e),d=(h.angleRelativeNormal(o,c)+TAU+NLA_PRECISION)%TAU-NLA_PRECISION;if(eq0(d)){const e=t.face.surface.normalP(s);if(t.face.surface.containsCurve(r)){return e.dot(a)>0?COPLANAR_SAME:COPLANAR_OPPOSITE}const o=P3.normalOnAnchor(c,s),d=t.face.surface.isCurvesWithPlane(o)[0],p=d.pointT(s),m=sign$10(d.tangentAt(p).dot(h)),g=1e-4,P=(d.at(p).to(d.at(p+i*m*g)).dot(e)-r.at(n).to(r.at(n+i*g)).dot(e))*(t.reversed?-1:1);P>0&&(!u||P<l)&&(u=!0,l=P,f=t.reversed?OUTSIDE$1:INSIDE)}else u||d<l&&(l=d,f=t.reversed?OUTSIDE$1:INSIDE)}return f}function splitsVolumeEnclosingCone(t,e,s){const r=P3.forAnchorAndPlaneVectors(e,s,s.getPerpendicular()),n=[];for(let i=0;i<t.faces.length;i++){const a=t.faces[i];if(assertf(()=>a instanceof PlaneFace),a.getAllEdges().some(t=>t.a.like(e)))if(r.isParallelToPlane(a.surface.plane)){if(a.pointsToInside(e,s)!=PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE}else{const t=L3$1.fromPlanes(r,a.surface.plane),i=a.edgeISPsWithPlane(t,r);let o=0;for(;o<i.length;){const a=i[o++],c=i[o++],h=a.p.like(e);if(h||c.p.like(e)){const e=h?t.dir1:t.dir1.negated(),i=(s.angleRelativeNormal(e,r.normal1)+2*Math.PI+NLA_PRECISION/2)%(2*Math.PI);n.push({angle:i,out:h})}}}}return n.sort((t,e)=>t.angle-e.angle),eq0(n[0].angle)?ALONG_EDGE_OR_PLANE:n[0].out?OUTSIDE$1:INSIDE}function splitsVolumeEnclosingCone2(t,e,s,r,n){assert$1(s.containsPoint(e));const i=s.tangentAt(r).times(n),a=(P3.forAnchorAndPlaneVectors(e,i,i.getPerpendicular()),t.faces.filter(t=>t.getAllEdges().some(t=>t.a.like(e))));for(let t=0;t<a.length;t++){const i=a[t];if(i.surface.containsCurve(s)&&i.pointsToInside3(e,s,r,n)!=PointVsFace.OUTSIDE)return ALONG_EDGE_OR_PLANE}return t.containsPoint(s.at(r+1e-6*n),!0)?INSIDE:OUTSIDE$1}function fff(t,e){const s=t.edge.reversed?t.edge.b:t.edge.a,r=e.normalP(s),n=snap0(t.inside.dot(r));return 0!==n?0<n?OUTSIDE$1:INSIDE:e.isCoplanarTo(t.face.surface)?0<t.normalAtCanonA.dot(r)?COPLANAR_SAME:COPLANAR_OPPOSITE:void assert$1(!1)}function triangulateVertices(t,e,s){const r=t.maxAbsDim(),n=sign$10(t.e(r)),i=new Float64Array(2*e.length);let a=e.length;for(;a--;)switch(r){case 0:i[2*a]=e[a].y*n,i[2*a+1]=e[a].z;break;case 1:i[2*a]=e[a].z*n,i[2*a+1]=e[a].x;break;case 2:i[2*a]=e[a].x*n,i[2*a+1]=e[a].y}return earcut(i,s)}function intersectionUnitCircleLine(t,e,s){assertNumbers(t,e,s);const r=sqrt$6(t*t+e*e-s*s);return{x1:(t*s+e*r)/(t*t+e*e),x2:(t*s-e*r)/(t*t+e*e),y1:(e*s-t*r)/(t*t+e*e),y2:(e*s+t*r)/(t*t+e*e)}}function intersectionUnitCircleLine2(t,e,s){assertNumbers(t,e,s);const r=snap0(t*t+e*e-s*s);if(r<0)return[];if(0==r)return[[t*s/(t*t+e*e),e*s/(t*t+e*e)]];{const n=sqrt$6(r);return[[(t*s+e*n)/(t*t+e*e),(e*s-t*n)/(t*t+e*e)],[(t*s-e*n)/(t*t+e*e),(e*s+t*n)/(t*t+e*e)]]}}function intersectionCircleLine(t,e,s,r){assertNumbers(t,e,s,r);const n=sqrt$6(r*r*(t*t+e*e)-s*s);return{x1:(t*s+e*n)/(t*t+e*e),x2:(t*s-e*n)/(t*t+e*e),y1:(e*s-t*n)/(t*t+e*e),y2:(e*s+t*n)/(t*t+e*e)}}function intersectionUnitHyperbolaLine(t,e,s){assertNumbers(t,e,s);const r=t*t,n=e*e,i=s*s,a=2*sqrt$6(n*i+n*n-r*n),o=sqrt$6(4*i*n-4*(n-r)*(i-r));return{x1:(-2*t*s+a)/2/(n-r),x2:(-2*t*s-a)/2/(n-r),y1:(2*e*s-o)/2/(n-r),y2:(2*e*s+o)/2/(n-r)}}function followAlgorithm2d(t,e,s=.5,r,n=e,i){assertNumbers(s,t(0,0)),assertVectors(e),i||(i=new V3(-t.y(e.x,e.y),t.x(e.x,e.y),0).toLength(s)),assertVectors(i);const a=[],o=[];assert$1(eq0(t(e.x,e.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let c=0,h=e,l=i;do{a.push(h),o.push(l);const e=h.plus(l);assert$1(e);const i=curvePointMF(t,e),u=t.x(i.x,i.y),f=t.y(i.x,i.y),d=new V3(-f,u,0).toLength(s);if(h.equals(i)&&assertNever(),l.dot(d)<0){const e=newtonIterate2d(t.x,t.y,h.x,h.y);if(eq0(t(e.x,e.y))&&e.distanceTo(h)<abs$13(s)){a.push(e),o.push(h.to(e));break}throw new Error}if(c>4){if(!r(h.x,h.y))break;if(h.distanceTo(n)<s){a.push(n);const e=new V3(-t.y(n.x,n.y),t.x(n.x,n.y),0).toLength(s);o.push(e);break}}assert$1(eq0(t(i.x,i.y),2*NLA_PRECISION),h,i,e),l=d,h=i}while(++c<1e3);return assert$1(c<1e3),{points:a,tangents:o}}function followAlgorithm2dAdjustable(t,e,s=.5,r,n=e){assertNumbers(s,t(0,0)),assertVectors(e);const i=[],a=[];assert$1(eq0(t(e.x,e.y),.01),"isZero(implicitCurve(startPoint.x, startPoint.y))");let o=e,c=o,h=0;do{const e=t.x(o.x,o.y),s=t.y(o.x,o.y),r=t.xx(o.x,o.y),n=t.yy(o.x,o.y),h=t.xy(o.x,o.y),l=abs$13((Math.pow(s,2)*r-2*e*s*h+Math.pow(e,2)*n)/Math.pow(Math.pow(e,2)+Math.pow(s,2),2)),u=new V3(e,s,0).times(l),f=1/16/u.length(),d=new V3(-s,e,0).unit(),p=(o.minus(c).dot(d),o.plus(d.times(f).plus(u.times(Math.pow(f,2)/2))));i.push(o),a.push(d),c=o;const m=curvePointMF(t,p);m.equals(o)&&assertNever(),console.log(o.to(m).length()),assert$1(eq0(t((o=m).x,o.y)))}while(h++<1e3&&(h<4||c.distanceTo(n)>s)&&r(o.x,o.y));assert$1(1e3!=h);const l=h<4||c.distanceTo(n)>s?o:n,u=new V3(-t.y(l.x,l.y),t.x(l.x,l.y),0).toLength(s);return i.push(l),a.push(u),{points:i,tangents:a}}function intersectionICurveICurve(t,e,s,r,n,i){assertNumbers(n,t(0,0),i(0,0)),assertVectors(e,s),assert$1(!r||r instanceof V3);const a=[];assert$1(eq0(t(e.x,e.y))),n=n||.5;let o=e,c=o,h=0;for(;h++<1e3&&(h<4||o.distanceTo(s)>1.1*n);){const e=t(o.x,o.y),s=(t(o.x+1e-5,o.y)-e)/1e-5,r=(t(o.x,o.y+1e-5)-e)/1e-5;let i=new V3(-r,s,0).toLength(n);o.minus(c).dot(i)<0&&(i=i.negated()),c=o,o=curvePoint(t,o.plus(i)),a.push(o)}return a}function intersectionICurveICurve2(t,e,s){let r,n=e[0],i=s(n.x,n.y);const a=[];for(let o=0;o<e.length;o++)r=i,(i=s(n=e[o]))*r<=0&&a.push(newtonIterate2d(t,s,n.x,n.y));return a}function intersectionICurvePSurface(t,e,s){}function cassini(t,e){return(s,r)=>(s*s+r*r)*(s*s+r*r)-2*e*e*(s*s-r*r)-(Math.pow(t,4)-Math.pow(e,4))}var MathFunctionR2R;!function(t){t.forNerdamer=function(t,e=["x","y"]){const s=nerdamer(t),r=nerdamer.diff(s,e[0]),n=nerdamer.diff(s,e[1]),i=s.buildFunction(e);return i.x=r.buildFunction(e),i.y=n.buildFunction(e),i.xx=nerdamer.diff(r,e[0]).buildFunction(e),i.xy=nerdamer.diff(r,e[1]).buildFunction(e),i.yy=nerdamer.diff(n,e[1]).buildFunction(e),i},t.nerdamerToR2_R=function(t,e=["x","y"]){return t.buildFunction(e)},t.forFFxFy=function(t,e,s){return t.x=e,t.y=s,t}}(MathFunctionR2R||(MathFunctionR2R={}));const cas2=cassini(.9,1.02);function doNotSerialize(t,e){(t.__SERIALIZATION_BLACKLIST||(t.__SERIALIZATION_BLACKLIST={}))[e]="no"}class ClassSerializer{constructor(){this.CLASS_NAMES=new Map,this.NAME_CLASSES=new Map,this.addClass("Object",Object)}addClass(t,e){if(this.NAME_CLASSES.has(t))throw new Error(t);return this.NAME_CLASSES.set(t,e),this.CLASS_NAMES.set(e,t),this}addNamespace(t,e){return Object.keys(t).forEach(s=>{const r=t[s];"function"==typeof r&&r.name&&this.addClass((e?e+".":"")+s,r)}),this}setUpdater(t){return this.updater=t,this}serialize(t){return JSON.stringify(this.serializeObj(t))}serializeObj(t){const e=[],s=t=>{if(void 0!==t&&t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor));else if(Array.isArray(t))if(n.has(t))i.has(t)||(i.set(t,a.length),a.push(t));else{n.add(t);for(let r=0;r<t.length;r++)e.push(""+r),s(t[r]),e.pop()}else if(void 0!==t&&"object"==typeof t)if(n.has(t))i.has(t)||(i.set(t,a.length),a.push(t));else{if(assert$1(!t.__noxTarget||!n.has(t.__noxTarget)),assert$1(!t.__noxProxy||!n.has(t.__noxProxy)),n.add(t),!t.getConstructorParameters)for(const r of Object.keys(t).sort())"__noxProxy"!=r&&"__noxTarget"!=r&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[r]||(e.push(r),s(t[r]),e.pop()));e.push("proto"),s(Object.getPrototypeOf(t)),e.pop()}},r=(t,e,s)=>{if("string"==typeof t||"number"==typeof t||"boolean"==typeof t||null===t)return t;if(void 0===t)return{"#REF":-1};if(t.hasOwnProperty("constructor")&&this.CLASS_NAMES.has(t.constructor))return{"#REF":this.CLASS_NAMES.get(t.constructor)};let n;if(e&&!s&&void 0!==(n=i.get(t)))return{"#REF":n};if(Array.isArray(t))return t.map(t=>r(t,e));if("object"==typeof t){if(t.getConstructorParameters)return{"#CONSTRUCTOR":this.CLASS_NAMES.get(t.constructor),"#ARGS":r(t.getConstructorParameters(),!1)};const s={};Object.prototype!==Object.getPrototypeOf(t)&&(s["#PROTO"]=r(Object.getPrototypeOf(t),e));for(const n of Object.keys(t))"__noxProxy"!=n&&"__noxTarget"!=n&&(t.__SERIALIZATION_BLACKLIST&&t.__SERIALIZATION_BLACKLIST[n]||(s[n]=r(t[n],e)));return s}throw new Error("?"+typeof t+t.toString())},n=new Set,i=new Map;let a=[];return i.set(t,0),a.push(t),s(t),a=a.map(t=>r(t,!0,!0))}unserialize(t){let e=0;const s=(t,i)=>{if(++e>100)throw new Error;if(t&&t.constructor===Array){i(t);for(let e=0;e<t.length;e++)s(t[e],s=>t[e]=s)}else if("object"==typeof t&&void 0!=t)if("#CONSTRUCTOR"in t){const e=t["#CONSTRUCTOR"],r=this.NAME_CLASSES.get(e);let n;assert$1(r,e+" Missing "),s(t["#ARGS"],t=>n=t),i(new r(...n))}else if("#REF"in t){const e=t["#REF"];"string"==typeof e?i(this.NAME_CLASSES.get(e).prototype):"number"==typeof e&&(-1==e?i(void 0):n[e]?i(n[e]):s(r[e],t=>i(n[e]=t)))}else{let e;"#PROTO"in t?s(t["#PROTO"],t=>{e=Object.create(t),i(e)}):i(e=t);const r=Object.keys(t);for(let n=0;n<r.length;n++)"#PROTO"!=r[n]&&s(t[r[n]],t=>e[r[n]]=t);Object.defineProperty(e,"loadID",{value:getGlobalId(),enumerable:!1,writable:!1}),this.updater&&this.updater(e)}else i(t);e--},r=JSON.parse(t),n=new Array(r.length);return s({"#REF":0},()=>{}),n[0]}}const fragmentShaderLighting="\n\tprecision highp float;\n\tuniform vec4 color;\n\tuniform vec3 camPos;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tvec3 normal1 = normalize(normal);\n\t\tvec3 lightPos = vec3(1000, 2000, 4000);\n\t\tvec3 lightDir = normalize(vPosition.xyz - lightPos);\n        vec3 reflectionDirection = reflect(lightDir, normal1);\n        vec3 eyeDirection = normalize(camPos.xyz-vPosition.xyz);\n        float uMaterialShininess = 256.0;\n\t\tfloat specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);\n\t\tfloat lightIntensity = 0.6 + 0.2 * max(0.0, -dot(lightDir, normal1)) + 0.2*specularLightWeighting;\n\t\tgl_FragColor = vec4(vec3(color) * lightIntensity, 1);\n\t}\n",vertexShaderLighting="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tuniform mat4 LGL_ModelViewMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n        vPosition = LGL_ModelViewMatrix * LGL_Vertex;\n\t\tnormal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t}\n",vertexShaderWaves="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tuniform mat4 LGL_ModelViewMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tuniform vec4 color;\n\tvarying vec3 normal;\n\tvarying vec4 vPosition;\n\tvoid main() {\n\t\tnormal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t\tfloat offset = mod  (((LGL_Vertex.x + LGL_Vertex.y + LGL_Vertex.z) * 31.0), 20.0) - 10.0;\n\t\tvec4 modPos = LGL_Vertex + vec4(normal * offset, 0);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * modPos;\n        vPosition = LGL_ModelViewMatrix * modPos;\n\t}\n",vertexShaderBasic="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t}\n",vertexShaderColor="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tattribute vec4 color;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t\tfragColor = color;\n\t}\n",vertexShaderArc="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float step, offset;\n\tuniform float radius, width;\n\tvoid main() {\n\t\tfloat r = radius;\n\t\tfloat t = offset + LGL_Vertex.x * step;\n\t\tfloat pRadius = r - LGL_Vertex.y * width;\n\t\tvec4 p = vec4(pRadius * cos(t), pRadius * sin(t), 0, 1);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * p;\n}\n",vertexShaderConic3d="\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float startT, endT, scale;\n\tuniform vec3 center, f1, f2;\n\tuniform int mode;\n\tfloat sinh(float x) { return (exp(x) - exp(-x)) / 2.0; }\n\tfloat cosh(float x) { return (exp(x) + exp(-x)) / 2.0; }\n\tvoid main() {\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT);\n\n\t\tvec3 normal = normalize(cross(f1, f2));\n\n\t\tvec3 p, tangent;\n\t\tif (0 == mode) { // ellipse\n\t\t\tp = center + f1 * cos(t) + f2 * sin(t);\n\t\t\ttangent = f1 * -sin(t) + f2 * cos(t);\n\t\t}\n\t\tif (1 == mode) { // parabola\n\t\t\tp = center + f1 * t + f2 * t * t;\n\t\t\ttangent = f1 + f2 * t;\n\t\t}\n\t\tif (2 == mode) { // hyperbola\n\t\t\tp = center + f1 * cosh(t) + f2 * sinh(t);\n\t\t\ttangent = f1 * sinh(t) + f2 * cosh(t);\n\t\t}\n\t\tvec3 outDir = normalize(cross(normal, tangent));\n\t\tvec3 p2 = p + scale * (outDir * LGL_Vertex.y + normal * LGL_Vertex.z);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderBezier="\n    // calculates a bezier curve using LGL_Vertex.x as the (t) parameter of the curve\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform float width, startT, endT;\n\tuniform vec3 p0, p1, p2, p3;\n\tvoid main() {\n\t\t// LGL_Vertex.y is in [0, 1]\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 pPos = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 pNormal = normalize(vec3(pTangent.y, -pTangent.x, 0));\n\t\tvec4 p = vec4(pPos - LGL_Vertex.y * width * pNormal, 1);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * p;\n\t}\n",vertexShaderBezier3d="\n    // calculates a bezier curve using LGL_Vertex.x as the (t) parameter of the curve\n\tuniform float scale, startT, endT;\n\tuniform vec3 ps[4];\n\tuniform vec3 p0, p1, p2, p3, normal;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\t// LGL_Vertex.y is in [0, 1]\n\t\tvec3 p5 = ps[0];\n\t\tfloat t = startT + LGL_Vertex.x * (endT - startT), s = 1.0 - t;\n\t\tfloat c0 = s * s * s, c1 = 3.0 * s * s * t, c2 = 3.0 * s * t * t, c3 = t * t * t;\n\t\tvec3 p = p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;\n\t\tfloat c01 = 3.0 * s * s, c12 = 6.0 * s * t, c23 = 3.0 * t * t;\n\t\tvec3 pTangent = (p1 - p0) * c01 + (p2 - p1) * c12 + (p3 - p2) * c23;\n\t\tvec3 outDir = normalize(cross(normal, pTangent));\n\t\tvec3 correctNormal = normalize(cross(pTangent, outDir));\n\t\tvec3 p2 = p + scale * (outDir * LGL_Vertex.y + correctNormal * LGL_Vertex.z);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(p2, 1);\n\t}\n",vertexShaderGeneric="\n\tuniform float scale;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat3 LGL_NormalMatrix;\n\tattribute vec3 LGL_Normal;\n\tvoid main() {\n\t\tvec3 normal = normalize(LGL_NormalMatrix * LGL_Normal);\n\t\tvec4 vertexPos = LGL_Vertex + vec4(normal * scale, 0);\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vertexPos;\n\t}\n",vertexShaderRing="\n\t#define M_PI 3.1415926535897932384626433832795\n\tuniform float step;\n\tuniform float innerRadius, outerRadius;\n\tattribute float index;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tattribute vec4 LGL_Vertex;\n\tvoid main() {\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(index, index, index, 1);\n\t\tfloat id = atan(LGL_Vertex.x, LGL_Vertex.y) / M_PI  * 32.0;\n\t\tfloat radius = mod(id, 2.0) < 1.0 ? outerRadius : innerRadius;\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * vec4(radius * cos(index * step), radius * sin(index * step), 0, 1);\n\t}\n",fragmentShaderColor="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tgl_FragColor = color;\n\t}\n",fragmentShaderVaryingColor="\n\tprecision highp float;\n\tvarying vec4 fragColor;\n\tvoid main() {\n\t\tgl_FragColor = fragColor;\n\t}\n",fragmentShaderColorHighlight="\n\tprecision highp float;\n\tuniform vec4 color;\n\tvoid main() {\n\t\tfloat diagonal = (gl_FragCoord.x + 2.0 * gl_FragCoord.y);\n\t\tif (mod(diagonal, 50.0) > 40.0) { // mod(diagonal, 2.0) > 1.0\n\t\t\tdiscard;\n\t\t\t//gl_FragColor = color + vec4(0.2,0.2,0.2,0);\n\t\t} else {\n\t\t\tgl_FragColor = color - vec4(0.2,0.2,0.2,0);\n\t\t}\n\t}\n",vertexShaderTexture="\n\tvarying vec2 texturePos;\n\tattribute vec4 LGL_Vertex;\n\tuniform mat4 LGL_ModelViewProjectionMatrix;\n\tvoid main() {\n\t\ttexturePos = LGL_Vertex.xy;\n\t\tgl_Position = LGL_ModelViewProjectionMatrix * LGL_Vertex;\n\t}\n",fragmentShaderTextureColor="\n\tprecision highp float;\n\tvarying vec2 texturePos;\n\tuniform vec4 color;\n\tuniform sampler2D texture;\n\tvoid main() {\n\t\tgl_FragColor = texture2D(texture, texturePos) * color;\n\t}\n",{pow:pow$5,sign:sign$11}=Math;function parseGetParams(t){const e={};return t.split("&").forEach(function(t){const s=t.indexOf("=");-1==s?e[t]=t:e[t.substr(0,s)]=decodeURI(t.substr(s+1))}),e}const COLORS={RD_FILL:chroma("#9EDBF9"),RD_STROKE:chroma("#77B0E0"),TS_FILL:chroma("#D19FE3"),TS_STROKE:chroma("#A76BC2"),PP_FILL:chroma("#F3B6CF"),PP_STROKE:chroma("#EB81B4")};class BREPGLContext{constructor(t){this.cachedMeshes=new WeakMap,this.shaders=initShaders(t),initMeshes(this.meshes={},t)}static create(t){return addOwnProperties(t,BREPGLContext.prototype),addOwnProperties(t,new BREPGLContext(t)),t}drawPoint(t,e=GL_COLOR_BLACK,s=5){this.pushMatrix(),this.translate(t),this.scale(s,s,s),this.shaders.singleColor.uniforms({color:e}).draw(this.meshes.sphere1),this.popMatrix()}drawEdge(t,e=GL_COLOR_BLACK,s=2){CURVE_PAINTERS[t.curve.constructor.name](this,t.curve,e,t.minT,t.maxT,s)}drawCurve(t,e=GL_COLOR_BLACK,s=2,r,n){CURVE_PAINTERS[t.constructor.name](this,t,e,r,n,s)}drawVector(t,e,s=GL_COLOR_BLACK,r=1){this.pushMatrix();const n=t.getPerpendicular().unit();this.multMatrix(M4.forSys(t,n,t.cross(n).unit(),e)),1!=r&&this.scale(r,r,r),this.shaders.singleColor.uniforms({color:s}).draw(this.meshes.vector),this.popMatrix()}drawVectors(t){this.drawVector(V3.X,V3.O,chroma("red").gl(),void 0),this.drawVector(V3.Y,V3.O,chroma("green").gl(),void 0),this.drawVector(V3.Z,V3.O,chroma("blue").gl(),void 0),t.forEach(t=>this.drawVector(t.dir1,t.anchor,t.color,void 0))}drawPlane(t,e,s=!1){this.pushMatrix(),this.multMatrix(M4.forSys(t.right,t.up,t.normal1)),this.translate(t.sMin,t.tMin,t.w),this.scale(t.sMax-t.sMin,t.tMax-t.tMin,1);const r=s?this.meshes.xyDottedLinePlane:this.meshes.xyLinePlane;this.shaders.singleColor.uniforms({color:e}).draw(r,DRAW_MODES.LINES),this.popMatrix()}}function conicPainter(t,e,s,r,n,i,a=2){e.shaders.ellipse3d.uniforms({f1:s.f1,f2:s.f2,center:s.center,color:r,startT:n,endT:i,scale:a,mode:t}).draw(e.meshes.pipe)}const CURVE_PAINTERS={[SemiEllipseCurve.name]:conicPainter.bind(void 0,0),[EllipseCurve.name]:conicPainter.bind(void 0,0),[ParabolaCurve.name]:conicPainter.bind(void 0,1),[HyperbolaCurve.name]:conicPainter.bind(void 0,2),[ImplicitCurve.name](t,e,s,r,n,i=2,a=V3.Z){let o=t.cachedMeshes.get(e);o||(o=(new Mesh).addIndexBuffer("TRIANGLES").addVertexBuffer("normals","LGL_Normal"),e.addToMesh(o),o.compile(),t.cachedMeshes.set(e,o)),t.shaders.generic3d.uniforms({color:s,scale:i}).draw(o)},[BezierCurve.name](t,e,s,r,n,i=2,a=V3.Z){t.shaders.bezier3d.uniforms({p0:e.p0,p1:e.p1,p2:e.p2,p3:e.p3,color:s,startT:r,endT:n,scale:i,normal:a}).draw(t.meshes.pipe)},[L3$1.name](t,e,s,r,n,i=2,a=V3.Z){t.pushMatrix();const o=e.at(r),c=e.at(n).minus(o),h=c.getPerpendicular().unit(),l=M4.forSys(c,h,c.cross(h).unit(),o);t.multMatrix(l),t.scale(1,i,i),t.shaders.singleColor.uniforms({color:s}).draw(t.meshes.pipe),t.popMatrix()}};function initMeshes(t,e){e.makeCurrent(),t.sphere1=Mesh.sphere(2),t.segment=Mesh.plane({startY:-.5,height:1,detailX:128}),t.text=Mesh.plane(),t.vector=Mesh.rotation([V3.O,V(0,.05,0),V(.8,.05),V(.8,.1),V(1,0)],L3$1.X,TAU,16,!0),t.pipe=Mesh.rotation(arrayFromFunction(128,t=>new V3(t/127,-.5,0)),L3$1.X,TAU,8,!0),t.xyLinePlane=Mesh.plane(),t.xyDottedLinePlane=makeDottedLinePlane()}function initShaders(t){return t.makeCurrent(),{singleColor:Shader.create(vertexShaderBasic,fragmentShaderColor),multiColor:Shader.create(vertexShaderColor,fragmentShaderVaryingColor),singleColorHighlight:Shader.create(vertexShaderBasic,fragmentShaderColorHighlight),textureColor:Shader.create(vertexShaderTexture,fragmentShaderTextureColor),arc:Shader.create(vertexShaderRing,fragmentShaderColor),arc2:Shader.create(vertexShaderArc,fragmentShaderColor),ellipse3d:Shader.create(vertexShaderConic3d,fragmentShaderColor),generic3d:Shader.create(vertexShaderGeneric,fragmentShaderColor),bezier3d:Shader.create(vertexShaderBezier3d,fragmentShaderColor),bezier:Shader.create(vertexShaderBezier,fragmentShaderColor),lighting:Shader.create(vertexShaderLighting,fragmentShaderLighting),waves:Shader.create(vertexShaderWaves,fragmentShaderLighting)}}function makeDottedLinePlane(t=128){const e=(new Mesh).addIndexBuffer("LINES"),s=arrayFromFunction(t,e=>new V3(e/t,0,0));return e.vertices.push(...s),e.vertices.push(...M4.forSys(V3.Y,V3.O,V3.O,V3.X).transformedPoints(s)),e.vertices.push(...M4.forSys(V3.X.negated(),V3.O,V3.O,new V3(1,1,0)).transformedPoints(s)),e.vertices.push(...M4.forSys(V3.Y.negated(),V3.O,V3.O,V3.Y).transformedPoints(s)),e.LINES=arrayFromFunction(4*t,e=>e-(e>=2*t?1:0)),e.compile(),e}function initNavigationEvents(t,e,s){const r=t.canvas;let n=V3.O;r.addEventListener("mousemove",r=>{const i=V(r.pageX,r.pageY),a=n.to(i);if(4&r.buttons){const r=V(2*-a.x/t.canvas.width,2*a.y/t.canvas.height),n=t.projectionMatrix.inversed().transformVector(r);e.pos=e.pos.plus(n),e.focus=e.focus.plus(n),setupCamera(e,t),s()}if(2&r.buttons){const r=-a.x/6*DEG,n=-a.y/6*DEG;let i=M4.rotateLine(e.focus,e.up,r);const o=e.up.cross(e.pos.minus(e.focus));i=i.times(M4.rotateLine(e.focus,o,n)),e.pos=i.transformPoint(e.pos),e.up=i.transformVector(e.up),setupCamera(e,t),s()}n=i}),r.addEventListener("wheel",function(r){const n=2*-sign$11(r.deltaY);e.zoomFactor*=pow$5(.9,-n);const i=getPosOnTarget(r),a=V(2*i.x/t.canvas.offsetWidth-1,2*-i.y/t.canvas.offsetHeight+1,0),o=a.times(1-1/pow$5(.9,-n)),c=t.projectionMatrix.inversed(),h=c.transformVector(o);e.pos=e.pos.plus(h),e.focus=e.focus.plus(h);const l=c.transformPoint(a),u=M4.rotateLine(l,e.pos.to(e.focus),10*-sign$11(r.deltaX)*DEG);e.up=u.transformVector(e.up),e.pos=u.transformPoint(e.pos),e.focus=u.transformPoint(e.focus),setupCamera(e,t),s(),r.preventDefault()})}function getMouseLine(t,e){const s=V(2*t.x/e.canvas.width-1,2*-t.y/e.canvas.height+1,0),r=V(2*t.x/e.canvas.width-1,2*-t.y/e.canvas.height+1,1),n=e.projectionMatrix.inversed(),i=n.transformPoint(s),a=n.transformPoint(r).minus(i);return L3$1.anchorDirection(i,a)}function getPosOnTarget(t){const e=t.target.getBoundingClientRect();return{x:t.clientX-e.left,y:t.clientY-e.top}}function setupCamera(t,e){const{pos:s,focus:r,up:n,zoomFactor:i}=t;e.matrixMode(e.PROJECTION),e.loadIdentity();const a=e.canvas.width/2/i,o=e.canvas.height/2/i;e.ortho(-a,a,-o,o,-1e4,1e4),e.lookAt(s,r,n),e.matrixMode(e.MODELVIEW),cameraChangeListeners.forEach(e=>e(t))}CURVE_PAINTERS[PICurve$1.name]=CURVE_PAINTERS[ImplicitCurve.name];const cameraChangeListeners=[],SHADERS_TYPE_VAR=!1;export{Curve,curvePoint,curvePointMF,XiEtaCurve,ImplicitCurve,BezierCurve,EllipseCurve,HyperbolaCurve,L3$1 as L3,PICurve$1 as PICurve,ParabolaCurve,SemiEllipseCurve,P3,Surface,PointVsFace,ParametricSurface,ImplicitSurface,ConicSurface,EllipsoidSurface,ProjectedCurveSurface,CylinderSurface,RotationREqFOfZ,SemiCylinderSurface,SemiEllipsoidSurface,PlaneSurface$1 as PlaneSurface,ZDirVolumeVisitor,CalculateAreaVisitor,B2T,CustomPlane,Edge,PCurveEdge,StraightEdge,FaceInfoFactory,Face,PlaneFace,RotationFace,EPS,getGlobalId,addLikeSurfaceFaces,assembleFaceFromLooseEdges,calcNextEdgeIndex,B2,dotCurve,dotCurve2,INSIDE,OUTSIDE$1 as OUTSIDE,COPLANAR_SAME,COPLANAR_OPPOSITE,ALONG_EDGE_OR_PLANE,splitsVolumeEnclosingFaces,splitsVolumeEnclosingFacesP,splitsVolumeEnclosingFacesP2,splitsVolumeEnclosingCone,splitsVolumeEnclosingCone2,fff,triangulateVertices,intersectionUnitCircleLine,intersectionUnitCircleLine2,intersectionCircleLine,intersectionUnitHyperbolaLine,followAlgorithm2d,followAlgorithm2dAdjustable,intersectionICurveICurve,intersectionICurveICurve2,intersectionICurvePSurface,cassini,MathFunctionR2R,cas2,doNotSerialize,ClassSerializer,parseGetParams,COLORS,BREPGLContext,CURVE_PAINTERS,initMeshes,initShaders,initNavigationEvents,getMouseLine,getPosOnTarget,setupCamera,cameraChangeListeners,SHADERS_TYPE_VAR};