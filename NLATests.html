<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>QUnit Example</title>
	<script type="text/javascript">
	</script>
	<script type="text/javascript" src="wu.debug.js"></script>
	<script type="text/javascript" src="NLA.js"></script>
	<script type="text/javascript" src="Vector3.js"></script>
	<script type="text/javascript" src="Matrix4x4.js"></script>
	<script type="text/javascript" src="Plane3.js"></script>
	<script type="text/javascript" src="Line3.js"></script>
	<script type="text/javascript" src="sylvester.src.js"></script>
	<script type="text/javascript" src="AABB.js"></script>

	<link rel="stylesheet" href="qunit-1.20.0.css">
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<script src="qunit-1.20.0.js"></script>
<script type="text/javascript">
	var L3 = NLA.Line3,P3 = NLA.Plane3
	window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {
		console.log(errorMsg, url, lineNumber, column, errorObj);
	}
	QUnit.assert.matrixEquals = function(actual, expected, message, precision) {
		this.push(actual.equalsMatrix(expected, precision), actual.toString(), expected.toString(), message)
	}
	QUnit.test( "Vector.isParallelTo", function( assert ) {
		console.log(V3)
		console.log(V3(0, 1, 2))
		assert.equal(1, new NLA.Line(NLA.Vector3.ZERO, NLA.Vector3.X).distanceToPoint(V3(1, 1, 0)))
	});
	QUnit.test( "arrayCopyStep", function( assert ) {
		var a = [1, 2, 3, 4, 5, 6, 7, 8]
		var b = [-1, -2, -3, -4]
		NLA.arrayCopyStep(b, 0, 1, a, 1, 2, 3)
		assert.deepEqual(a, [1, -1, 3, -2, 5, -3, 7, 8])
	});
	QUnit.test( "arrayCopy", function( assert ) {
		var a = [1, 2, 3, 4, 5, 6, 7, 8]
		var b = [-1, -2, -3, -4]
		NLA.arrayCopy(b, 1, a, 2, 2)
		assert.deepEqual(a, [1, 2, -2, -3, 5, 6, 7, 8])
	});
	QUnit.test( "matrix rowArrays", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
		assert.deepEqual(a.rowArray(0, Array), [6, 3])
		assert.deepEqual(a.rowArray(1, Array), [4, 3])
		assert.deepEqual(a.asRowArrays(Array), [[6, 3],[4, 3]])
	});
	QUnit.test( "matrix transposed", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
		assert.deepEqual(a.transposed().asRowArrays(Array), [[6, 4],[3, 3]])
	});
	QUnit.test( "matrix transpose", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
		a.transpose()
		assert.deepEqual(a.asRowArrays(Array), [[6, 4],[3, 3]])

		a = NLA.Matrix.fromRowArrays([6, 3, 4, 3])
		a.transpose()
		assert.deepEqual(a.asRowArrays(Array), [[6],[3],[4],[3]])
		a.transpose()
		assert.deepEqual(a.asRowArrays(Array), [[6, 3, 4, 3]])
	});
	QUnit.test( "Matrix.prototype.times", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
		assert.deepEqual(NLA.Matrix.identity(2).times(a).asRowArrays(Array), [[6, 3],[4, 3]])
		assert.deepEqual(a.times(NLA.Matrix.identity(2)).asRowArrays(Array), [[6, 3],[4, 3]])
	});
	QUnit.test( "Matrix.identity", function( assert ) {
		var a = NLA.Matrix.identity(2)
		assert.deepEqual(a.asRowArrays(Array), [[1, 0],[0, 1]])
	});
	QUnit.test( "Matrix.prototype.rowsIndependent", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
        var b = NLA.Matrix.fromRowArrays([6, 3],[12, 6])

        // all rows on plane through origin with normal = V3(1, -1, 0)
        var c = NLA.Matrix.fromRowArrays([1, -1, 1],[1, 1, 1],[-1, 0, -1])
		assert.ok(a.rowsIndependent())
        assert.notOk(b.rowsIndependent())
        assert.notOk(c.rowsIndependent())
	});
	QUnit.test( "Matrix.prototype.rank", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
        var b = NLA.Matrix.fromRowArrays([6, 3],[12, 6])

        // all rows on plane through origin with normal = V3(1, -1, 0)
        var c = NLA.Matrix.fromRowArrays([1, -1, 1],[1, 1, 1],[-1, 0, -1])
		assert.equal(a.rank(), 2)
        assert.equal(b.rank(), 1)
        assert.equal(c.rank(), 2)

        var d = NLA.Matrix.fromRowArrays([1, 1, 0, 2],[-1, -1, 0, -2])
        assert.equal(d.rank(), 1)
        assert.equal(d.transposed().rank(), 1)

	});
	QUnit.test( "LU Decomposition", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([6, 3],[4, 3])
		var aLU = a.luDecomposition()
		assert.deepEqual(aLU.L.asRowArrays(Array), [[1, 0],[4/6, 1]])
		assert.deepEqual(aLU.U.asRowArrays(Array), [[6, 3],[0, 1]])
		assert.deepEqual(aLU.P.asRowArrays(Array), [[1, 0],[0, 1]])
		assert.matrixEquals(aLU.P.times(a), aLU.L.times(aLU.U))
	});
	QUnit.test( "LU Decomposition 2", function( assert ) {
		var a = NLA.Matrix.fromFunction(8, 8, (i, j) => Math.round((Math.random() - 0.5) * 4096))
		//var a = NLA.Matrix.fromRowArrays2([[-1636, 1740, -516], [-708, 403, 1986], [-1256, -1493, 996]])
		assert.ok(a.rowsIndependent())
		var aLU = a.luDecomposition()
		assert.ok(aLU.P.isPermutation())
		assert.ok(aLU.L.isLowerTriangular())
		assert.ok(aLU.U.isUpperTriangular())
		assert.matrixEquals(aLU.P.times(a), aLU.L.times(aLU.U))
	});
	QUnit.test( "LU Decomposition 3", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([0,1,1],[1,1,1],[1,2,3])
		var aLU = a.luDecomposition()
		assert.deepEqual(aLU.U.asRowArrays(Array), [[1,1,1],[0,1,1],[0,0,1]])
		assert.deepEqual(aLU.L.asRowArrays(Array), [[1,0,0],[0,1,0],[1,1,1]])
		assert.deepEqual(aLU.P.asRowArrays(Array), [[0,1,0],[1,0,0],[0,0,1]])
		assert.matrixEquals(aLU.P.times(a), aLU.L.times(aLU.U))
	});
	QUnit.test( "Matrix.isOrthogonal", function( assert ) {
		var a = NLA.Matrix.identity(4)
		assert.ok(a.isOrthogonal())
		var a = NLA.Matrix.fromRowArrays([Math.sqrt(2) / 2, Math.sqrt(2) / 2],[-Math.sqrt(2) / 2, Math.sqrt(2) / 2])
		assert.ok(a.isOrthogonal())
	});
	QUnit.test( "Matrix.prototype.solveLinearSystem", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([0,1,1],[1,1,1],[1,2,3])
		var b = NLA.Vector.fromArguments(1, 2, 3)
		var x = a.solveLinearSystem(b)
		assert.ok(x.equals(NLA.Vector.fromArguments(1, 1, 0)))
		assert.ok(a.timesVector(x).equals(b))
	});
	QUnit.test( "Matrix.prototype.inverse", function( assert ) {
		var a = NLA.Matrix.fromRowArrays([0,1,1],[1,1,1],[1,2,3])
		var aInverse = a.inversed()
		console.log(aInverse.toString())
		assert.matrixEquals(a.times(aInverse), NLA.Matrix.identity(3))
	});
	QUnit.test( "Matrix.prototype.inverse 2", function( assert ) {
		var a = NLA.Matrix.random(8, 8)
		var aInverse = a.inversed()
		assert.matrixEquals(a.times(aInverse), NLA.Matrix.identity(8))
	});
	QUnit.test( "Matrix.prototype.qrDecompositionGivensRotation", function( assert ) {
		var sqrt = Math.sqrt
		var m = NLA.Matrix.fromRowArrays([3,5], [0,2], [0,0], [4,5])
		var {Q, R} = m.qrDecompositionGivensRotation()
		assert.matrixEquals(Q, NLA.Matrix.fromRowArrays(
				[3/5, 4/5/sqrt(5), 0, -8/5/sqrt(5)],
				[0, 2/sqrt(5), 0, 1/sqrt(5)],
				[0,0,1,0],
				[4/5, -3/5/sqrt(5), 0, 6/5/sqrt(5)]
		))
		assert.ok(Q.isOrthogonal())
		assert.matrixEquals(R, NLA.Matrix.fromRowArrays(
				[5,7],
				[0, sqrt(5)],
				[0,0],
				[0,0]
		))
		assert.matrixEquals(Q.times(R), NLA.Matrix.fromRowArrays([3,5], [0,2], [0,0], [4,5]))
	});

	QUnit.test( "Plane3.prototype.projectedVector", function( assert ) {
		var p = NLA.Plane3(V3(0,0,1), 2)
		assert.ok(V3(1, 1, 0).like(p.projectedVector(V3(1,1,1))))
	});
	QUnit.test( "Line3.prototype.distanceToLine", function( assert ) {
		assert.equal(L3.X.distanceToLine(L3(V3.Z, V3.Y)), 1)
		assert.equal(L3.X.distanceToLine(L3(V3.Z, V3.X)), 1)
	});
	QUnit.test( "Plane3.prototype.transformed", function( assert ) {
		var p = NLA.Plane3(V3(0,0,1), 2)
		assert.ok(P3.XY.like(P3.XY.transform(M4.identity())))
	});
	QUnit.test( "Matrix4x4.prototype.isAxisAligned", function( assert ) {
		assert.ok(NLA.Matrix4x4.rotationX(Math.PI / 2).isAxisAligned())
		console.log(NLA.Matrix4x4.rotationX(Math.PI / 4).toString())
		console.log(false + true + true)
		assert.notOk(NLA.Matrix4x4.rotationX(Math.PI / 4).isAxisAligned())
	});
	QUnit.test( "Matrix4x4.prototype.rotationLine", function( assert ) {
		assert.matrixEquals(M4.rotationLine(V3.ZERO, V3.X, 1), M4.rotationX(1))
		assert.matrixEquals(M4.rotationLine(V3.ZERO, V3.Y, 1), M4.rotationY(1))
		assert.matrixEquals(M4.rotationLine(V3.ZERO, V3.Z, 1), M4.rotationZ(1))

		var a = V3(1, 2, 3), PI = Math.PI;
		assert.matrixEquals(
				M4.rotationLine(a, V3(1, 1, 0).unit(), 1),
				M4.multiplyMultiple(M4.translation(a), M4.rotationZ(PI / 4), M4.rotationX(1), M4.rotationZ(-PI / 4), M4.translation(a.negated())),
				"",
				1e-6)
	});
	QUnit.test( "Matrix4x4.multiplyMultiple", function( assert ) {
		assert.matrixEquals(M4.multiplyMultiple(M4.rotationX(1), M4.rotationZ(1)), M4.rotationX(1).times(M4.rotationZ(1)))
	});
	QUnit.test( "Plane3.prototype.intersectionWithPlane", function( assert ) {
		assert.ok(P3.XY.intersectionWithPlane(P3.ZX).equals(L3.X))
		assert.ok(P3.ZX.intersectionWithPlane(P3.XY).equals(L3.X))
		assert.notOk(P3.ZX.intersectionWithPlane(P3.XY).equals(L3.Y))
	});
	QUnit.test( "Line3.prototype.intersectionWithLine", function( assert ) {
		console.log(L3.X.intersectionWithLine(L3(V3(1, 1, 0), V3.Y)).ss)
		assert.ok(L3.X.intersectionWithLine(L3(V3(1, 1, 0), V3.Y)).equals(V3.X))
	});
	QUnit.test( "V3.prototype.zip", function( assert ) {
		var a = V3(1, 2, 3), b = V3(4, 5, 6)
		assert.ok(V3.zip((a, b) => a + 3 * b, a, b).equals(a.plus(b.times(3))))
	});
	QUnit.test( "NLA.magic", function( assert ) {
		var a = V3(1, 2, 3), b = V3(4, 5, 6)
		//assert.ok(NLA.magic("a b c s => abs(a) x b .. c + 3 + ")(a, b, c, 3).equals(a.abs().cross(b).dot(c) + 3))
	});
	QUnit.test( "AABB", function( assert ) {
		console.log(V3)
		var a = new AABB(V3.ZERO, V3(20, 10, 30))
		var b = new AABB(V3.ZERO, V3(1, 1, 1))
		assert.ok(a.likeAABB(a))
		assert.notOk(a.likeAABB(a.translate(10, 0, 0)))
		assert.ok(a.withoutAABB(b).likeAABB(new AABB(V3(0, 0, 1), V3(20, 10, 30))))
	});
	QUnit.test( "V3.areDisjoint", function(assert ) {

		assert.ok(V3.areDisjoint([V3.ZERO, V3.X, V3.Y].entries()))
		assert.ok(V3.areDisjoint([V3.ZERO, V3.X, V3.X, V3.Y].entries())) // same value twice is ok, as same reference
		assert.notOk(V3.areDisjoint([V3.ZERO, V3.X, V3(0, 0, 0), V3.Y].entries())) // not ok as V3.ZERO != V3(0, 0, 0)
		assert.notOk(V3.areDisjoint([V3.ZERO, V3.X, V3(NLA.PRECISION / 2, 0, 0), V3.Y].entries())) // not ok as !V3.ZERO.like(V3(...))
		assert.ok(V3.areDisjoint([V3(NLA.PRECISION * -0.7, 0, 0), V3(NLA.PRECISION * 0.7, 0, 0)].entries())) // not ok as V3.ZERO != V3(0, 0, 0)
	});
	QUnit.test( "V3.areDisjoint2", function(assert ) {
		console.log(~~2147483657)
		var s = new NLA.CustomSet()
		var a = V3(0, 2.7499999999999996, -5), b = V3(0, 2.749999999999999, -5)
		s.canonicalizeLike(a)
		console.log(s._map, a.like(b), a.hashCodes(), b.hashCodes(), a.hashCode(), b.hashCode())
		assert.ok(s.canonicalizeLike(b) == a)
	});

	/*

	//var a = NLA.Vector.random(3), b = NLA.Vector.random(3), c = NLA.Vector.random(3)
	while (count--) {
		//	console.log(b.times(a.plus(b).dot(c)))
		var b = s.inv()
	}
	//console.log( b.times(a.plus(b).dot(c)).cross(a).length());

	var end = new Date().getTime();
	var time = end - start;
	console.log('Execution time: ' + time + "ms");
	*/
</script>
</body>
</html>